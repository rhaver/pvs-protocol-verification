(process_rules
 (process_add 0
  (process_add-1 nil 3662229309
   ("" (auto-rewrite "prefix_closed[T]" "prefix[T]" "add[T]")
    (("" (skosimp :preds? t)
      (("" (assert)
        (("" (inst - "t!1" "add(t!1, a!1)")
          (("" (assert) (("" (inst?) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil process_rules nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (add const-decl "(cons?[T])" more_list_props nil)
    (prefix const-decl "bool" traces nil))
   nil))
 (sigma_stop 0
  (sigma_stop-1 nil 3662229309
   ("" (apply-extensionality :hide? t) (("" (grind) nil nil)) nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (list2set def-decl "set[T]" list2set nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (sigma const-decl "setof[T]" processes nil)
    (Stop const-decl "process" processes nil)
    (set type-eq-decl nil sets nil)
    (emptyset const-decl "set" sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil process_rules nil))
   nil))
 (sigma_choice 0
  (sigma_choice-1 nil 3662229309
   ("" (skolem!)
    (("" (apply-extensionality :hide? t)
      ((""
        (grind :defs nil :rewrites ("sigma" "Choice" "\\/") :theories
         ("sets[T]" "sets[trace[T]]"))
        nil nil))
      nil))
    nil)
   ((T formal-type-decl nil process_rules nil)
    (boolean nonempty-type-decl nil booleans nil)
    (union const-decl "set" sets nil) (set type-eq-decl nil sets nil)
    (\\/ const-decl "process" processes nil)
    (sigma const-decl "setof[T]" processes nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (t!1 skolem-const-decl "(union(P1!1, P2!1))" process_rules nil)
    (P2!1 skolem-const-decl "process[T]" process_rules nil)
    (P1!1 skolem-const-decl "process[T]" process_rules nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (member const-decl "bool" sets nil))
   nil))
 (sigma_choice2 0
  (sigma_choice2-1 nil 3662229309
   ("" (auto-rewrite "sigma" "Choice" "union" "emptyset" "list2set")
    (("" (skolem!)
      (("" (apply-extensionality :hide? t)
        (("" (iff)
          (("" (ground)
            (("1" (skolem-typepred)
              (("1" (assert)
                (("1" (ground)
                  (("1" (skolem!)
                    (("1" (inst + "P!1") (("1" (inst?) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (skosimp*)
              (("2" (inst?)
                (("2" (flatten)
                  (("2" (inst + "i!1") (("2" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((OR const-decl "[bool, bool -> bool]" booleans nil)
    (i!1 skolem-const-decl "(SP!1)" process_rules nil)
    (t!1 skolem-const-decl "(i!1)" process_rules nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (emptyset const-decl "set" sets nil)
    (list2set def-decl "set[T]" list2set nil)
    (SP!1 skolem-const-decl "set[process[T]]" process_rules nil)
    (P!1 skolem-const-decl "(SP!1)" process_rules nil)
    (t!1 skolem-const-decl "(Choice(SP!1))" process_rules nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (sigma const-decl "setof[T]" processes nil)
    (set type-eq-decl nil sets nil)
    (Choice const-decl "process" processes nil)
    (union const-decl "set[T]" parametric_sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil process_rules nil))
   nil))
 (sigma_pref 0
  (sigma_pref-1 nil 3662229309
   ("" (skolem!)
    (("" (apply-extensionality :hide? t)
      (("" (grind :if-match nil)
        (("1" (inst?) nil nil)
         ("2" (inst + "(: a!1 :)")
          (("1" (assert) nil nil) ("2" (inst?) nil nil)) nil)
         ("3" (inst + "cons(a!1, t!1)")
          (("1" (assert) nil nil) ("2" (inst?) nil nil)) nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil process_rules nil)
    (boolean nonempty-type-decl nil booleans nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (>> const-decl "process" processes nil)
    (sigma const-decl "setof[T]" processes nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (t!1 skolem-const-decl "(P!1)" process_rules nil)
    (P!1 skolem-const-decl "process[T]" process_rules nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (a!1 skolem-const-decl "T" process_rules nil)
    (list2set def-decl "set[T]" list2set nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (member const-decl "bool" sets nil))
   nil))
 (sigma_par 0
  (sigma_par-1 nil 3662229309
   ("" (expand "Par")
    (("" (expand "sigma")
      ((""
        (grind :defs nil :theories ("sets[T]" "sets[trace[T]]")
         :if-match nil)
        (("" (forward-chain "sigma_prod")
          (("" (replace*) (("" (assert) (("" (reduce) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sigma const-decl "setof[T]" processes nil)
    (sigma_prod formula-decl nil traces nil)
    (t2!1 skolem-const-decl "(P2!1)" process_rules nil)
    (P2!1 skolem-const-decl "process[T]" process_rules nil)
    (P1!1 skolem-const-decl "process[T]" process_rules nil)
    (set type-eq-decl nil sets nil) (prod def-decl "bool" traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (subset? const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (T formal-type-decl nil process_rules nil)
    (Par const-decl "process" processes nil))
   nil))
 (sigma_free_par 0
  (sigma_free_par-1 nil 3662229309
   ("" (skolem!)
    (("" (expand "//")
      (("" (use "sigma_par")
        (("" (apply-extensionality :hide? t)
          (("" (auto-rewrite-theory "sets[T]")
            (("" (iff)
              (("" (ground)
                (("1" (inst?) (("1" (assert) nil nil)) nil)
                 ("2" (delete -2)
                  (("2" (expand "sigma" +)
                    (("2" (expand "sigma" -)
                      (("2" (prop)
                        (("1" (skolem!)
                          (("1" (inst?)
                            (("1" (expand "Par")
                              (("1"
                                (inst + "t!1" "null")
                                (("1"
                                  (rewrite "free_prod_left[T]")
                                  nil
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (skolem!)
                          (("2" (quant?)
                            (("2" (expand "Par")
                              (("2"
                                (inst + "null" "t!1")
                                (("2"
                                  (rewrite "free_prod_right[T]")
                                  nil
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((// const-decl "process" processes nil)
    (union const-decl "set" sets nil)
    (Par const-decl "process" processes nil)
    (sigma const-decl "setof[T]" processes nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (free_prod_right formula-decl nil traces nil)
    (t!1 skolem-const-decl "(P2!1)" process_rules nil)
    (free_prod_left formula-decl nil traces nil)
    (t!1 skolem-const-decl "(P1!1)" process_rules nil)
    (P2!1 skolem-const-decl "process[T]" process_rules nil)
    (P1!1 skolem-const-decl "process[T]" process_rules nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (T formal-type-decl nil process_rules nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (emptyset const-decl "set" sets nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (sigma_par formula-decl nil process_rules nil))
   nil))
 (sigma_empty 0
  (sigma_empty-1 nil 3662229309
   ("" (skolem!)
    (("" (ground)
      (("1" (apply-extensionality :hide? t)
        (("1" (expand "Stop")
          (("1" (rewrite "emptyset_is_empty?" :dir rl)
            (("1" (grind)
              (("1" (inst - "car(x!1)")
                (("1" (inst?) (("1" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (replace*) (("2" (rewrite "sigma_stop") nil nil)) nil))
      nil))
    nil)
   ((finite_emptyset name-judgement "finite_set" finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (add const-decl "(nonempty?)" sets nil)
    (list2set def-decl "set[T]" list2set nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (sigma const-decl "setof[T]" processes nil)
    (set type-eq-decl nil sets nil)
    (emptyset_is_empty? formula-decl nil sets_lemmas nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (Stop const-decl "process" processes nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil process_rules nil)
    (sigma_stop formula-decl nil process_rules nil))
   nil))
 (sigma_union 0
  (sigma_union-1 nil 3662229309
   ("" (expand "sigma" 1 1)
    (("" (expand "union") (("" (propax) nil nil)) nil)) nil)
   ((union const-decl "set[T]" parametric_sets nil)
    (sigma const-decl "setof[T]" processes nil))
   nil))
 (sigma_subset 0
  (sigma_subset-1 nil 3662229309
   ("" (skolem!)
    (("" (rewrite "sigma_union")
      (("" (expand "union")
        (("" (expand "subset?")
          (("" (skosimp)
            (("" (expand "member") (("" (inst?) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((sigma_union formula-decl nil process_rules nil)
    (T formal-type-decl nil process_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set[T]" parametric_sets nil))
   nil))
 (sigma_hide 0
  (sigma_hide-1 nil 3662229309
   ("" (skolem!)
    (("" (apply-extensionality :hide? t)
      (("" (iff)
        (("" (split)
          (("1" (flatten)
            (("1" (expand "/")
              (("1" (expand "sigma" -)
                (("1" (skolem-typepred)
                  (("1" (skolem-typepred)
                    (("1" (replace -2)
                      (("1" (delete -2)
                        (("1" (rewrite "sigma_proj")
                          (("1" (expand "intersection")
                            (("1" (expand "member")
                              (("1"
                                (flatten)
                                (("1"
                                  (expand "difference")
                                  (("1"
                                    (expand "member")
                                    (("1"
                                      (split)
                                      (("1"
                                        (expand "sigma" +)
                                        (("1" (inst 1 "t1!1") nil nil))
                                        nil)
                                       ("2"
                                        (expand "complement")
                                        (("2"
                                          (expand "member")
                                          (("2" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (expand "difference")
              (("2" (expand "member")
                (("2" (flatten)
                  (("2" (expand "sigma" -)
                    (("2" (skolem-typepred)
                      (("2" (expand "/")
                        (("2" (expand "sigma" 2)
                          (("2" (inst 2 "proj(t!1, complement(A!1))")
                            (("1" (rewrite "sigma_proj")
                              (("1"
                                (expand "intersection")
                                (("1"
                                  (expand "member")
                                  (("1"
                                    (split)
                                    (("1" (propax) nil nil)
                                     ("2"
                                      (expand "complement")
                                      (("2"
                                        (expand "member")
                                        (("2" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (inst?) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil process_rules nil)
    (boolean nonempty-type-decl nil booleans nil)
    (difference const-decl "set" sets nil)
    (set type-eq-decl nil sets nil)
    (/ const-decl "process" processes nil)
    (sigma const-decl "setof[T]" processes nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (complement const-decl "set" sets nil)
    (sigma_proj formula-decl nil traces nil)
    (member const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (P!1 skolem-const-decl "process[T]" process_rules nil)
    (t!1 skolem-const-decl "(P!1)" process_rules nil)
    (A!1 skolem-const-decl "set[T]" process_rules nil))
   nil))
 (stop_subset 0
  (stop_subset-1 nil 3662229309
   ("" (grind :exclude "prefix_closed") nil nil)
   ((subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (Stop const-decl "process" processes nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil process_rules nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (stop_smallest 0
  (stop_smallest-1 nil 3662229309
   ("" (grind :exclude "prefix_closed" :if-match nil)
    (("" (apply-extensionality :hide? t)
      (("" (inst?) (("" (iff) (("" (ground) nil nil)) nil)) nil)) nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil process_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (subset? const-decl "bool" sets nil)
    (Stop const-decl "process" processes nil)
    (member const-decl "bool" sets nil))
   nil))
 (choice_commutes 0
  (choice_commutes-1 nil 3662229309
   ("" (grind :exclude "prefix_closed")
    (("" (rewrite "union_commutative") nil nil)) nil)
   ((union_commutative formula-decl nil sets_lemmas nil)
    (set type-eq-decl nil sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil process_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (\\/ const-decl "process" processes nil))
   nil))
 (choice_assoc 0
  (choice_assoc-1 nil 3662229309
   ("" (auto-rewrite "\\/" "Choice")
    (("" (skolem!)
      (("" (assert) (("" (rewrite "union_associative") nil nil)) nil))
      nil))
    nil)
   ((union_associative formula-decl nil sets_lemmas nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (T formal-type-decl nil process_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (\\/ const-decl "process" processes nil))
   nil))
 (choice_idempotent 0
  (choice_idempotent-1 nil 3662229309
   ("" (auto-rewrite "\\/" "Choice")
    (("" (skolem!)
      (("" (assert) (("" (rewrite "union_idempotent") nil nil)) nil))
      nil))
    nil)
   ((union_idempotent formula-decl nil sets_lemmas nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (T formal-type-decl nil process_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (\\/ const-decl "process" processes nil))
   nil))
 (choice_subset1 0
  (choice_subset1-1 nil 3662229309
   ("" (auto-rewrite "\\/" "Choice")
    (("" (skolem!)
      (("" (assert) (("" (rewrite "union_subset1") nil nil)) nil))
      nil))
    nil)
   ((union_subset1 formula-decl nil sets_lemmas nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (T formal-type-decl nil process_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (\\/ const-decl "process" processes nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil))
   nil))
 (choice_subset2 0
  (choice_subset2-1 nil 3662229309
   ("" (skolem!)
    (("" (rewrite "choice_commutes")
      (("" (rewrite "choice_subset1") nil nil)) nil))
    nil)
   ((choice_commutes formula-decl nil process_rules nil)
    (T formal-type-decl nil process_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (choice_subset1 formula-decl nil process_rules nil))
   nil))
 (choice_stop1 0
  (choice_stop1-1 nil 3662229309
   ("" (auto-rewrite "\\/" "Choice")
    (("" (skolem!)
      (("" (apply-extensionality :hide? t) (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (\\/ const-decl "process" processes nil)
    (Stop const-decl "process" processes nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil process_rules nil))
   nil))
 (choice_stop2 0
  (choice_stop2-1 nil 3662229309
   ("" (skolem!)
    (("" (rewrite "choice_commutes")
      (("" (rewrite "choice_stop1") nil nil)) nil))
    nil)
   ((choice_commutes formula-decl nil process_rules nil)
    (T formal-type-decl nil process_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (Stop const-decl "process" processes nil)
    (choice_stop1 formula-decl nil process_rules nil))
   nil))
 (choice_stop3 0
  (choice_stop3-1 nil 3662229309
   ("" (auto-rewrite "choice_idempotent" "stop_smallest")
    (("" (skolem!)
      (("" (ground)
        (("1" (use "choice_subset1")
          (("1" (replace*) (("1" (assert) nil nil)) nil)) nil)
         ("2" (use "choice_subset2")
          (("2" (replace*) (("2" (assert) nil nil)) nil)) nil)
         ("3" (replace*) (("3" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((choice_idempotent formula-decl nil process_rules nil)
    (choice_subset2 formula-decl nil process_rules nil)
    (choice_subset1 formula-decl nil process_rules nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil process_rules nil)
    (stop_smallest formula-decl nil process_rules nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil))
   nil))
 (choice_empty 0
  (choice_empty-1 nil 3662229309
   ("" (apply-extensionality :hide? t) (("" (grind) nil nil)) nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (prefix const-decl "bool" traces nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (set type-eq-decl nil sets nil)
    (Choice const-decl "process" processes nil)
    (emptyset const-decl "set" sets nil)
    (Stop const-decl "process" processes nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil process_rules nil))
   nil))
 (choice_add 0
  (choice_add-1 nil 3662229309
   ("" (skolem!)
    (("" (apply-extensionality :hide? t)
      (("" (grind :exclude "prefix_closed" :if-match nil)
        (("1" (inst?) nil nil) ("2" (inst?) nil nil)
         ("3" (inst?) nil nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil process_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (\\/ const-decl "process" processes nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (Choice const-decl "process" processes nil)
    (set type-eq-decl nil sets nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil))
   nil))
 (choice_singleton 0
  (choice_singleton-1 nil 3662229309
   ("" (skolem!)
    (("" (apply-extensionality :hide? t)
      (("" (grind :exclude "prefix_closed") nil nil)) nil))
    nil)
   ((T formal-type-decl nil process_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (singleton const-decl "(singleton?)" sets nil)
    (singleton? const-decl "bool" sets nil)
    (Choice const-decl "process" processes nil)
    (set type-eq-decl nil sets nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   nil))
 (choice_union 0
  (choice_union-1 nil 3662229309
   ("" (skolem!)
    (("" (apply-extensionality :hide? t)
      (("" (grind :exclude "prefix_closed") nil nil)) nil))
    nil)
   ((T formal-type-decl nil process_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (\\/ const-decl "process" processes nil)
    (union const-decl "set" sets nil)
    (Choice const-decl "process" processes nil)
    (set type-eq-decl nil sets nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (P!1 skolem-const-decl "(union(SP1!1, SP2!1))" process_rules nil)
    (SP2!1 skolem-const-decl "set[process[T]]" process_rules nil)
    (SP1!1 skolem-const-decl "set[process[T]]" process_rules nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil))
   nil))
 (choice_member 0
  (choice_member-1 nil 3662229309
   ("" (grind :exclude "prefix_closed") nil nil)
   ((subset? const-decl "bool" sets nil)
    (Choice const-decl "process" processes nil)
    (member const-decl "bool" sets nil) (set type-eq-decl nil sets nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil process_rules nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil))
 (par_commutes 0
  (par_commutes-1 nil 3662229309
   ("" (skolem!)
    (("" (expand "Par")
      (("" (apply-extensionality :hide? t)
        (("" (iff)
          (("" (ground)
            (("1" (skosimp)
              (("1" (rewrite "prod_commutes") (("1" (inst?) nil nil))
                nil))
              nil)
             ("2" (skolem!)
              (("2" (rewrite "prod_commutes") (("2" (inst?) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Par const-decl "process" processes nil)
    (prod_commutes formula-decl nil traces nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (prod def-decl "bool" traces nil) (set type-eq-decl nil sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil process_rules nil))
   nil))
 (par_assoc 0
  (par_assoc-1 nil 3662229309
   ("" (skolem!)
    (("" (expand "Par")
      (("" (apply-extensionality :hide? t)
        (("" (reduce :if-match nil)
          (("1" (use "prod_assoc2" ("u" "t2!1"))
            (("1" (assert)
              (("1" (skosimp)
                (("1" (inst + "u1!1" "t2!2") (("1" (inst?) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (use "prod_assoc1" ("u" "t1!1"))
            (("2" (assert)
              (("2" (skosimp)
                (("2" (inst + "t1!2" "u1!1") (("2" (inst?) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Par const-decl "process" processes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (u1!1 skolem-const-decl "trace[T]" process_rules nil)
    (A!1 skolem-const-decl "set[T]" process_rules nil)
    (P2!1 skolem-const-decl "process[T]" process_rules nil)
    (P1!1 skolem-const-decl "process[T]" process_rules nil)
    (prod_assoc2 formula-decl nil traces nil)
    (u1!1 skolem-const-decl "trace[T]" process_rules nil)
    (P3!1 skolem-const-decl "process[T]" process_rules nil)
    (prod_assoc1 formula-decl nil traces nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (prod def-decl "bool" traces nil) (set type-eq-decl nil sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil process_rules nil))
   nil))
 (par_stop 0
  (par_stop-1 nil 3662229309
   ("" (auto-rewrite "Par" "Stop")
    (("" (skolem!)
      (("" (apply-extensionality :hide? t)
        (("" (iff)
          (("" (prop)
            (("1" (skolem-typepred)
              (("1" (assert)
                (("1" (replace*)
                  (("1" (forward-chain "prod_null1")
                    (("1" (assert) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (skolem-typepred)
              (("2" (assert)
                (("2" (replace*)
                  (("2" (forward-chain "proj_prod2")
                    (("2" (auto-rewrite "proj")
                      (("2" (auto-rewrite "proj" "filter")
                        (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (forward-chain "prod_null3") (("3" (inst?) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((prod_null3 formula-decl nil traces nil)
    (P!1 skolem-const-decl "process[T]" process_rules nil)
    (x!1 skolem-const-decl "trace[T]" process_rules nil)
    (filter def-decl "list[T]" filters nil)
    (proj_prod2 formula-decl nil traces nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (prod_null1 formula-decl nil traces nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (Par const-decl "process" processes nil)
    (set type-eq-decl nil sets nil)
    (Stop const-decl "process" processes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil process_rules nil))
   nil))
 (par_full 0
  (par_full-1 nil 3662229309
   ("" (skolem!)
    (("" (apply-extensionality :hide? t)
      (("" (grind :exclude ("prod") :rewrites ("prod_fullset[T]")) nil
        nil))
      nil))
    nil)
   ((T formal-type-decl nil process_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (intersection const-decl "set" sets nil)
    (fullset const-decl "set" sets nil) (set type-eq-decl nil sets nil)
    (Par const-decl "process" processes nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (P1!1 skolem-const-decl "process[T]" process_rules nil)
    (x!1 skolem-const-decl "trace[T]" process_rules nil)
    (prod_fullset formula-decl nil traces nil)
    (member const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   nil))
 (interleaves_commutes 0
  (interleaves_commutes-1 nil 3662229309
   ("" (expand "//")
    (("" (skolem!) (("" (rewrite "par_commutes") nil nil)) nil)) nil)
   ((process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (emptyset const-decl "set" sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil process_rules nil)
    (par_commutes formula-decl nil process_rules nil)
    (// const-decl "process" processes nil))
   nil))
 (interleaves_assoc 0
  (interleaves_assoc-1 nil 3662229309
   ("" (skolem!)
    (("" (expand "//") (("" (rewrite "par_assoc") nil nil)) nil)) nil)
   ((// const-decl "process" processes nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (emptyset const-decl "set" sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil process_rules nil)
    (par_assoc formula-decl nil process_rules nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   nil))
 (interleaves_subset1 0
  (interleaves_subset1-1 nil 3662229309
   ("" (grind :if-match nil)
    (("" (inst + "x!1" "null")
      (("" (rewrite "free_prod_left") nil nil)) nil))
    nil)
   ((free_prod_left formula-decl nil traces nil)
    (prefix const-decl "bool" traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil process_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (subset? const-decl "bool" sets nil)
    (Par const-decl "process" processes nil)
    (member const-decl "bool" sets nil)
    (// const-decl "process" processes nil))
   nil))
 (interleaves_subset2 0
  (interleaves_subset2-1 nil 3662229309
   ("" (grind :if-match nil)
    (("" (inst + "null" "x!1")
      (("" (rewrite "free_prod_right") nil nil)) nil))
    nil)
   ((free_prod_right formula-decl nil traces nil)
    (prefix const-decl "bool" traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil process_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (subset? const-decl "bool" sets nil)
    (Par const-decl "process" processes nil)
    (member const-decl "bool" sets nil)
    (// const-decl "process" processes nil))
   nil))
 (interleaves_stop1 0
  (interleaves_stop1-1 nil 3662229309
   ("" (skolem!)
    (("" (apply-extensionality :hide? t)
      (("" (grind :exclude ("prod" "prefix_closed"))
        (("1" (use "prod_null1" ("t1" "t1!1" "t" "x!1"))
          (("1" (assert) nil nil)) nil)
         ("2" (inst + "null")
          (("2" (rewrite "free_prod_left") nil nil)) nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil process_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (Stop const-decl "process" processes nil)
    (// const-decl "process" processes nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (free_prod_left formula-decl nil traces nil)
    (prod_null1 formula-decl nil traces nil)
    (set type-eq-decl nil sets nil)
    (emptyset const-decl "set" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (Par const-decl "process" processes nil))
   nil))
 (interleaves_stop2 0
  (interleaves_stop2-1 nil 3662229309
   ("" (skolem!)
    (("" (rewrite "interleaves_commutes")
      (("" (rewrite "interleaves_stop1") nil nil)) nil))
    nil)
   ((interleaves_commutes formula-decl nil process_rules nil)
    (T formal-type-decl nil process_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (Stop const-decl "process" processes nil)
    (interleaves_stop1 formula-decl nil process_rules nil))
   nil))
 (hide_equiv 0
  (hide_equiv-1 nil 3662229309
   ("" (skosimp)
    (("" (expand "/")
      (("" (skolem!) (("" (inst?) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((/ const-decl "process" processes nil)
    (T formal-type-decl nil process_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil))
   nil))
 (hide_stop 0
  (hide_stop-1 nil 3662229309
   ("" (skolem!)
    (("" (apply-extensionality :hide? t)
      (("" (iff)
        (("" (ground)
          (("1" (expand "/")
            (("1" (skolem-typepred)
              (("1" (expand "Stop" -1)
                (("1" (replace -1 -2)
                  (("1" (rewrite "proj_null")
                    (("1" (replace -2 1)
                      (("1" (expand "Stop") (("1" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand "Stop" -1) (("2" (propax) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil process_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (set type-eq-decl nil sets nil)
    (Stop const-decl "process" processes nil)
    (/ const-decl "process" processes nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (proj_null formula-decl nil traces nil)
    (complement const-decl "set" sets nil))
   nil))
 (hide_emptyset 0
  (hide_emptyset-1 nil 3662229309
   ("" (skolem!)
    (("" (apply-extensionality :hide? t)
      (("" (iff)
        (("" (split)
          (("1" (flatten)
            (("1" (expand "/")
              (("1" (skolem-typepred)
                (("1" (rewrite "complement_emptyset")
                  (("1" (rewrite "proj_fullset")
                    (("1" (replace -2 1) (("1" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (expand "/")
              (("2" (inst?)
                (("2" (rewrite "complement_emptyset")
                  (("2" (rewrite "proj_fullset") nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil process_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (emptyset const-decl "set" sets nil)
    (set type-eq-decl nil sets nil)
    (/ const-decl "process" processes nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (complement_emptyset formula-decl nil sets_lemmas nil)
    (proj_fullset formula-decl nil traces nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (x!1 skolem-const-decl "trace[T]" process_rules nil)
    (P!1 skolem-const-decl "process[T]" process_rules nil))
   nil))
 (hide_fullset 0
  (hide_fullset-1 nil 3662229309
   ("" (skolem!)
    (("" (apply-extensionality :hide? t)
      (("" (iff)
        (("" (split)
          (("1" (flatten)
            (("1" (expand "/")
              (("1" (skolem!)
                (("1" (rewrite "complement_fullset")
                  (("1" (rewrite "proj_emptyset")
                    (("1" (replace -1 1) (("1" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (expand "Stop") (("2" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil process_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (Stop const-decl "process" processes nil)
    (fullset const-decl "set" sets nil) (set type-eq-decl nil sets nil)
    (/ const-decl "process" processes nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (complement_fullset formula-decl nil sets_lemmas nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (proj_emptyset formula-decl nil traces nil))
   nil))
 (hide_union 0
  (hide_union-1 nil 3662229309
   ("" (auto-rewrite-theory "sets[T]")
    (("" (skolem!)
      (("" (apply-extensionality :hide? t)
        (("" (iff)
          (("" (ground)
            (("1" (expand "/")
              (("1" (skolem-typepred)
                (("1" (skolem-typepred)
                  (("1" (replace -2 -3)
                    (("1" (rewrite "proj_twice")
                      (("1" (inst?)
                        (("1" (replace -3 1)
                          (("1" (delete -)
                            (("1"
                              (case "intersection(complement(A!1), complement(B!1)) = complement(union(A!1, B!1))")
                              (("1"
                                (replace -1 1)
                                (("1" (propax) nil nil))
                                nil)
                               ("2"
                                (delete 2)
                                (("2"
                                  (apply-extensionality :hide? t)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand "/")
              (("2" (skolem-typepred)
                (("2" (inst 1 "proj(t1!1, complement(A!1))")
                  (("1" (rewrite "proj_twice")
                    (("1" (replace -2 1)
                      (("1" (delete -)
                        (("1"
                          (case "complement(union(A!1, B!1)) = intersection(complement(A!1), complement(B!1))")
                          (("1" (replace -1 1) (("1" (propax) nil nil))
                            nil)
                           ("2" (delete 2)
                            (("2" (apply-extensionality :hide? t)
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (inst?) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((A!1 skolem-const-decl "set[T]" process_rules nil)
    (t1!1 skolem-const-decl "(P!1)" process_rules nil)
    (P!1 skolem-const-decl "process[T]" process_rules nil)
    (proj_twice formula-decl nil traces nil)
    (intersection const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (complement const-decl "set" sets nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (/ const-decl "process" processes nil)
    (set type-eq-decl nil sets nil) (union const-decl "set" sets nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil process_rules nil))
   nil))
 (hide_prefix1 0
  (hide_prefix1-1 nil 3662229309
   ("" (auto-rewrite-theory "sets[T]")
    (("" (skosimp)
      (("" (apply-extensionality :hide? t)
        (("" (iff)
          (("" (ground)
            (("1" (expand ">>" -1)
              (("1" (expand "/" -1)
                (("1" (skolem-typepred)
                  (("1" (split)
                    (("1" (expand "proj")
                      (("1" (expand "filter")
                        (("1" (lift-if)
                          (("1" (split)
                            (("1" (flatten)
                              (("1"
                                (replace -2 1)
                                (("1"
                                  (delete -)
                                  (("1"
                                    (expand ">>")
                                    (("1" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (flatten) nil nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (skolem-typepred)
                      (("2" (replace -2 -3)
                        (("2" (rewrite "proj_cons")
                          (("2" (replace -3 1)
                            (("2" (expand ">>")
                              (("2"
                                (inst 1 "proj(t1!2, complement(A!1))")
                                (("2"
                                  (expand "/")
                                  (("2" (inst?) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand ">>" -1)
              (("2" (skolem-typepred)
                (("2" (expand "/" -1)
                  (("2" (skolem-typepred)
                    (("2" (replace -2 -3)
                      (("2" (replace -3 1)
                        (("2" (expand "/")
                          (("2" (inst 1 "cons(a!1, t1!2)")
                            (("1" (rewrite "proj_cons") nil nil)
                             ("2" (expand ">>")
                              (("2" (inst 1 "t1!2") nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((a!1 skolem-const-decl "T" process_rules nil)
    (t1!2 skolem-const-decl "(P!1)" process_rules nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (complement const-decl "set" sets nil)
    (proj_cons formula-decl nil traces nil)
    (member const-decl "bool" sets nil)
    (t1!2 skolem-const-decl "(P!1)" process_rules nil)
    (A!1 skolem-const-decl "set[T]" process_rules nil)
    (P!1 skolem-const-decl "process[T]" process_rules nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (filter def-decl "list[T]" filters nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (/ const-decl "process" processes nil)
    (>> const-decl "process" processes nil)
    (set type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil process_rules nil))
   nil))
 (hide_prefix2 0
  (hide_prefix2-1 nil 3662229309
   ("" (auto-rewrite-theory "sets[T]")
    (("" (skosimp)
      (("" (apply-extensionality :hide? t)
        (("" (iff)
          (("" (ground)
            (("1" (expand ">>")
              (("1" (expand "/")
                (("1" (skolem-typepred)
                  (("1" (split)
                    (("1" (inst?)
                      (("1" (delete -2 -3) (("1" (grind) nil nil))
                        nil))
                      nil)
                     ("2" (skolem-typepred)
                      (("2" (inst 1 "t1!2")
                        (("2" (replace -2 -3)
                          (("2" (replace -3 1)
                            (("2" (delete -1 -2 -3)
                              (("2"
                                (expand "proj" 1 1)
                                (("2"
                                  (expand "filter")
                                  (("2"
                                    (lift-if)
                                    (("2"
                                      (split)
                                      (("1"
                                        (expand "complement" 1 1)
                                        (("1"
                                          (expand "member")
                                          (("1" (propax) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (expand "proj")
                                          (("2" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand ">>")
              (("2" (expand "/")
                (("2" (skolem-typepred)
                  (("2" (inst 1 "cons(a!1, t1!1)")
                    (("1" (replace -2 1)
                      (("1" (expand "proj")
                        (("1" (expand "filter" 1 2)
                          (("1" (lift-if)
                            (("1" (split)
                              (("1"
                                (flatten)
                                (("1"
                                  (expand "complement")
                                  (("1"
                                    (expand "member")
                                    (("1" (propax) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (inst?) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((t1!1 skolem-const-decl "(P!1)" process_rules nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (filter def-decl "list[T]" filters nil)
    (member const-decl "bool" sets nil)
    (complement const-decl "set" sets nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (P!1 skolem-const-decl "process[T]" process_rules nil)
    (a!1 skolem-const-decl "T" process_rules nil)
    (t1!1 skolem-const-decl
     "({t | null?[T](t) OR (EXISTS (t1: (P!1)): t = cons(a!1, t1))})"
     process_rules nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (/ const-decl "process" processes nil)
    (>> const-decl "process" processes nil)
    (set type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil process_rules nil))
   nil))
 (hide_choice1 0
  (hide_choice1-1 nil 3662229309
   ("" (auto-rewrite-theory "sets[T]")
    (("" (skolem!)
      (("" (apply-extensionality :hide? t)
        (("" (iff)
          (("" (ground)
            (("1" (expand "/")
              (("1" (skolem-typepred)
                (("1" (expand "\\/")
                  (("1" (expand "union")
                    (("1" (expand "member")
                      (("1" (flatten)
                        (("1" (split)
                          (("1" (inst?) nil nil)
                           ("2" (inst? 2) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand "\\/")
              (("2" (expand "/")
                (("2" (expand "union")
                  (("2" (expand "member")
                    (("2" (split)
                      (("1" (skolem-typepred)
                        (("1" (inst?)
                          (("1" (expand "union")
                            (("1" (expand "member")
                              (("1" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("2" (skolem-typepred)
                        (("2" (inst?)
                          (("2" (expand "union")
                            (("2" (expand "member")
                              (("2" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((t1!1 skolem-const-decl "(P1!1)" process_rules nil)
    (t1!1 skolem-const-decl "(P2!1)" process_rules nil)
    (member const-decl "bool" sets nil)
    (P1!1 skolem-const-decl "process[T]" process_rules nil)
    (P2!1 skolem-const-decl "process[T]" process_rules nil)
    (t1!1 skolem-const-decl "(P1!1 \\/ P2!1)" process_rules nil)
    (union const-decl "set" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (/ const-decl "process" processes nil)
    (\\/ const-decl "process" processes nil)
    (set type-eq-decl nil sets nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil process_rules nil))
   nil))
 (hide_sigma 0
  (hide_sigma-1 nil 3662229309
   ("" (skosimp)
    (("" (apply-extensionality :hide? t)
      (("" (iff)
        (("" (split)
          (("1" (flatten)
            (("1" (expand "/")
              (("1" (skolem-typepred)
                (("1" (case "t1!1 = x!1")
                  (("1" (replace -1) (("1" (propax) nil nil)) nil)
                   ("2" (replace -2)
                    (("2" (delete -1 -2 2)
                      (("2" (generalize "t1!1" "t")
                        (("2" (induct "t" :name "add_induction[T]")
                          (("1" (grind) nil nil) ("2" (grind) nil nil)
                           ("3" (skosimp*)
                            (("3" (assert)
                              (("3"
                                (typepred "P!1")
                                (("3"
                                  (delete -1)
                                  (("3"
                                    (expand "prefix_closed")
                                    (("3"
                                      (inst?)
                                      (("3"
                                        (inst -1 "add(l!1, a!1)")
                                        (("3"
                                          (assert)
                                          (("3"
                                            (use "prefix_add1[T]")
                                            (("3"
                                              (assert)
                                              (("3"
                                                (delete -1)
                                                (("3"
                                                  (expand "disjoint?")
                                                  (("3"
                                                    (expand "empty?")
                                                    (("3"
                                                      (expand
                                                       "intersection")
                                                      (("3"
                                                        (expand
                                                         "member")
                                                        (("3"
                                                          (inst?)
                                                          (("3"
                                                            (split)
                                                            (("1"
                                                              (expand
                                                               "sigma")
                                                              (("1"
                                                                (inst
                                                                 1
                                                                 "add(l!1, a!1)")
                                                                (("1"
                                                                  (delete
                                                                   -1
                                                                   -2
                                                                   -3
                                                                   2)
                                                                  (("1"
                                                                    (rewrite
                                                                     "sigma_add")
                                                                    (("1"
                                                                      (grind)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (rewrite
                                                               "proj_add")
                                                              (("2"
                                                                (lift-if)
                                                                (("2"
                                                                  (split)
                                                                  (("1"
                                                                    (expand
                                                                     "complement"
                                                                     1
                                                                     1)
                                                                    (("1"
                                                                      (propax)
                                                                      nil
                                                                      nil))
                                                                    nil)
                                                                   ("2"
                                                                    (flatten)
                                                                    (("2"
                                                                      (expand
                                                                       "complement")
                                                                      (("2"
                                                                        (expand
                                                                         "member")
                                                                        (("2"
                                                                          (propax)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (expand "/")
              (("2" (inst?)
                (("2" (generalize "x!1" "t")
                  (("2" (induct "t" :name "add_induction[T]")
                    (("1" (grind) nil nil)
                     ("2" (skosimp*)
                      (("2" (assert)
                        (("2" (typepred "P!1")
                          (("2" (delete -1)
                            (("2" (expand "prefix_closed")
                              (("2"
                                (inst?)
                                (("2"
                                  (inst -1 "add(l!1, a!1)")
                                  (("2"
                                    (assert)
                                    (("2"
                                      (use "prefix_add1[T]")
                                      (("2"
                                        (assert)
                                        (("2"
                                          (delete -1)
                                          (("2"
                                            (expand "disjoint?")
                                            (("2"
                                              (expand "empty?")
                                              (("2"
                                                (expand "intersection")
                                                (("2"
                                                  (expand "member")
                                                  (("2"
                                                    (inst?)
                                                    (("2"
                                                      (split)
                                                      (("1"
                                                        (expand
                                                         "sigma")
                                                        (("1"
                                                          (inst
                                                           1
                                                           "add(l!1, a!1)")
                                                          (("1"
                                                            (rewrite
                                                             "sigma_add")
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (rewrite
                                                         "proj_add")
                                                        (("2"
                                                          (lift-if)
                                                          (("2"
                                                            (split)
                                                            (("1"
                                                              (expand
                                                               "complement"
                                                               1
                                                               1)
                                                              (("1"
                                                                (propax)
                                                                nil
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (flatten)
                                                              (("2"
                                                                (expand
                                                                 "complement")
                                                                (("2"
                                                                  (expand
                                                                   "member")
                                                                  (("2"
                                                                    (propax)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil process_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (set type-eq-decl nil sets nil)
    (/ const-decl "process" processes nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (add_induction formula-decl nil more_list_props nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (member const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (filter def-decl "list[T]" filters nil)
    (proj_add formula-decl nil traces nil)
    (add const-decl "(nonempty?)" sets nil)
    (sigma_add formula-decl nil traces nil)
    (prefix_add1 formula-decl nil traces nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (add const-decl "(cons?[T])" more_list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (disjoint? const-decl "bool" sets nil)
    (sigma const-decl "setof[T]" processes nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (complement const-decl "set" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (P!1 skolem-const-decl "process[T]" process_rules nil)
    (x!1 skolem-const-decl "trace[T]" process_rules nil))
   nil))
 (hide_twice 0
  (hide_twice-1 nil 3662229309
   ("" (skolem!)
    (("" (use "hide_sigma")
      (("" (assert)
        (("" (delete 2)
          (("" (expand "disjoint?")
            (("" (expand "empty?")
              (("" (expand "intersection")
                (("" (expand "member")
                  (("" (skosimp)
                    (("" (use "sigma_par")
                      (("" (expand "subset?")
                        (("" (expand "member")
                          (("" (inst?)
                            (("" (assert)
                              ((""
                                (delete -2)
                                ((""
                                  (expand "union")
                                  ((""
                                    (expand "member")
                                    ((""
                                      (split)
                                      (("1"
                                        (rewrite "sigma_hide")
                                        (("1"
                                          (expand "difference")
                                          (("1"
                                            (expand "member")
                                            (("1" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (rewrite "sigma_hide")
                                        (("2"
                                          (expand "difference")
                                          (("2"
                                            (expand "member")
                                            (("2" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((hide_sigma formula-decl nil process_rules nil)
    (/ const-decl "process" processes nil)
    (Par const-decl "process" processes nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil) (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil process_rules nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (sigma_par formula-decl nil process_rules nil)
    (union const-decl "set" sets nil)
    (difference const-decl "set" sets nil)
    (sigma_hide formula-decl nil process_rules nil)
    (subset? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (disjoint? const-decl "bool" sets nil))
   nil))
 (rename_prefix 0
  (rename_prefix-1 nil 3662229309
   ("" (skosimp)
    (("" (apply-extensionality :hide? t)
      (("" (iff)
        (("" (split)
          (("1" (flatten)
            (("1" (expand "rename" -1)
              (("1" (skolem-typepred)
                (("1" (expand ">>" -1)
                  (("1" (split)
                    (("1" (case "t1!1 = null")
                      (("1" (replace -1 -3)
                        (("1" (expand "trename")
                          (("1" (propax) nil nil)) nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil)
                     ("2" (skolem-typepred)
                      (("2" (replace -2 -3)
                        (("2" (expand "trename" -3)
                          (("2" (flatten)
                            (("2" (expand "Choice")
                              (("2"
                                (inst 1 "car(x!1) >> rename(P!1, R!1)")
                                (("1"
                                  (expand ">>" 1)
                                  (("1"
                                    (inst 1 "cdr(x!1)")
                                    (("1"
                                      (lemma "list_cons_eta[T]")
                                      (("1"
                                        (inst?)
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (expand "rename")
                                      (("2" (inst?) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (inst?) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (expand "Choice")
              (("2" (skolem-typepred)
                (("2" (delete -1 -2)
                  (("2" (skolem-typepred)
                    (("2" (flatten)
                      (("2" (expand ">>" -2)
                        (("2" (replace -2 -3)
                          (("2" (delete -2)
                            (("2" (beta)
                              (("2"
                                (split)
                                (("1"
                                  (case "x!1 = null")
                                  (("1"
                                    (replace -1 1)
                                    (("1"
                                      (typepred
                                       "rename(a!1 >> P!1, R!1)")
                                      (("1" (propax) nil nil))
                                      nil))
                                    nil)
                                   ("2" (assert) nil nil))
                                  nil)
                                 ("2"
                                  (skolem-typepred)
                                  (("2"
                                    (expand "rename")
                                    (("2"
                                      (skolem-typepred)
                                      (("2"
                                        (inst 1 "cons(a!1, t1!2)")
                                        (("1"
                                          (replace -3 1)
                                          (("1"
                                            (expand "trename" 1)
                                            (("1"
                                              (split)
                                              (("1" (propax) nil nil)
                                               ("2" (propax) nil nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (expand ">>" 1)
                                          (("2" (inst?) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil process_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Choice const-decl "process" processes nil)
    (set type-eq-decl nil sets nil)
    (>> const-decl "process" processes nil)
    (rename const-decl "process" processes nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list_cons_eta formula-decl nil list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (R!1 skolem-const-decl "set[[T, T]]" process_rules nil)
    (a!1 skolem-const-decl "T" process_rules nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (x!1 skolem-const-decl "trace[T]" process_rules nil)
    (P!1 skolem-const-decl "process[T]" process_rules nil)
    (trename def-decl "bool" traces nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (t1!2 skolem-const-decl "(P!1)" process_rules nil))
   nil))
 (rename_choice 0
  (rename_choice-1 nil 3662229309
   ("" (skosimp)
    (("" (apply-extensionality :hide? t)
      (("" (iff)
        (("" (ground)
          (("1" (expand "\\/" -1)
            (("1" (expand "rename" -1)
              (("1" (skolem-typepred)
                (("1" (expand "\\/" 1)
                  (("1" (expand "union")
                    (("1" (expand "member")
                      (("1" (flatten)
                        (("1" (split)
                          (("1" (expand "rename" 1)
                            (("1" (inst?) nil nil)) nil)
                           ("2" (expand "rename" 2)
                            (("2" (inst?) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand "\\/" -1)
            (("2" (expand "union")
              (("2" (expand "member")
                (("2" (split)
                  (("1" (expand "rename")
                    (("1" (skolem-typepred)
                      (("1" (inst?)
                        (("1" (delete -2) (("1" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand "rename")
                    (("2" (skolem-typepred)
                      (("2" (inst?)
                        (("2" (delete -2) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil process_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (set type-eq-decl nil sets nil)
    (\\/ const-decl "process" processes nil)
    (rename const-decl "process" processes nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil)
    (t1!1 skolem-const-decl "(union(P1!1, P2!1))" process_rules nil)
    (P2!1 skolem-const-decl "process[T]" process_rules nil)
    (P1!1 skolem-const-decl "process[T]" process_rules nil)
    (union const-decl "set" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (t1!1 skolem-const-decl "(P1!1)" process_rules nil)
    (t1!1 skolem-const-decl "(P2!1)" process_rules nil))
   nil))
 (rename_choice2 0
  (rename_choice2-1 nil 3662229309
   ("" (skosimp)
    (("" (apply-extensionality :hide? t)
      (("" (iff)
        (("" (split)
          (("1" (flatten)
            (("1" (expand "rename" -1)
              (("1" (skolem-typepred)
                (("1" (expand "Choice")
                  (("1" (split)
                    (("1" (case "t1!1 = null")
                      (("1" (replace -1 -3)
                        (("1" (expand "trename")
                          (("1" (propax) nil nil)) nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil)
                     ("2" (skolem-typepred)
                      (("2" (delete -1 -2)
                        (("2" (inst 1 "rename(P!1, R!1)")
                          (("1" (expand "rename")
                            (("1" (inst?) nil nil)) nil)
                           ("2" (inst?) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (expand "Choice" -1)
              (("2" (skolem-typepred)
                (("2" (delete -1 -2)
                  (("2" (skolem-typepred)
                    (("2" (delete -1 -2)
                      (("2" (replace -2 -3)
                        (("2" (delete -2)
                          (("2" (expand "rename")
                            (("2" (skolem-typepred)
                              (("2"
                                (inst?)
                                (("2"
                                  (expand "Choice")
                                  (("2"
                                    (flatten)
                                    (("2" (inst 2 "P2!1") nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil process_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Choice const-decl "process" processes nil)
    (set type-eq-decl nil sets nil)
    (rename const-decl "process" processes nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (R!1 skolem-const-decl "set[[T, T]]" process_rules nil)
    (P!1 skolem-const-decl "(SP!1)" process_rules nil)
    (SP!1 skolem-const-decl "set[process[T]]" process_rules nil)
    (t1!1 skolem-const-decl "(Choice(SP!1))" process_rules nil)
    (trename def-decl "bool" traces nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (P2!1 skolem-const-decl "(SP!1)" process_rules nil)
    (t1!1 skolem-const-decl "(P2!1)" process_rules nil))
   nil)))

