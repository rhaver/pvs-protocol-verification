(traces
 (prefix_equiv 0
  (prefix_equiv-1 nil 3417192745 3417192749
   ("" (auto-rewrite "prefix" "append")
    (("" (skolem!)
      (("" (ground)
        (("1" (skolem!) (("1" (assert) nil)))
         ("2" (skolem!)
          (("2" (assert) (("2" (replace*) (("2" (assert) nil)))))))
         ("3" (skolem!)
          (("3" (inst + "t!1")
            (("3" (replace*)
              (("3" (expand "append" 1 1) (("3" (propax) nil)))))))))
         ("4" (inst + "t2!1") nil)
         ("5" (skolem!)
          (("5" (inst + "t!1")
            (("5" (apply-extensionality) nil))))))))))
    nil)
   proved
   ((prefix const-decl "bool" traces nil)
    (append def-decl "list[T]" list_props nil)
    (T formal-type-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil))
   2371 180 t nil))
 (null_prefix 0
  (null_prefix-1 nil 3417191621 3417191668
   ("" (skolem!) (("" (rewrite "prefix_equiv") nil nil)) nil) proved
   ((prefix_equiv formula-decl nil traces nil)
    (T formal-type-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil))
   64 20 nil nil))
 (prefix_null 0
  (prefix_null-1 nil 3417191621 3417191668
   ("" (skolem!)
    (("" (rewrite "prefix_equiv") (("" (ground) nil nil)) nil)) nil)
   proved
   ((prefix_equiv formula-decl nil traces nil)
    (T formal-type-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil))
   71 30 nil nil))
 (cons_prefix 0
  (cons_prefix-1 nil 3417191621 3417191668
   ("" (skolem!)
    (("" (ground)
      (("1" (rewrite "prefix_equiv") nil nil)
       ("2" (rewrite "prefix_equiv" -) nil nil)
       ("3" (rewrite "prefix_equiv" +) nil nil))
      nil))
    nil)
   proved
   ((cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (prefix_equiv formula-decl nil traces nil))
   97 70 nil nil))
 (prefix_append1 0
  (prefix_append1-1 nil 3417191621 3417191669
   ("" (expand "prefix")
    (("" (skosimp*)
      (("" (replace*)
        (("" (inst + "append(t!1, t3!1)")
          (("" (rewrite "append_assoc") nil nil)) nil))
        nil))
      nil))
    nil)
   proved
   ((T formal-type-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (append def-decl "list[T]" list_props nil)
    (append_assoc formula-decl nil list_props nil)
    (prefix const-decl "bool" traces nil))
   112 50 nil nil))
 (prefix_append2 0
  (prefix_append2-1 nil 3417191621 3417191669
   ("" (expand "prefix")
    (("" (skosimp*)
      (("" (replace*)
        (("" (inst + "t!2") (("" (rewrite "append_assoc") nil nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((T formal-type-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (append_assoc formula-decl nil list_props nil)
    (prefix const-decl "bool" traces nil))
   79 40 nil nil))
 (prefix_add1 0
  (prefix_add1-1 nil 3417191621 3417191669
   ("" (auto-rewrite "add" "prefix")
    (("" (assert) (("" (skolem!) (("" (inst?) nil nil)) nil)) nil))
    nil)
   proved
   ((prefix const-decl "bool" traces nil)
    (add const-decl "(cons?[T])" more_list_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil traces nil))
   68 40 nil nil))
 (prefix_add2 0
  (prefix_add2-1 nil 3417191621 3417191669
   ("" (auto-rewrite "add" "prefix_append1")
    (("" (skosimp) (("" (assert) nil nil)) nil)) nil)
   proved
   ((add const-decl "(cons?[T])" more_list_props nil)
    (prefix_append1 formula-decl nil traces nil))
   66 40 nil nil))
 (length_prefix 0
  (length_prefix-1 nil 3417191621 3417191669
   ("" (grind :defs nil :rewrites ("prefix" "length_append[T]")) nil
    nil)
   proved
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length_append formula-decl nil more_list_props nil)
    (T formal-type-decl nil traces nil)
    (prefix const-decl "bool" traces nil))
   166 80 nil nil))
 (prefix_reflexive 0
  (prefix_reflexive-1 nil 3417191621 3417191669
   ("" (auto-rewrite "append_null" "prefix")
    (("" (auto-rewrite "append_null[T]" "prefix")
      (("" (skolem!)
        (("" (assert)
          (("" (inst + "null") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   proved
   ((prefix const-decl "bool" traces nil)
    (append_null formula-decl nil list_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil traces nil))
   66 20 nil nil))
 (prefix_transitive 0
  (prefix_transitive-1 nil 3417191621 3417191669
   ("" (expand "prefix")
    (("" (skosimp*)
      (("" (replace*)
        (("" (inst + "append(t!1, t!2)")
          (("" (rewrite "append_assoc") nil nil)) nil))
        nil))
      nil))
    nil)
   proved
   ((T formal-type-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (append def-decl "list[T]" list_props nil)
    (append_assoc formula-decl nil list_props nil)
    (prefix const-decl "bool" traces nil))
   84 40 nil nil))
 (prefix_antisymmetric 0
  (prefix_antisymmetric-1 nil 3417191621 3417191669
   ("" (expand "prefix")
    (("" (skosimp*)
      (("" (auto-rewrite "length_zero[T]" "append_null[T]")
        (("" (case "length(t!1) = 0")
          (("1" (assert)
            (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)
           ("2" (use "length_append[T]")
            (("2" (use "length_append[T]" ("l1" "t2!1"))
              (("2" (stop-rewrite "length_zero[T]")
                (("2" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((trace type-eq-decl nil traces nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (append_null formula-decl nil list_props nil)
    (length_zero formula-decl nil more_list_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length_append formula-decl nil more_list_props nil)
    (prefix const-decl "bool" traces nil))
   301 180 nil nil))
 (proj_null 0
  (proj_null-1 nil 3417191621 3417191669 ("" (grind) nil nil) proved
   ((proj const-decl "[trace, set[T] -> trace]" traces nil)
    (filter def-decl "list[T]" filters nil))
   28 30 nil nil))
 (proj_emptyset 0
  (proj_emptyset-1 nil 3417191621 3417191670
   ("" (induct "t")
    (("1" (grind) nil nil)
     ("2" (skosimp)
      (("2" (expand "proj" 1)
        (("2" (expand "filter")
          (("2" (lift-if)
            (("2" (split)
              (("1" (flatten)
                (("1" (expand "emptyset") (("1" (propax) nil nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (expand "proj") (("2" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((finite_emptyset name-judgement "finite_set" finite_sets nil)
    (filter def-decl "list[T]" filters nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (emptyset const-decl "set" sets nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   139 70 nil nil))
 (proj_fullset 0
  (proj_fullset-1 nil 3417191621 3417191670
   ("" (induct "t")
    (("1" (grind) nil nil)
     ("2" (skosimp)
      (("2" (expand "proj" 1)
        (("2" (expand "filter")
          (("2" (lift-if)
            (("2" (split)
              (("1" (flatten)
                (("1" (expand "proj")
                  (("1" (replace -2 1) (("1" (propax) nil nil)) nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (expand "fullset" 1) (("2" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((filter def-decl "list[T]" filters nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (fullset const-decl "set" sets nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   141 50 nil nil))
 (proj_cons 0
  (proj_cons-1 nil 3417191621 3417191670
   ("" (auto-rewrite "proj" "filter[T]")
    (("" (skolem!) (("" (assert) nil)))) nil)
   proved
   ((proj const-decl "[trace, set[T] -> trace]" traces nil)
    (T formal-type-decl nil traces nil)
    (filter def-decl "list[T]" filters nil))
   89 50 nil nil))
 (proj_append 0
  (proj_append-1 nil 3417191621 3417191670
   ("" (skolem 1 ("A!1" _ "t!2")) (("" (induct-and-simplify "t1") nil))
    nil)
   proved
   ((filter def-decl "list[T]" filters nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (setof type-eq-decl nil defined_types nil)
    (append def-decl "list[T]" list_props nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   128 90 nil nil))
 (proj_add 0
  (proj_add-1 nil 3417191621 3417191670
   ("" (auto-rewrite "proj_append" "add")
    (("" (skolem!)
      (("" (assert)
        (("" (auto-rewrite "proj" "filter" "append_null[T]")
          (("" (lift-if) (("" (ground) nil))))))))))
    nil)
   proved
   ((T formal-type-decl nil traces nil)
    (append_null formula-decl nil list_props nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (filter def-decl "list[T]" filters nil)
    (add const-decl "(cons?[T])" more_list_props nil)
    (proj_append formula-decl nil traces nil))
   89 60 nil nil))
 (proj_prefix 0
  (proj_prefix-1 nil 3417191621 3417191670
   ("" (grind :exclude ("append" "proj") :rewrites ("proj_append")) nil
    nil)
   proved
   ((setof type-eq-decl nil defined_types nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (proj_append formula-decl nil traces nil)
    (prefix const-decl "bool" traces nil))
   134 70 nil nil))
 (proj_reverse 0
  (proj_reverse-1 nil 3417191621 3417191670
   ("" (induct "t")
    (("1" (grind) nil)
     ("2" (skosimp*)
      (("2" (auto-rewrite "reverse" "proj_append")
        (("2" (assert)
          (("2" (auto-rewrite "proj" "filter" "append_null[T]")
            (("2" (reduce) nil))))))))))
    nil)
   proved
   ((proj_append formula-decl nil traces nil)
    (append_null formula-decl nil list_props nil)
    (filter def-decl "list[T]" filters nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (reverse def-decl "list[T]" list_props nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   230 100 nil nil))
 (prefix_of_proj 0
  (prefix_of_proj-1 nil 3417191621 3417191671
   ("" (skolem + ("A!1" _ _))
    ((""
      (auto-rewrite "proj" "filter" "prefix_null" "null_prefix"
                    "cons_prefix")
      (("" (induct "t")
        (("1" (skosimp)
          (("1" (assert) (("1" (inst?) (("1" (assert) nil nil)) nil))
            nil))
          nil)
         ("2" (skosimp*)
          (("2" (assert)
            (("2" (lift-if)
              (("2" (ground)
                (("1" (rewrite "prefix_equiv")
                  (("1" (ground)
                    (("1" (inst + "null") (("1" (assert) nil nil)) nil)
                     ("2" (inst? -)
                      (("2" (assert)
                        (("2" (skosimp)
                          (("2" (inst + "cons(cons1_var!1, t2!1)")
                            (("2" (assert)
                              (("2" (apply-extensionality) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (inst? -)
                  (("2" (assert)
                    (("2" (skosimp)
                      (("2" (inst + "cons(cons1_var!1, t2!1)")
                        (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((pred type-eq-decl nil defined_types nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (prefix_equiv formula-decl nil traces nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons_prefix formula-decl nil traces nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null_prefix formula-decl nil traces nil)
    (prefix_null formula-decl nil traces nil)
    (filter def-decl "list[T]" filters nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (set type-eq-decl nil sets nil)
    (prefix const-decl "bool" traces nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   352 190 nil nil))
 (prefix_of_proj2 0
  (prefix_of_proj2-1 nil 3417191621 3417191671
   (""
    (grind :defs nil :if-match nil :rewrites
     ("prefix_of_proj" "proj_prefix"))
    nil nil)
   proved
   ((proj_prefix formula-decl nil traces nil)
    (prefix_of_proj formula-decl nil traces nil))
   137 70 nil nil))
 (proj_twice 0
  (proj_twice-1 nil 3417191621 3417191671
   ("" (skolem 1 ("A!1" "B!1" _)) (("" (induct-and-simplify "t") nil))
    nil)
   proved
   ((member const-decl "bool" sets nil)
    (filter def-decl "list[T]" filters nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (intersection const-decl "set" sets nil)
    (setof type-eq-decl nil defined_types nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   166 90 nil nil))
 (cons_proj 0
  (cons_proj-1 nil 3417191621 3417191671 ("" (grind) nil nil) proved
   ((filter def-decl "list[T]" filters nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil))
   93 50 nil nil))
 (every_proj 0
  (every_proj-1 nil 3417191621 3417191671
   ("" (induct-and-simplify "t") nil nil) proved
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (T formal-type-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil)
    (filter def-decl "list[T]" filters nil))
   283 170 nil nil))
 (every_proj2 0
  (every_proj2-1 nil 3417191621 3417191672
   ("" (induct-and-simplify "t") nil nil) proved
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (complement const-decl "set" sets nil)
    (T formal-type-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil)
    (filter def-decl "list[T]" filters nil)
    (member const-decl "bool" sets nil))
   231 150 nil nil))
 (add_proj 0
  (add_proj-1 nil 3417191621 3417191672
   ("" (skosimp)
    (("" (use "prefix_add1[T]")
      (("" (replace -2 -1)
        (("" (forward-chain "prefix_of_proj[T]")
          (("" (skosimp)
            (("" (replace -2 -4)
              (("" (inst 1 "proj(t2!1, A!1)")
                (("" (rewrite "proj_twice")
                  (("" (case "intersection(A!1, A!1) = A!1")
                    (("1" (replace -1)
                      (("1" (assert) (("1" (postpone) nil nil)) nil))
                      nil)
                     ("2" (delete -1 -2 -3 -4 2)
                      (("2" (apply-extensionality :hide? t)
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished nil 216 80 nil nil))
 (prod_TCC1 0
  (prod_TCC1-1 nil 3417191621 3417191672 ("" (grind) nil nil) proved
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   169 90 nil nil))
 (prod_TCC2 0
  (prod_TCC2-1 nil 3417191621 3417191672 ("" (grind) nil nil) proved
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   159 80 nil nil))
 (prod_TCC3 0
  (prod_TCC3-1 nil 3417191621 3417191672 ("" (grind) nil nil) proved
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   181 100 nil nil))
 (prod_append 0
  (prod_append-1 nil 3417191621 3417191675
   ("" (induct "t")
    (("1" (skosimp)
      (("1" (expand "prod" -1)
        (("1" (flatten) (("1" (grind) nil nil)) nil)) nil))
      nil)
     ("2" (skosimp*)
      (("2" (expand "prod" -2)
        (("2" (split)
          (("1" (flatten)
            (("1"
              (inst -7 "A!1" "cdr(t1!1)" "cdr(t2!1)" "u!1" "u1!1"
               "u2!1")
              (("1" (assert)
                (("1" (expand "append" 1 3)
                  (("1" (expand "prod" 1) (("1" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (split)
              (("1" (flatten)
                (("1"
                  (inst -4 "A!1" "cdr(t1!1)" "t2!1" "u!1" "u1!1"
                   "u2!1")
                  (("1" (assert)
                    (("1" (expand "append" 2 3)
                      (("1" (expand "prod" 2)
                        (("1" (flatten)
                          (("1" (delete 3) (("1" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2"
                  (inst -4 "A!1" "t1!1" "cdr(t2!1)" "u!1" "u1!1"
                   "u2!1")
                  (("2" (assert)
                    (("2" (expand "append" 2 3)
                      (("2" (expand "prod" 2)
                        (("2" (flatten)
                          (("2" (delete 2) (("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (append def-decl "list[T]" list_props nil)
    (prod def-decl "bool" traces nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   2255 290 nil nil))
 (prod_add1 0
  (prod_add1-1 nil 3417191621 3417191675
   ("" (induct "t")
    (("1" (grind) nil nil)
     ("2" (skosimp*)
      (("2" (expand "prod" -2)
        (("2" (split -2)
          (("1" (flatten)
            (("1"
              (case "add(cons(cons1_var!1, cons2_var!1), a!1) = cons(cons1_var!1, add(cons2_var!1, a!1))")
              (("1" (replace -1)
                (("1" (delete -1)
                  (("1" (expand "prod" 1)
                    (("1" (assert)
                      (("1" (split)
                        (("1" (grind) nil nil) ("2" (grind) nil nil)
                         ("3" (grind) nil nil) ("4" (grind) nil nil)
                         ("5"
                          (case "cdr(add(t1!1, a!1)) = add(cdr(t1!1), a!1) AND cdr(add(t2!1, a!1)) = add(cdr(t2!1), a!1)")
                          (("1" (flatten)
                            (("1" (replace -1)
                              (("1"
                                (replace -2)
                                (("1"
                                  (delete -1 -2)
                                  (("1"
                                    (inst?)
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (delete -1 -6 -7 -8 2)
                            (("2" (split)
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (delete -1 -6 -7 2) (("2" (grind) nil nil)) nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (split)
              (("1" (flatten)
                (("1"
                  (case "add(cons(cons1_var!1, cons2_var!1), a!1) = cons(cons1_var!1, add(cons2_var!1, a!1))")
                  (("1" (replace -1)
                    (("1" (expand "prod" 2)
                      (("1" (assert)
                        (("1" (flatten)
                          (("1" (delete -1)
                            (("1" (delete 3)
                              (("1"
                                (split)
                                (("1" (grind) nil nil)
                                 ("2" (grind) nil nil)
                                 ("3"
                                  (case
                                   "cdr(add(t1!1, a!1)) = add(cdr(t1!1), a!1)")
                                  (("1"
                                    (replace -1)
                                    (("1"
                                      (inst?)
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (delete -3 -4 -5 2 3)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (delete -3 -4 -5 2 3) (("2" (grind) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2"
                  (case "add(cons(cons1_var!1, cons2_var!1), a!1) = cons(cons1_var!1, add(cons2_var!1, a!1))")
                  (("1" (replace -1)
                    (("1" (delete -1)
                      (("1" (expand "prod" 2)
                        (("1" (assert)
                          (("1" (flatten)
                            (("1" (delete 2)
                              (("1"
                                (split)
                                (("1" (grind) nil nil)
                                 ("2" (grind) nil nil)
                                 ("3"
                                  (case
                                   "cdr(add(t2!1, a!1)) = add(cdr(t2!1), a!1)")
                                  (("1"
                                    (replace -1)
                                    (("1"
                                      (inst?)
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (delete -3 -4 -5 2 3)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (delete -3 -4 -5 2 3) (("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((= const-decl "[T, T -> boolean]" equalities nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (add const-decl "(cons?[T])" more_list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (prod def-decl "bool" traces nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   726 510 nil nil))
 (prod_add2 0
  (prod_add2-1 nil 3417191621 3417191676
   ("" (induct "t")
    (("1" (grind) nil nil)
     ("2" (skosimp*)
      (("2" (expand "prod" -2)
        (("2" (split -2)
          (("1" (flatten)
            (("1" (split)
              (("1"
                (case "add(cons(cons1_var!1, cons2_var!1), a!1) = cons(cons1_var!1, add(cons2_var!1, a!1))")
                (("1" (replace -1)
                  (("1" (delete -1)
                    (("1" (expand "prod" 1)
                      (("1" (assert)
                        (("1" (split)
                          (("1" (grind) nil nil) ("2" (grind) nil nil)
                           ("3"
                            (case "cdr(add(t2!1, a!1)) = add(cdr(t2!1), a!1)")
                            (("1" (replace -1)
                              (("1"
                                (inst?)
                                (("1" (assert) nil nil))
                                nil))
                              nil)
                             ("2" (delete -1 -6 -7 -8 2)
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete -1 -6 -7 2) (("2" (grind) nil nil)) nil))
                nil)
               ("2"
                (case "add(cons(cons1_var!1, cons2_var!1), a!1) = cons(cons1_var!1, add(cons2_var!1, a!1))")
                (("1" (replace -1)
                  (("1" (expand "prod" 1)
                    (("1" (assert)
                      (("1" (delete -1)
                        (("1" (split)
                          (("1" (grind) nil nil) ("2" (grind) nil nil)
                           ("3"
                            (case "cdr(add(t1!1, a!1)) = add(cdr(t1!1), a!1)")
                            (("1" (replace -1)
                              (("1"
                                (inst?)
                                (("1" (assert) nil nil))
                                nil))
                              nil)
                             ("2" (delete -3 -4 -5 2 3)
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete -3 -4 -5 2 3) (("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (split)
              (("1" (flatten)
                (("1" (split)
                  (("1"
                    (case "add(cons(cons1_var!1, cons2_var!1), a!1) = cons(cons1_var!1, add(cons2_var!1, a!1))")
                    (("1" (replace -1)
                      (("1" (expand "prod" 1)
                        (("1" (assert)
                          (("1" (flatten)
                            (("1" (delete -1 2)
                              (("1"
                                (inst?)
                                (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (delete -3 -4 -5 2 3) (("2" (grind) nil nil))
                      nil))
                    nil)
                   ("2"
                    (case "add(cons(cons1_var!1, cons2_var!1), a!1) = cons(cons1_var!1, add(cons2_var!1, a!1))")
                    (("1" (replace -1)
                      (("1" (delete -1)
                        (("1" (expand "prod" 1)
                          (("1" (assert)
                            (("1" (flatten)
                              (("1"
                                (delete 2)
                                (("1"
                                  (split)
                                  (("1" (grind) nil nil)
                                   ("2" (grind) nil nil)
                                   ("3"
                                    (case
                                     "cdr(add(t1!1, a!1)) = add(cdr(t1!1), a!1)")
                                    (("1"
                                      (replace -1)
                                      (("1"
                                        (inst?)
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (delete -3 -4 -5 2 3)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (delete -3 -4 -5 2 3) (("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (split)
                  (("1"
                    (case "add(cons(cons1_var!1, cons2_var!1), a!1) = cons(cons1_var!1, add(cons2_var!1, a!1))")
                    (("1" (replace -1)
                      (("1" (expand "prod" 1)
                        (("1" (assert)
                          (("1" (flatten)
                            (("1" (delete 1)
                              (("1"
                                (delete -1)
                                (("1"
                                  (split)
                                  (("1" (grind) nil nil)
                                   ("2" (grind) nil nil)
                                   ("3"
                                    (case
                                     "cdr(add(t2!1, a!1)) = add(cdr(t2!1), a!1)")
                                    (("1"
                                      (replace -1)
                                      (("1"
                                        (inst?)
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (delete -3 -4 -5 2 3)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (delete -3 -4 -5 2 3) (("2" (grind) nil nil))
                      nil))
                    nil)
                   ("2"
                    (case "add(cons(cons1_var!1, cons2_var!1), a!1) = cons(cons1_var!1, add(cons2_var!1, a!1))")
                    (("1" (replace -1)
                      (("1" (delete -1)
                        (("1" (expand "prod" 1)
                          (("1" (assert)
                            (("1" (flatten)
                              (("1"
                                (delete 1)
                                (("1"
                                  (inst?)
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (delete -3 -4 -5 2 3) (("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (append def-decl "list[T]" list_props nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (add const-decl "(cons?[T])" more_list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (prod def-decl "bool" traces nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   1026 700 nil nil))
 (prod_reverse 0
  (prod_reverse-1 nil 3417191621 3417191677
   ("" (induct "t")
    (("1" (skosimp)
      (("1" (expand "reverse" 1 3)
        (("1" (expand "prod")
          (("1" (split) (("1" (grind) nil nil) ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skosimp*)
      (("2" (expand "prod" -2)
        (("2" (split)
          (("1" (flatten)
            (("1" (inst?)
              (("1" (assert)
                (("1" (lemma "prod_add1")
                  (("1"
                    (inst -1 "A!1" "cons1_var!1" "reverse(cons2_var!1)"
                     "reverse(cdr(t1!1))" "reverse(cdr(t2!1))")
                    (("1" (assert)
                      (("1" (rewrite "reverse_cons" :dir rl)
                        (("1" (rewrite "reverse_cons" :dir rl)
                          (("1" (rewrite "reverse_cons" :dir rl)
                            (("1"
                              (case "cons(cons1_var!1, cdr(t1!1)) = t1!1 AND cons(cons1_var!1, cdr(t2!1)) = t2!1")
                              (("1"
                                (flatten)
                                (("1"
                                  (replace -1)
                                  (("1"
                                    (replace -2)
                                    (("1" (propax) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (split)
                                (("1"
                                  (replace -5 1 rl)
                                  (("1"
                                    (lemma "list_cons_eta[T]")
                                    (("1" (inst?) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (replace -6 1 rl)
                                  (("2"
                                    (lemma "list_cons_eta[T]")
                                    (("2" (inst?) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (split)
              (("1" (flatten)
                (("1" (inst?)
                  (("1" (assert)
                    (("1" (lemma "prod_add2")
                      (("1"
                        (inst -1 "A!1" "cons1_var!1"
                         "reverse(cons2_var!1)" "reverse(cdr(t1!1))"
                         "reverse(t2!1)")
                        (("1" (assert)
                          (("1" (flatten)
                            (("1" (delete -1)
                              (("1"
                                (rewrite "reverse_cons" :dir rl)
                                (("1"
                                  (rewrite "reverse_cons" :dir rl)
                                  (("1"
                                    (case
                                     "cons(cons1_var!1, cdr(t1!1)) = t1!1")
                                    (("1"
                                      (replace -1)
                                      (("1" (propax) nil nil))
                                      nil)
                                     ("2"
                                      (replace -3 1 rl)
                                      (("2"
                                        (lemma "list_cons_eta[T]")
                                        (("2" (inst?) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (inst?)
                  (("2" (assert)
                    (("2" (lemma "prod_add2")
                      (("2"
                        (inst -1 "A!1" "cons1_var!1"
                         "reverse(cons2_var!1)" "reverse(t1!1)"
                         "reverse(cdr(t2!1))")
                        (("2" (assert)
                          (("2" (flatten)
                            (("2" (delete -2)
                              (("2"
                                (rewrite "reverse_cons" :dir rl)
                                (("2"
                                  (rewrite "reverse_cons" :dir rl)
                                  (("2"
                                    (case
                                     "cons(cons1_var!1, cdr(t2!1)) = t2!1")
                                    (("1"
                                      (replace -1)
                                      (("1" (propax) nil nil))
                                      nil)
                                     ("2"
                                      (replace -3 1 rl)
                                      (("2"
                                        (lemma "list_cons_eta[T]")
                                        (("2" (inst?) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (prod_add1 formula-decl nil traces nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (list_cons_eta formula-decl nil list_adt nil)
    (reverse_cons formula-decl nil more_list_props nil)
    (prod_add2 formula-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (reverse def-decl "list[T]" list_props nil)
    (prod def-decl "bool" traces nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   672 360 nil nil))
 (prod_reverse2 0
  (prod_reverse2-1 nil 3417191621 3417191677
   ("" (skosimp)
    (("" (lemma "prod_reverse")
      ((""
        (inst -1 "A!1" "reverse(t!1)" "reverse(t1!1)" "reverse(t2!1)")
        (("" (assert)
          (("" (rewrite "reverse_reverse")
            (("" (rewrite "reverse_reverse")
              (("" (rewrite "reverse_reverse") nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((prod_reverse formula-decl nil traces nil)
    (reverse_reverse formula-decl nil list_props nil)
    (reverse def-decl "list[T]" list_props nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil traces nil))
   123 60 nil nil))
 (prod_reverse3 0
  (prod_reverse3-1 nil 3417191621 3417191677
   ("" (skosimp)
    (("" (iff)
      (("" (split)
        (("1" (use "prod_reverse") nil nil)
         ("2" (lemma "prod_reverse2")
          (("2" (inst -1 "A!1" "t!1" "t1!1" "t2!1") nil nil)) nil))
        nil))
      nil))
    nil)
   proved
   ((prod_reverse2 formula-decl nil traces nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil traces nil)
    (prod_reverse formula-decl nil traces nil))
   106 40 nil nil))
 (prod_proj2 0
  (prod_proj2-1 nil 3417191621 3417191678
   ("" (induct "t3")
    (("1" (grind) nil nil)
     ("2" (skosimp*)
      (("2" (expand "prod" -2)
        (("2" (smash 2)
          (("1" (rewrite "proj_cons")
            (("1" (lift-if)
              (("1" (split)
                (("1" (flatten)
                  (("1"
                    (case "proj(t1!1, B!1) = cons(cons1_var!1, proj(cdr(t1!1), B!1))")
                    (("1" (replace -1)
                      (("1" (delete -1)
                        (("1"
                          (case "proj(t2!1, B!1) = cons(cons1_var!1, proj(cdr(t2!1), B!1))")
                          (("1" (replace -1)
                            (("1" (delete -1)
                              (("1"
                                (expand "prod" 1)
                                (("1"
                                  (inst?)
                                  (("1"
                                    (assert)
                                    (("1" (inst?) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (delete -2 -3 -4 -6 -8 2)
                            (("2" (lemma "list_cons_eta[T]")
                              (("2"
                                (inst?)
                                (("2"
                                  (replace -1 1 rl)
                                  (("2"
                                    (replace -4)
                                    (("2"
                                      (rewrite "proj_cons")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (delete -2 -3 -5 -7 -8 2)
                      (("2" (lemma "list_cons_eta[T]")
                        (("2" (inst?)
                          (("2" (replace -1 1 rl)
                            (("2" (replace -4)
                              (("2"
                                (rewrite "proj_cons")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (case "proj(t1!1, B!1) = proj(cdr(t1!1), B!1)")
                    (("1" (replace -1)
                      (("1" (delete -1)
                        (("1"
                          (case "proj(t2!1, B!1) = proj(cdr(t2!1), B!1)")
                          (("1" (replace -1)
                            (("1" (delete -1)
                              (("1"
                                (inst?)
                                (("1"
                                  (assert)
                                  (("1" (inst?) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (delete -1 -2 -3 -5 -7 3)
                            (("2" (lemma "list_cons_eta[T]")
                              (("2"
                                (inst?)
                                (("2"
                                  (replace -1 1 rl)
                                  (("2"
                                    (replace -3)
                                    (("2"
                                      (rewrite "proj_cons")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (delete -1 -2 -4 -6 -7 3)
                      (("2" (lemma "list_cons_eta[T]")
                        (("2" (inst?)
                          (("2" (replace -1 1 rl)
                            (("2" (replace -3)
                              (("2"
                                (rewrite "proj_cons")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (rewrite "proj_cons")
            (("2" (lift-if)
              (("2" (split)
                (("1" (flatten)
                  (("1"
                    (case "proj(t1!1, B!1) = cons(cons1_var!1, proj(cdr(t1!1), B!1))")
                    (("1" (replace -1)
                      (("1" (delete -1)
                        (("1" (expand "prod" 1)
                          (("1" (flatten)
                            (("1" (delete 2)
                              (("1"
                                (inst?)
                                (("1"
                                  (assert)
                                  (("1" (inst?) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (delete -2 -5 2 3)
                      (("2" (lemma "list_cons_eta[T]")
                        (("2" (inst?)
                          (("2" (replace -1 1 rl)
                            (("2" (replace -4)
                              (("2"
                                (rewrite "proj_cons")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (case "proj(t1!1, B!1) = proj(cdr(t1!1), B!1)")
                    (("1" (replace -1)
                      (("1" (delete -1)
                        (("1" (inst?)
                          (("1" (assert) (("1" (inst?) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (delete -1 -4 3 4)
                      (("2" (lemma "list_cons_eta[T]")
                        (("2" (inst?)
                          (("2" (replace -1 1 rl)
                            (("2" (replace -3)
                              (("2"
                                (rewrite "proj_cons")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (rewrite "proj_cons")
            (("3" (lift-if)
              (("3" (split)
                (("1" (flatten)
                  (("1"
                    (case "proj(t2!1, B!1) = cons(cons1_var!1, proj(cdr(t2!1), B!1))")
                    (("1" (replace -1)
                      (("1" (delete -1)
                        (("1" (expand "prod" 1)
                          (("1" (flatten)
                            (("1" (delete 1)
                              (("1"
                                (inst?)
                                (("1"
                                  (assert)
                                  (("1" (inst?) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (delete -2 -5 2 3)
                      (("2" (lemma "list_cons_eta[T]")
                        (("2" (inst?)
                          (("2" (replace -1 1 rl)
                            (("2" (replace -4)
                              (("2"
                                (rewrite "proj_cons")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (case "proj(t2!1, B!1) = proj(cdr(t2!1), B!1)")
                    (("1" (replace -1)
                      (("1" (delete -1)
                        (("1" (inst?)
                          (("1" (assert) (("1" (inst?) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (delete -1 -4 3 4)
                      (("2" (lemma "list_cons_eta[T]")
                        (("2" (inst?)
                          (("2" (replace -1 1 rl)
                            (("2" (replace -3)
                              (("2"
                                (rewrite "proj_cons")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((list_cons_eta formula-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (proj_cons formula-decl nil traces nil)
    (filter def-decl "list[T]" filters nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (set type-eq-decl nil sets nil) (prod def-decl "bool" traces nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   1032 590 nil nil))
 (prod_commutes 0
  (prod_commutes-1 nil 3417191621 3417191679
   ("" (skolem!)
    ((""
      (case "FORALL t1, t2, t : prod(A!1)(t1, t2, t) IMPLIES prod(A!1)(t2, t1, t)")
      (("1" (grind :if-match all) nil nil)
       ("2" (delete 2)
        (("2" (auto-rewrite "prod" "proj" "filter")
          (("2" (induct "t")
            (("1" (skosimp)
              (("1" (assert) (("1" (ground) nil nil)) nil)) nil)
             ("2" (skosimp*)
              (("2" (case "A!1(cons1_var!1)")
                (("1" (assert)
                  (("1" (ground)
                    (("1" (inst?) (("1" (assert) nil nil)) nil)) nil))
                  nil)
                 ("2" (assert)
                  (("2" (split -)
                    (("1" (flatten)
                      (("1" (inst? - :where 3) (("1" (assert) nil nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (inst? - :where 2) (("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((prod def-decl "bool" traces nil)
    (setof type-eq-decl nil defined_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list_induction formula-decl nil list_adt nil))
   326 200 nil nil))
 (proj_prod1 0
  (proj_prod1-1 nil 3417191621 3417191679
   ("" (induct-and-simplify "t") nil nil) proved
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (prod def-decl "bool" traces nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (T formal-type-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil)
    (filter def-decl "list[T]" filters nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil))
   266 160 nil nil))
 (proj_prod2 0
  (proj_prod2-1 nil 3417191621 3417191679
   ("" (skosimp)
    (("" (rewrite "prod_commutes")
      (("" (forward-chain "proj_prod1") nil))))
    nil)
   proved
   ((prod_commutes formula-decl nil traces nil)
    (T formal-type-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (proj_prod1 formula-decl nil traces nil))
   105 50 nil nil))
 (prod_null1 0
  (prod_null1-1 nil 3417191621 3417191679
   ("" (induct-and-simplify "t") (("" (apply-extensionality) nil)) nil)
   proved
   ((list_cons_extensionality formula-decl nil list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (prod def-decl "bool" traces nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil))
   212 120 nil nil))
 (prod_null2 0
  (prod_null2-1 nil 3417191621 3417191679
   ("" (skosimp)
    (("" (rewrite "prod_commutes")
      (("" (forward-chain "prod_null1") nil))))
    nil)
   proved
   ((prod_commutes formula-decl nil traces nil)
    (T formal-type-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prod_null1 formula-decl nil traces nil))
   103 30 nil nil))
 (prod_null3 0
  (prod_null3-1 nil 3417191621 3417191680
   ("" (induct-and-simplify "t") nil nil) proved
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prod def-decl "bool" traces nil)
    (T formal-type-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil)
    (filter def-decl "list[T]" filters nil))
   188 120 nil nil))
 (prod_null4 0
  (prod_null4-1 nil 3417191621 3417191680
   ("" (skosimp)
    (("" (rewrite "prod_commutes") (("" (rewrite "prod_null3") nil))))
    nil)
   proved
   ((prod_commutes formula-decl nil traces nil)
    (T formal-type-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prod_null3 formula-decl nil traces nil))
   68 40 nil nil))
 (prefix_prod 0
  (prefix_prod-1 nil 3417191621 3417191680
   ("" (skolem + ("A!1" _ _ _ _))
    (("" (auto-rewrite "prod" "prefix_null" "null_prefix")
      (("" (induct "t")
        (("1" (skosimp)
          (("1" (assert)
            (("1" (inst + "null" "null") (("1" (ground) nil nil)) nil))
            nil))
          nil)
         ("2" (skosimp*)
          (("2" (case "null?(u!1)")
            (("1" (delete -2 -3)
              (("1" (inst + "null" "null") (("1" (assert) nil nil))
                nil))
              nil)
             ("2" (rewrite "prefix_equiv")
              (("2" (assert)
                (("2" (ground)
                  (("1" (inst? -)
                    (("1" (inst? -)
                      (("1" (assert)
                        (("1" (skosimp)
                          (("1"
                            (inst + "cons(cons1_var!1, u1!1)"
                             "cons(cons1_var!1, u2!1)")
                            (("1" (assert)
                              (("1"
                                (auto-rewrite "prefix_equiv")
                                (("1" (ground) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (inst? -)
                    (("2" (inst? -)
                      (("2" (assert)
                        (("2" (skosimp)
                          (("2"
                            (inst + "cons(cons1_var!1, u1!1)" "u2!1")
                            (("2" (assert)
                              (("2"
                                (rewrite "prefix_equiv" +)
                                nil
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (inst? -)
                    (("3" (inst? -)
                      (("3" (assert)
                        (("3" (skosimp)
                          (("3"
                            (inst + "u1!1" "cons(cons1_var!1, u2!1)")
                            (("3" (assert)
                              (("3"
                                (rewrite "prefix_equiv" +)
                                nil
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (prefix_equiv formula-decl nil traces nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null_prefix formula-decl nil traces nil)
    (prefix_null formula-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (prefix const-decl "bool" traces nil)
    (prod def-decl "bool" traces nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   627 360 nil nil))
 (prod_assoc1 0
  (prod_assoc1-1 nil 3417191621 3417191681
   ("" (skolem 1 ("A!1" _ _ _ _ _))
    (("" (auto-rewrite "prod")
      (("" (induct "t")
        (("1" (reduce) nil)
         ("2" (skosimp*)
          (("2" (reduce :if-match nil)
            (("1" (inst?)
              (("1" (inst?)
                (("1" (assert)
                  (("1" (skosimp)
                    (("1" (inst + "cons(cons1_var!1, u1!1)")
                      (("1" (assert) nil)))))))))))
             ("2" (inst? -)
              (("2" (inst? -)
                (("2" (assert)
                  (("2" (skosimp)
                    (("2" (inst?) (("2" (assert) nil)))))))))))
             ("3" (inst? -)
              (("3" (inst? -)
                (("3" (assert)
                  (("3" (skosimp)
                    (("3" (inst + "cons(cons1_var!1, u1!1)")
                      (("3" (assert) nil)))))))))))
             ("4" (inst? -)
              (("4" (inst? -)
                (("4" (assert)
                  (("4" (skosimp)
                    (("4" (inst + "cons(cons1_var!1, u1!1)")
                      (("4" (assert) nil))))))))))))))))))))
    nil)
   proved
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (prod def-decl "bool" traces nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   1040 750 nil nil))
 (prod_assoc2 0
  (prod_assoc2-1 nil 3417191621 3417191682
   ("" (skolem 1 ("A!1" _ _ _ _ _))
    (("" (auto-rewrite "prod")
      (("" (induct "t")
        (("1" (reduce) nil)
         ("2" (skosimp*)
          (("2" (reduce :if-match nil)
            (("1"
              (inst - "cdr(t1!1)" "cdr(t2!1)" "cdr(t3!1)" "cdr(u!1)")
              (("1" (assert)
                (("1" (skosimp)
                  (("1" (inst + "cons(cons1_var!1, u1!1)")
                    (("1" (assert) nil)))))))))
             ("2" (inst - "cdr(t1!1)" "t2!1" "t3!1" "u!1")
              (("2" (assert)
                (("2" (skosimp)
                  (("2" (inst + "cons(cons1_var!1, u1!1)")
                    (("2" (assert) nil)))))))))
             ("3" (inst - "t1!1" "cdr(t2!1)" "t3!1" "cdr(u!1)")
              (("3" (assert)
                (("3" (skosimp)
                  (("3" (inst + "cons(cons1_var!1, u1!1)")
                    (("3" (assert) nil)))))))))
             ("4" (inst - "t1!1" "t2!1" "cdr(t3!1)" "cdr(u!1)")
              (("4" (assert)
                (("4" (skosimp)
                  (("4" (inst?) (("4" (assert) nil))))))))))))))))))
    nil)
   proved
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (prod def-decl "bool" traces nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   997 680 nil nil))
 (prod_assoc 0
  (prod_assoc-1 nil 3417191621 3417191683
   ("" (reduce :if-match nil)
    (("1" (use "prod_assoc1") (("1" (assert) nil)))
     ("2" (use "prod_assoc2") (("2" (assert) nil))))
    nil)
   proved
   ((prod_assoc2 formula-decl nil traces nil)
    (prod_assoc1 formula-decl nil traces nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil traces nil))
   263 150 nil nil))
 (prod_fullset 0
  (prod_fullset-1 nil 3417191621 3417191683
   ("" (auto-rewrite "fullset" "prod")
    (("" (induct "u")
      (("1" (reduce) nil)
       ("2" (skosimp*)
        (("2" (assert)
          (("2" (split)
            (("1" (flatten)
              (("1" (assert)
                (("1" (inst?)
                  (("1" (ground)
                    (("1" (apply-extensionality :hide? t) nil)
                     ("2" (apply-extensionality :hide? t) nil)))))))))
             ("2" (flatten)
              (("2" (assert)
                (("2" (inst?)
                  (("2" (replace*)
                    (("2" (delete -)
                      (("2" (assert) nil))))))))))))))))))))
    nil)
   proved
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (prod def-decl "bool" traces nil) (set type-eq-decl nil sets nil)
    (fullset const-decl "set" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil))
   292 150 nil nil))
 (prod_fullset2 0
  (prod_fullset2-1 nil 3417191621 3417191684
   ("" (induct "t")
    (("1" (skosimp)
      (("1" (rewrite "proj_null")
        (("1" (expand "prod")
          (("1" (flatten)
            (("1" (split) (("1" (grind) nil nil) ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skosimp*)
      (("2" (expand "prod" -2)
        (("2" (split -2)
          (("1" (flatten)
            (("1" (inst?)
              (("1" (assert)
                (("1" (rewrite "prod_fullset" -7)
                  (("1" (rewrite "proj_cons")
                    (("1" (expand "prod" 1)
                      (("1" (split)
                        (("1" (grind)
                          (("1" (rewrite "prod_fullset") nil nil)) nil)
                         ("2" (flatten)
                          (("2" (expand "fullset")
                            (("2" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (split)
              (("1" (flatten)
                (("1" (inst?)
                  (("1" (assert)
                    (("1" (rewrite "prod_fullset" -4)
                      (("1" (rewrite "proj_cons")
                        (("1" (flatten)
                          (("1" (lemma "list_cons_eta[T]")
                            (("1" (inst -1 "t1!1")
                              (("1"
                                (replace -3 -1)
                                (("1"
                                  (replace -1 2 rl)
                                  (("1"
                                    (rewrite "proj_cons")
                                    (("1"
                                      (rewrite "prod_fullset")
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (inst?)
                  (("2" (assert)
                    (("2" (rewrite "prod_fullset" -4)
                      (("2" (flatten)
                        (("2" (rewrite "proj_cons")
                          (("2" (lemma "list_cons_eta[T]")
                            (("2" (inst -1 "t2!1")
                              (("2"
                                (replace -3 -1)
                                (("2"
                                  (replace -1 2 rl)
                                  (("2"
                                    (rewrite "proj_cons")
                                    (("2"
                                      (rewrite "prod_fullset")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (prod_fullset formula-decl nil traces nil)
    (pred type-eq-decl nil defined_types nil)
    (proj_cons formula-decl nil traces nil)
    (list_cons_eta formula-decl nil list_adt nil)
    (filter def-decl "list[T]" filters nil)
    (proj_null formula-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (fullset const-decl "set" sets nil) (set type-eq-decl nil sets nil)
    (prod def-decl "bool" traces nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   770 400 nil nil))
 (free_prod_left 0
  (free_prod_left-1 nil 3417191621 3417191684
   ("" (induct-and-simplify "t") nil nil) proved
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (prod def-decl "bool" traces nil) (set type-eq-decl nil sets nil)
    (emptyset const-decl "set" sets nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (T formal-type-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   85 40 nil nil))
 (free_prod_right 0
  (free_prod_right-1 nil 3417191621 3417191684
   ("" (induct-and-simplify "t") nil nil) proved
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (prod def-decl "bool" traces nil) (set type-eq-decl nil sets nil)
    (emptyset const-decl "set" sets nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (T formal-type-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   86 60 nil nil))
 (trename_TCC1 0
  (trename_TCC1-1 nil 3417191621 3417191684
   ("" (termination-tcc) nil nil) proved
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   151 90 nil nil))
 (trename_null1 0
  (trename_null1-1 nil 3417191621 3417191684
   ("" (skosimp)
    (("" (expand "trename")
      (("" (lift-if)
        (("" (split)
          (("1" (flatten) (("1" (assert) nil nil)) nil)
           ("2" (flatten) (("2" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   proved ((trename def-decl "bool" traces nil)) 30 30 nil nil))
 (trename_null2 0
  (trename_null2-1 nil 3417191621 3417191684
   ("" (skosimp) (("" (expand "trename") (("" (assert) nil nil)) nil))
    nil)
   proved ((trename def-decl "bool" traces nil)) 62 20 nil nil))
 (prefix_trename 0
  (prefix_trename-1 nil 3417191621 3417191685
   ("" (skolem + ("R!1" _ _ _))
    (("" (induct "t")
      (("1" (skosimp)
        (("1" (forward-chain "trename_null2")
          (("1" (rewrite "prefix_null")
            (("1" (replace -1 1)
              (("1" (replace -3 1)
                (("1" (inst 1 "null") (("1" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skolem!)
        (("2" (flatten)
          (("2" (skolem!)
            (("2" (lemma "list_inclusive[T]")
              (("2" (inst -1 "u!1")
                (("2" (split)
                  (("1" (flatten)
                    (("1" (inst 1 "null")
                      (("1" (split)
                        (("1" (use "null_prefix") nil nil)
                         ("2" (case "u!1 = null")
                          (("1" (replace -1 1)
                            (("1" (expand "trename" 1)
                              (("1" (propax) nil nil)) nil))
                            nil)
                           ("2" (delete -2 -3 -4 2)
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (inst -2 "cdr(t1!1)" "cdr(u!1)")
                      (("1" (split)
                        (("1" (skosimp)
                          (("1" (inst 1 "cons(car(t1!1), u1!1)")
                            (("1" (split)
                              (("1"
                                (lemma "list_cons_eta[T]")
                                (("1"
                                  (inst -1 "t1!1")
                                  (("1"
                                    (replace -1 1 :dir rl)
                                    (("1"
                                      (rewrite "cons_prefix")
                                      nil
                                      nil))
                                    nil)
                                   ("2"
                                    (expand "trename" -4)
                                    (("2" (flatten) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (expand "trename" -4)
                                (("2"
                                  (flatten)
                                  (("2"
                                    (lemma "list_cons_eta[T]")
                                    (("2"
                                      (inst -1 "u!1")
                                      (("2"
                                        (replace -1 1 :dir rl)
                                        (("2"
                                          (expand "trename" 1)
                                          (("2"
                                            (split)
                                            (("1"
                                              (replace -1 -8 :dir rl)
                                              (("1"
                                                (rewrite "cons_prefix")
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (replace -8 1)
                                                    (("1"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (expand "trename" -4)
                              (("2" (flatten) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (delete -1 -3 2)
                          (("2" (expand "trename" -1)
                            (("2" (flatten) nil nil)) nil))
                          nil)
                         ("3" (delete -2 2)
                          (("3" (lemma "list_cons_eta[T]")
                            (("3" (inst -1 "u!1")
                              (("3"
                                (replace -1 -3 :dir rl)
                                (("3"
                                  (rewrite "cons_prefix")
                                  (("3" (flatten) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand "trename" -2)
                        (("2" (flatten) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (trename def-decl "bool" traces nil)
    (prefix const-decl "bool" traces nil)
    (T formal-type-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil)
    (trename_null2 formula-decl nil traces nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (prefix_null formula-decl nil traces nil)
    (list_inclusive formula-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null_prefix formula-decl nil traces nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (u!1 skolem-const-decl "trace" traces nil)
    (t1!1 skolem-const-decl "trace" traces nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons_prefix formula-decl nil traces nil)
    (list_cons_eta formula-decl nil list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil))
   559 270 nil nil))
 (sigma_equiv 0
  (sigma_equiv-1 nil 3417191621 3417191685
   ("" (induct-and-simplify "t")
    (("1" (apply-extensionality :hide? t) nil)
     ("2" (replace*)
      (("2" (apply-extensionality :hide? t) (("2" (smash) nil))))))
    nil)
   proved
   ((member const-decl "bool" sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (FALSE const-decl "bool" booleans nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (list2set def-decl "set[T]" list2set nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (member def-decl "bool" list_props nil)
    (T formal-type-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil))
   246 130 nil nil))
 (sigma_null 0
  (sigma_null-1 nil 3417191621 3417191685 ("" (grind) nil nil) proved
   ((sigma const-decl "[trace -> set[T]]" traces nil)
    (list2set def-decl "set[T]" list2set nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   28 20 nil nil))
 (sigma_cons 0
  (sigma_cons-1 nil 3417191621 3417191685 ("" (grind) nil nil) proved
   ((sigma const-decl "[trace -> set[T]]" traces nil)
    (list2set def-decl "set[T]" list2set nil))
   66 30 nil nil))
 (sigma_empty 0
  (sigma_empty-1 nil 3417191621 3417191685 ("" (grind) nil nil) proved
   ((trace type-eq-decl nil traces nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (list2set def-decl "set[T]" list2set nil)
    (add const-decl "(nonempty?)" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (emptyset const-decl "set" sets nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil))
   176 130 nil nil))
 (sigma_append 0
  (sigma_append-1 nil 3417191621 3417191686
   ("" (induct-and-simplify "t1")
    (("1" (apply-extensionality :hide? t) nil)
     ("2" (replace*)
      (("2" (apply-extensionality :hide? t) (("2" (smash) nil))))))
    nil)
   proved
   ((nonempty? const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (nonempty_union1 application-judgement "(nonempty?)" sets nil)
    (list2set def-decl "set[T]" list2set nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (append def-decl "list[T]" list_props nil)
    (union const-decl "set" sets nil)
    (T formal-type-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil))
   368 220 nil nil))
 (sigma_add 0
  (sigma_add-1 nil 3417191621 3417191686
   ("" (expand "add" 1 1)
    (("" (skolem!)
      (("" (rewrite "sigma_append")
        (("" (apply-extensionality :hide? t) (("" (grind) nil))))))))
    nil)
   proved
   ((add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (union const-decl "set" sets nil) (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (list2set def-decl "set[T]" list2set nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (sigma_append formula-decl nil traces nil)
    (add const-decl "(cons?[T])" more_list_props nil))
   174 120 nil nil))
 (sigma_prefix 0
  (sigma_prefix-1 nil 3417191621 3417191686
   ("" (auto-rewrite "prefix" "sigma_append")
    (("" (auto-rewrite-theory "sets[T]") (("" (reduce) nil)))) nil)
   proved
   ((subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (T formal-type-decl nil traces nil)
    (prefix const-decl "bool" traces nil)
    (sigma_append formula-decl nil traces nil)
    (union const-decl "set" sets nil))
   239 170 nil nil))
 (sigma_proj 0
  (sigma_proj-1 nil 3417191621 3417191687
   ("" (induct-and-simplify "t")
    (("1" (apply-extensionality :hide? t) nil)
     ("2" (replace*)
      (("2" (apply-extensionality :hide? t) (("2" (smash) nil)))))
     ("3" (replace*)
      (("3" (apply-extensionality :hide? t) (("3" (smash) nil))))))
    nil)
   proved
   ((add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (finite_intersection2 application-judgement "finite_set"
     finite_sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (filter def-decl "list[T]" filters nil)
    (list2set def-decl "set[T]" list2set nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (intersection const-decl "set" sets nil)
    (T formal-type-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil))
   508 260 nil nil))
 (sigma_prod 0
  (sigma_prod-1 nil 3417191621 3417191687
   ("" (induct-and-simplify "t")
    (("1" (apply-extensionality :hide? t) nil)
     ("2" (replace*)
      (("2" (apply-extensionality :hide? t)
        (("2" (iff) (("2" (ground) nil)))))))
     ("3" (replace*)
      (("3" (apply-extensionality :hide? t)
        (("3" (iff) (("3" (ground) nil)))))))
     ("4" (replace*)
      (("4" (apply-extensionality :hide? t)
        (("4" (iff) (("4" (ground) nil))))))))
    nil)
   proved
   ((add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (nonempty_union1 application-judgement "(nonempty?)" sets nil)
    (nonempty_union2 application-judgement "(nonempty?)" sets nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list2set def-decl "set[T]" list2set nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (prod def-decl "bool" traces nil) (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (union const-decl "set" sets nil)
    (T formal-type-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil))
   807 500 nil nil))
 (sigma_prod_inter1 0
  (sigma_prod_inter1-1 nil 3417191621 3417191687
   ("" (skosimp)
    (("" (forward-chain "proj_prod1")
      (("" (rewrite "sigma_proj" :dir rl)
        (("" (rewrite "sigma_proj" :dir rl) (("" (assert) nil))))))))
    nil)
   proved
   ((proj_prod1 formula-decl nil traces nil)
    (T formal-type-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (sigma_proj formula-decl nil traces nil))
   121 50 nil nil))
 (sigma_prod_inter2 0
  (sigma_prod_inter2-1 nil 3417191621 3417191688
   ("" (skosimp)
    (("" (rewrite "prod_commutes")
      (("" (forward-chain "sigma_prod_inter1") nil))))
    nil)
   proved
   ((prod_commutes formula-decl nil traces nil)
    (T formal-type-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (sigma_prod_inter1 formula-decl nil traces nil))
   110 30 nil nil))
 (every_sigma 0
  (every_sigma-1 nil 3417192842 3417192846
   ("" (induct "t")
    (("1" (grind) nil)
     ("2" (skosimp*)
      (("2" (split)
        (("1" (flatten)
          (("1" (skolem-typepred)
            (("1" (expand "every" -2)
              (("1" (flatten)
                (("1" (expand "sigma" -1)
                  (("1" (expand "list2set" -1)
                    (("1" (expand "add")
                      (("1" (split)
                        (("1" (replace -1) (("1" (propax) nil)))
                         ("2" (expand "member")
                          (("2" (inst?)
                            (("2" (assert)
                              (("2"
                                (inst -4 "a!1")
                                (("2"
                                  (expand "sigma")
                                  (("2"
                                    (propax)
                                    nil)))))))))))))))))))))))))))
         ("2" (flatten)
          (("2" (expand "every" 1)
            (("2" (split)
              (("1" (inst?)
                (("1" (expand "sigma" 1)
                  (("1" (expand "list2set" 1)
                    (("1" (expand "add") (("1" (propax) nil)))))))))
               ("2" (inst -2 ("A!1"))
                (("2" (prop)
                  (("2" (delete 2 3)
                    (("2" (skolem-typepred)
                      (("2" (inst?)
                        (("2" (expand "sigma" 1)
                          (("2" (expand "list2set" 1)
                            (("2" (expand "add" 1)
                              (("2"
                                (flatten)
                                (("2"
                                  (expand "member" 2)
                                  (("2"
                                    (expand "sigma")
                                    (("2"
                                      (propax)
                                      nil))))))))))))))))))))))))))))))))))
    nil)
   proved
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (set type-eq-decl nil sets nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (T formal-type-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (emptyset const-decl "set" sets nil)
    (list2set def-decl "set[T]" list2set nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons2_var!1 skolem-const-decl "list[T]" traces nil)
    (cons1_var!1 skolem-const-decl "T" traces nil)
    (a!1 skolem-const-decl "(sigma(cons(cons1_var!1, cons2_var!1)))"
     traces nil)
    (member const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (a!1 skolem-const-decl "(sigma(cons2_var!1))" traces nil))
   2171 280 nil nil))
 (null_proj_equiv 0
  (null_proj_equiv-1 nil 3417191621 3417191688
   ("" (skolem + ("B!1" _)) (("" (induct-and-simplify "t") nil)) nil)
   proved
   ((add const-decl "(nonempty?)" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_intersection2 application-judgement "finite_set"
     finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (list2set def-decl "set[T]" list2set nil)
    (filter def-decl "list[T]" filters nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (disjoint? const-decl "bool" sets nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (setof type-eq-decl nil defined_types nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   384 260 nil nil))
 (null_proj_subset 0
  (null_proj_subset-1 nil 3417191621 3417191689
   ("" (auto-rewrite "null_proj_equiv")
    (("" (skosimp)
      (("" (assert)
        (("" (auto-rewrite-theory "sets[T]") (("" (reduce) nil))))))))
    nil)
   proved
   ((disjoint? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (T formal-type-decl nil traces nil)
    (null_proj_equiv formula-decl nil traces nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil))
   309 240 nil nil))
 (null_proj_union 0
  (null_proj_union-1 nil 3417191621 3417191689
   ("" (auto-rewrite "null_proj_equiv")
    (("" (skolem!)
      (("" (assert)
        (("" (auto-rewrite-theory "sets[T]") (("" (reduce) nil))))))))
    nil)
   proved
   ((disjoint? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (T formal-type-decl nil traces nil)
    (null_proj_equiv formula-decl nil traces nil))
   561 340 nil nil))
 (null_proj_prod 0
  (null_proj_prod-1 nil 3417191621 3417191690
   ("" (auto-rewrite "null_proj_equiv")
    (("" (skosimp)
      (("" (assert)
        (("" (forward-chain "sigma_prod")
          (("" (replace*)
            (("" (delete -)
              (("" (auto-rewrite-theory "sets[T]")
                (("" (reduce) nil))))))))))))))
    nil)
   proved
   ((sigma_prod formula-decl nil traces nil)
    (T formal-type-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (disjoint? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (null_proj_equiv formula-decl nil traces nil))
   547 350 nil nil))
 (null_proj_prod1 0
  (null_proj_prod1-1 nil 3417191621 3417191690
   ("" (skosimp) (("" (use "null_proj_prod") (("" (ground) nil)))) nil)
   proved
   ((null_proj_prod formula-decl nil traces nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil traces nil))
   112 70 nil nil))
 (null_proj_prod2 0
  (null_proj_prod2-1 nil 3417191621 3417191690
   ("" (skosimp)
    (("" (rewrite "prod_commutes")
      (("" (forward-chain "null_proj_prod1") nil))))
    nil)
   proved
   ((prod_commutes formula-decl nil traces nil)
    (T formal-type-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (null_proj_prod1 formula-decl nil traces nil))
   152 50 nil nil))
 (null_proj_prod3 0
  (null_proj_prod3-1 nil 3417191621 3417191690
   ("" (auto-rewrite "null_proj_equiv")
    (("" (skosimp)
      (("" (assert)
        (("" (forward-chain "sigma_prod_inter1")
          (("" (delete -2)
            (("" (auto-rewrite-theory "sets[T]")
              (("" (reduce)
                (("" (case "intersection(sigma(t!1), A!1)(x!1)")
                  (("1" (replace -2) (("1" (assert) nil)))
                   ("2" (assert) nil))))))))))))))))
    nil)
   proved
   ((sigma_prod_inter1 formula-decl nil traces nil)
    (T formal-type-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil) (set type-eq-decl nil sets nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (disjoint? const-decl "bool" sets nil)
    (null_proj_equiv formula-decl nil traces nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil))
   394 290 nil nil))
 (null_proj_prod4 0
  (null_proj_prod4-1 nil 3417191621 3417191691
   ("" (skosimp)
    (("" (rewrite "prod_commutes")
      (("" (forward-chain "null_proj_prod3") nil))))
    nil)
   proved
   ((prod_commutes formula-decl nil traces nil)
    (T formal-type-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (null_proj_prod3 formula-decl nil traces nil))
   145 30 nil nil))
 (interleave_prod 0
  (interleave_prod-1 nil 3417191621 3417191691
   ("" (induct "t2")
    (("1" (skosimp)
      (("1" (inst 1 "t1!1")
        (("1" (rewrite "prod_null3")
          (("1" (delete -2 2)
            (("1" (rewrite "null_proj_equiv") nil nil)) nil))
          nil))
        nil))
      nil)
     ("2" (skosimp*)
      (("2" (inst? -1)
        (("2" (assert)
          (("2" (rewrite "sigma_cons")
            (("2"
              (case "disjoint?(sigma(cons2_var!1), A!1) AND NOT A!1(cons1_var!1)")
              (("1" (flatten)
                (("1" (assert)
                  (("1" (skolem!)
                    (("1" (inst 2 "cons(cons1_var!1, t!1)")
                      (("1" (expand "prod" 2) (("1" (flatten) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (delete -1 -2 2)
                (("2" (split)
                  (("1" (grind :if-match nil :exclude "sigma")
                    (("1" (inst?)
                      (("1" (split)
                        (("1" (flatten) nil nil)
                         ("2" (propax) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind :if-match nil :exclude "sigma")
                    (("2" (inst?)
                      (("2" (split)
                        (("1" (flatten) nil nil)
                         ("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (member const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (sigma_cons formula-decl nil traces nil)
    (prod_null3 formula-decl nil traces nil)
    (null_proj_equiv formula-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (prod def-decl "bool" traces nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (disjoint? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   388 220 nil nil))
 (prod_proj1 0
  (prod_proj1-1 nil 3417191621 3417191692
   ("" (induct "t")
    (("1" (skosimp)
      (("1" (expand "prod" -2)
        (("1" (flatten)
          (("1"
            (case "disjoint?(sigma(t1!1), A!1) AND disjoint?(sigma(t2!1), A!1)")
            (("1" (flatten)
              (("1" (delete -4 -5)
                (("1" (lemma "interleave_prod")
                  (("1" (inst?)
                    (("1" (inst -1 "t2!1")
                      (("1" (assert)
                        (("1" (skolem!)
                          (("1" (inst?)
                            (("1" (split)
                              (("1" (propax) nil nil)
                               ("2"
                                (use "null_proj_equiv")
                                (("2"
                                  (assert)
                                  (("2"
                                    (delete 2)
                                    (("2"
                                      (forward-chain "sigma_prod")
                                      (("2"
                                        (replace -1)
                                        (("2"
                                          (delete -1 -2)
                                          (("2" (postpone) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (delete 2)
              (("2" (split)
                (("1" (use "null_proj_equiv")
                  (("1" (assert)
                    (("1" (delete -3 -4)
                      (("1" (grind :if-match nil :exclude "sigma")
                        (("1" (inst?)
                          (("1" (split)
                            (("1" (propax) nil nil)
                             ("2" (inst?)
                              (("2"
                                (split)
                                (("1" (propax) nil nil)
                                 ("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete -2)
                  (("2" (use "null_proj_equiv")
                    (("2" (assert)
                      (("2" (delete -3)
                        (("2" (grind :if-match nil :exclude "sigma")
                          (("2" (inst?)
                            (("2" (split)
                              (("1" (propax) nil nil)
                               ("2"
                                (inst?)
                                (("2"
                                  (split)
                                  (("1" (propax) nil nil)
                                   ("2" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skosimp*)
      (("2" (inst? -1)
        (("2" (expand "prod" -3)
          (("2" (ground)
            (("1" (postpone) nil nil) ("2" (postpone) nil nil)
             ("3" (postpone) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   unfinished nil 632 360 nil nil))
 (prod_add 0
  (prod_add-1 nil 3417191621 3417191693
   ("" (skolem!)
    (("" (iff)
      (("" (split)
        (("1" (ground)
          (("1" (rewrite "prod_reverse3")
            (("1" (rewrite "reverse_add")
              (("1" (expand "prod" -2)
                (("1" (flatten)
                  (("1" (rewrite "prod_reverse3")
                    (("1"
                      (inst 1 "reverse(cdr(reverse(t1!1)))"
                       "reverse(cdr(reverse(t2!1)))")
                      (("1" (split)
                        (("1" (rewrite "reverse_cons" 1 :dir rl)
                          (("1" (replace -4 1 rl)
                            (("1"
                              (case "cons(car(reverse(t1!1)), cdr(reverse(t1!1))) = reverse(t1!1)")
                              (("1"
                                (replace -1 1)
                                (("1"
                                  (rewrite "reverse_reverse")
                                  nil
                                  nil))
                                nil)
                               ("2"
                                (lemma "list_cons_eta[T]")
                                (("2" (inst?) nil nil))
                                nil)
                               ("3" (propax) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (rewrite "reverse_cons" :dir rl)
                          (("2" (replace -5 1 rl)
                            (("2"
                              (case "cons(car(reverse(t2!1)), cdr(reverse(t2!1))) = reverse(t2!1)")
                              (("1"
                                (replace -1)
                                (("1"
                                  (rewrite "reverse_reverse")
                                  nil
                                  nil))
                                nil)
                               ("2"
                                (lemma "list_cons_eta[T]")
                                (("2" (inst?) nil nil))
                                nil)
                               ("3" (propax) nil nil))
                              nil))
                            nil))
                          nil)
                         ("3" (rewrite "reverse_reverse") nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (rewrite "prod_reverse3")
            (("2" (rewrite "reverse_add")
              (("2" (expand "prod" -1)
                (("2" (split)
                  (("1" (flatten)
                    (("1" (rewrite "prod_reverse3")
                      (("1" (inst 2 "reverse(cdr(reverse(t1!1)))")
                        (("1" (delete 3)
                          (("1" (split)
                            (("1" (rewrite "reverse_cons" 1 :dir rl)
                              (("1"
                                (replace -2 1 rl)
                                (("1"
                                  (case
                                   "cons(car(reverse(t1!1)), cdr(reverse(t1!1))) = reverse(t1!1)")
                                  (("1"
                                    (replace -1 1)
                                    (("1"
                                      (rewrite "reverse_reverse")
                                      nil
                                      nil))
                                    nil)
                                   ("2"
                                    (lemma "list_cons_eta[T]")
                                    (("2" (inst?) nil nil))
                                    nil)
                                   ("3" (propax) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (rewrite "reverse_reverse")
                              (("2"
                                (rewrite "reverse_reverse")
                                nil
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (rewrite "prod_reverse3")
                      (("2" (delete 2)
                        (("2" (inst 2 "reverse(cdr(reverse(t2!1)))")
                          (("2" (split)
                            (("1" (rewrite "reverse_cons" 1 :dir rl)
                              (("1"
                                (replace -2 1 rl)
                                (("1"
                                  (case
                                   "cons(car(reverse(t2!1)), cdr(reverse(t2!1))) = reverse(t2!1)")
                                  (("1"
                                    (replace -1)
                                    (("1"
                                      (rewrite "reverse_reverse")
                                      nil
                                      nil))
                                    nil)
                                   ("2"
                                    (lemma "list_cons_eta[T]")
                                    (("2" (inst?) nil nil))
                                    nil)
                                   ("3" (propax) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (rewrite "reverse_reverse")
                              (("2"
                                (rewrite "reverse_reverse")
                                nil
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (ground)
          (("1" (skosimp)
            (("1" (replace -2)
              (("1" (replace -3)
                (("1" (delete -2 -3)
                  (("1" (rewrite "prod_reverse3")
                    (("1" (rewrite "prod_reverse3" 1)
                      (("1" (rewrite "reverse_add")
                        (("1" (rewrite "reverse_add")
                          (("1" (rewrite "reverse_add")
                            (("1" (expand "prod" 1)
                              (("1" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (skosimp)
            (("2" (replace -1)
              (("2" (delete -1)
                (("2" (rewrite "prod_reverse3")
                  (("2" (rewrite "prod_reverse3" 2)
                    (("2" (rewrite "reverse_add")
                      (("2" (rewrite "reverse_add")
                        (("2" (expand "prod" 2)
                          (("2" (flatten) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (skosimp)
            (("3" (replace -1)
              (("3" (delete -1)
                (("3" (rewrite "prod_reverse3")
                  (("3" (rewrite "prod_reverse3" 2)
                    (("3" (rewrite "reverse_add")
                      (("3" (rewrite "reverse_add")
                        (("3" (expand "prod" 2)
                          (("3" (flatten) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((reverse_add formula-decl nil more_list_props nil)
    (reverse_cons formula-decl nil more_list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (reverse_reverse formula-decl nil list_props nil)
    (list_cons_eta formula-decl nil list_adt nil)
    (reverse def-decl "list[T]" list_props nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (prod def-decl "bool" traces nil)
    (add const-decl "(cons?[T])" more_list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil traces nil)
    (prod_reverse3 formula-decl nil traces nil))
   1181 570 nil nil))
 (every_prod 0
  (every_prod-1 nil 3417191621 3417191693
   ("" (induct "t")
    (("1" (skosimp) (("1" (expand "prod") (("1" (grind) nil nil)) nil))
      nil)
     ("2" (skosimp*)
      (("2" (inst -1 "A!1" "B!1" "_" "_")
        (("2" (expand "prod" -2)
          (("2" (split)
            (("1" (flatten)
              (("1" (expand "every" -8)
                (("1" (flatten)
                  (("1" (use "list_cons_eta[T]")
                    (("1" (replace -1 1 rl)
                      (("1" (expand "every" 1)
                        (("1" (replace -5)
                          (("1" (assert)
                            (("1" (inst?) (("1" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (split)
                (("1" (flatten)
                  (("1" (expand "every" -5)
                    (("1" (flatten)
                      (("1" (use "list_cons_eta[T]")
                        (("1" (replace -1 2 rl)
                          (("1" (expand "every" 2)
                            (("1" (replace -3)
                              (("1"
                                (assert)
                                (("1"
                                  (inst?)
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "every" -5)
                    (("2" (flatten)
                      (("2" (inst?) (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list_cons_eta formula-decl nil list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (prod def-decl "bool" traces nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   454 250 nil nil)))

