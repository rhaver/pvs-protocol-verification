(fixed_points2
 (mu_TCC1 0
  (mu_TCC1-1 nil 3417191624 3417191724
   ("" (grind :if-match nil)
    (("" (inst - "X!1(x!1)" "Y!1(x!1)") (("" (reduce) nil nil)) nil))
    nil)
   proved
   ((dummy nonempty-type-decl nil fixed_points2 nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil fixed_points2 nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (monotonic? const-decl "bool" fixed_points2 nil)
    (monotonic? const-decl "bool" fixed_points nil)
    (ext const-decl "[dummy -> process[T]]" fixed_points2 nil)
    (<= const-decl "bool" fixed_points nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil))
   234 110 nil nil))
 (closure_mu2 0
  (closure_mu2-1 nil 3417191624 3417191724
   ("" (skolem!)
    (("" (auto-rewrite "mu_TCC1" "ext" "<=")
      (("" (expand "mu")
        (("" (use "closure_mu" ("G" "ext(G!1)"))
          (("" (assert) (("" (inst?) nil))))))))))
    nil)
   proved
   ((closure_mu formula-decl nil fixed_points nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (monotonic? const-decl "bool" fixed_points nil)
    (ext const-decl "[dummy -> process[T]]" fixed_points2 nil)
    (monotonic? const-decl "bool" fixed_points2 nil)
    (dummy nonempty-type-decl nil fixed_points2 nil)
    (T formal-type-decl nil fixed_points2 nil)
    (rep const-decl "dummy" fixed_points2 nil)
    (<= const-decl "bool" fixed_points nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (mu const-decl "process[T]" fixed_points2 nil))
   86 60 nil nil))
 (smallest_closed2 0
  (smallest_closed2-1 nil 3417191624 3417191725
   ("" (skosimp)
    (("" (auto-rewrite "mu_TCC1" "ext" "<=")
      (("" (expand "mu")
        ((""
          (use "smallest_closed" ("G" "ext(G!1)" "X" "lambda x : X!1"))
          (("" (ground) (("1" (inst?) nil) ("2" (skolem!) nil))))))))))
    nil)
   proved
   ((smallest_closed formula-decl nil fixed_points nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (monotonic? const-decl "bool" fixed_points nil)
    (ext const-decl "[dummy -> process[T]]" fixed_points2 nil)
    (monotonic? const-decl "bool" fixed_points2 nil)
    (dummy nonempty-type-decl nil fixed_points2 nil)
    (T formal-type-decl nil fixed_points2 nil)
    (rep const-decl "dummy" fixed_points2 nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (<= const-decl "bool" fixed_points nil)
    (mu const-decl "process[T]" fixed_points2 nil))
   145 50 nil nil))
 (fixed_point2 0
  (fixed_point2-1 nil 3417191624 3417191725
   ("" (skolem!)
    (("" (auto-rewrite "mu_TCC1" "ext" "<=")
      (("" (use "fixed_point" ("G" "ext(G!1)"))
        (("" (expand "mu" 1 2)
          (("" (replace -1 + rl)
            (("" (assert)
              (("" (expand "mu" 1 1) (("" (propax) nil))))))))))))))
    nil)
   proved
   ((mu const-decl "process[T]" fixed_points2 nil)
    (T formal-type-decl nil fixed_points2 nil)
    (dummy nonempty-type-decl nil fixed_points2 nil)
    (monotonic? const-decl "bool" fixed_points2 nil)
    (ext const-decl "[dummy -> process[T]]" fixed_points2 nil)
    (monotonic? const-decl "bool" fixed_points nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (fixed_point formula-decl nil fixed_points nil)
    (mu_TCC1 subtype-tcc nil fixed_points2 nil))
   122 40 nil nil))
 (least_fixed_point2 0
  (least_fixed_point2-1 nil 3417191624 3417191725
   ("" (skosimp)
    (("" (auto-rewrite "mu_TCC1" "ext" "<=")
      (("" (expand "mu")
        ((""
          (use "least_fixed_point"
               ("G" "ext(G!1)" "X" "lambda x : X!1"))
          (("" (ground)
            (("1" (inst?) nil nil)
             ("2" (apply-extensionality :hide? t) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((least_fixed_point formula-decl nil fixed_points nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (monotonic? const-decl "bool" fixed_points nil)
    (ext const-decl "[dummy -> process[T]]" fixed_points2 nil)
    (monotonic? const-decl "bool" fixed_points2 nil)
    (dummy nonempty-type-decl nil fixed_points2 nil)
    (T formal-type-decl nil fixed_points2 nil)
    (rep const-decl "dummy" fixed_points2 nil)
    (<= const-decl "bool" fixed_points nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (mu const-decl "process[T]" fixed_points2 nil))
   146 80 nil nil))
 (induction 0
  (induction-1 nil 3417193325 3417193329
   ("" (skosimp)
    (("" (auto-rewrite "mu_TCC1" "ext")
      (("" (expand "mu")
        ((""
          (use "param_induction" ("G" "ext(G!1)" "E" "lambda x : E!1"))
          (("" (ground)
            (("1" (inst?) nil)
             ("2" (skolem!)
              (("2" (skosimp*)
                (("2" (inst?)
                  (("2" (inst?) (("2" (assert) nil))))))))))))))))))
    nil)
   proved
   ((mu const-decl "process[T]" fixed_points2 nil)
    (rep const-decl "dummy" fixed_points2 nil)
    (T formal-type-decl nil fixed_points2 nil)
    (dummy nonempty-type-decl nil fixed_points2 nil)
    (monotonic? const-decl "bool" fixed_points2 nil)
    (ext const-decl "[dummy -> process[T]]" fixed_points2 nil)
    (monotonic? const-decl "bool" fixed_points nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (set type-eq-decl nil sets nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (param_induction formula-decl nil fixed_points nil))
   1675 120 nil nil))
 (induction2 0
  (induction2-1 nil 3417191624 3417191725
   ("" (skosimp)
    (("" (use "induction")
      (("" (ground) (("" (delete -2 2) (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   proved
   ((induction formula-decl nil fixed_points2 nil)
    (monotonic? const-decl "bool" fixed_points2 nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil fixed_points2 nil)
    (\|> const-decl "bool" satisfaction nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (Stop const-decl "process" processes nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil))
   147 90 nil nil))
 (sigma_fix2 0
  (sigma_fix2-1 nil 3417191624 3417191725
   ("" (skosimp)
    (("" (auto-rewrite "mu_TCC1" "ext")
      (("" (expand "mu")
        (("" (use "sigma_fix[dummy, T]")
          (("" (ground)
            (("1" (inst?) nil nil)
             ("2" (skosimp*)
              (("2" (inst?)
                (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((sigma_fix formula-decl nil fixed_points nil)
    (dummy nonempty-type-decl nil fixed_points2 nil)
    (T formal-type-decl nil fixed_points2 nil)
    (monotonic? const-decl "bool" fixed_points2 nil)
    (ext const-decl "[dummy -> process[T]]" fixed_points2 nil)
    (monotonic? const-decl "bool" fixed_points nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil) (set type-eq-decl nil sets nil)
    (rep const-decl "dummy" fixed_points2 nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (mu const-decl "process[T]" fixed_points2 nil))
   270 230 nil nil)))

