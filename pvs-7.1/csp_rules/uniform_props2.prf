(uniform_props2
 (uniform3_choice 0
  (uniform3_choice-1 nil 3417193659
   ("" (skolem!)
    (("" (rewrite "sat_choice3")
      (("" (ground) (("" (rewrite "uniform_stop") nil nil)) nil)) nil))
    nil)
   ((sat_choice3 formula-decl nil satisfaction2 nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (T formal-type-decl nil uniform_props2 nil)
    (U formal-type-decl nil uniform_props2 nil)
    (uniform_stop formula-decl nil uniform_props nil))
   nil))
 (uniform3_choice2 0
  (uniform3_choice2-1 nil 3417193659
   ("" (skolem!)
    (("" (rewrite "sat_choice3")
      (("" (ground) (("" (rewrite "uniform_stop2") nil nil)) nil))
      nil))
    nil)
   ((sat_choice3 formula-decl nil satisfaction2 nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (pred type-eq-decl nil defined_types nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (T formal-type-decl nil uniform_props2 nil)
    (U formal-type-decl nil uniform_props2 nil)
    (uniform_stop2 formula-decl nil uniform_props nil))
   nil))
 (uniform2_fix 0
  (uniform2_fix-1 nil 3417193672
   ("" (auto-rewrite-theory "sets")
    (("" (skosimp)
      (("" (skosimp)
        (("" (lemma "param_induction[U, T]")
          (("" (inst?)
            (("" (split)
              (("1" (inst?)
                (("1" (forward-chain "every_implies3")
                  (("1" (lemma "sat_transitive2[T]")
                    (("1" (assert)
                      (("1" (inst?)
                        (("1" (assert)
                          (("1" (eta "pred[T]")
                            (("1" (inst -1 "q!1(i1!1)")
                              (("1"
                                (replace -1 -2 rl)
                                (("1"
                                  (assert)
                                  (("1"
                                    (inst? -2)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (replace -1 -2 rl)
                                        (("1"
                                          (grind)
                                          nil)))))))))))))))))))))))))))
               ("2" (skolem!) (("2" (use "uniform_stop") nil)))
               ("3" (propax) nil))))))))))))
    nil)
   ((T formal-type-decl nil uniform_props2 nil)
    (U formal-type-decl nil uniform_props2 nil)
    (param_induction formula-decl nil fixed_points nil)
    (every_implies3 formula-decl nil more_list_props nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (<= const-decl "bool" fixed_points nil)
    (glb const-decl "process[T]" fixed_points nil)
    (\|> const-decl "bool" satisfaction nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (mu const-decl "[U -> process[T]]" fixed_points nil)
    (sat_transitive2 formula-decl nil satisfaction nil)
    (uniform_stop formula-decl nil uniform_props nil)
    (monotonic? const-decl "bool" fixed_points nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil))
   nil))
 (uniform2_fix2 0
  (uniform2_fix2-1 nil 3417193709
   ("" (auto-rewrite-theory "sets")
    (("" (skolem-typepred)
      (("" (flatten)
        (("" (skosimp)
          (("" (lemma "param_induction[U, T]")
            ((""
              (inst -1
               "LAMBDA i : (LAMBDA t: every(q1!1(i))(t) => every(q2!1(i))(t))"
               "F!1")
              (("" (split)
                (("1" (inst?)
                  (("1" (lemma "every_implies4[T]")
                    (("1"
                      (inst -1 "p1!1" "p2!1" "q1!1(i1!1)" "q2!1(i1!1)")
                      (("1" (split)
                        (("1" (lemma "sat_transitive2[T]")
                          (("1"
                            (inst -1
                             "(LAMBDA t: every(q1!1(i1!1))(t) => every(q2!1(i1!1))(t))"
                             "(LAMBDA t: every(p1!1)(t) => every(p2!1)(t))"
                             "mu(F!1)(i1!1)")
                            (("1" (assert) nil)))))
                         ("2" (skosimp)
                          (("2" (inst? -4)
                            (("2" (flatten) (("2" (assert) nil)))))))
                         ("3" (skosimp)
                          (("3" (inst? -4)
                            (("3" (flatten)
                              (("3" (assert) nil)))))))))))))))
                 ("2" (skolem!) (("2" (use "uniform_stop2") nil)))
                 ("3" (propax) nil))))))))))))))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (U formal-type-decl nil uniform_props2 nil)
    (T formal-type-decl nil uniform_props2 nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (monotonic? const-decl "bool" fixed_points nil)
    (pred type-eq-decl nil defined_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (uniform_stop2 formula-decl nil uniform_props nil)
    (sat_transitive2 formula-decl nil satisfaction nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (mu const-decl "[U -> process[T]]" fixed_points nil)
    (every_implies4 formula-decl nil more_list_props nil)
    (param_induction formula-decl nil fixed_points nil))
   nil)))

