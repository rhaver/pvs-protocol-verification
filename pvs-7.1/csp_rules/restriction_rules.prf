(restriction_rules
 (restriction_equiv 0
  (restriction_equiv-1 nil 3662229312
   ("" (skolem!) (("" (expand "#") (("" (rewrite "par_stop") nil))))
    nil)
   ((|#| const-decl "process[T]" restriction_rules nil)
    (T formal-type-decl nil restriction_rules nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil) (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (par_stop formula-decl nil process_rules nil))
   nil))
 (restriction_twice 0
  (restriction_twice-1 nil 3662229312
   ("" (skolem!)
    (("" (auto-rewrite "restriction_equiv" "null_proj_union[T]")
      (("" (name-replace "XX" "P!1 # A!1" :hide? nil)
        (("" (assert)
          (("" (apply-extensionality :hide? t)
            (("" (replace -1 + rl)
              (("" (assert)
                (("" (delete -)
                  (("" (iff) (("" (ground) nil))))))))))))))))))
    nil)
   ((restriction_equiv formula-decl nil restriction_rules nil)
    (null_proj_union formula-decl nil traces nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (|#| const-decl "process[T]" restriction_rules nil)
    (set type-eq-decl nil sets nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil restriction_rules nil))
   nil))
 (restriction_prop 0
  (restriction_prop-1 nil 3662229312
   ("" (auto-rewrite-theory "sets")
    (("" (skosimp)
      (("" (assert)
        (("" (skosimp)
          (("" (rewrite "restriction_equiv")
            (("" (rewrite "restriction_equiv")
              (("" (grind :if-match nil)
                (("" (inst?) (("" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((filter def-decl "list[T]" filters nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil) (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil restriction_rules nil)
    (restriction_equiv formula-decl nil restriction_rules nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil))
   nil))
 (restriction_prop2 0
  (restriction_prop2-1 nil 3662229312
   ("" (auto-rewrite-theory "sets")
    (("" (assert)
      (("" (skosimp*)
        (("" (rewrite "restriction_equiv")
          (("" (assert) (("" (flatten) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (restriction_equiv formula-decl nil restriction_rules nil)
    (T formal-type-decl nil restriction_rules nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil) (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil))
   nil))
 (restriction_stop 0
  (restriction_stop-1 nil 3662229312
   ("" (skolem!)
    (("" (rewrite "restriction_equiv")
      (("" (apply-extensionality :hide? t) (("" (grind) nil))))))
    nil)
   ((restriction_equiv formula-decl nil restriction_rules nil)
    (T formal-type-decl nil restriction_rules nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil) (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (Stop const-decl "process" processes nil)
    (filter def-decl "list[T]" filters nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil))
   nil))
 (restriction_pref1 0
  (restriction_pref1-1 nil 3662229312
   ("" (skosimp)
    (("" (auto-rewrite "restriction_equiv")
      (("" (apply-extensionality :hide? t) (("" (grind) nil))))))
    nil)
   ((filter def-decl "list[T]" filters nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (restriction_equiv formula-decl nil restriction_rules nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (set type-eq-decl nil sets nil)
    (|#| const-decl "process[T]" restriction_rules nil)
    (>> const-decl "process" processes nil)
    (Stop const-decl "process" processes nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil restriction_rules nil))
   nil))
 (restriction_pref2 0
  (restriction_pref2-1 nil 3662229312
   ("" (skosimp)
    (("" (auto-rewrite "restriction_equiv")
      (("" (apply-extensionality :hide? t)
        (("" (grind :if-match nil)
          (("1" (inst?) nil) ("2" (inst?) nil))))))))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (filter def-decl "list[T]" filters nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (restriction_equiv formula-decl nil restriction_rules nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (set type-eq-decl nil sets nil)
    (|#| const-decl "process[T]" restriction_rules nil)
    (>> const-decl "process" processes nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil restriction_rules nil))
   nil))
 (restriction_pref 0
  (restriction_pref-1 nil 3662229312
   ("" (auto-rewrite "restriction_pref1" "restriction_pref2")
    (("" (skolem!) (("" (lift-if) (("" (ground) nil)))))) nil)
   ((restriction_pref2 formula-decl nil restriction_rules nil)
    (restriction_pref1 formula-decl nil restriction_rules nil))
   nil))
 (restriction_choice 0
  (restriction_choice-1 nil 3662229312
   ("" (skolem!)
    (("" (auto-rewrite "restriction_equiv")
      (("" (assert)
        (("" (expand "\\/")
          (("" (apply-extensionality :hide? t)
            (("" (grind :exclude ("proj")) nil))))))))))
    nil)
   ((\\/ const-decl "process" processes nil)
    (member const-decl "bool" sets nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil) (union const-decl "set" sets nil)
    (setof type-eq-decl nil defined_types nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil restriction_rules nil)
    (restriction_equiv formula-decl nil restriction_rules nil))
   nil))
 (restriction_choice2 0
  (restriction_choice2-1 nil 3662229312
   ("" (skolem!)
    (("" (auto-rewrite "restriction_equiv")
      (("" (assert)
        (("" (expand "Choice")
          (("" (apply-extensionality :hide? t)
            (("" (iff)
              (("" (ground)
                (("1" (expand "proj")
                  (("1" (expand "filter") (("1" (propax) nil)))))
                 ("2" (skosimp)
                  (("2" (inst + "i!1") nil))))))))))))))))
    nil)
   ((Choice const-decl "process[T]" parametric_choice nil)
    (Choice const-decl "process" processes nil)
    (filter def-decl "list[T]" filters nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (setof type-eq-decl nil defined_types nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil restriction_rules nil)
    (restriction_equiv formula-decl nil restriction_rules nil))
   nil))
 (restriction_par 0
  (restriction_par-1 nil 3662229312
   ("" (skosimp)
    (("" (auto-rewrite "restriction_equiv")
      (("" (assert)
        (("" (expand "Par")
          (("" (apply-extensionality :hide? t)
            (("" (iff)
              (("" (ground)
                (("1" (skolem!)
                  (("1" (use "null_proj_prod[T]")
                    (("1" (ground) (("1" (inst?) nil nil)) nil)) nil))
                  nil)
                 ("2" (skolem!) (("2" (inst?) nil nil)) nil)
                 ("3" (skolem-typepred)
                  (("3" (use "null_proj_prod[T]")
                    (("3" (ground) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Par const-decl "process" processes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (null_proj_prod formula-decl nil traces nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (prod def-decl "bool" traces nil) (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil restriction_rules nil)
    (restriction_equiv formula-decl nil restriction_rules nil))
   nil))
 (restriction_fullset 0
  (restriction_fullset-1 nil 3662229312
   ("" (skolem!)
    (("" (auto-rewrite "intersection" "member")
      (("" (apply-extensionality :hide? t)
        (("" (iff)
          (("" (ground)
            (("1" (rewrite "restriction_equiv" -1)
              (("1" (beta)
                (("1" (rewrite "par_full")
                  (("1" (rewrite "par_full")
                    (("1" (assert)
                      (("1" (split)
                        (("1" (grind) nil nil)
                         ("2" (rewrite "restriction_equiv")
                          (("2" (beta) (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (rewrite "restriction_equiv" 1)
              (("2" (beta)
                (("2" (rewrite "par_full")
                  (("2" (rewrite "par_full")
                    (("2" (assert)
                      (("2" (split)
                        (("1" (grind) nil nil)
                         ("2" (rewrite "restriction_equiv")
                          (("2" (beta) (("2" (assert) nil nil)) nil))
                          nil)
                         ("3" (rewrite "restriction_equiv")
                          (("3" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((restriction_equiv formula-decl nil restriction_rules nil)
    (par_full formula-decl nil process_rules nil)
    (member const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (set type-eq-decl nil sets nil)
    (|#| const-decl "process[T]" restriction_rules nil)
    (Par const-decl "process" processes nil)
    (fullset const-decl "set" sets nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil restriction_rules nil))
   nil))
 (restriction_free_par 0
  (restriction_free_par-1 nil 3662229312
   ("" (skolem!)
    (("" (expand "//") (("" (rewrite "restriction_par") nil)))) nil)
   ((// const-decl "process" processes nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (emptyset const-decl "set" sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil restriction_rules nil)
    (restriction_par formula-decl nil restriction_rules nil))
   nil))
 (restriction_hide 0
  (restriction_hide-1 nil 3662229312
   ("" (skosimp)
    (("" (apply-extensionality :hide? t)
      (("" (smash)
        (("1" (rewrite "restriction_equiv")
          (("1" (assert)
            (("1" (flatten)
              (("1" (expand "/" -1)
                (("1" (skolem-typepred)
                  (("1" (replace -2)
                    (("1" (delete -2)
                      (("1" (rewrite "proj_twice")
                        (("1" (expand "/")
                          (("1" (inst?)
                            (("1" (rewrite "restriction_equiv")
                              (("1"
                                (assert)
                                (("1"
                                  (expand "difference")
                                  (("1"
                                    (expand "member")
                                    (("1"
                                      (expand "complement")
                                      (("1"
                                        (expand "intersection")
                                        (("1"
                                          (expand "member")
                                          (("1"
                                            (delete -1)
                                            (("1"
                                              (case
                                               "{x_95: T | NOT A!1(x_95) AND B!1(x_95)} = {x: T | B!1(x) AND NOT A!1(x)}")
                                              (("1"
                                                (replace -1)
                                                (("1"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil)
                                               ("2"
                                                (delete -1 2)
                                                (("2"
                                                  (apply-extensionality
                                                   :hide?
                                                   t)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand "/" -1)
          (("2" (skolem-typepred)
            (("2" (rewrite "restriction_equiv")
              (("2" (assert)
                (("2" (flatten)
                  (("2" (replace -3)
                    (("2" (delete -3)
                      (("2" (rewrite "restriction_equiv")
                        (("2" (assert)
                          (("2" (split)
                            (("1" (expand "/") (("1" (inst?) nil nil))
                              nil)
                             ("2" (rewrite "proj_twice")
                              (("2"
                                (expand "difference")
                                (("2"
                                  (expand "complement")
                                  (("2"
                                    (expand "intersection")
                                    (("2"
                                      (expand "member")
                                      (("2"
                                        (case
                                         "{x: T | B!1(x) AND NOT A!1(x)} = {x_101: T | NOT A!1(x_101) AND B!1(x_101)}")
                                        (("1"
                                          (replace -1)
                                          (("1" (propax) nil nil))
                                          nil)
                                         ("2"
                                          (delete -1 -2 2)
                                          (("2"
                                            (apply-extensionality
                                             :hide?
                                             t)
                                            (("2" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil restriction_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (difference const-decl "set" sets nil)
    (/ const-decl "process" processes nil)
    (|#| const-decl "process[T]" restriction_rules nil)
    (set type-eq-decl nil sets nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restriction_equiv formula-decl nil restriction_rules nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (intersection const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (t1!1 skolem-const-decl "(P!1)" restriction_rules nil)
    (A!1 skolem-const-decl "set[T]" restriction_rules nil)
    (B!1 skolem-const-decl "set[T]" restriction_rules nil)
    (P!1 skolem-const-decl "process[T]" restriction_rules nil)
    (proj_twice formula-decl nil traces nil)
    (complement const-decl "set" sets nil))
   nil))
 (restriction_rename 0
  (restriction_rename-1 nil 3662229312
   ("" (skolem!)
    (("" (apply-extensionality :hide? t)
      (("" (smash)
        (("1" (rewrite "restriction_equiv")
          (("1" (assert)
            (("1" (flatten)
              (("1" (expand "rename" -1)
                (("1" (skolem-typepred)
                  (("1" (expand "rename" 1)
                    (("1" (inst?)
                      (("1" (delete -1)
                        (("1"
                          (case "FORALL (x : list[T]) : FORALL (t : list[T]) : trename(R!1, t, x) AND proj(x, B!1) = null IMPLIES trename({(a, b) | R!1(a, b) AND NOT B!1(b)}, t, x)")
                          (("1" (inst?) (("1" (assert) nil nil)) nil)
                           ("2" (delete -1 -2 2)
                            (("2" (induct "x")
                              (("1" (grind) nil nil)
                               ("2"
                                (skosimp*)
                                (("2"
                                  (expand "trename" -2)
                                  (("2"
                                    (flatten)
                                    (("2"
                                      (lemma "list_cons_eta[T]")
                                      (("2"
                                        (inst -1 "t!1")
                                        (("2"
                                          (replace -1 1 rl)
                                          (("2"
                                            (rewrite "proj_cons" -6)
                                            (("2"
                                              (lift-if)
                                              (("2"
                                                (split)
                                                (("1" (assert) nil nil)
                                                 ("2"
                                                  (flatten)
                                                  (("2"
                                                    (inst
                                                     -3
                                                     "cdr(t!1)")
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (delete
                                                         -1
                                                         -2
                                                         -6)
                                                        (("2"
                                                          (expand
                                                           "trename"
                                                           2)
                                                          (("2"
                                                            (propax)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (rewrite "restriction_equiv")
          (("2" (assert)
            (("2" (split)
              (("1" (expand "rename" -1)
                (("1" (skolem-typepred)
                  (("1" (expand "rename")
                    (("1" (inst?)
                      (("1"
                        (case "FORALL (x : list[T]) : FORALL (t : list[T]) : trename({(a, b) | R!1(a, b) AND NOT B!1(b)}, t, x) IMPLIES trename(R!1, t, x)")
                        (("1" (inst?) (("1" (assert) nil nil)) nil)
                         ("2" (delete -1 -2 2)
                          (("2" (induct "x")
                            (("1" (grind) nil nil)
                             ("2" (skosimp*)
                              (("2"
                                (expand "trename" -2)
                                (("2"
                                  (flatten)
                                  (("2"
                                    (inst?)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (lemma "list_cons_eta[T]")
                                        (("2"
                                          (inst -1 "t!1")
                                          (("2"
                                            (replace -1 2 rl)
                                            (("2"
                                              (expand "trename" 2)
                                              (("2" (propax) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand "rename")
                (("2" (skolem!)
                  (("2"
                    (case "FORALL (x : list[T]) : FORALL (t : list[T]) : trename({(a, b) | R!1(a, b) AND NOT B!1(b)}, t, x) IMPLIES proj(x, B!1) = null")
                    (("1" (inst?) (("1" (assert) nil nil)) nil)
                     ("2" (delete -1 2)
                      (("2" (induct "x")
                        (("1" (grind) nil nil)
                         ("2" (skosimp*)
                          (("2" (expand "trename" -2)
                            (("2" (flatten)
                              (("2"
                                (inst?)
                                (("2"
                                  (assert)
                                  (("2" (rewrite "proj_cons") nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil restriction_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (rename const-decl "process" processes nil)
    (|#| const-decl "process[T]" restriction_rules nil)
    (set type-eq-decl nil sets nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (restriction_equiv formula-decl nil restriction_rules nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (trename def-decl "bool" traces nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (list_induction formula-decl nil list_adt nil)
    (filter def-decl "list[T]" filters nil)
    (list_cons_eta formula-decl nil list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (proj_cons formula-decl nil traces nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil))
   nil))
 (restriction_sat_equiv 0
  (restriction_sat_equiv-1 nil 3662229312
   ("" (skolem!)
    (("" (rewrite "restriction_equiv")
      (("" (grind :exclude ("proj") :if-match nil)
        (("1" (inst?) (("1" (assert) nil)))
         ("2" (inst?) (("2" (assert) nil))))))))
    nil)
   ((restriction_equiv formula-decl nil restriction_rules nil)
    (T formal-type-decl nil restriction_rules nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil) (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (\|> const-decl "bool" satisfaction nil))
   nil))
 (monotonic_lemma 0
  (monotonic_lemma-1 nil 3662229312
   ("" (expand "monotonic?")
    (("" (skosimp*)
      (("" (expand "subset?")
        (("" (expand "member")
          (("" (skosimp)
            (("" (rewrite "restriction_equiv")
              (("" (assert)
                (("" (flatten)
                  (("" (rewrite "restriction_equiv")
                    (("" (assert)
                      (("" (typepred "F!1")
                        (("" (expand "monotonic?")
                          (("" (inst?)
                            (("" (inst -1 "Y!1")
                              ((""
                                (expand "subset?")
                                ((""
                                  (expand "member")
                                  ((""
                                    (split -1)
                                    (("1"
                                      (inst?)
                                      (("1" (assert) nil nil))
                                      nil)
                                     ("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((member const-decl "bool" sets nil)
    (restriction_equiv formula-decl nil restriction_rules nil)
    (T formal-type-decl nil restriction_rules nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil) (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subset? const-decl "bool" sets nil)
    (monotonic? const-decl "bool" fixed_points2 nil))
   nil))
 (restriction_fix1_TCC1 0
  (restriction_fix1_TCC1-1 nil 3662229312
   ("" (skosimp) (("" (rewrite "monotonic_lemma") nil nil)) nil)
   ((monotonic_lemma formula-decl nil restriction_rules nil)
    (T formal-type-decl nil restriction_rules nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil) (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (monotonic? const-decl "bool" fixed_points2 nil))
   nil))
 (restriction_fix1 0
  (restriction_fix1-1 nil 3662229312
   ("" (auto-rewrite "monotonic_lemma")
    (("" (skolem!)
      ((""
        (case "(FORALL P: F!1(P) # B!1 = F!1(P # B!1) # B!1) IMPLIES subset?(mu(F!1) # B!1, mu(LAMBDA P1: (F!1(P1) # B!1))) AND subset?(mu(LAMBDA P1: (F!1(P1) # B!1)), mu(F!1) # B!1)")
        (("1" (split)
          (("1" (auto-rewrite-theory "sets")
            (("1" (rewrite "subset_antisymmetric")
              (("1" (flatten) nil nil) ("2" (flatten) nil nil)) nil))
            nil)
           ("2" (flatten) nil nil))
          nil)
         ("2" (delete 2)
          (("2" (flatten)
            (("2" (split)
              (("1"
                (case "mu(F!1) # B!1 |> mu(LAMBDA P1: (F!1(P1) # B!1))")
                (("1" (expand "|>") (("1" (propax) nil nil)) nil)
                 ("2" (delete 2)
                  (("2" (rewrite "restriction_sat_equiv")
                    (("2" (rewrite "induction")
                      (("1" (delete 2) (("1" (grind) nil nil)) nil)
                       ("2" (delete 2)
                        (("2" (skosimp)
                          (("2"
                            (rewrite "restriction_sat_equiv" :dir rl)
                            (("2"
                              (rewrite "restriction_sat_equiv" :dir rl)
                              (("2"
                                (expand "|>")
                                (("2"
                                  (eta "process[T]")
                                  (("2"
                                    (inst
                                     -1
                                     "mu(LAMBDA P1: (F!1(P1) # B!1))")
                                    (("2"
                                      (replace -1)
                                      (("2"
                                        (delete -1)
                                        (("2"
                                          (typepred "F!1")
                                          (("2"
                                            (expand "monotonic?")
                                            (("2"
                                              (inst
                                               -1
                                               "X!1 # B!1"
                                               "mu(LAMBDA P1: (F!1(P1) # B!1))")
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (delete -2)
                                                  (("2"
                                                    (lemma
                                                     "restriction_prop")
                                                    (("2"
                                                      (inst
                                                       -1
                                                       "B!1"
                                                       "F!1(X!1 # B!1)"
                                                       "F!1(mu(LAMBDA P1: (F!1(P1) # B!1)))")
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (lemma
                                                           "fixed_point2[T]")
                                                          (("2"
                                                            (inst
                                                             -1
                                                             "LAMBDA P1: (F!1(P1) # B!1)")
                                                            (("2"
                                                              (replace
                                                               -1
                                                               -2)
                                                              (("2"
                                                                (delete
                                                                 -1
                                                                 -3)
                                                                (("2"
                                                                  (inst
                                                                   -2
                                                                   "X!1")
                                                                  (("2"
                                                                    (replace
                                                                     -2)
                                                                    (("2"
                                                                      (propax)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (inst -1 "mu(F!1)")
                (("2" (lemma "fixed_point2[T]")
                  (("2" (inst?)
                    (("2" (replace -1)
                      (("2" (delete -1)
                        (("2"
                          (case "F!1(mu(F!1) # B!1) # B!1 = (LAMBDA P1: (F!1(P1) # B!1))(mu(F!1) # B!1)")
                          (("1" (replace -1)
                            (("1" (delete -1)
                              (("1"
                                (lemma "least_fixed_point2[T]")
                                (("1"
                                  (inst
                                   -1
                                   "(LAMBDA P1: (F!1(P1) # B!1))"
                                   "mu(F!1) # B!1")
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((proj const-decl "[trace, set[T] -> trace]" traces nil)
    (induction formula-decl nil fixed_points2 nil)
    (ext const-decl "[dummy -> process[T]]" fixed_points2 nil)
    (Par const-decl "process" processes nil)
    (<= const-decl "bool" fixed_points nil)
    (mu const-decl "[U -> process[T]]" fixed_points nil)
    (glb const-decl "process[T]" fixed_points nil)
    (Stop const-decl "process" processes nil)
    (filter def-decl "list[T]" filters nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (dummy nonempty-type-decl nil fixed_points2 nil)
    (prod def-decl "bool" traces nil)
    (fixed_point2 formula-decl nil fixed_points2 nil)
    (restriction_prop formula-decl nil restriction_rules nil)
    (restriction_sat_equiv formula-decl nil restriction_rules nil)
    (\|> const-decl "bool" satisfaction nil)
    (pred type-eq-decl nil defined_types nil)
    (least_fixed_point2 formula-decl nil fixed_points2 nil)
    (monotonic_lemma formula-decl nil restriction_rules nil)
    (subset_antisymmetric formula-decl nil sets_lemmas nil)
    (member const-decl "bool" sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-type-decl nil restriction_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (|#| const-decl "process[T]" restriction_rules nil)
    (monotonic? const-decl "bool" fixed_points2 nil)
    (subset? const-decl "bool" sets nil)
    (mu const-decl "process[T]" fixed_points2 nil))
   nil))
 (restriction_elim 0
  (restriction_elim-1 nil 3662229312
   ("" (skosimp)
    (("" (rewrite "restriction_sat_equiv")
      (("" (lemma "sat_transitive2[T]")
        ((""
          (inst -1 "E!1" "({t | proj(t, B!1) = null IMPLIES E!1(t)})"
           "P!1")
          (("" (assert) (("" (delete -1 2) (("" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((restriction_sat_equiv formula-decl nil restriction_rules nil)
    (T formal-type-decl nil restriction_rules nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil) (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (pred type-eq-decl nil defined_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (sat_transitive2 formula-decl nil satisfaction nil))
   nil)))

