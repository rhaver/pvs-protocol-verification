(traces
 (prefix_equiv 0
  (prefix_equiv-1 nil 3417192745
   ("" (auto-rewrite "prefix" "append")
    (("" (skolem!)
      (("" (ground)
        (("1" (skolem!) (("1" (assert) nil)))
         ("2" (skolem!)
          (("2" (assert) (("2" (replace*) (("2" (assert) nil)))))))
         ("3" (skolem!)
          (("3" (inst + "t!1")
            (("3" (replace*)
              (("3" (expand "append" 1 1) (("3" (propax) nil)))))))))
         ("4" (inst + "t2!1") nil)
         ("5" (skolem!)
          (("5" (inst + "t!1")
            (("5" (apply-extensionality) nil))))))))))
    nil)
   ((cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (append def-decl "list[T]" list_props nil)
    (prefix const-decl "bool" traces nil))
   nil))
 (null_prefix 0
  (null_prefix-1 nil 3417191621
   ("" (skolem!) (("" (rewrite "prefix_equiv") nil nil)) nil)
   ((prefix_equiv formula-decl nil traces nil)
    (T formal-type-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil))
   nil))
 (prefix_null 0
  (prefix_null-1 nil 3417191621
   ("" (skolem!)
    (("" (rewrite "prefix_equiv") (("" (ground) nil nil)) nil)) nil)
   ((prefix_equiv formula-decl nil traces nil)
    (T formal-type-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil))
   nil))
 (cons_prefix 0
  (cons_prefix-1 nil 3417191621
   ("" (skolem!)
    (("" (ground)
      (("1" (rewrite "prefix_equiv") nil nil)
       ("2" (rewrite "prefix_equiv" -) nil nil)
       ("3" (rewrite "prefix_equiv" +) nil nil))
      nil))
    nil)
   ((cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (prefix_equiv formula-decl nil traces nil))
   nil))
 (prefix_append1 0
  (prefix_append1-1 nil 3417191621
   ("" (expand "prefix")
    (("" (skosimp*)
      (("" (replace*)
        (("" (inst + "append(t!1, t3!1)")
          (("" (rewrite "append_assoc") nil nil)) nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (append def-decl "list[T]" list_props nil)
    (append_assoc formula-decl nil list_props nil)
    (prefix const-decl "bool" traces nil))
   nil))
 (prefix_append2 0
  (prefix_append2-1 nil 3417191621
   ("" (expand "prefix")
    (("" (skosimp*)
      (("" (replace*)
        (("" (inst + "t!2") (("" (rewrite "append_assoc") nil nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (append_assoc formula-decl nil list_props nil)
    (prefix const-decl "bool" traces nil))
   nil))
 (prefix_add1 0
  (prefix_add1-1 nil 3417191621
   ("" (auto-rewrite "add" "prefix")
    (("" (assert) (("" (skolem!) (("" (inst?) nil nil)) nil)) nil))
    nil)
   ((prefix const-decl "bool" traces nil)
    (add const-decl "(cons?[T])" more_list_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil traces nil))
   nil))
 (prefix_add2 0
  (prefix_add2-1 nil 3417191621
   ("" (auto-rewrite "add" "prefix_append1")
    (("" (skosimp) (("" (assert) nil nil)) nil)) nil)
   ((add const-decl "(cons?[T])" more_list_props nil)
    (prefix_append1 formula-decl nil traces nil))
   nil))
 (length_prefix 0
  (length_prefix-1 nil 3417191621
   ("" (grind :defs nil :rewrites ("prefix" "length_append[T]")) nil
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length_append formula-decl nil more_list_props nil)
    (T formal-type-decl nil traces nil)
    (prefix const-decl "bool" traces nil))
   nil))
 (prefix_reflexive 0
  (prefix_reflexive-1 nil 3417191621
   ("" (auto-rewrite "append_null" "prefix")
    (("" (auto-rewrite "append_null[T]" "prefix")
      (("" (skolem!)
        (("" (assert)
          (("" (inst + "null") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((prefix const-decl "bool" traces nil)
    (append_null formula-decl nil list_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil traces nil))
   nil))
 (prefix_transitive 0
  (prefix_transitive-1 nil 3417191621
   ("" (expand "prefix")
    (("" (skosimp*)
      (("" (replace*)
        (("" (inst + "append(t!1, t!2)")
          (("" (rewrite "append_assoc") nil nil)) nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (append def-decl "list[T]" list_props nil)
    (append_assoc formula-decl nil list_props nil)
    (prefix const-decl "bool" traces nil))
   nil))
 (prefix_antisymmetric 0
  (prefix_antisymmetric-1 nil 3417191621
   ("" (expand "prefix")
    (("" (skosimp*)
      (("" (auto-rewrite "length_zero[T]" "append_null[T]")
        (("" (case "length(t!1) = 0")
          (("1" (assert)
            (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)
           ("2" (use "length_append[T]")
            (("2" (use "length_append[T]" ("l1" "t2!1"))
              (("2" (stop-rewrite "length_zero[T]")
                (("2" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((trace type-eq-decl nil traces nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (append_null formula-decl nil list_props nil)
    (length_zero formula-decl nil more_list_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length_append formula-decl nil more_list_props nil)
    (prefix const-decl "bool" traces nil))
   nil))
 (proj_null 0
  (proj_null-1 nil 3417191621 ("" (grind) nil nil)
   ((proj const-decl "[trace, set[T] -> trace]" traces nil)
    (filter def-decl "list[T]" filters nil))
   nil))
 (proj_emptyset 0
  (proj_emptyset-1 nil 3417191621
   ("" (induct "t")
    (("1" (grind) nil nil)
     ("2" (skosimp)
      (("2" (expand "proj" 1)
        (("2" (expand "filter")
          (("2" (lift-if)
            (("2" (split)
              (("1" (flatten)
                (("1" (expand "emptyset") (("1" (propax) nil nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (expand "proj") (("2" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_emptyset name-judgement "finite_set" finite_sets nil)
    (filter def-decl "list[T]" filters nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (emptyset const-decl "set" sets nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (proj_fullset 0
  (proj_fullset-1 nil 3417191621
   ("" (induct "t")
    (("1" (grind) nil nil)
     ("2" (skosimp)
      (("2" (expand "proj" 1)
        (("2" (expand "filter")
          (("2" (lift-if)
            (("2" (split)
              (("1" (flatten)
                (("1" (expand "proj")
                  (("1" (replace -2 1) (("1" (propax) nil nil)) nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (expand "fullset" 1) (("2" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((filter def-decl "list[T]" filters nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (fullset const-decl "set" sets nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (proj_cons 0
  (proj_cons-1 nil 3417191621
   ("" (auto-rewrite "proj" "filter[T]")
    (("" (skolem!) (("" (assert) nil)))) nil)
   ((proj const-decl "[trace, set[T] -> trace]" traces nil)
    (T formal-type-decl nil traces nil)
    (filter def-decl "list[T]" filters nil))
   nil))
 (proj_append 0
  (proj_append-1 nil 3417191621
   ("" (skolem 1 ("A!1" _ "t!2")) (("" (induct-and-simplify "t1") nil))
    nil)
   ((filter def-decl "list[T]" filters nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (setof type-eq-decl nil defined_types nil)
    (append def-decl "list[T]" list_props nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (proj_add 0
  (proj_add-1 nil 3417191621
   ("" (auto-rewrite "proj_append" "add")
    (("" (skolem!)
      (("" (assert)
        (("" (auto-rewrite "proj" "filter" "append_null[T]")
          (("" (lift-if) (("" (ground) nil))))))))))
    nil)
   ((T formal-type-decl nil traces nil)
    (append_null formula-decl nil list_props nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (filter def-decl "list[T]" filters nil)
    (add const-decl "(cons?[T])" more_list_props nil)
    (proj_append formula-decl nil traces nil))
   nil))
 (proj_prefix 0
  (proj_prefix-1 nil 3417191621
   ("" (grind :exclude ("append" "proj") :rewrites ("proj_append")) nil
    nil)
   ((setof type-eq-decl nil defined_types nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (proj_append formula-decl nil traces nil)
    (prefix const-decl "bool" traces nil))
   nil))
 (proj_reverse 0
  (proj_reverse-1 nil 3417191621
   ("" (induct "t")
    (("1" (grind) nil)
     ("2" (skosimp*)
      (("2" (auto-rewrite "reverse" "proj_append")
        (("2" (assert)
          (("2" (auto-rewrite "proj" "filter" "append_null[T]")
            (("2" (reduce) nil))))))))))
    nil)
   ((proj_append formula-decl nil traces nil)
    (append_null formula-decl nil list_props nil)
    (filter def-decl "list[T]" filters nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (reverse def-decl "list[T]" list_props nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (prefix_of_proj 0
  (prefix_of_proj-1 nil 3417191621
   ("" (skolem + ("A!1" _ _))
    ((""
      (auto-rewrite "proj" "filter" "prefix_null" "null_prefix"
                    "cons_prefix")
      (("" (induct "t")
        (("1" (skosimp)
          (("1" (assert) (("1" (inst?) (("1" (assert) nil nil)) nil))
            nil))
          nil)
         ("2" (skosimp*)
          (("2" (assert)
            (("2" (lift-if)
              (("2" (ground)
                (("1" (rewrite "prefix_equiv")
                  (("1" (ground)
                    (("1" (inst + "null") (("1" (assert) nil nil)) nil)
                     ("2" (inst? -)
                      (("2" (assert)
                        (("2" (skosimp)
                          (("2" (inst + "cons(cons1_var!1, t2!1)")
                            (("2" (assert)
                              (("2" (apply-extensionality) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (inst? -)
                  (("2" (assert)
                    (("2" (skosimp)
                      (("2" (inst + "cons(cons1_var!1, t2!1)")
                        (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pred type-eq-decl nil defined_types nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (prefix_equiv formula-decl nil traces nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons_prefix formula-decl nil traces nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null_prefix formula-decl nil traces nil)
    (prefix_null formula-decl nil traces nil)
    (filter def-decl "list[T]" filters nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (set type-eq-decl nil sets nil)
    (prefix const-decl "bool" traces nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (prefix_of_proj2 0
  (prefix_of_proj2-1 nil 3417191621
   (""
    (grind :defs nil :if-match nil :rewrites
     ("prefix_of_proj" "proj_prefix"))
    nil nil)
   ((proj_prefix formula-decl nil traces nil)
    (prefix_of_proj formula-decl nil traces nil))
   nil))
 (proj_twice 0
  (proj_twice-1 nil 3417191621
   ("" (skolem 1 ("A!1" "B!1" _)) (("" (induct-and-simplify "t") nil))
    nil)
   ((member const-decl "bool" sets nil)
    (filter def-decl "list[T]" filters nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (intersection const-decl "set" sets nil)
    (setof type-eq-decl nil defined_types nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (cons_proj 0
  (cons_proj-1 nil 3417191621 ("" (grind) nil nil)
   ((filter def-decl "list[T]" filters nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil))
   nil))
 (every_proj 0
  (every_proj-1 nil 3417191621 ("" (induct-and-simplify "t") nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (T formal-type-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil)
    (filter def-decl "list[T]" filters nil))
   nil))
 (every_proj2 0
  (every_proj2-1 nil 3417191621 ("" (induct-and-simplify "t") nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (complement const-decl "set" sets nil)
    (T formal-type-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil)
    (filter def-decl "list[T]" filters nil)
    (member const-decl "bool" sets nil))
   nil))
 (prod_TCC1 0
  (prod_TCC1-1 nil 3417191621 ("" (grind) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil
   (prod termination
    "traces.prod(traces.A)(list_adt[traces.T].cdr(traces.t1), list_adt[traces.T].cdr(traces.t2), traces.y)"
    "nil")))
 (prod_TCC2 0
  (prod_TCC2-1 nil 3417191621 ("" (grind) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil
   (prod termination
    "traces.prod(traces.A)(list_adt[traces.T].cdr(traces.t1), traces.t2, traces.y)"
    "nil")))
 (prod_TCC3 0
  (prod_TCC3-1 nil 3417191621 ("" (grind) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil
   (prod termination
    "traces.prod(traces.A)(traces.t1, list_adt[traces.T].cdr(traces.t2), traces.y)"
    "nil")))
 (prod_append 0
  (prod_append-1 nil 3417191621
   ("" (induct "t")
    (("1" (skosimp)
      (("1" (expand "prod" -1)
        (("1" (flatten) (("1" (grind) nil nil)) nil)) nil))
      nil)
     ("2" (skosimp*)
      (("2" (expand "prod" -2)
        (("2" (split)
          (("1" (flatten)
            (("1"
              (inst -7 "A!1" "cdr(t1!1)" "cdr(t2!1)" "u!1" "u1!1"
               "u2!1")
              (("1" (assert)
                (("1" (expand "append" 1 3)
                  (("1" (expand "prod" 1) (("1" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (split)
              (("1" (flatten)
                (("1"
                  (inst -4 "A!1" "cdr(t1!1)" "t2!1" "u!1" "u1!1"
                   "u2!1")
                  (("1" (assert)
                    (("1" (expand "append" 2 3)
                      (("1" (expand "prod" 2)
                        (("1" (flatten)
                          (("1" (delete 3) (("1" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2"
                  (inst -4 "A!1" "t1!1" "cdr(t2!1)" "u!1" "u1!1"
                   "u2!1")
                  (("2" (assert)
                    (("2" (expand "append" 2 3)
                      (("2" (expand "prod" 2)
                        (("2" (flatten)
                          (("2" (delete 2) (("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (append def-decl "list[T]" list_props nil)
    (prod def-decl "bool" traces nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (prod_add1 0
  (prod_add1-1 nil 3417191621
   ("" (induct "t")
    (("1" (grind) nil nil)
     ("2" (skosimp*)
      (("2" (expand "prod" -2)
        (("2" (split -2)
          (("1" (flatten)
            (("1"
              (case "add(cons(cons1_var!1, cons2_var!1), a!1) = cons(cons1_var!1, add(cons2_var!1, a!1))")
              (("1" (replace -1)
                (("1" (delete -1)
                  (("1" (expand "prod" 1)
                    (("1" (assert)
                      (("1" (split)
                        (("1" (grind) nil nil) ("2" (grind) nil nil)
                         ("3" (grind) nil nil) ("4" (grind) nil nil)
                         ("5"
                          (case "cdr(add(t1!1, a!1)) = add(cdr(t1!1), a!1) AND cdr(add(t2!1, a!1)) = add(cdr(t2!1), a!1)")
                          (("1" (flatten)
                            (("1" (replace -1)
                              (("1"
                                (replace -2)
                                (("1"
                                  (delete -1 -2)
                                  (("1"
                                    (inst?)
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (delete -1 -6 -7 -8 2)
                            (("2" (split)
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (delete -1 -6 -7 2) (("2" (grind) nil nil)) nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (split)
              (("1" (flatten)
                (("1"
                  (case "add(cons(cons1_var!1, cons2_var!1), a!1) = cons(cons1_var!1, add(cons2_var!1, a!1))")
                  (("1" (replace -1)
                    (("1" (expand "prod" 2)
                      (("1" (assert)
                        (("1" (flatten)
                          (("1" (delete -1)
                            (("1" (delete 3)
                              (("1"
                                (split)
                                (("1" (grind) nil nil)
                                 ("2" (grind) nil nil)
                                 ("3"
                                  (case
                                   "cdr(add(t1!1, a!1)) = add(cdr(t1!1), a!1)")
                                  (("1"
                                    (replace -1)
                                    (("1"
                                      (inst?)
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (delete -3 -4 -5 2 3)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (delete -3 -4 -5 2 3) (("2" (grind) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2"
                  (case "add(cons(cons1_var!1, cons2_var!1), a!1) = cons(cons1_var!1, add(cons2_var!1, a!1))")
                  (("1" (replace -1)
                    (("1" (delete -1)
                      (("1" (expand "prod" 2)
                        (("1" (assert)
                          (("1" (flatten)
                            (("1" (delete 2)
                              (("1"
                                (split)
                                (("1" (grind) nil nil)
                                 ("2" (grind) nil nil)
                                 ("3"
                                  (case
                                   "cdr(add(t2!1, a!1)) = add(cdr(t2!1), a!1)")
                                  (("1"
                                    (replace -1)
                                    (("1"
                                      (inst?)
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (delete -3 -4 -5 2 3)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (delete -3 -4 -5 2 3) (("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((= const-decl "[T, T -> boolean]" equalities nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (add const-decl "(cons?[T])" more_list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (prod def-decl "bool" traces nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (prod_add2 0
  (prod_add2-1 nil 3417191621
   ("" (induct "t")
    (("1" (grind) nil nil)
     ("2" (skosimp*)
      (("2" (expand "prod" -2)
        (("2" (split -2)
          (("1" (flatten)
            (("1" (split)
              (("1"
                (case "add(cons(cons1_var!1, cons2_var!1), a!1) = cons(cons1_var!1, add(cons2_var!1, a!1))")
                (("1" (replace -1)
                  (("1" (delete -1)
                    (("1" (expand "prod" 1)
                      (("1" (assert)
                        (("1" (split)
                          (("1" (grind) nil nil) ("2" (grind) nil nil)
                           ("3"
                            (case "cdr(add(t2!1, a!1)) = add(cdr(t2!1), a!1)")
                            (("1" (replace -1)
                              (("1"
                                (inst?)
                                (("1" (assert) nil nil))
                                nil))
                              nil)
                             ("2" (delete -1 -6 -7 -8 2)
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete -1 -6 -7 2) (("2" (grind) nil nil)) nil))
                nil)
               ("2"
                (case "add(cons(cons1_var!1, cons2_var!1), a!1) = cons(cons1_var!1, add(cons2_var!1, a!1))")
                (("1" (replace -1)
                  (("1" (expand "prod" 1)
                    (("1" (assert)
                      (("1" (delete -1)
                        (("1" (split)
                          (("1" (grind) nil nil) ("2" (grind) nil nil)
                           ("3"
                            (case "cdr(add(t1!1, a!1)) = add(cdr(t1!1), a!1)")
                            (("1" (replace -1)
                              (("1"
                                (inst?)
                                (("1" (assert) nil nil))
                                nil))
                              nil)
                             ("2" (delete -3 -4 -5 2 3)
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete -3 -4 -5 2 3) (("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (split)
              (("1" (flatten)
                (("1" (split)
                  (("1"
                    (case "add(cons(cons1_var!1, cons2_var!1), a!1) = cons(cons1_var!1, add(cons2_var!1, a!1))")
                    (("1" (replace -1)
                      (("1" (expand "prod" 1)
                        (("1" (assert)
                          (("1" (flatten)
                            (("1" (delete -1 2)
                              (("1"
                                (inst?)
                                (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (delete -3 -4 -5 2 3) (("2" (grind) nil nil))
                      nil))
                    nil)
                   ("2"
                    (case "add(cons(cons1_var!1, cons2_var!1), a!1) = cons(cons1_var!1, add(cons2_var!1, a!1))")
                    (("1" (replace -1)
                      (("1" (delete -1)
                        (("1" (expand "prod" 1)
                          (("1" (assert)
                            (("1" (flatten)
                              (("1"
                                (delete 2)
                                (("1"
                                  (split)
                                  (("1" (grind) nil nil)
                                   ("2" (grind) nil nil)
                                   ("3"
                                    (case
                                     "cdr(add(t1!1, a!1)) = add(cdr(t1!1), a!1)")
                                    (("1"
                                      (replace -1)
                                      (("1"
                                        (inst?)
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (delete -3 -4 -5 2 3)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (delete -3 -4 -5 2 3) (("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (split)
                  (("1"
                    (case "add(cons(cons1_var!1, cons2_var!1), a!1) = cons(cons1_var!1, add(cons2_var!1, a!1))")
                    (("1" (replace -1)
                      (("1" (expand "prod" 1)
                        (("1" (assert)
                          (("1" (flatten)
                            (("1" (delete 1)
                              (("1"
                                (delete -1)
                                (("1"
                                  (split)
                                  (("1" (grind) nil nil)
                                   ("2" (grind) nil nil)
                                   ("3"
                                    (case
                                     "cdr(add(t2!1, a!1)) = add(cdr(t2!1), a!1)")
                                    (("1"
                                      (replace -1)
                                      (("1"
                                        (inst?)
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (delete -3 -4 -5 2 3)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (delete -3 -4 -5 2 3) (("2" (grind) nil nil))
                      nil))
                    nil)
                   ("2"
                    (case "add(cons(cons1_var!1, cons2_var!1), a!1) = cons(cons1_var!1, add(cons2_var!1, a!1))")
                    (("1" (replace -1)
                      (("1" (delete -1)
                        (("1" (expand "prod" 1)
                          (("1" (assert)
                            (("1" (flatten)
                              (("1"
                                (delete 1)
                                (("1"
                                  (inst?)
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (delete -3 -4 -5 2 3) (("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (append def-decl "list[T]" list_props nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (add const-decl "(cons?[T])" more_list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (prod def-decl "bool" traces nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (prod_reverse 0
  (prod_reverse-1 nil 3417191621
   ("" (induct "t")
    (("1" (skosimp)
      (("1" (expand "reverse" 1 3)
        (("1" (expand "prod")
          (("1" (split) (("1" (grind) nil nil) ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skosimp*)
      (("2" (expand "prod" -2)
        (("2" (split)
          (("1" (flatten)
            (("1" (inst?)
              (("1" (assert)
                (("1" (lemma "prod_add1")
                  (("1"
                    (inst -1 "A!1" "cons1_var!1" "reverse(cons2_var!1)"
                     "reverse(cdr(t1!1))" "reverse(cdr(t2!1))")
                    (("1" (assert)
                      (("1" (rewrite "reverse_cons" :dir rl)
                        (("1" (rewrite "reverse_cons" :dir rl)
                          (("1" (rewrite "reverse_cons" :dir rl)
                            (("1"
                              (case "cons(cons1_var!1, cdr(t1!1)) = t1!1 AND cons(cons1_var!1, cdr(t2!1)) = t2!1")
                              (("1"
                                (flatten)
                                (("1"
                                  (replace -1)
                                  (("1"
                                    (replace -2)
                                    (("1" (propax) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (split)
                                (("1"
                                  (replace -5 1 rl)
                                  (("1"
                                    (lemma "list_cons_eta[T]")
                                    (("1" (inst?) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (replace -6 1 rl)
                                  (("2"
                                    (lemma "list_cons_eta[T]")
                                    (("2" (inst?) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (split)
              (("1" (flatten)
                (("1" (inst?)
                  (("1" (assert)
                    (("1" (lemma "prod_add2")
                      (("1"
                        (inst -1 "A!1" "cons1_var!1"
                         "reverse(cons2_var!1)" "reverse(cdr(t1!1))"
                         "reverse(t2!1)")
                        (("1" (assert)
                          (("1" (flatten)
                            (("1" (delete -1)
                              (("1"
                                (rewrite "reverse_cons" :dir rl)
                                (("1"
                                  (rewrite "reverse_cons" :dir rl)
                                  (("1"
                                    (case
                                     "cons(cons1_var!1, cdr(t1!1)) = t1!1")
                                    (("1"
                                      (replace -1)
                                      (("1" (propax) nil nil))
                                      nil)
                                     ("2"
                                      (replace -3 1 rl)
                                      (("2"
                                        (lemma "list_cons_eta[T]")
                                        (("2" (inst?) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (inst?)
                  (("2" (assert)
                    (("2" (lemma "prod_add2")
                      (("2"
                        (inst -1 "A!1" "cons1_var!1"
                         "reverse(cons2_var!1)" "reverse(t1!1)"
                         "reverse(cdr(t2!1))")
                        (("2" (assert)
                          (("2" (flatten)
                            (("2" (delete -2)
                              (("2"
                                (rewrite "reverse_cons" :dir rl)
                                (("2"
                                  (rewrite "reverse_cons" :dir rl)
                                  (("2"
                                    (case
                                     "cons(cons1_var!1, cdr(t2!1)) = t2!1")
                                    (("1"
                                      (replace -1)
                                      (("1" (propax) nil nil))
                                      nil)
                                     ("2"
                                      (replace -3 1 rl)
                                      (("2"
                                        (lemma "list_cons_eta[T]")
                                        (("2" (inst?) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (prod_add1 formula-decl nil traces nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (list_cons_eta formula-decl nil list_adt nil)
    (reverse_cons formula-decl nil more_list_props nil)
    (prod_add2 formula-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (reverse def-decl "list[T]" list_props nil)
    (prod def-decl "bool" traces nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (prod_reverse2 0
  (prod_reverse2-1 nil 3417191621
   ("" (skosimp)
    (("" (lemma "prod_reverse")
      ((""
        (inst -1 "A!1" "reverse(t!1)" "reverse(t1!1)" "reverse(t2!1)")
        (("" (assert)
          (("" (rewrite "reverse_reverse")
            (("" (rewrite "reverse_reverse")
              (("" (rewrite "reverse_reverse") nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((prod_reverse formula-decl nil traces nil)
    (reverse_reverse formula-decl nil list_props nil)
    (reverse def-decl "list[T]" list_props nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil traces nil))
   nil))
 (prod_reverse3 0
  (prod_reverse3-1 nil 3417191621
   ("" (skosimp)
    (("" (iff)
      (("" (split)
        (("1" (use "prod_reverse") nil nil)
         ("2" (lemma "prod_reverse2")
          (("2" (inst -1 "A!1" "t!1" "t1!1" "t2!1") nil nil)) nil))
        nil))
      nil))
    nil)
   ((prod_reverse2 formula-decl nil traces nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil traces nil)
    (prod_reverse formula-decl nil traces nil))
   nil))
 (prod_proj2 0
  (prod_proj2-1 nil 3417191621
   ("" (induct "t3")
    (("1" (grind) nil nil)
     ("2" (skosimp*)
      (("2" (expand "prod" -2)
        (("2" (smash)
          (("1" (rewrite "proj_cons")
            (("1" (lift-if)
              (("1" (split)
                (("1" (flatten)
                  (("1"
                    (case "proj(t1!1, B!1) = cons(cons1_var!1, proj(cdr(t1!1), B!1))")
                    (("1" (replace -1)
                      (("1" (delete -1)
                        (("1"
                          (case "proj(t2!1, B!1) = cons(cons1_var!1, proj(cdr(t2!1), B!1))")
                          (("1" (replace -1)
                            (("1" (delete -1)
                              (("1"
                                (expand "prod" 1)
                                (("1"
                                  (inst?)
                                  (("1"
                                    (assert)
                                    (("1" (inst?) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (delete -2 -3 -4 -6 -8 2)
                            (("2" (lemma "list_cons_eta[T]")
                              (("2"
                                (inst?)
                                (("2"
                                  (replace -1 1 rl)
                                  (("2"
                                    (replace -4)
                                    (("2"
                                      (rewrite "proj_cons")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (delete -2 -3 -5 -7 -8 2)
                      (("2" (lemma "list_cons_eta[T]")
                        (("2" (inst?)
                          (("2" (replace -1 1 rl)
                            (("2" (replace -4)
                              (("2"
                                (rewrite "proj_cons")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (case "proj(t1!1, B!1) = proj(cdr(t1!1), B!1)")
                    (("1" (replace -1)
                      (("1" (delete -1)
                        (("1"
                          (case "proj(t2!1, B!1) = proj(cdr(t2!1), B!1)")
                          (("1" (replace -1)
                            (("1" (delete -1)
                              (("1"
                                (inst?)
                                (("1"
                                  (assert)
                                  (("1" (inst?) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (delete -1 -2 -3 -5 -7 3)
                            (("2" (lemma "list_cons_eta[T]")
                              (("2"
                                (inst?)
                                (("2"
                                  (replace -1 1 rl)
                                  (("2"
                                    (replace -3)
                                    (("2"
                                      (rewrite "proj_cons")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (delete -1 -2 -4 -6 -7 3)
                      (("2" (lemma "list_cons_eta[T]")
                        (("2" (inst?)
                          (("2" (replace -1 1 rl)
                            (("2" (replace -3)
                              (("2"
                                (rewrite "proj_cons")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (rewrite "proj_cons")
            (("2" (lift-if)
              (("2" (split)
                (("1" (flatten)
                  (("1"
                    (case "proj(t1!1, B!1) = cons(cons1_var!1, proj(cdr(t1!1), B!1))")
                    (("1" (replace -1)
                      (("1" (delete -1)
                        (("1" (expand "prod" 1)
                          (("1" (flatten)
                            (("1" (delete 2)
                              (("1"
                                (inst?)
                                (("1"
                                  (assert)
                                  (("1" (inst?) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (delete -2 -5 2 3)
                      (("2" (lemma "list_cons_eta[T]")
                        (("2" (inst?)
                          (("2" (replace -1 1 rl)
                            (("2" (replace -4)
                              (("2"
                                (rewrite "proj_cons")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (case "proj(t1!1, B!1) = proj(cdr(t1!1), B!1)")
                    (("1" (replace -1)
                      (("1" (delete -1)
                        (("1" (inst?)
                          (("1" (assert) (("1" (inst?) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (delete -1 -4 3 4)
                      (("2" (lemma "list_cons_eta[T]")
                        (("2" (inst?)
                          (("2" (replace -1 1 rl)
                            (("2" (replace -3)
                              (("2"
                                (rewrite "proj_cons")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (rewrite "proj_cons")
            (("3" (lift-if)
              (("3" (split)
                (("1" (flatten)
                  (("1"
                    (case "proj(t2!1, B!1) = cons(cons1_var!1, proj(cdr(t2!1), B!1))")
                    (("1" (replace -1)
                      (("1" (delete -1)
                        (("1" (expand "prod" 1)
                          (("1" (flatten)
                            (("1" (delete 1)
                              (("1"
                                (inst?)
                                (("1"
                                  (assert)
                                  (("1" (inst?) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (delete -2 -5 2 3)
                      (("2" (lemma "list_cons_eta[T]")
                        (("2" (inst?)
                          (("2" (replace -1 1 rl)
                            (("2" (replace -4)
                              (("2"
                                (rewrite "proj_cons")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (case "proj(t2!1, B!1) = proj(cdr(t2!1), B!1)")
                    (("1" (replace -1)
                      (("1" (delete -1)
                        (("1" (inst?)
                          (("1" (assert) (("1" (inst?) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (delete -1 -4 3 4)
                      (("2" (lemma "list_cons_eta[T]")
                        (("2" (inst?)
                          (("2" (replace -1 1 rl)
                            (("2" (replace -3)
                              (("2"
                                (rewrite "proj_cons")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((list_cons_eta formula-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (proj_cons formula-decl nil traces nil)
    (filter def-decl "list[T]" filters nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (set type-eq-decl nil sets nil) (prod def-decl "bool" traces nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (prod_commutes 0
  (prod_commutes-1 nil 3417191621
   ("" (skolem!)
    ((""
      (case "FORALL t1, t2, t : prod(A!1)(t1, t2, t) IMPLIES prod(A!1)(t2, t1, t)")
      (("1" (grind :if-match all) nil nil)
       ("2" (delete 2)
        (("2" (auto-rewrite "prod" "proj" "filter")
          (("2" (induct "t")
            (("1" (skosimp)
              (("1" (assert) (("1" (ground) nil nil)) nil)) nil)
             ("2" (skosimp*)
              (("2" (case "A!1(cons1_var!1)")
                (("1" (assert)
                  (("1" (ground)
                    (("1" (inst?) (("1" (assert) nil nil)) nil)) nil))
                  nil)
                 ("2" (assert)
                  (("2" (split -)
                    (("1" (flatten)
                      (("1" (inst? - :where 3) (("1" (assert) nil nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (inst? - :where 2) (("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((prod def-decl "bool" traces nil)
    (setof type-eq-decl nil defined_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list_induction formula-decl nil list_adt nil))
   nil))
 (proj_prod1 0
  (proj_prod1-1 nil 3417191621 ("" (induct-and-simplify "t") nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (prod def-decl "bool" traces nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (T formal-type-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil)
    (filter def-decl "list[T]" filters nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil))
   nil))
 (proj_prod2 0
  (proj_prod2-1 nil 3417191621
   ("" (skosimp)
    (("" (rewrite "prod_commutes")
      (("" (forward-chain "proj_prod1") nil))))
    nil)
   ((prod_commutes formula-decl nil traces nil)
    (T formal-type-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (proj_prod1 formula-decl nil traces nil))
   nil))
 (prod_null1 0
  (prod_null1-1 nil 3417191621
   ("" (induct-and-simplify "t") (("" (apply-extensionality) nil)) nil)
   ((list_cons_extensionality formula-decl nil list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (prod def-decl "bool" traces nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil))
   nil))
 (prod_null2 0
  (prod_null2-1 nil 3417191621
   ("" (skosimp)
    (("" (rewrite "prod_commutes")
      (("" (forward-chain "prod_null1") nil))))
    nil)
   ((prod_commutes formula-decl nil traces nil)
    (T formal-type-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prod_null1 formula-decl nil traces nil))
   nil))
 (prod_null3 0
  (prod_null3-1 nil 3417191621 ("" (induct-and-simplify "t") nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prod def-decl "bool" traces nil)
    (T formal-type-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil)
    (filter def-decl "list[T]" filters nil))
   nil))
 (prod_null4 0
  (prod_null4-1 nil 3417191621
   ("" (skosimp)
    (("" (rewrite "prod_commutes") (("" (rewrite "prod_null3") nil))))
    nil)
   ((prod_commutes formula-decl nil traces nil)
    (T formal-type-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prod_null3 formula-decl nil traces nil))
   nil))
 (prefix_prod 0
  (prefix_prod-1 nil 3417191621
   ("" (skolem + ("A!1" _ _ _ _))
    (("" (auto-rewrite "prod" "prefix_null" "null_prefix")
      (("" (induct "t")
        (("1" (skosimp)
          (("1" (assert)
            (("1" (inst + "null" "null") (("1" (ground) nil nil)) nil))
            nil))
          nil)
         ("2" (skosimp*)
          (("2" (case "null?(u!1)")
            (("1" (delete -2 -3)
              (("1" (inst + "null" "null") (("1" (assert) nil nil))
                nil))
              nil)
             ("2" (rewrite "prefix_equiv")
              (("2" (assert)
                (("2" (ground)
                  (("1" (inst? -)
                    (("1" (inst? -)
                      (("1" (assert)
                        (("1" (skosimp)
                          (("1"
                            (inst + "cons(cons1_var!1, u1!1)"
                             "cons(cons1_var!1, u2!1)")
                            (("1" (assert)
                              (("1"
                                (auto-rewrite "prefix_equiv")
                                (("1" (ground) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (inst? -)
                    (("2" (inst? -)
                      (("2" (assert)
                        (("2" (skosimp)
                          (("2"
                            (inst + "cons(cons1_var!1, u1!1)" "u2!1")
                            (("2" (assert)
                              (("2"
                                (rewrite "prefix_equiv" +)
                                nil
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (inst? -)
                    (("3" (inst? -)
                      (("3" (assert)
                        (("3" (skosimp)
                          (("3"
                            (inst + "u1!1" "cons(cons1_var!1, u2!1)")
                            (("3" (assert)
                              (("3"
                                (rewrite "prefix_equiv" +)
                                nil
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (prefix_equiv formula-decl nil traces nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null_prefix formula-decl nil traces nil)
    (prefix_null formula-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (prefix const-decl "bool" traces nil)
    (prod def-decl "bool" traces nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (prod_assoc1 0
  (prod_assoc1-1 nil 3417191621
   ("" (skolem 1 ("A!1" _ _ _ _ _))
    (("" (auto-rewrite "prod")
      (("" (induct "t")
        (("1" (reduce) nil)
         ("2" (skosimp*)
          (("2" (reduce :if-match nil)
            (("1" (inst?)
              (("1" (inst?)
                (("1" (assert)
                  (("1" (skosimp)
                    (("1" (inst + "cons(cons1_var!1, u1!1)")
                      (("1" (assert) nil)))))))))))
             ("2" (inst? -)
              (("2" (inst? -)
                (("2" (assert)
                  (("2" (skosimp)
                    (("2" (inst?) (("2" (assert) nil)))))))))))
             ("3" (inst? -)
              (("3" (inst? -)
                (("3" (assert)
                  (("3" (skosimp)
                    (("3" (inst + "cons(cons1_var!1, u1!1)")
                      (("3" (assert) nil)))))))))))
             ("4" (inst? -)
              (("4" (inst? -)
                (("4" (assert)
                  (("4" (skosimp)
                    (("4" (inst + "cons(cons1_var!1, u1!1)")
                      (("4" (assert) nil))))))))))))))))))))
    nil)
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (prod def-decl "bool" traces nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (prod_assoc2 0
  (prod_assoc2-1 nil 3417191621
   ("" (skolem 1 ("A!1" _ _ _ _ _))
    (("" (auto-rewrite "prod")
      (("" (induct "t")
        (("1" (reduce) nil)
         ("2" (skosimp*)
          (("2" (reduce :if-match nil)
            (("1"
              (inst - "cdr(t1!1)" "cdr(t2!1)" "cdr(t3!1)" "cdr(u!1)")
              (("1" (assert)
                (("1" (skosimp)
                  (("1" (inst + "cons(cons1_var!1, u1!1)")
                    (("1" (assert) nil)))))))))
             ("2" (inst - "cdr(t1!1)" "t2!1" "t3!1" "u!1")
              (("2" (assert)
                (("2" (skosimp)
                  (("2" (inst + "cons(cons1_var!1, u1!1)")
                    (("2" (assert) nil)))))))))
             ("3" (inst - "t1!1" "cdr(t2!1)" "t3!1" "cdr(u!1)")
              (("3" (assert)
                (("3" (skosimp)
                  (("3" (inst + "cons(cons1_var!1, u1!1)")
                    (("3" (assert) nil)))))))))
             ("4" (inst - "t1!1" "t2!1" "cdr(t3!1)" "cdr(u!1)")
              (("4" (assert)
                (("4" (skosimp)
                  (("4" (inst?) (("4" (assert) nil))))))))))))))))))
    nil)
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (prod def-decl "bool" traces nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (prod_assoc 0
  (prod_assoc-1 nil 3417191621
   ("" (reduce :if-match nil)
    (("1" (use "prod_assoc1") (("1" (assert) nil)))
     ("2" (use "prod_assoc2") (("2" (assert) nil))))
    nil)
   ((prod_assoc2 formula-decl nil traces nil)
    (prod_assoc1 formula-decl nil traces nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil traces nil))
   nil))
 (prod_fullset 0
  (prod_fullset-1 nil 3417191621
   ("" (auto-rewrite "fullset" "prod")
    (("" (induct "u")
      (("1" (reduce) nil)
       ("2" (skosimp*)
        (("2" (assert)
          (("2" (split)
            (("1" (flatten)
              (("1" (assert)
                (("1" (inst?)
                  (("1" (ground)
                    (("1" (apply-extensionality :hide? t) nil)
                     ("2" (apply-extensionality :hide? t) nil)))))))))
             ("2" (flatten)
              (("2" (assert)
                (("2" (inst?)
                  (("2" (replace*)
                    (("2" (delete -)
                      (("2" (assert) nil))))))))))))))))))))
    nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (prod def-decl "bool" traces nil) (set type-eq-decl nil sets nil)
    (fullset const-decl "set" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil))
   nil))
 (prod_fullset2 0
  (prod_fullset2-1 nil 3417191621
   ("" (induct "t")
    (("1" (skosimp)
      (("1" (rewrite "proj_null")
        (("1" (expand "prod")
          (("1" (flatten)
            (("1" (split) (("1" (grind) nil nil) ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skosimp*)
      (("2" (expand "prod" -2)
        (("2" (split -2)
          (("1" (flatten)
            (("1" (inst?)
              (("1" (assert)
                (("1" (rewrite "prod_fullset" -7)
                  (("1" (rewrite "proj_cons")
                    (("1" (expand "prod" 1)
                      (("1" (split)
                        (("1" (grind)
                          (("1" (rewrite "prod_fullset") nil nil)) nil)
                         ("2" (flatten)
                          (("2" (expand "fullset")
                            (("2" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (split)
              (("1" (flatten)
                (("1" (inst?)
                  (("1" (assert)
                    (("1" (rewrite "prod_fullset" -4)
                      (("1" (rewrite "proj_cons")
                        (("1" (flatten)
                          (("1" (lemma "list_cons_eta[T]")
                            (("1" (inst -1 "t1!1")
                              (("1"
                                (replace -3 -1)
                                (("1"
                                  (replace -1 2 rl)
                                  (("1"
                                    (rewrite "proj_cons")
                                    (("1"
                                      (rewrite "prod_fullset")
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (inst?)
                  (("2" (assert)
                    (("2" (rewrite "prod_fullset" -4)
                      (("2" (flatten)
                        (("2" (rewrite "proj_cons")
                          (("2" (lemma "list_cons_eta[T]")
                            (("2" (inst -1 "t2!1")
                              (("2"
                                (replace -3 -1)
                                (("2"
                                  (replace -1 2 rl)
                                  (("2"
                                    (rewrite "proj_cons")
                                    (("2"
                                      (rewrite "prod_fullset")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (prod_fullset formula-decl nil traces nil)
    (pred type-eq-decl nil defined_types nil)
    (proj_cons formula-decl nil traces nil)
    (list_cons_eta formula-decl nil list_adt nil)
    (filter def-decl "list[T]" filters nil)
    (proj_null formula-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (fullset const-decl "set" sets nil) (set type-eq-decl nil sets nil)
    (prod def-decl "bool" traces nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (free_prod_left 0
  (free_prod_left-1 nil 3417191621
   ("" (induct-and-simplify "t") nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (prod def-decl "bool" traces nil) (set type-eq-decl nil sets nil)
    (emptyset const-decl "set" sets nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (T formal-type-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   nil))
 (free_prod_right 0
  (free_prod_right-1 nil 3417191621
   ("" (induct-and-simplify "t") nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (prod def-decl "bool" traces nil) (set type-eq-decl nil sets nil)
    (emptyset const-decl "set" sets nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (T formal-type-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   nil))
 (trename_TCC1 0
  (trename_TCC1-1 nil 3417191621 ("" (termination-tcc) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil
   (trename termination
    "traces.trename(traces.R, list_adt[traces.T].cdr(traces.t1), traces.y)"
    "nil")))
 (trename_null1 0
  (trename_null1-1 nil 3417191621
   ("" (skosimp)
    (("" (expand "trename")
      (("" (lift-if)
        (("" (split)
          (("1" (flatten) (("1" (assert) nil nil)) nil)
           ("2" (flatten) (("2" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((trename def-decl "bool" traces nil)) nil))
 (trename_null2 0
  (trename_null2-1 nil 3417191621
   ("" (skosimp) (("" (expand "trename") (("" (assert) nil nil)) nil))
    nil)
   ((trename def-decl "bool" traces nil)) nil))
 (prefix_trename 0
  (prefix_trename-1 nil 3417191621
   ("" (skolem + ("R!1" _ _ _))
    (("" (induct "t")
      (("1" (skosimp)
        (("1" (forward-chain "trename_null2")
          (("1" (rewrite "prefix_null")
            (("1" (replace -1 1)
              (("1" (replace -3 1)
                (("1" (inst 1 "null") (("1" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skolem!)
        (("2" (flatten)
          (("2" (skolem!)
            (("2" (lemma "list_inclusive[T]")
              (("2" (inst -1 "u!1")
                (("2" (split)
                  (("1" (flatten)
                    (("1" (inst 1 "null")
                      (("1" (split)
                        (("1" (use "null_prefix") nil nil)
                         ("2" (case "u!1 = null")
                          (("1" (replace -1 1)
                            (("1" (expand "trename" 1)
                              (("1" (propax) nil nil)) nil))
                            nil)
                           ("2" (delete -2 -3 -4 2)
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (inst -2 "cdr(t1!1)" "cdr(u!1)")
                      (("1" (split)
                        (("1" (skosimp)
                          (("1" (inst 1 "cons(car(t1!1), u1!1)")
                            (("1" (split)
                              (("1"
                                (lemma "list_cons_eta[T]")
                                (("1"
                                  (inst -1 "t1!1")
                                  (("1"
                                    (replace -1 1 :dir rl)
                                    (("1"
                                      (rewrite "cons_prefix")
                                      nil
                                      nil))
                                    nil)
                                   ("2"
                                    (expand "trename" -4)
                                    (("2" (flatten) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (expand "trename" -4)
                                (("2"
                                  (flatten)
                                  (("2"
                                    (lemma "list_cons_eta[T]")
                                    (("2"
                                      (inst -1 "u!1")
                                      (("2"
                                        (replace -1 1 :dir rl)
                                        (("2"
                                          (expand "trename" 1)
                                          (("2"
                                            (split)
                                            (("1"
                                              (replace -1 -8 :dir rl)
                                              (("1"
                                                (rewrite "cons_prefix")
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (replace -8 1)
                                                    (("1"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2" (propax) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (expand "trename" -4)
                              (("2" (flatten) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (delete -1 -3 2)
                          (("2" (expand "trename" -1)
                            (("2" (flatten) nil nil)) nil))
                          nil)
                         ("3" (delete -2 2)
                          (("3" (lemma "list_cons_eta[T]")
                            (("3" (inst -1 "u!1")
                              (("3"
                                (replace -1 -3 :dir rl)
                                (("3"
                                  (rewrite "cons_prefix")
                                  (("3" (flatten) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand "trename" -2)
                        (("2" (flatten) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (trename def-decl "bool" traces nil)
    (prefix const-decl "bool" traces nil)
    (T formal-type-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil)
    (trename_null2 formula-decl nil traces nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (prefix_null formula-decl nil traces nil)
    (list_inclusive formula-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null_prefix formula-decl nil traces nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (u!1 skolem-const-decl "trace" traces nil)
    (t1!1 skolem-const-decl "trace" traces nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons_prefix formula-decl nil traces nil)
    (list_cons_eta formula-decl nil list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil))
   nil))
 (sigma_equiv 0
  (sigma_equiv-1 nil 3417191621
   ("" (induct-and-simplify "t")
    (("1" (apply-extensionality :hide? t) nil)
     ("2" (replace*)
      (("2" (apply-extensionality :hide? t) (("2" (smash) nil))))))
    nil)
   ((member const-decl "bool" sets nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (FALSE const-decl "bool" booleans nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (list2set def-decl "set[T]" list2set nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (member def-decl "bool" list_props nil)
    (T formal-type-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil))
   nil))
 (sigma_null 0
  (sigma_null-1 nil 3417191621 ("" (grind) nil nil)
   ((sigma const-decl "[trace -> set[T]]" traces nil)
    (list2set def-decl "set[T]" list2set nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   nil))
 (sigma_cons 0
  (sigma_cons-1 nil 3417191621 ("" (grind) nil nil)
   ((sigma const-decl "[trace -> set[T]]" traces nil)
    (list2set def-decl "set[T]" list2set nil))
   nil))
 (sigma_empty 0
  (sigma_empty-1 nil 3417191621 ("" (grind) nil nil)
   ((emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (list2set def-decl "set[T]" list2set nil)
    (T formal-type-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (trace type-eq-decl nil traces nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil))
   nil))
 (sigma_append 0
  (sigma_append-1 nil 3417191621
   ("" (induct-and-simplify "t1")
    (("1" (apply-extensionality :hide? t) nil)
     ("2" (replace*)
      (("2" (apply-extensionality :hide? t) (("2" (smash) nil))))))
    nil)
   ((nonempty? const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (nonempty_union1 application-judgement "(nonempty?)" sets nil)
    (list2set def-decl "set[T]" list2set nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (append def-decl "list[T]" list_props nil)
    (union const-decl "set" sets nil)
    (T formal-type-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil))
   nil))
 (sigma_add 0
  (sigma_add-1 nil 3417191621
   ("" (expand "add" 1 1)
    (("" (skolem!)
      (("" (rewrite "sigma_append")
        (("" (apply-extensionality :hide? t) (("" (grind) nil))))))))
    nil)
   ((add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (union const-decl "set" sets nil) (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (list2set def-decl "set[T]" list2set nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (sigma_append formula-decl nil traces nil)
    (add const-decl "(cons?[T])" more_list_props nil))
   nil))
 (sigma_prefix 0
  (sigma_prefix-1 nil 3417191621
   ("" (auto-rewrite "prefix" "sigma_append")
    (("" (auto-rewrite-theory "sets[T]") (("" (reduce) nil)))) nil)
   ((subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (T formal-type-decl nil traces nil)
    (prefix const-decl "bool" traces nil)
    (sigma_append formula-decl nil traces nil)
    (union const-decl "set" sets nil))
   nil))
 (sigma_proj 0
  (sigma_proj-1 nil 3417191621
   ("" (induct-and-simplify "t")
    (("1" (apply-extensionality :hide? t) nil)
     ("2" (replace*)
      (("2" (apply-extensionality :hide? t) (("2" (smash) nil)))))
     ("3" (replace*)
      (("3" (apply-extensionality :hide? t) (("3" (smash) nil))))))
    nil)
   ((add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (finite_intersection2 application-judgement "finite_set"
     finite_sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (filter def-decl "list[T]" filters nil)
    (list2set def-decl "set[T]" list2set nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (intersection const-decl "set" sets nil)
    (T formal-type-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil))
   nil))
 (sigma_prod 0
  (sigma_prod-1 nil 3417191621
   ("" (induct-and-simplify "t")
    (("1" (apply-extensionality :hide? t) nil)
     ("2" (replace*)
      (("2" (apply-extensionality :hide? t)
        (("2" (iff) (("2" (ground) nil)))))))
     ("3" (replace*)
      (("3" (apply-extensionality :hide? t)
        (("3" (iff) (("3" (ground) nil)))))))
     ("4" (replace*)
      (("4" (apply-extensionality :hide? t)
        (("4" (iff) (("4" (ground) nil))))))))
    nil)
   ((add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (finite_union application-judgement "finite_set" finite_sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (nonempty_union1 application-judgement "(nonempty?)" sets nil)
    (nonempty_union2 application-judgement "(nonempty?)" sets nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list2set def-decl "set[T]" list2set nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (prod def-decl "bool" traces nil) (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (union const-decl "set" sets nil)
    (T formal-type-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil))
   nil))
 (sigma_prod_inter1 0
  (sigma_prod_inter1-1 nil 3417191621
   ("" (skosimp)
    (("" (forward-chain "proj_prod1")
      (("" (rewrite "sigma_proj" :dir rl)
        (("" (rewrite "sigma_proj" :dir rl) (("" (assert) nil))))))))
    nil)
   ((proj_prod1 formula-decl nil traces nil)
    (T formal-type-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (sigma_proj formula-decl nil traces nil))
   nil))
 (sigma_prod_inter2 0
  (sigma_prod_inter2-1 nil 3417191621
   ("" (skosimp)
    (("" (rewrite "prod_commutes")
      (("" (forward-chain "sigma_prod_inter1") nil))))
    nil)
   ((prod_commutes formula-decl nil traces nil)
    (T formal-type-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (sigma_prod_inter1 formula-decl nil traces nil))
   nil))
 (every_sigma 0
  (every_sigma-1 nil 3417192842
   ("" (induct "t")
    (("1" (grind) nil)
     ("2" (skosimp*)
      (("2" (split)
        (("1" (flatten)
          (("1" (skolem-typepred)
            (("1" (expand "every" -2)
              (("1" (flatten)
                (("1" (expand "sigma" -1)
                  (("1" (expand "list2set" -1)
                    (("1" (expand "add")
                      (("1" (split)
                        (("1" (replace -1) (("1" (propax) nil)))
                         ("2" (expand "member")
                          (("2" (inst?)
                            (("2" (assert)
                              (("2"
                                (inst -4 "a!1")
                                (("2"
                                  (expand "sigma")
                                  (("2"
                                    (propax)
                                    nil)))))))))))))))))))))))))))
         ("2" (flatten)
          (("2" (expand "every" 1)
            (("2" (split)
              (("1" (inst?)
                (("1" (expand "sigma" 1)
                  (("1" (expand "list2set" 1)
                    (("1" (expand "add") (("1" (propax) nil)))))))))
               ("2" (inst -2 ("A!1"))
                (("2" (prop)
                  (("2" (delete 2 3)
                    (("2" (skolem-typepred)
                      (("2" (inst?)
                        (("2" (expand "sigma" 1)
                          (("2" (expand "list2set" 1)
                            (("2" (expand "add" 1)
                              (("2"
                                (flatten)
                                (("2"
                                  (expand "member" 2)
                                  (("2"
                                    (expand "sigma")
                                    (("2"
                                      (propax)
                                      nil))))))))))))))))))))))))))))))))))
    nil)
   ((a!1 skolem-const-decl "(sigma(cons2_var!1))" traces nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (a!1 skolem-const-decl "(sigma(cons(cons1_var!1, cons2_var!1)))"
     traces nil)
    (cons1_var!1 skolem-const-decl "T" traces nil)
    (cons2_var!1 skolem-const-decl "list[T]" traces nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (list2set def-decl "set[T]" list2set nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (set type-eq-decl nil sets nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (null_proj_equiv 0
  (null_proj_equiv-1 nil 3417191621
   ("" (skolem + ("B!1" _)) (("" (induct-and-simplify "t") nil)) nil)
   ((add const-decl "(nonempty?)" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (finite_intersection2 application-judgement "finite_set"
     finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (emptyset const-decl "set" sets nil)
    (list2set def-decl "set[T]" list2set nil)
    (filter def-decl "list[T]" filters nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (disjoint? const-decl "bool" sets nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (setof type-eq-decl nil defined_types nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (set type-eq-decl nil sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (null_proj_subset 0
  (null_proj_subset-1 nil 3417191621
   ("" (auto-rewrite "null_proj_equiv")
    (("" (skosimp)
      (("" (assert)
        (("" (auto-rewrite-theory "sets[T]") (("" (reduce) nil))))))))
    nil)
   ((disjoint? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (T formal-type-decl nil traces nil)
    (null_proj_equiv formula-decl nil traces nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil))
   nil))
 (null_proj_union 0
  (null_proj_union-1 nil 3417191621
   ("" (auto-rewrite "null_proj_equiv")
    (("" (skolem!)
      (("" (assert)
        (("" (auto-rewrite-theory "sets[T]") (("" (reduce) nil))))))))
    nil)
   ((disjoint? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (T formal-type-decl nil traces nil)
    (null_proj_equiv formula-decl nil traces nil))
   nil))
 (null_proj_prod 0
  (null_proj_prod-1 nil 3417191621
   ("" (auto-rewrite "null_proj_equiv")
    (("" (skosimp)
      (("" (assert)
        (("" (forward-chain "sigma_prod")
          (("" (replace*)
            (("" (delete -)
              (("" (auto-rewrite-theory "sets[T]")
                (("" (reduce) nil))))))))))))))
    nil)
   ((sigma_prod formula-decl nil traces nil)
    (T formal-type-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (disjoint? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (union const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (null_proj_equiv formula-decl nil traces nil))
   nil))
 (null_proj_prod1 0
  (null_proj_prod1-1 nil 3417191621
   ("" (skosimp) (("" (use "null_proj_prod") (("" (ground) nil)))) nil)
   ((null_proj_prod formula-decl nil traces nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil traces nil))
   nil))
 (null_proj_prod2 0
  (null_proj_prod2-1 nil 3417191621
   ("" (skosimp)
    (("" (rewrite "prod_commutes")
      (("" (forward-chain "null_proj_prod1") nil))))
    nil)
   ((prod_commutes formula-decl nil traces nil)
    (T formal-type-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (null_proj_prod1 formula-decl nil traces nil))
   nil))
 (null_proj_prod3 0
  (null_proj_prod3-1 nil 3417191621
   ("" (auto-rewrite "null_proj_equiv")
    (("" (skosimp)
      (("" (assert)
        (("" (forward-chain "sigma_prod_inter1")
          (("" (delete -2)
            (("" (auto-rewrite-theory "sets[T]")
              (("" (reduce)
                (("" (case "intersection(sigma(t!1), A!1)(x!1)")
                  (("1" (replace -2) (("1" (assert) nil)))
                   ("2" (assert) nil))))))))))))))))
    nil)
   ((sigma_prod_inter1 formula-decl nil traces nil)
    (T formal-type-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil) (set type-eq-decl nil sets nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (disjoint? const-decl "bool" sets nil)
    (null_proj_equiv formula-decl nil traces nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil))
   nil))
 (null_proj_prod4 0
  (null_proj_prod4-1 nil 3417191621
   ("" (skosimp)
    (("" (rewrite "prod_commutes")
      (("" (forward-chain "null_proj_prod3") nil))))
    nil)
   ((prod_commutes formula-decl nil traces nil)
    (T formal-type-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (null_proj_prod3 formula-decl nil traces nil))
   nil))
 (interleave_prod 0
  (interleave_prod-1 nil 3417191621
   ("" (induct "t2")
    (("1" (skosimp)
      (("1" (inst 1 "t1!1")
        (("1" (rewrite "prod_null3")
          (("1" (delete -2 2)
            (("1" (rewrite "null_proj_equiv") nil nil)) nil))
          nil))
        nil))
      nil)
     ("2" (skosimp*)
      (("2" (inst? -1)
        (("2" (assert)
          (("2" (rewrite "sigma_cons")
            (("2"
              (case "disjoint?(sigma(cons2_var!1), A!1) AND NOT A!1(cons1_var!1)")
              (("1" (flatten)
                (("1" (assert)
                  (("1" (skolem!)
                    (("1" (inst 2 "cons(cons1_var!1, t!1)")
                      (("1" (expand "prod" 2) (("1" (flatten) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (delete -1 -2 2)
                (("2" (split)
                  (("1" (grind :if-match nil :exclude "sigma")
                    (("1" (inst?)
                      (("1" (split)
                        (("1" (flatten) nil nil)
                         ("2" (propax) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind :if-match nil :exclude "sigma")
                    (("2" (inst?)
                      (("2" (split)
                        (("1" (flatten) nil nil)
                         ("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (member const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (sigma_cons formula-decl nil traces nil)
    (prod_null3 formula-decl nil traces nil)
    (null_proj_equiv formula-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (prod def-decl "bool" traces nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (disjoint? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (prod_add 0
  (prod_add-1 nil 3417191621
   ("" (skolem!)
    (("" (iff)
      (("" (split)
        (("1" (ground)
          (("1" (rewrite "prod_reverse3")
            (("1" (rewrite "reverse_add")
              (("1" (expand "prod" -2)
                (("1" (flatten)
                  (("1" (rewrite "prod_reverse3")
                    (("1"
                      (inst 1 "reverse(cdr(reverse(t1!1)))"
                       "reverse(cdr(reverse(t2!1)))")
                      (("1" (split)
                        (("1" (rewrite "reverse_cons" 1 :dir rl)
                          (("1" (replace -4 1 rl)
                            (("1"
                              (case "cons(car(reverse(t1!1)), cdr(reverse(t1!1))) = reverse(t1!1)")
                              (("1"
                                (replace -1 1)
                                (("1"
                                  (rewrite "reverse_reverse")
                                  nil
                                  nil))
                                nil)
                               ("2"
                                (lemma "list_cons_eta[T]")
                                (("2" (inst?) nil nil))
                                nil)
                               ("3" (propax) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (rewrite "reverse_cons" :dir rl)
                          (("2" (replace -5 1 rl)
                            (("2"
                              (case "cons(car(reverse(t2!1)), cdr(reverse(t2!1))) = reverse(t2!1)")
                              (("1"
                                (replace -1)
                                (("1"
                                  (rewrite "reverse_reverse")
                                  nil
                                  nil))
                                nil)
                               ("2"
                                (lemma "list_cons_eta[T]")
                                (("2" (inst?) nil nil))
                                nil)
                               ("3" (propax) nil nil))
                              nil))
                            nil))
                          nil)
                         ("3" (rewrite "reverse_reverse") nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (rewrite "prod_reverse3")
            (("2" (rewrite "reverse_add")
              (("2" (expand "prod" -1)
                (("2" (split)
                  (("1" (flatten)
                    (("1" (rewrite "prod_reverse3")
                      (("1" (inst 2 "reverse(cdr(reverse(t1!1)))")
                        (("1" (delete 3)
                          (("1" (split)
                            (("1" (rewrite "reverse_cons" 1 :dir rl)
                              (("1"
                                (replace -2 1 rl)
                                (("1"
                                  (case
                                   "cons(car(reverse(t1!1)), cdr(reverse(t1!1))) = reverse(t1!1)")
                                  (("1"
                                    (replace -1 1)
                                    (("1"
                                      (rewrite "reverse_reverse")
                                      nil
                                      nil))
                                    nil)
                                   ("2"
                                    (lemma "list_cons_eta[T]")
                                    (("2" (inst?) nil nil))
                                    nil)
                                   ("3" (propax) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (rewrite "reverse_reverse")
                              (("2"
                                (rewrite "reverse_reverse")
                                nil
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (rewrite "prod_reverse3")
                      (("2" (delete 2)
                        (("2" (inst 2 "reverse(cdr(reverse(t2!1)))")
                          (("2" (split)
                            (("1" (rewrite "reverse_cons" 1 :dir rl)
                              (("1"
                                (replace -2 1 rl)
                                (("1"
                                  (case
                                   "cons(car(reverse(t2!1)), cdr(reverse(t2!1))) = reverse(t2!1)")
                                  (("1"
                                    (replace -1)
                                    (("1"
                                      (rewrite "reverse_reverse")
                                      nil
                                      nil))
                                    nil)
                                   ("2"
                                    (lemma "list_cons_eta[T]")
                                    (("2" (inst?) nil nil))
                                    nil)
                                   ("3" (propax) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (rewrite "reverse_reverse")
                              (("2"
                                (rewrite "reverse_reverse")
                                nil
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (ground)
          (("1" (skosimp)
            (("1" (replace -2)
              (("1" (replace -3)
                (("1" (delete -2 -3)
                  (("1" (rewrite "prod_reverse3")
                    (("1" (rewrite "prod_reverse3" 1)
                      (("1" (rewrite "reverse_add")
                        (("1" (rewrite "reverse_add")
                          (("1" (rewrite "reverse_add")
                            (("1" (expand "prod" 1)
                              (("1" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (skosimp)
            (("2" (replace -1)
              (("2" (delete -1)
                (("2" (rewrite "prod_reverse3")
                  (("2" (rewrite "prod_reverse3" 2)
                    (("2" (rewrite "reverse_add")
                      (("2" (rewrite "reverse_add")
                        (("2" (expand "prod" 2)
                          (("2" (flatten) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (skosimp)
            (("3" (replace -1)
              (("3" (delete -1)
                (("3" (rewrite "prod_reverse3")
                  (("3" (rewrite "prod_reverse3" 2)
                    (("3" (rewrite "reverse_add")
                      (("3" (rewrite "reverse_add")
                        (("3" (expand "prod" 2)
                          (("3" (flatten) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((reverse_add formula-decl nil more_list_props nil)
    (reverse_cons formula-decl nil more_list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (reverse_reverse formula-decl nil list_props nil)
    (list_cons_eta formula-decl nil list_adt nil)
    (reverse def-decl "list[T]" list_props nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (prod def-decl "bool" traces nil)
    (add const-decl "(cons?[T])" more_list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil traces nil)
    (prod_reverse3 formula-decl nil traces nil))
   nil))
 (every_prod 0
  (every_prod-1 nil 3417191621
   ("" (induct "t")
    (("1" (skosimp) (("1" (expand "prod") (("1" (grind) nil nil)) nil))
      nil)
     ("2" (skosimp*)
      (("2" (inst -1 "A!1" "B!1" "_" "_")
        (("2" (expand "prod" -2)
          (("2" (split)
            (("1" (flatten)
              (("1" (expand "every" -8)
                (("1" (flatten)
                  (("1" (use "list_cons_eta[T]")
                    (("1" (replace -1 1 rl)
                      (("1" (expand "every" 1)
                        (("1" (replace -5)
                          (("1" (assert)
                            (("1" (inst?) (("1" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (split)
                (("1" (flatten)
                  (("1" (expand "every" -5)
                    (("1" (flatten)
                      (("1" (use "list_cons_eta[T]")
                        (("1" (replace -1 2 rl)
                          (("1" (expand "every" 2)
                            (("1" (replace -3)
                              (("1"
                                (assert)
                                (("1"
                                  (inst?)
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "every" -5)
                    (("2" (flatten)
                      (("2" (inst?) (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list_cons_eta formula-decl nil list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil traces nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (prod def-decl "bool" traces nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil)))

