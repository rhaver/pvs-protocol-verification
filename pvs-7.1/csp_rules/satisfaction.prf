(satisfaction
 (sat_idempotent 0
  (sat_idempotent-1 nil 3417191620
   ("" (skolem!) (("" (grind) nil nil)) nil)
   ((subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (\|> const-decl "bool" satisfaction nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil))
   nil))
 (sat_transitive1 0
  (sat_transitive1-1 nil 3417191620
   ("" (skosimp) (("" (grind) nil nil)) nil)
   ((subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (\|> const-decl "bool" satisfaction nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil satisfaction nil))
   nil))
 (sat_transitive2 0
  (sat_transitive2-1 nil 3417191620
   ("" (skosimp) (("" (grind) nil nil)) nil)
   ((subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (\|> const-decl "bool" satisfaction nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil satisfaction nil))
   nil))
 (sat_choice1 0
  (sat_choice1-1 nil 3417191620
   ("" (skolem!) (("" (grind) nil nil)) nil)
   ((T formal-type-decl nil satisfaction nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (\\/ const-decl "process" processes nil)
    (member const-decl "bool" sets nil)
    (union const-decl "set" sets nil)
    (subset? const-decl "bool" sets nil)
    (\|> const-decl "bool" satisfaction nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil))
   nil))
 (sat_choice2 0
  (sat_choice2-1 nil 3417192542
   ("" (grind :exclude ("prefix_closed") :if-match nil)
    (("1" (inst?) (("1" (ground) (("1" (inst + "P!1") nil)))))
     ("2" (inst?) (("2" (assert) nil)))
     ("3" (inst?) (("3" (assert) nil)))
     ("4" (inst - "P!1" "x!1") (("4" (assert) nil))))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-type-decl nil satisfaction nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (set type-eq-decl nil sets nil)
    (Stop const-decl "process" processes nil)
    (\|> const-decl "bool" satisfaction nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (Choice const-decl "process" processes nil))
   nil))
 (sat_free_par1 0
  (sat_free_par1-1 nil 3417191620
   ("" (skosimp)
    (("" (use "interleaves_subset1[T]")
      (("" (rewrite "|>" :dir rl)
        (("" (forward-chain "sat_transitive1") nil nil)) nil))
      nil))
    nil)
   ((interleaves_subset1 formula-decl nil process_rules nil)
    (T formal-type-decl nil satisfaction nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (sat_transitive1 formula-decl nil satisfaction nil)
    (// const-decl "process" processes nil)
    (pred type-eq-decl nil defined_types nil)
    (\|> const-decl "bool" satisfaction nil))
   nil))
 (sat_free_par2 0
  (sat_free_par2-1 nil 3417191620
   ("" (skosimp)
    (("" (use "interleaves_subset2[T]")
      (("" (rewrite "|>" :dir rl)
        (("" (forward-chain "sat_transitive1") nil nil)) nil))
      nil))
    nil)
   ((interleaves_subset2 formula-decl nil process_rules nil)
    (T formal-type-decl nil satisfaction nil)
    (process type-eq-decl nil processes nil)
    (prefix_closed const-decl "bool" processes nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (sat_transitive1 formula-decl nil satisfaction nil)
    (// const-decl "process" processes nil)
    (pred type-eq-decl nil defined_types nil)
    (\|> const-decl "bool" satisfaction nil))
   nil))
 (sat_par_fullset 0
  (sat_par_fullset-1 nil 3417191620
   ("" (skosimp)
    (("" (rewrite "par_full")
      (("" (expand "|>") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((par_full formula-decl nil process_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (T formal-type-decl nil satisfaction nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (\|> const-decl "bool" satisfaction nil))
   nil))
 (sat_par_fullset2 0
  (sat_par_fullset2-1 nil 3417191620
   ("" (skosimp)
    (("" (rewrite "par_full")
      (("" (expand "|>") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((par_full formula-decl nil process_rules nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (setof type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (prefix_closed const-decl "bool" processes nil)
    (process type-eq-decl nil processes nil)
    (T formal-type-decl nil satisfaction nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (\|> const-decl "bool" satisfaction nil))
   nil)))

