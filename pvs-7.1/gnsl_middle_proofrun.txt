Starting pvs-allegro -qq ...
International Allegro CL Enterprise Edition
10.1 [64-bit Linux (x86-64)] (Nov 14, 2020 18:29)
Copyright (C) 1985-2017, Franz Inc., Oakland, CA, USA.  All Rights Reserved.

This dynamic runtime copy of Allegro CL was built by:
   [TC21720] SRI International

;; Optimization settings: safety 1, space 1, speed 3, debug 1.
;; For a complete description of all compiler switches given the
;; current optimization settings evaluate (explain-compiler-settings).
;;---
;; Current reader case mode: :case-sensitive-lower

pvs(1): 
pvs(2): 
Defining stop. 
Defining stop$. 
Defining choice. 
Defining choice$. 
Defining choice2. 
Defining choice2$. 
Defining choice3. 
Defining choice3$. 
Defining prefix. 
Defining prefix$. 
Defining interleaving. 
Defining interleaving$. 
Defining interleaving2. 
Defining interleaving2$. 
Defining parallel. 
Defining parallel$. 
Defining parallel2. 
Defining parallel2$. 
Defining fix1. 
Defining fix1$. 
Defining fix2. 
Defining fix2$. 
Defining run. 
Defining run$. 
Defining mdecompose-equality. 
Defining mdecompose-equality$. 
Defining mdec-eq-last. 
Defining mdec-eq-last$. 
Defining grind-dec-eq. 
Defining grind-dec-eq$. 
stop exists as a defined rule.
Redefining stop. 
stop$ exists as a strategy.
Redefining stop$. 
choice exists as a defined rule.
Redefining choice. 
choice$ exists as a strategy.
Redefining choice$. 
choice2 exists as a defined rule.
Redefining choice2. 
choice2$ exists as a strategy.
Redefining choice2$. 
choice3 exists as a defined rule.
Redefining choice3. 
choice3$ exists as a strategy.
Redefining choice3$. 
Warning: |(defstep) prefix|, :operator was defined in
         /home/ubuntu/Desktop/csp_rules/pvs-strategies and is now being
         defined in /home/ubuntu/Desktop/gnsl/pvs-strategies

prefix exists as a defined rule.
Redefining prefix. 
prefix$ exists as a strategy.
Redefining prefix$. 
Defining prefix2. 
Defining prefix2$. 
interleaving exists as a defined rule.
Redefining interleaving. 
interleaving$ exists as a strategy.
Redefining interleaving$. 
interleaving2 exists as a defined rule.
Redefining interleaving2. 
interleaving2$ exists as a strategy.
Redefining interleaving2$. 
parallel exists as a defined rule.
Redefining parallel. 
parallel$ exists as a strategy.
Redefining parallel$. 
parallel2 exists as a defined rule.
Redefining parallel2. 
parallel2$ exists as a strategy.
Redefining parallel2$. 
fix1 exists as a defined rule.
Redefining fix1. 
fix1$ exists as a strategy.
Redefining fix1$. 
fix2 exists as a defined rule.
Redefining fix2. 
fix2$ exists as a strategy.
Redefining fix2$. 
Warning: |(defstep) run|, :operator was defined in
         /home/ubuntu/Desktop/csp_rules/pvs-strategies and is now being
         defined in /home/ubuntu/Desktop/gnsl/pvs-strategies

run exists as a defined rule.
Redefining run. 
run$ exists as a strategy.
Redefining run$. 
mdecompose-equality exists as a defined rule.
Redefining mdecompose-equality. 
mdecompose-equality$ exists as a strategy.
Redefining mdecompose-equality$. 
Warning: |(defstep) mdec-eq-last|, :operator was defined in
         /home/ubuntu/Desktop/csp_rules/pvs-strategies and is now being
         defined in /home/ubuntu/Desktop/gnsl/pvs-strategies

mdec-eq-last exists as a defined rule.
Redefining mdec-eq-last. 
mdec-eq-last$ exists as a strategy.
Redefining mdec-eq-last$. 
grind-dec-eq exists as a defined rule.
Redefining grind-dec-eq. 
grind-dec-eq$ exists as a strategy.
Redefining grind-dec-eq$. 
Defining nonemptylist. 
Defining nonemptylist$. 
stop exists as a defined rule.
Redefining stop. 
stop$ exists as a strategy.
Redefining stop$. 
choice exists as a defined rule.
Redefining choice. 
choice$ exists as a strategy.
Redefining choice$. 
choice2 exists as a defined rule.
Redefining choice2. 
choice2$ exists as a strategy.
Redefining choice2$. 
choice3 exists as a defined rule.
Redefining choice3. 
choice3$ exists as a strategy.
Redefining choice3$. 
prefix exists as a defined rule.
Redefining prefix. 
prefix$ exists as a strategy.
Redefining prefix$. 
prefix2 exists as a defined rule.
Redefining prefix2. 
prefix2$ exists as a strategy.
Redefining prefix2$. 
interleaving exists as a defined rule.
Redefining interleaving. 
interleaving$ exists as a strategy.
Redefining interleaving$. 
interleaving2 exists as a defined rule.
Redefining interleaving2. 
interleaving2$ exists as a strategy.
Redefining interleaving2$. 
parallel exists as a defined rule.
Redefining parallel. 
parallel$ exists as a strategy.
Redefining parallel$. 
parallel2 exists as a defined rule.
Redefining parallel2. 
parallel2$ exists as a strategy.
Redefining parallel2$. 
fix1 exists as a defined rule.
Redefining fix1. 
fix1$ exists as a strategy.
Redefining fix1$. 
fix2 exists as a defined rule.
Redefining fix2. 
fix2$ exists as a strategy.
Redefining fix2$. 
run exists as a defined rule.
Redefining run. 
run$ exists as a strategy.
Redefining run$. 
mdecompose-equality exists as a defined rule.
Redefining mdecompose-equality. 
mdecompose-equality$ exists as a strategy.
Redefining mdecompose-equality$. 
mdec-eq-last exists as a defined rule.
Redefining mdec-eq-last. 
mdec-eq-last$ exists as a strategy.
Redefining mdec-eq-last$. 
grind-dec-eq exists as a defined rule.
Redefining grind-dec-eq. 
grind-dec-eq$ exists as a strategy.
Redefining grind-dec-eq$. 
nonemptylist exists as a defined rule.
Redefining nonemptylist. 
nonemptylist$ exists as a strategy.
Redefining nonemptylist$. 
Installing rewrite rule sets.singleton_rew (all instances)
n_prop :  

  |-------
{1}   FORALL (P: nat_from_2, u: Identity, r: Role):
        (P /= p OR r /= mid) =>
         NOT pt[[nat_from_2, Identity, Role], Nonce](P, u, r)(n_mid)

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
n_prop :  

{-1}  2 <= P!1
{-2}  u!1 >= 0
{-3}  r!1 >= 0
  |-------
{1}   (P!1 /= p OR r!1 /= mid) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, r!1)(n_mid)

Rerunning step: (typepred "n_mid")
Adding type constraints for  n_mid,
this simplifies to: 
n_prop :  

{-1}  IRpart(p, hu(mid), mid)(n_mid)
[-2]  2 <= P!1
[-3]  u!1 >= 0
[-4]  r!1 >= 0
  |-------
[1]   (P!1 /= p OR r!1 /= mid) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, r!1)(n_mid)

Rerunning step: (typepred "pt[[nat_from_2, Identity, Role], Nonce]")
Adding type constraints for  pt[[nat_from_2, Identity, Role], Nonce],
this simplifies to: 
n_prop :  

{-1}  FORALL (i: [nat_from_2, Identity, Role]),
             (j: [nat_from_2, Identity, Role]), (n: Nonce):
        i /= j AND pt[[nat_from_2, Identity, Role], Nonce](i)(n) =>
         NOT pt[[nat_from_2, Identity, Role], Nonce](j)(n)
{-2}  FORALL (i: [nat_from_2, Identity, Role]):
        EXISTS (n: Nonce): pt[[nat_from_2, Identity, Role], Nonce](i)(n)
[-3]  IRpart(p, hu(mid), mid)(n_mid)
[-4]  2 <= P!1
[-5]  u!1 >= 0
[-6]  r!1 >= 0
  |-------
[1]   (P!1 /= p OR r!1 /= mid) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, r!1)(n_mid)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
n_prop :  

[-1]  FORALL (i: [nat_from_2, Identity, Role]),
             (j: [nat_from_2, Identity, Role]), (n: Nonce):
        i /= j AND pt[[nat_from_2, Identity, Role], Nonce](i)(n) =>
         NOT pt[[nat_from_2, Identity, Role], Nonce](j)(n)
[-2]  IRpart(p, hu(mid), mid)(n_mid)
[-3]  2 <= P!1
[-4]  u!1 >= 0
[-5]  r!1 >= 0
  |-------
[1]   (P!1 /= p OR r!1 /= mid) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, r!1)(n_mid)

Rerunning step: (inst -1 "(P!1, u!1, r!1)" "(p, hu(mid), mid)" "n_mid")
Instantiating the top quantifier in -1 with the terms: 
 (P!1, u!1, r!1), (p, hu(mid), mid), n_mid,
this simplifies to: 
n_prop :  

{-1}  (P!1, u!1, r!1) /= (p, hu(mid), mid) AND
       pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, r!1)(n_mid)
       =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](p, hu(mid), mid)(n_mid)
[-2]  IRpart(p, hu(mid), mid)(n_mid)
[-3]  2 <= P!1
[-4]  u!1 >= 0
[-5]  r!1 >= 0
  |-------
[1]   (P!1 /= p OR r!1 /= mid) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, r!1)(n_mid)

Rerunning step: (grind)
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
/= rewrites P!1 /= p
  to NOT (P!1 = p)
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
/= rewrites r!1 /= mid
  to NOT (r!1 = mid)
Trying repeated skolemization, instantiation, and if-lifting,
Q.E.D.


Run time  = 0.16 secs.
Real time = 0.48 secs.
nil
pvs(22): 
Installing rewrite rule sets.singleton_rew (all instances)
n_orig :  

  |-------
{1}   FORALL (P: nat_from_2, u: Identity, r: nat):
        IRpart(P, u, r)(n_mid) => (P = p AND u = hu(mid) AND r = mid)

Rerunning step: (skosimp)
Skolemizing and flattening,
this simplifies to: 
n_orig :  

{-1}  IRpart(P!1, u!1, r!1)(n_mid)
  |-------
{1}   (P!1 = p AND u!1 = hu(mid) AND r!1 = mid)

Rerunning step: (typepred "pt[[nat_from_2, Identity, Role], Nonce]"
                 "n_mid")
Adding type constraints for  pt[[nat_from_2, Identity, Role],
                                Nonce], n_mid,
this simplifies to: 
n_orig :  

{-1}  FORALL (i: [nat_from_2, Identity, Role]),
             (j: [nat_from_2, Identity, Role]), (n: Nonce):
        i /= j AND pt[[nat_from_2, Identity, Role], Nonce](i)(n) =>
         NOT pt[[nat_from_2, Identity, Role], Nonce](j)(n)
{-2}  FORALL (i: [nat_from_2, Identity, Role]):
        EXISTS (n: Nonce): pt[[nat_from_2, Identity, Role], Nonce](i)(n)
{-3}  IRpart(p, hu(mid), mid)(n_mid)
[-4]  IRpart(P!1, u!1, r!1)(n_mid)
  |-------
[1]   (P!1 = p AND u!1 = hu(mid) AND r!1 = mid)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
n_orig :  

[-1]  FORALL (i: [nat_from_2, Identity, Role]),
             (j: [nat_from_2, Identity, Role]), (n: Nonce):
        i /= j AND pt[[nat_from_2, Identity, Role], Nonce](i)(n) =>
         NOT pt[[nat_from_2, Identity, Role], Nonce](j)(n)
[-2]  IRpart(p, hu(mid), mid)(n_mid)
[-3]  IRpart(P!1, u!1, r!1)(n_mid)
  |-------
[1]   (P!1 = p AND u!1 = hu(mid) AND r!1 = mid)

Rerunning step: (inst -1 "(P!1, u!1, r!1)" "(p, hu(mid), mid)" "n_mid")
Instantiating the top quantifier in -1 with the terms: 
 (P!1, u!1, r!1), (p, hu(mid), mid), n_mid,
this simplifies to: 
n_orig :  

{-1}  (P!1, u!1, r!1) /= (p, hu(mid), mid) AND
       pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, r!1)(n_mid)
       =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](p, hu(mid), mid)(n_mid)
[-2]  IRpart(p, hu(mid), mid)(n_mid)
[-3]  IRpart(P!1, u!1, r!1)(n_mid)
  |-------
[1]   (P!1 = p AND u!1 = hu(mid) AND r!1 = mid)

Rerunning step: (expand "IRpart")
Expanding the definition of IRpart,
this simplifies to: 
n_orig :  

[-1]  (P!1, u!1, r!1) /= (p, hu(mid), mid) AND
       pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, r!1)(n_mid)
       =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](p, hu(mid), mid)(n_mid)
{-2}  pt[[nat_from_2, Identity, Role], Nonce](p, hu(mid), mid)(n_mid)
{-3}  pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, r!1)(n_mid)
  |-------
[1]   (P!1 = p AND u!1 = hu(mid) AND r!1 = mid)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,
Q.E.D.


Run time  = 0.07 secs.
Real time = 0.18 secs.
nil
pvs(27): 
Installing rewrite rule sets.singleton_rew (all instances)
select_right_nonce1 :  

  |-------
{1}   FORALL (P: nat_from_2):
        (P = p IMPLIES floor(((mid - 1) / (p - 2)) * (P - 2)) = mid - 1)
         AND
         floor(((mid - 1) / (p - 2)) * (P - 2)) >= 0 AND
          floor(((mid - 1) / (p - 2)) * (P - 2)) < P - 1

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
select_right_nonce1 :  

  |-------
{1}   (P!1 = p IMPLIES floor(((mid - 1) / (p - 2)) * (P!1 - 2)) = mid - 1)
       AND
       floor(((mid - 1) / (p - 2)) * (P!1 - 2)) >= 0 AND
        floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1

Rerunning step: (typepred "P!1" "p" "mid")
Adding type constraints for  P!1, p, mid,
this simplifies to: 
select_right_nonce1 :  

{-1}  2 <= P!1
{-2}  3 <= p
{-3}  0 < mid
{-4}  mid < p - 1
  |-------
[1]   (P!1 = p IMPLIES floor(((mid - 1) / (p - 2)) * (P!1 - 2)) = mid - 1)
       AND
       floor(((mid - 1) / (p - 2)) * (P!1 - 2)) >= 0 AND
        floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1

Rerunning step: (prop)
Applying propositional simplification,
this yields  3 subgoals: 
select_right_nonce1.1 :  

{-1}  P!1 = p
[-2]  2 <= P!1
[-3]  3 <= p
[-4]  0 < mid
[-5]  mid < p - 1
  |-------
{1}   floor(((mid - 1) / (p - 2)) * (P!1 - 2)) = mid - 1

Rerunning step: (replace* -1)
Repeatedly applying the replace rule,
this simplifies to: 
select_right_nonce1.1 :  

[-1]  P!1 = p
{-2}  2 <= p
[-3]  3 <= p
[-4]  0 < mid
[-5]  mid < p - 1
  |-------
{1}   floor(((mid - 1) / (p - 2)) * (p - 2)) = mid - 1

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
select_right_nonce1.1 :  

[-1]  2 <= p
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
[1]   floor(((mid - 1) / (p - 2)) * (p - 2)) = mid - 1

Rerunning step: (rewrite "div_cancel2")
Found matching substitution:
n0z: nonzero_real gets (p - 2),
x: real gets (mid - 1),
Rewriting using div_cancel2, matching in *,
this simplifies to: 
select_right_nonce1.1 :  

[-1]  2 <= p
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
{1}   floor((mid - 1)) = mid - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of select_right_nonce1.1.

select_right_nonce1.2 :  

[-1]  2 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
{1}   floor(((mid - 1) / (p - 2)) * (P!1 - 2)) >= 0

Rerunning step: (case "((mid-1)/(p-2))*(P!1-2)>=0")
Case splitting on 
   ((mid - 1) / (p - 2)) * (P!1 - 2) >= 0, 
this yields  2 subgoals: 
select_right_nonce1.2.1 :  

{-1}  ((mid - 1) / (p - 2)) * (P!1 - 2) >= 0
[-2]  2 <= P!1
[-3]  3 <= p
[-4]  0 < mid
[-5]  mid < p - 1
  |-------
[1]   floor(((mid - 1) / (p - 2)) * (P!1 - 2)) >= 0

Rerunning step: (rewrite "nonneg_floor_is_nat")
Found matching substitution:
x: nonneg_real gets ((mid - 1) / (p - 2)) * (P!1 - 2),
Rewriting using nonneg_floor_is_nat, matching in *,

This completes the proof of select_right_nonce1.2.1.

select_right_nonce1.2.2 :  

[-1]  2 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
{1}   ((mid - 1) / (p - 2)) * (P!1 - 2) >= 0
[2]   floor(((mid - 1) / (p - 2)) * (P!1 - 2)) >= 0

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
select_right_nonce1.2.2 :  

[-1]  2 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
[1]   ((mid - 1) / (p - 2)) * (P!1 - 2) >= 0

Rerunning step: (lemma "pos_times_le" ("x" "(mid-1)/(p-2)" "y" "P!1-2"))
Applying pos_times_le where 
  x gets (mid - 1) / (p - 2),
  y gets P!1 - 2,
this simplifies to: 
select_right_nonce1.2.2 :  

{-1}  0 <= (mid - 1) / (p - 2) * (P!1 - 2) IFF
       (0 <= (mid - 1) / (p - 2) AND 0 <= P!1 - 2) OR
        ((mid - 1) / (p - 2) <= 0 AND P!1 - 2 <= 0)
[-2]  2 <= P!1
[-3]  3 <= p
[-4]  0 < mid
[-5]  mid < p - 1
  |-------
[1]   ((mid - 1) / (p - 2)) * (P!1 - 2) >= 0

Rerunning step: (ground)
Applying propositional simplification and decision procedures,
this simplifies to: 
select_right_nonce1.2.2 :  

[-1]  2 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
{1}   P!1 - 2 <= 0
{2}   0 <= (mid - 1) / (p - 2)
{3}   0 <= (mid - 1) / (p - 2) * P!1 - 2 * ((mid - 1) / (p - 2))
{4}   ((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2)) >= 0

Rerunning step: (delete 1 3 4)
Deleting some formulas,
this simplifies to: 
select_right_nonce1.2.2 :  

[-1]  2 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
[1]   0 <= (mid - 1) / (p - 2)

Rerunning step: (rewrite "div_mult_pos_le2")
Found matching substitution:
py: posreal gets (p - 2),
z: real gets (mid - 1),
x: real gets 0,
Rewriting using div_mult_pos_le2, matching in *,

This completes the proof of select_right_nonce1.2.2.


This completes the proof of select_right_nonce1.2.

select_right_nonce1.3 :  

[-1]  2 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
{1}   floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1

Rerunning step: (case "P!1=2")
Case splitting on 
   P!1 = 2, 
this yields  2 subgoals: 
select_right_nonce1.3.1 :  

{-1}  P!1 = 2
[-2]  2 <= P!1
[-3]  3 <= p
[-4]  0 < mid
[-5]  mid < p - 1
  |-------
[1]   floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1

Rerunning step: (replace* -1)
Repeatedly applying the replace rule,
this simplifies to: 
select_right_nonce1.3.1 :  

[-1]  P!1 = 2
{-2}  2 <= 2
[-3]  3 <= p
[-4]  0 < mid
[-5]  mid < p - 1
  |-------
{1}   floor(((mid - 1) / (p - 2)) * (2 - 2)) < 2 - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of select_right_nonce1.3.1.

select_right_nonce1.3.2 :  

[-1]  2 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
{1}   P!1 = 2
[2]   floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1

Rerunning step: (typepred "floor(((mid-1)/(p-2))*(P!1-2))")
Adding type constraints for  floor(((mid - 1) / (p - 2)) * (P!1 - 2)),
this simplifies to: 
select_right_nonce1.3.2 :  

{-1}  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) <=
       ((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))
{-2}  ((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2)) <
       1 + floor(((mid - 1) / (p - 2)) * (P!1 - 2))
[-3]  2 <= P!1
[-4]  3 <= p
[-5]  0 < mid
[-6]  mid < p - 1
  |-------
[1]   P!1 = 2
[2]   floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1

Rerunning step: (case "((mid-1)/(p-2))*(P!1-2) < P!1-1")
Case splitting on 
   ((mid - 1) / (p - 2)) * (P!1 - 2) < P!1 - 1, 
this yields  2 subgoals: 
select_right_nonce1.3.2.1 :  

{-1}  ((mid - 1) / (p - 2)) * (P!1 - 2) < P!1 - 1
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) <=
       ((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))
[-3]  ((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2)) <
       1 + floor(((mid - 1) / (p - 2)) * (P!1 - 2))
[-4]  2 <= P!1
[-5]  3 <= p
[-6]  0 < mid
[-7]  mid < p - 1
  |-------
[1]   P!1 = 2
[2]   floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
select_right_nonce1.3.2.1 :  

[-1]  ((mid - 1) / (p - 2)) * (P!1 - 2) < P!1 - 1
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) <=
       ((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))
[-3]  2 <= P!1
[-4]  3 <= p
[-5]  0 < mid
[-6]  mid < p - 1
  |-------
[1]   P!1 = 2
[2]   floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of select_right_nonce1.3.2.1.

select_right_nonce1.3.2.2 :  

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) <=
       ((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))
[-2]  ((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2)) <
       1 + floor(((mid - 1) / (p - 2)) * (P!1 - 2))
[-3]  2 <= P!1
[-4]  3 <= p
[-5]  0 < mid
[-6]  mid < p - 1
  |-------
{1}   ((mid - 1) / (p - 2)) * (P!1 - 2) < P!1 - 1
[2]   P!1 = 2
[3]   floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1

Rerunning step: (delete -1 -2 3)
Deleting some formulas,
this simplifies to: 
select_right_nonce1.3.2.2 :  

[-1]  2 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
[1]   ((mid - 1) / (p - 2)) * (P!1 - 2) < P!1 - 1
[2]   P!1 = 2

Rerunning step: (case "((mid-1)/(p-2))*(P!1-2) < P!1-2")
Case splitting on 
   ((mid - 1) / (p - 2)) * (P!1 - 2) < P!1 - 2, 
this yields  2 subgoals: 
select_right_nonce1.3.2.2.1 :  

{-1}  ((mid - 1) / (p - 2)) * (P!1 - 2) < P!1 - 2
[-2]  2 <= P!1
[-3]  3 <= p
[-4]  0 < mid
[-5]  mid < p - 1
  |-------
[1]   ((mid - 1) / (p - 2)) * (P!1 - 2) < P!1 - 1
[2]   P!1 = 2

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of select_right_nonce1.3.2.2.1.

select_right_nonce1.3.2.2.2 :  

[-1]  2 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
{1}   ((mid - 1) / (p - 2)) * (P!1 - 2) < P!1 - 2
[2]   ((mid - 1) / (p - 2)) * (P!1 - 2) < P!1 - 1
[3]   P!1 = 2

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
select_right_nonce1.3.2.2.2 :  

[-1]  2 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
[1]   ((mid - 1) / (p - 2)) * (P!1 - 2) < P!1 - 2
[2]   P!1 = 2

Rerunning step: (rewrite "div_mult_pos_lt2" :dir rl)
Found matching substitution:
z: real gets P!1 - 2,
py: posreal gets (P!1 - 2),
x: real gets ((mid - 1) / (p - 2)),
Rewriting using div_mult_pos_lt2, matching in *,
this simplifies to: 
select_right_nonce1.3.2.2.2 :  

[-1]  2 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
{1}   ((mid - 1) / (p - 2)) < (P!1 - 2) / (P!1 - 2)
[2]   P!1 = 2

Rerunning step: (rewrite "div_simp")
Found matching substitution:
n0x: nonzero_real gets P!1 - 2,
Rewriting using div_simp, matching in *,
this simplifies to: 
select_right_nonce1.3.2.2.2 :  

[-1]  2 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
{1}   ((mid - 1) / (p - 2)) < 1
[2]   P!1 = 2

Rerunning step: (rewrite "div_mult_pos_lt1")
Found matching substitution:
x: real gets 1,
py: posreal gets (p - 2),
z: real gets (mid - 1),
Rewriting using div_mult_pos_lt1, matching in *,

This completes the proof of select_right_nonce1.3.2.2.2.


This completes the proof of select_right_nonce1.3.2.2.


This completes the proof of select_right_nonce1.3.2.


This completes the proof of select_right_nonce1.3.

Q.E.D.


Run time  = 0.54 secs.
Real time = 0.75 secs.
nil
pvs(32): 
Installing rewrite rule sets.singleton_rew (all instances)
select_right_nonce2 :  

  |-------
{1}   FORALL (P: nat_from_3):
        (P = p IMPLIES floor(((mid - 1) / (p - 2)) * (P - 2) + 1) = mid)
         AND
         floor(((mid - 1) / (p - 2)) * (P - 2) + 1) >= 1 AND
          floor(((mid - 1) / (p - 2)) * (P - 2) + 1) < P - 1

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
select_right_nonce2 :  

  |-------
{1}   (P!1 = p IMPLIES floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid)
       AND
       floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1 AND
        floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1

Rerunning step: (typepred "P!1" "p" "mid")
Adding type constraints for  P!1, p, mid,
this simplifies to: 
select_right_nonce2 :  

{-1}  3 <= P!1
{-2}  3 <= p
{-3}  0 < mid
{-4}  mid < p - 1
  |-------
[1]   (P!1 = p IMPLIES floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid)
       AND
       floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1 AND
        floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1

Rerunning step: (prop)
Applying propositional simplification,
this yields  3 subgoals: 
select_right_nonce2.1 :  

{-1}  P!1 = p
[-2]  3 <= P!1
[-3]  3 <= p
[-4]  0 < mid
[-5]  mid < p - 1
  |-------
{1}   floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid

Rerunning step: (replace* -1)
Repeatedly applying the replace rule,
this simplifies to: 
select_right_nonce2.1 :  

[-1]  P!1 = p
{-2}  3 <= p
[-3]  3 <= p
[-4]  0 < mid
[-5]  mid < p - 1
  |-------
{1}   floor(((mid - 1) / (p - 2)) * (p - 2) + 1) = mid

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
select_right_nonce2.1 :  

[-1]  3 <= p
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
[1]   floor(((mid - 1) / (p - 2)) * (p - 2) + 1) = mid

Rerunning step: (rewrite "div_cancel2")
Found matching substitution:
n0z: nonzero_real gets (p - 2),
x: real gets (mid - 1),
Rewriting using div_cancel2, matching in *,
this simplifies to: 
select_right_nonce2.1 :  

[-1]  3 <= p
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
{1}   floor((mid - 1) + 1) = mid

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of select_right_nonce2.1.

select_right_nonce2.2 :  

[-1]  3 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
{1}   floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1

Rerunning step: (case "((mid - 1) / (p - 2)) * (P!1 - 2) >= 0")
Case splitting on 
   ((mid - 1) / (p - 2)) * (P!1 - 2) >= 0, 
this yields  2 subgoals: 
select_right_nonce2.2.1 :  

{-1}  ((mid - 1) / (p - 2)) * (P!1 - 2) >= 0
[-2]  3 <= P!1
[-3]  3 <= p
[-4]  0 < mid
[-5]  mid < p - 1
  |-------
[1]   floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1

Rerunning step: (rewrite "floor_plus_int")
Found matching substitution:
i: integer gets 1,
x: real gets ((mid - 1) / (p - 2)) * (P!1 - 2),
Rewriting using floor_plus_int, matching in *,
this simplifies to: 
select_right_nonce2.2.1 :  

[-1]  ((mid - 1) / (p - 2)) * (P!1 - 2) >= 0
[-2]  3 <= P!1
[-3]  3 <= p
[-4]  0 < mid
[-5]  mid < p - 1
  |-------
{1}   1 + floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >=
       1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of select_right_nonce2.2.1.

select_right_nonce2.2.2 :  

[-1]  3 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
{1}   ((mid - 1) / (p - 2)) * (P!1 - 2) >= 0
[2]   floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
select_right_nonce2.2.2 :  

[-1]  3 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
[1]   ((mid - 1) / (p - 2)) * (P!1 - 2) >= 0

Rerunning step: (lemma "pos_times_le" ("x" "(mid-1)/(p-2)" "y" "P!1-2"))
Applying pos_times_le where 
  x gets (mid - 1) / (p - 2),
  y gets P!1 - 2,
this simplifies to: 
select_right_nonce2.2.2 :  

{-1}  0 <= (mid - 1) / (p - 2) * (P!1 - 2) IFF
       (0 <= (mid - 1) / (p - 2) AND 0 <= P!1 - 2) OR
        ((mid - 1) / (p - 2) <= 0 AND P!1 - 2 <= 0)
[-2]  3 <= P!1
[-3]  3 <= p
[-4]  0 < mid
[-5]  mid < p - 1
  |-------
[1]   ((mid - 1) / (p - 2)) * (P!1 - 2) >= 0

Rerunning step: (ground)
Applying propositional simplification and decision procedures,
this simplifies to: 
select_right_nonce2.2.2 :  

[-1]  3 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
{1}   P!1 - 2 <= 0
{2}   0 <= (mid - 1) / (p - 2)
{3}   0 <= (mid - 1) / (p - 2) * P!1 - 2 * ((mid - 1) / (p - 2))
{4}   ((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2)) >= 0

Rerunning step: (delete 1 3 4)
Deleting some formulas,
this simplifies to: 
select_right_nonce2.2.2 :  

[-1]  3 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
[1]   0 <= (mid - 1) / (p - 2)

Rerunning step: (rewrite "div_mult_pos_le2")
Found matching substitution:
py: posreal gets (p - 2),
z: real gets (mid - 1),
x: real gets 0,
Rewriting using div_mult_pos_le2, matching in *,

This completes the proof of select_right_nonce2.2.2.


This completes the proof of select_right_nonce2.2.

select_right_nonce2.3 :  

[-1]  3 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
{1}   floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1

Rerunning step: (typepred "floor(((mid - 1) / (p - 2)) * (P!1 - 2))")
Adding type constraints for  floor(((mid - 1) / (p - 2)) * (P!1 - 2)),
this simplifies to: 
select_right_nonce2.3 :  

{-1}  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) <=
       ((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))
{-2}  ((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2)) <
       1 + floor(((mid - 1) / (p - 2)) * (P!1 - 2))
[-3]  3 <= P!1
[-4]  3 <= p
[-5]  0 < mid
[-6]  mid < p - 1
  |-------
[1]   floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1

Rerunning step: (rewrite "floor_plus_int")
Found matching substitution:
i: integer gets 1,
x: real gets ((mid - 1) / (p - 2)) * (P!1 - 2),
Rewriting using floor_plus_int, matching in *,
this simplifies to: 
select_right_nonce2.3 :  

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) <=
       ((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))
[-2]  ((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2)) <
       1 + floor(((mid - 1) / (p - 2)) * (P!1 - 2))
[-3]  3 <= P!1
[-4]  3 <= p
[-5]  0 < mid
[-6]  mid < p - 1
  |-------
{1}   1 + floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1

Rerunning step: (case "((mid-1)/(p-2))*(P!1-2) < P!1-2")
Case splitting on 
   ((mid - 1) / (p - 2)) * (P!1 - 2) < P!1 - 2, 
this yields  2 subgoals: 
select_right_nonce2.3.1 :  

{-1}  ((mid - 1) / (p - 2)) * (P!1 - 2) < P!1 - 2
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) <=
       ((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))
[-3]  ((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2)) <
       1 + floor(((mid - 1) / (p - 2)) * (P!1 - 2))
[-4]  3 <= P!1
[-5]  3 <= p
[-6]  0 < mid
[-7]  mid < p - 1
  |-------
[1]   1 + floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of select_right_nonce2.3.1.

select_right_nonce2.3.2 :  

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) <=
       ((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))
[-2]  ((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2)) <
       1 + floor(((mid - 1) / (p - 2)) * (P!1 - 2))
[-3]  3 <= P!1
[-4]  3 <= p
[-5]  0 < mid
[-6]  mid < p - 1
  |-------
{1}   ((mid - 1) / (p - 2)) * (P!1 - 2) < P!1 - 2
[2]   1 + floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1

Rerunning step: (delete -1 -2 2)
Deleting some formulas,
this simplifies to: 
select_right_nonce2.3.2 :  

[-1]  3 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
[1]   ((mid - 1) / (p - 2)) * (P!1 - 2) < P!1 - 2

Rerunning step: (rewrite "div_mult_pos_lt2" :dir rl)
Found matching substitution:
z: real gets P!1 - 2,
py: posreal gets (P!1 - 2),
x: real gets ((mid - 1) / (p - 2)),
Rewriting using div_mult_pos_lt2, matching in *,
this simplifies to: 
select_right_nonce2.3.2 :  

[-1]  3 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
{1}   ((mid - 1) / (p - 2)) < (P!1 - 2) / (P!1 - 2)

Rerunning step: (rewrite "div_simp")
Found matching substitution:
n0x: nonzero_real gets P!1 - 2,
Rewriting using div_simp, matching in *,
this simplifies to: 
select_right_nonce2.3.2 :  

[-1]  3 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
{1}   ((mid - 1) / (p - 2)) < 1

Rerunning step: (rewrite "div_mult_pos_lt1")
Found matching substitution:
x: real gets 1,
py: posreal gets (p - 2),
z: real gets (mid - 1),
Rewriting using div_mult_pos_lt1, matching in *,

This completes the proof of select_right_nonce2.3.2.


This completes the proof of select_right_nonce2.3.

Q.E.D.


Run time  = 0.61 secs.
Real time = 0.75 secs.
nil
pvs(37): 
Installing rewrite rule sets.singleton_rew (all instances)
select_right_nonce3 :  

  |-------
{1}   FORALL (P: nat_from_2):
        (P = p IMPLIES floor((mid / (p - 1)) * (P - 1)) = mid) AND
         floor((mid / (p - 1)) * (P - 1)) >= 0 AND
          floor((mid / (p - 1)) * (P - 1)) < P - 1

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
select_right_nonce3 :  

  |-------
{1}   (P!1 = p IMPLIES floor((mid / (p - 1)) * (P!1 - 1)) = mid) AND
       floor((mid / (p - 1)) * (P!1 - 1)) >= 0 AND
        floor((mid / (p - 1)) * (P!1 - 1)) < P!1 - 1

Rerunning step: (typepred "P!1" "p" "mid")
Adding type constraints for  P!1, p, mid,
this simplifies to: 
select_right_nonce3 :  

{-1}  2 <= P!1
{-2}  3 <= p
{-3}  0 < mid
{-4}  mid < p - 1
  |-------
[1]   (P!1 = p IMPLIES floor((mid / (p - 1)) * (P!1 - 1)) = mid) AND
       floor((mid / (p - 1)) * (P!1 - 1)) >= 0 AND
        floor((mid / (p - 1)) * (P!1 - 1)) < P!1 - 1

Rerunning step: (prop)
Applying propositional simplification,
this yields  3 subgoals: 
select_right_nonce3.1 :  

{-1}  P!1 = p
[-2]  2 <= P!1
[-3]  3 <= p
[-4]  0 < mid
[-5]  mid < p - 1
  |-------
{1}   floor((mid / (p - 1)) * (P!1 - 1)) = mid

Rerunning step: (replace* -1)
Repeatedly applying the replace rule,
this simplifies to: 
select_right_nonce3.1 :  

[-1]  P!1 = p
{-2}  2 <= p
[-3]  3 <= p
[-4]  0 < mid
[-5]  mid < p - 1
  |-------
{1}   floor((mid / (p - 1)) * (p - 1)) = mid

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
select_right_nonce3.1 :  

[-1]  2 <= p
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
[1]   floor((mid / (p - 1)) * (p - 1)) = mid

Rerunning step: (rewrite "div_cancel2")
Found matching substitution:
n0z: nonzero_real gets (p - 1),
x: real gets mid,
Rewriting using div_cancel2, matching in *,
this simplifies to: 
select_right_nonce3.1 :  

[-1]  2 <= p
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
{1}   floor(mid) = mid

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of select_right_nonce3.1.

select_right_nonce3.2 :  

[-1]  2 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
{1}   floor((mid / (p - 1)) * (P!1 - 1)) >= 0

Rerunning step: (case "(mid/(p-1))*(P!1-1) >= 0")
Case splitting on 
   (mid / (p - 1)) * (P!1 - 1) >= 0, 
this yields  2 subgoals: 
select_right_nonce3.2.1 :  

{-1}  (mid / (p - 1)) * (P!1 - 1) >= 0
[-2]  2 <= P!1
[-3]  3 <= p
[-4]  0 < mid
[-5]  mid < p - 1
  |-------
[1]   floor((mid / (p - 1)) * (P!1 - 1)) >= 0

Rerunning step: (rewrite "nonneg_floor_is_nat")
Found matching substitution:
x: nonneg_real gets (mid / (p - 1)) * (P!1 - 1),
Rewriting using nonneg_floor_is_nat, matching in *,

This completes the proof of select_right_nonce3.2.1.

select_right_nonce3.2.2 :  

[-1]  2 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
{1}   (mid / (p - 1)) * (P!1 - 1) >= 0
[2]   floor((mid / (p - 1)) * (P!1 - 1)) >= 0

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
select_right_nonce3.2.2 :  

[-1]  2 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
[1]   (mid / (p - 1)) * (P!1 - 1) >= 0

Rerunning step: (lemma "pos_times_le" ("x" "mid/(p-1)" "y" "P!1-1"))
Applying pos_times_le where 
  x gets mid / (p - 1),
  y gets P!1 - 1,
this simplifies to: 
select_right_nonce3.2.2 :  

{-1}  0 <= mid / (p - 1) * (P!1 - 1) IFF
       (0 <= mid / (p - 1) AND 0 <= P!1 - 1) OR
        (mid / (p - 1) <= 0 AND P!1 - 1 <= 0)
[-2]  2 <= P!1
[-3]  3 <= p
[-4]  0 < mid
[-5]  mid < p - 1
  |-------
[1]   (mid / (p - 1)) * (P!1 - 1) >= 0

Rerunning step: (ground)
Applying propositional simplification and decision procedures,
this simplifies to: 
select_right_nonce3.2.2 :  

[-1]  2 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
{1}   P!1 - 1 <= 0
{2}   0 <= mid / (p - 1)
{3}   0 <= mid / (p - 1) * P!1 - mid / (p - 1)
{4}   (mid / (p - 1)) * P!1 - (mid / (p - 1)) >= 0

Rerunning step: (delete 1 3 4)
Deleting some formulas,
this simplifies to: 
select_right_nonce3.2.2 :  

[-1]  2 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
[1]   0 <= mid / (p - 1)

Rerunning step: (rewrite "div_mult_pos_le2")
Found matching substitution:
py: posreal gets (p - 1),
z: real gets mid,
x: real gets 0,
Rewriting using div_mult_pos_le2, matching in *,

This completes the proof of select_right_nonce3.2.2.


This completes the proof of select_right_nonce3.2.

select_right_nonce3.3 :  

[-1]  2 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
{1}   floor((mid / (p - 1)) * (P!1 - 1)) < P!1 - 1

Rerunning step: (typepred "floor((mid/(p-1))*(P!1-1))")
Adding type constraints for  floor((mid / (p - 1)) * (P!1 - 1)),
this simplifies to: 
select_right_nonce3.3 :  

{-1}  floor((mid / (p - 1)) * (P!1 - 1)) <=
       (mid / (p - 1)) * P!1 - (mid / (p - 1))
{-2}  (mid / (p - 1)) * P!1 - (mid / (p - 1)) <
       1 + floor((mid / (p - 1)) * (P!1 - 1))
[-3]  2 <= P!1
[-4]  3 <= p
[-5]  0 < mid
[-6]  mid < p - 1
  |-------
[1]   floor((mid / (p - 1)) * (P!1 - 1)) < P!1 - 1

Rerunning step: (case "(mid/(p-1))*(P!1-1) < P!1-1")
Case splitting on 
   (mid / (p - 1)) * (P!1 - 1) < P!1 - 1, 
this yields  2 subgoals: 
select_right_nonce3.3.1 :  

{-1}  (mid / (p - 1)) * (P!1 - 1) < P!1 - 1
[-2]  floor((mid / (p - 1)) * (P!1 - 1)) <=
       (mid / (p - 1)) * P!1 - (mid / (p - 1))
[-3]  (mid / (p - 1)) * P!1 - (mid / (p - 1)) <
       1 + floor((mid / (p - 1)) * (P!1 - 1))
[-4]  2 <= P!1
[-5]  3 <= p
[-6]  0 < mid
[-7]  mid < p - 1
  |-------
[1]   floor((mid / (p - 1)) * (P!1 - 1)) < P!1 - 1

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
select_right_nonce3.3.1 :  

[-1]  (mid / (p - 1)) * (P!1 - 1) < P!1 - 1
[-2]  floor((mid / (p - 1)) * (P!1 - 1)) <=
       (mid / (p - 1)) * P!1 - (mid / (p - 1))
[-3]  2 <= P!1
[-4]  3 <= p
[-5]  0 < mid
[-6]  mid < p - 1
  |-------
[1]   floor((mid / (p - 1)) * (P!1 - 1)) < P!1 - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of select_right_nonce3.3.1.

select_right_nonce3.3.2 :  

[-1]  floor((mid / (p - 1)) * (P!1 - 1)) <=
       (mid / (p - 1)) * P!1 - (mid / (p - 1))
[-2]  (mid / (p - 1)) * P!1 - (mid / (p - 1)) <
       1 + floor((mid / (p - 1)) * (P!1 - 1))
[-3]  2 <= P!1
[-4]  3 <= p
[-5]  0 < mid
[-6]  mid < p - 1
  |-------
{1}   (mid / (p - 1)) * (P!1 - 1) < P!1 - 1
[2]   floor((mid / (p - 1)) * (P!1 - 1)) < P!1 - 1

Rerunning step: (delete -1 -2 2)
Deleting some formulas,
this simplifies to: 
select_right_nonce3.3.2 :  

[-1]  2 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
[1]   (mid / (p - 1)) * (P!1 - 1) < P!1 - 1

Rerunning step: (rewrite "div_mult_pos_lt2" :dir rl)
Found matching substitution:
z: real gets P!1 - 1,
py: posreal gets (P!1 - 1),
x: real gets (mid / (p - 1)),
Rewriting using div_mult_pos_lt2, matching in *,
this simplifies to: 
select_right_nonce3.3.2 :  

[-1]  2 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
{1}   (mid / (p - 1)) < (P!1 - 1) / (P!1 - 1)

Rerunning step: (rewrite "div_simp")
Found matching substitution:
n0x: nonzero_real gets P!1 - 1,
Rewriting using div_simp, matching in *,
this simplifies to: 
select_right_nonce3.3.2 :  

[-1]  2 <= P!1
[-2]  3 <= p
[-3]  0 < mid
[-4]  mid < p - 1
  |-------
{1}   (mid / (p - 1)) < 1

Rerunning step: (rewrite "div_mult_pos_lt1")
Found matching substitution:
x: real gets 1,
py: posreal gets (p - 1),
z: real gets mid,
Rewriting using div_mult_pos_lt1, matching in *,

This completes the proof of select_right_nonce3.3.2.


This completes the proof of select_right_nonce3.3.

Q.E.D.


Run time  = 0.35 secs.
Real time = 0.50 secs.
nil
pvs(42): 
Installing rewrite rule sets.singleton_rew (all instances)
hu_list_exists :  

  |-------
{1}   EXISTS (x1:
                {x: list[Identity] |
                   (length[Identity](x) = p) AND
                    (FORALL (i: nat_to_p): nth[Identity](x, i) = hu(i))}):
        TRUE

Rerunning step: (typepred "p")
Adding type constraints for  p,
this simplifies to: 
hu_list_exists :  

{-1}  3 <= p
  |-------
[1]   EXISTS (x1:
                {x: list[Identity] |
                   (length[Identity](x) = p) AND
                    (FORALL (i: nat_to_p): nth[Identity](x, i) = hu(i))}):
        TRUE

Rerunning step: (inst 1 "gen_f_list(p, 0, hu)")
Instantiating the top quantifier in 1 with the terms: 
 gen_f_list(p, 0, hu),
this yields  2 subgoals: 
hu_list_exists.1 (TCC):   

[-1]  3 <= p
  |-------
{1}   (length[Identity](gen_f_list[Identity](p, 0, hu)) = p) AND
       FORALL (i: nat_to_p):
         nth[Identity](gen_f_list[Identity](p, 0, hu), i) = hu(i)

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
hu_list_exists.1.1 :  

[-1]  3 <= p
  |-------
{1}   (length[Identity](gen_f_list[Identity](p, 0, hu)) = p)

Rerunning step: (rewrite "gen1")
Found matching substitution:
f: [below[k] -> T] gets hu,
i: below[k] gets 0,
k: nat gets p,
Rewriting using gen1, matching in *,

This completes the proof of hu_list_exists.1.1.

hu_list_exists.1.2 :  

[-1]  3 <= p
  |-------
{1}   FORALL (i: nat_to_p):
        nth[Identity](gen_f_list[Identity](p, 0, hu), i) = hu(i)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
hu_list_exists.1.2 :  

[-1]  3 <= p
  |-------
{1}   nth[Identity](gen_f_list[Identity](p, 0, hu), i!1) = hu(i!1)

Rerunning step: (rewrite "gen2")
Found matching substitution:
j: below[k - i] gets i!1,
f: [below[k] -> T] gets hu,
i: below[k] gets 0,
k: nat gets p,
Rewriting using gen2, matching in *,

This completes the proof of hu_list_exists.1.2.


This completes the proof of hu_list_exists.1.

hu_list_exists.2 (TCC):   

[-1]  3 <= p
  |-------
{1}   0 < p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of hu_list_exists.2.

Q.E.D.


Run time  = 0.13 secs.
Real time = 0.23 secs.
nil
pvs(47): 
Installing rewrite rule sets.singleton_rew (all instances)
cons_hu_list :  

  |-------
{1}   cons?(hu_list) AND length(hu_list) = p

Rerunning step: (typepred "hu_list")
Adding type constraints for  hu_list,
this simplifies to: 
cons_hu_list :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-2}  (length(hu_list) = p)
{-3}  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
  |-------
[1]   cons?(hu_list) AND length(hu_list) = p

Rerunning step: (delete -1 -3)
Deleting some formulas,
this simplifies to: 
cons_hu_list :  

[-1]  (length(hu_list) = p)
  |-------
[1]   cons?(hu_list) AND length(hu_list) = p

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
cons_hu_list :  

[-1]  (length(hu_list) = p)
  |-------
{1}   cons?(hu_list)

Rerunning step: (expand "length" -1)
Expanding the definition of length,
this simplifies to: 
cons_hu_list :  

{-1}  (CASES hu_list OF null: 0, cons(x, y): length[Identity](y) + 1
         ENDCASES
        = p)
  |-------
[1]   cons?(hu_list)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,
Q.E.D.


Run time  = 0.03 secs.
Real time = 0.10 secs.
nil
pvs(52): 
Installing rewrite rule sets.singleton_rew (all instances)
restrictpremid_init :  

  |-------
{1}   FORALL (P: nat_from_2, u: Identity, v: below[mid]):
        ((Interleave! (nn0: Nonces(P, u, 0)): UROLE_INIT(P, u, nn0)) #
          R_premid(v))
         |> RankUser(rho_premid(v))

Rerunning step: (auto-rewrite-theory "sets")
Rewriting relative to the theory: sets,
this simplifies to: 
restrictpremid_init :  

  |-------
[1]   FORALL (P: nat_from_2, u: Identity, v: below[mid]):
        ((Interleave! (nn0: Nonces(P, u, 0)): UROLE_INIT(P, u, nn0)) #
          R_premid(v))
         |> RankUser(rho_premid(v))

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictpremid_init :  

  |-------
{1}   ((Interleave! (nn0: Nonces(P!1, u!1, 0)): UROLE_INIT(P!1, u!1, nn0))
        # R_premid(v!1))
       |> RankUser(rho_premid(v!1))

Rerunning step: (expand "RankUser")
Expanding the definition of RankUser,
this simplifies to: 
restrictpremid_init :  

  |-------
{1}   ((Interleave! (nn0: Nonces(P!1, u!1, 0)): UROLE_INIT(P!1, u!1, nn0))
        # R_premid(v!1))
       |>
       LAMBDA (tr: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(tr)
          =>
          every(LAMBDA (e: event):
                  complement(rec?)(e) => rho_premid(v!1)(msg(e)))
               (tr)

Rerunning step: (interleaving2)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
Applying interleaving rule,
this simplifies to: 
restrictpremid_init :  

  |-------
{1}   UROLE_INIT(P!1, u!1, i!1) # R_premid(v!1) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (expand "UROLE_INIT")
Expanding the definition of UROLE_INIT,
this simplifies to: 
restrictpremid_init :  

  |-------
{1}   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (signal(running(0, cons(u!1, il),
                            nth(nl,
                                floor(((mid - 1) / (p - 2)) * P!1
                                      -
                                      2 * ((mid - 1) / (p - 2))))))
              >>
              (trans(u!1, car(il),
                     E(public(car(il)),
                       conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                >> Stop[event]))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (typepred "P!1")
Adding type constraints for  P!1,
this simplifies to: 
restrictpremid_init :  

{-1}  2 <= P!1
  |-------
[1]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (signal(running(0, cons(u!1, il),
                            nth(nl,
                                floor(((mid - 1) / (p - 2)) * P!1
                                      -
                                      2 * ((mid - 1) / (p - 2))))))
              >>
              (trans(u!1, car(il),
                     E(public(car(il)),
                       conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                >> Stop[event]))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (lemma "select_right_nonce1" ("P" "P!1"))
Applying select_right_nonce1 where 
  P gets P!1,
this simplifies to: 
restrictpremid_init :  

{-1}  (P!1 = p IMPLIES floor(((mid - 1) / (p - 2)) * (P!1 - 2)) = mid - 1)
       AND
       floor(((mid - 1) / (p - 2)) * (P!1 - 2)) >= 0 AND
        floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1
[-2]  2 <= P!1
  |-------
[1]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (signal(running(0, cons(u!1, il),
                            nth(nl,
                                floor(((mid - 1) / (p - 2)) * P!1
                                      -
                                      2 * ((mid - 1) / (p - 2))))))
              >>
              (trans(u!1, car(il),
                     E(public(car(il)),
                       conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                >> Stop[event]))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictpremid_init :  

{-1}  (P!1 = p IMPLIES floor(((mid - 1) / (p - 2)) * (P!1 - 2)) = mid - 1)
{-2}  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) >= 0
{-3}  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (signal(running(0, cons(u!1, il),
                            nth(nl,
                                floor(((mid - 1) / (p - 2)) * P!1
                                      -
                                      2 * ((mid - 1) / (p - 2))))))
              >>
              (trans(u!1, car(il),
                     E(public(car(il)),
                       conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                >> Stop[event]))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictpremid_init :  

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) >= 0
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1
[-3]  2 <= P!1
  |-------
[1]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (signal(running(0, cons(u!1, il),
                            nth(nl,
                                floor(((mid - 1) / (p - 2)) * P!1
                                      -
                                      2 * ((mid - 1) / (p - 2))))))
              >>
              (trans(u!1, car(il),
                     E(public(car(il)),
                       conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                >> Stop[event]))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (choice3)
Applying choice rule,
this yields  7 subgoals: 
restrictpremid_init.1 :  

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) >= 0
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   (trans(u!1, car(i!2`2),
             E(public(car(i!2`2)),
               conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))
        >>
        (rec(u!1, nth(i!2`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
          >>
          (signal(running(0, cons(u!1, i!2`2),
                          nth(i!2`1,
                              floor(((mid - 1) / (p - 2)) * P!1
                                    -
                                    2 * ((mid - 1) / (p - 2))))))
            >>
            (trans(u!1, car(i!2`2),
                   E(public(car(i!2`2)),
                     conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
              >> Stop[event]))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictpremid_init.1.1 :  

{-1}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
{-2}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   rho_premid(v!1)
                (E(public(car(i!2`2)),
                   conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))
{2}   R_premid(v!1)
              (trans(u!1, car(i!2`2),
                     E(public(car(i!2`2)),
                       conc(nlist((: i!1 :)),
                            ilist(cons(u!1, cdr(i!2`2)))))))
{3}   trans(u!1, car(i!2`2),
            E(public(car(i!2`2)),
              conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))
       >>
       ((rec(u!1, nth(i!2`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
          >>
          (signal(running(0, cons(u!1, i!2`2),
                          nth(i!2`1,
                              floor(((mid - 1) / (p - 2)) * P!1
                                    -
                                    2 * ((mid - 1) / (p - 2))))))
            >>
            (trans(u!1, car(i!2`2),
                   E(public(car(i!2`2)),
                     conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
              >> Stop[event])))
         # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -2 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.1.1 :  

[-1]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (E(public(car(i!2`2)),
                   conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))

Rerunning step: (typepred "i!1" "mid")
Adding type constraints for  i!1, mid,
this simplifies to: 
restrictpremid_init.1.1 :  

{-1}  IRpart(P!1, u!1, 0)(i!1)
{-2}  0 < mid
{-3}  mid < p - 1
[-4]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (E(public(car(i!2`2)),
                   conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))

Rerunning step: (lemma "n_prop" ("P" "P!1" "u" "u!1" "r" "0"))
Applying n_prop where 
  P gets P!1,
  u gets u!1,
  r gets 0,
this simplifies to: 
restrictpremid_init.1.1 :  

{-1}  (P!1 /= p OR 0 /= mid) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, 0)(n_mid)
[-2]  IRpart(P!1, u!1, 0)(i!1)
[-3]  0 < mid
[-4]  mid < p - 1
[-5]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (E(public(car(i!2`2)),
                   conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))

Rerunning step: (grind)
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
E rewrites 
  E(public(car(i!2`2)),
    conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2)))))
  to code(public(car(i!2`2)),
           conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2)))))
elt rewrites elt((: i!1 :), n_mid)
  to EXISTS (i: below[length((: i!1 :))]): nth((: i!1 :), i) = n_mid
rho_premid rewrites rho_premid(v!1)(nlist((: i!1 :)))
  to NOT EXISTS (i: below[length((: i!1 :))]): nth((: i!1 :), i) = n_mid
rho_premid rewrites rho_premid(v!1)(ilist(cons(u!1, cdr(i!2`2))))
  to TRUE
rho_premid rewrites 
  rho_premid(v!1)(conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2)))))
  to NOT EXISTS (i: below[length((: i!1 :))]): nth((: i!1 :), i) = n_mid
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_premid rewrites 
  rho_premid(v!1)
            (code(public(car(i!2`2)),
                  conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))
  to NOT EXISTS (i: below[length((: i!1 :))]): nth((: i!1 :), i) = n_mid
       OR
       (EXISTS (i: {x: nat | mid < x AND x <= p}):
          public(car(i!2`2)) = public(hu(rem(p)(i))) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                   nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
             conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2)))) =
              conc(nlist(append(nl1, cons(n_mid, nl2))),
                   ilist(remove(hu_list, rem(p)(i)))))
        OR
        EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
          public(car(i!2`2)) = public(hu(i)) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                   nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
             conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2)))) =
              conc(ilist(cons(car(hu_list), remove(cdr(hu_list), i - 1))),
                   nlist(append(nl1, cons(n_mid, nl2))))
/= rewrites P!1 /= p
  to NOT (P!1 = p)
/= rewrites 0 /= mid
  to TRUE
length rewrites length[Nonce]((: :))
  to 0
length rewrites length((: i!1 :))
  to 1
nth rewrites nth((: i!1 :), i!3)
  to i!1
length rewrites length[Nonce]((: :))
  to 0
length rewrites length((: i!1 :))
  to 1
nth rewrites nth((: i!1 :), i!3)
  to i!1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpremid_init.1.1.

restrictpremid_init.1.2 :  

{-1}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
{-2}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   ((rec(u!1, nth(i!2`2, P!1 - 2),
            E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
         >>
         (signal(running(0, cons(u!1, i!2`2),
                         nth(i!2`1,
                             floor(((mid - 1) / (p - 2)) * P!1 -
                                    2 * ((mid - 1) / (p - 2))))))
           >>
           (trans(u!1, car(i!2`2),
                  E(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
             >> Stop[event])))
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
{2}   R_premid(v!1)
              (trans(u!1, car(i!2`2),
                     E(public(car(i!2`2)),
                       conc(nlist((: i!1 :)),
                            ilist(cons(u!1, cdr(i!2`2)))))))
{3}   trans(u!1, car(i!2`2),
            E(public(car(i!2`2)),
              conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))
       >>
       ((rec(u!1, nth(i!2`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
          >>
          (signal(running(0, cons(u!1, i!2`2),
                          nth(i!2`1,
                              floor(((mid - 1) / (p - 2)) * P!1
                                    -
                                    2 * ((mid - 1) / (p - 2))))))
            >>
            (trans(u!1, car(i!2`2),
                   E(public(car(i!2`2)),
                     conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
              >> Stop[event])))
         # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.1.2 :  

[-1]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
[-2]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-3]  2 <= P!1
  |-------
[1]   ((rec(u!1, nth(i!2`2, P!1 - 2),
            E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
         >>
         (signal(running(0, cons(u!1, i!2`2),
                         nth(i!2`1,
                             floor(((mid - 1) / (p - 2)) * P!1 -
                                    2 * ((mid - 1) / (p - 2))))))
           >>
           (trans(u!1, car(i!2`2),
                  E(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
             >> Stop[event])))
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictpremid_init.1.2 :  

{-1}  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
[-3]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-4]  2 <= P!1
  |-------
{1}   ((signal(running(0, cons(u!1, i!2`2),
                       nth(i!2`1,
                           floor(((mid - 1) / (p - 2)) * P!1 -
                                  2 * ((mid - 1) / (p - 2))))))
         >>
         (trans(u!1, car(i!2`2),
                E(public(car(i!2`2)),
                  conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
           >> Stop[event]))
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
{2}   R_premid(v!1)
              (rec(u!1, nth(i!2`2, P!1 - 2),
                   E(public(u!1),
                     conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)))))
{3}   rec(u!1, nth(i!2`2, P!1 - 2),
          E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
       >>
       ((signal(running(0, cons(u!1, i!2`2),
                        nth(i!2`1,
                            floor(((mid - 1) / (p - 2)) * P!1 -
                                   2 * ((mid - 1) / (p - 2))))))
          >>
          (trans(u!1, car(i!2`2),
                 E(public(car(i!2`2)),
                   conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
            >> Stop[event]))
         # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.1.2 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
[-3]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   ((signal(running(0, cons(u!1, i!2`2),
                       nth(i!2`1,
                           floor(((mid - 1) / (p - 2)) * P!1 -
                                  2 * ((mid - 1) / (p - 2))))))
         >>
         (trans(u!1, car(i!2`2),
                E(public(car(i!2`2)),
                  conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
           >> Stop[event]))
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictpremid_init.1.2.1 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
[-3]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-4]  2 <= P!1
  |-------
{1}   rho_premid(v!1)
                (running(0, cons(u!1, i!2`2),
                         nth(i!2`1,
                             floor(((mid - 1) / (p - 2)) * P!1 -
                                    2 * ((mid - 1) / (p - 2))))))
{2}   R_premid(v!1)
              (signal(running(0, cons(u!1, i!2`2),
                              nth(i!2`1,
                                  floor(((mid - 1) / (p - 2)) * P!1
                                        -
                                        2 * ((mid - 1) / (p - 2)))))))
{3}   signal(running(0, cons(u!1, i!2`2),
                     nth(i!2`1,
                         floor(((mid - 1) / (p - 2)) * P!1 -
                                2 * ((mid - 1) / (p - 2))))))
       >>
       ((trans(u!1, car(i!2`2),
               E(public(car(i!2`2)),
                 conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
          >> Stop[event])
         # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.1.2.1 :  

  |-------
[1]   rho_premid(v!1)
                (running(0, cons(u!1, i!2`2),
                         nth(i!2`1,
                             floor(((mid - 1) / (p - 2)) * P!1 -
                                    2 * ((mid - 1) / (p - 2))))))

Rerunning step: (expand "rho_premid")
Expanding the definition of rho_premid,
this simplifies to: 
restrictpremid_init.1.2.1 :  

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictpremid_init.1.2.1.

restrictpremid_init.1.2.2 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
[-3]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-4]  2 <= P!1
  |-------
{1}   ((trans(u!1, car(i!2`2),
              E(public(car(i!2`2)),
                conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
         >> Stop[event])
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
{2}   R_premid(v!1)
              (signal(running(0, cons(u!1, i!2`2),
                              nth(i!2`1,
                                  floor(((mid - 1) / (p - 2)) * P!1
                                        -
                                        2 * ((mid - 1) / (p - 2)))))))
{3}   signal(running(0, cons(u!1, i!2`2),
                     nth(i!2`1,
                         floor(((mid - 1) / (p - 2)) * P!1 -
                                2 * ((mid - 1) / (p - 2))))))
       >>
       ((trans(u!1, car(i!2`2),
               E(public(car(i!2`2)),
                 conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
          >> Stop[event])
         # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.1.2.2 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
[-3]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   ((trans(u!1, car(i!2`2),
              E(public(car(i!2`2)),
                conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
         >> Stop[event])
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[2]   R_premid(v!1)
              (signal(running(0, cons(u!1, i!2`2),
                              nth(i!2`1,
                                  floor(((mid - 1) / (p - 2)) * P!1
                                        -
                                        2 * ((mid - 1) / (p - 2)))))))

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictpremid_init.1.2.2.1 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
[-3]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-4]  2 <= P!1
  |-------
{1}   rho_premid(v!1)
                (E(public(car(i!2`2)),
                   conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
{2}   R_premid(v!1)
              (trans(u!1, car(i!2`2),
                     E(public(car(i!2`2)),
                       conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1)))))
{3}   trans(u!1, car(i!2`2),
            E(public(car(i!2`2)),
              conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
       >> (Stop[event] # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   R_premid(v!1)
              (signal(running(0, cons(u!1, i!2`2),
                              nth(i!2`1,
                                  floor(((mid - 1) / (p - 2)) * P!1
                                        -
                                        2 * ((mid - 1) / (p - 2)))))))

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.1.2.2.1 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
[-3]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (E(public(car(i!2`2)),
                   conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
[2]   R_premid(v!1)
              (signal(running(0, cons(u!1, i!2`2),
                              nth(i!2`1,
                                  floor(((mid - 1) / (p - 2)) * P!1
                                        -
                                        2 * ((mid - 1) / (p - 2)))))))

Rerunning step: (expand "R_premid")
Expanding the definition of R_premid,
this simplifies to: 
restrictpremid_init.1.2.2.1 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
[-3]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (E(public(car(i!2`2)),
                   conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
{2}   signal(running(0, cons(u!1, i!2`2),
                     nth(i!2`1,
                         floor(((mid - 1) / (p - 2)) * P!1 -
                                2 * ((mid - 1) / (p - 2))))))
       = signal(running(v!1, hu_list, n_mid))

Rerunning step: (case "v!1=0 AND cons(u!1,i!2`2)=hu_list AND nth(i!2`1,floor(((mid-1)/(p-2))*P!1-2*((mid-1)/(p-2))))=n_mid")
Case splitting on 
   v!1 = 0 AND
    cons(u!1, i!2`2) = hu_list AND
     nth(i!2`1,
         floor(((mid - 1) / (p - 2)) * P!1 -
                2 * ((mid - 1) / (p - 2))))
      = n_mid, 
this yields  2 subgoals: 
restrictpremid_init.1.2.2.1.1 :  

{-1}  v!1 = 0 AND
       cons(u!1, i!2`2) = hu_list AND
        nth(i!2`1,
            floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
         = n_mid
[-2]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-3]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
[-4]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (E(public(car(i!2`2)),
                   conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
[2]   signal(running(0, cons(u!1, i!2`2),
                     nth(i!2`1,
                         floor(((mid - 1) / (p - 2)) * P!1 -
                                2 * ((mid - 1) / (p - 2))))))
       = signal(running(v!1, hu_list, n_mid))

Rerunning step: (delete -2 -3 -4 -5 1)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.1.2.2.1.1 :  

[-1]  v!1 = 0 AND
       cons(u!1, i!2`2) = hu_list AND
        nth(i!2`1,
            floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
         = n_mid
  |-------
[1]   signal(running(0, cons(u!1, i!2`2),
                     nth(i!2`1,
                         floor(((mid - 1) / (p - 2)) * P!1 -
                                2 * ((mid - 1) / (p - 2))))))
       = signal(running(v!1, hu_list, n_mid))

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_init.1.2.2.1.1.

restrictpremid_init.1.2.2.1.2 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
[-3]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-4]  2 <= P!1
  |-------
{1}   v!1 = 0 AND
       cons(u!1, i!2`2) = hu_list AND
        nth(i!2`1,
            floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
         = n_mid
[2]   rho_premid(v!1)
                (E(public(car(i!2`2)),
                   conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
[3]   signal(running(0, cons(u!1, i!2`2),
                     nth(i!2`1,
                         floor(((mid - 1) / (p - 2)) * P!1 -
                                2 * ((mid - 1) / (p - 2))))))
       = signal(running(v!1, hu_list, n_mid))

Rerunning step: (delete -2 -3 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.1.2.2.1.2 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   v!1 = 0 AND
       cons(u!1, i!2`2) = hu_list AND
        nth(i!2`1,
            floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
         = n_mid
[2]   rho_premid(v!1)
                (E(public(car(i!2`2)),
                   conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (expand "E")
Expanding the definition of E,
this simplifies to: 
restrictpremid_init.1.2.2.1.2 :  

{-1}  rho_premid(v!1)
                (code(public(u!1),
                      conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   v!1 = 0 AND
       cons(u!1, i!2`2) = hu_list AND
        nth(i!2`1,
            floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
         = n_mid
{2}   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (comment "explore the 3 options that could make -1 true")
Adding comment: explore the 3 options that could make -1 true
this simplifies to: 
restrictpremid_init.1.2.2.1.2 : 
;;; explore the 3 options that could make -1 true

[-1]  rho_premid(v!1)
                (code(public(u!1),
                      conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   v!1 = 0 AND
       cons(u!1, i!2`2) = hu_list AND
        nth(i!2`1,
            floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
         = n_mid
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (expand "rho_premid" -1)
Expanding the definition of rho_premid,
this simplifies to: 
restrictpremid_init.1.2.2.1.2 : 
;;; explore the 3 options that could make -1 true

{-1}  rho_premid(v!1)(conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))) OR
       (EXISTS (i: {x: nat | mid < x AND x <= p}):
          public(u!1) = public(hu(rem(p)(i))) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                   nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
             conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)) =
              conc(nlist(append(nl1, cons(n_mid, nl2))),
                   ilist(remove(hu_list, rem(p)(i)))))
        OR
        EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
          public(u!1) = public(hu(i)) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                   nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
             conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)) =
              conc(ilist(remove(hu_list, i)),
                   nlist(append(nl1, cons(n_mid, nl2))))
[-2]  2 <= P!1
  |-------
[1]   v!1 = 0 AND
       cons(u!1, i!2`2) = hu_list AND
        nth(i!2`1,
            floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
         = n_mid
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (split -1)
Splitting conjunctions,
this yields  3 subgoals: 
restrictpremid_init.1.2.2.1.2.1 : 
;;; explore the 3 options that could make -1 true

{-1}  rho_premid(v!1)(conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)))
[-2]  2 <= P!1
  |-------
[1]   v!1 = 0 AND
       cons(u!1, i!2`2) = hu_list AND
        nth(i!2`1,
            floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
         = n_mid
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (delete 1)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.1 : 
;;; explore the 3 options that could make -1 true

[-1]  rho_premid(v!1)(conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)))
[-2]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (lemma "listprops[Nonce].elt_append2"
                 ("l1" "(:i!1:)" "l2" "i!2`1" "t" "n_mid"))
Applying listprops[Nonce].elt_append2 where 
  l1 gets (: i!1 :),
  l2 gets i!2`1,
  t gets n_mid,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.1 : 
;;; explore the 3 options that could make -1 true

{-1}  elt(i!2`1, n_mid) IMPLIES elt(append((: i!1 :), i!2`1), n_mid)
[-2]  rho_premid(v!1)(conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)))
[-3]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (grind :exclude "elt")
append rewrites append((: :), i!2`1)
  to i!2`1
append rewrites append((: i!1 :), i!2`1)
  to cons(i!1, i!2`1)
rho_premid rewrites rho_premid(v!1)(nlist(cons(i!1, i!2`1)))
  to FALSE
rho_premid rewrites rho_premid(v!1)(ilist(i!2`2))
  to TRUE
rho_premid rewrites 
  rho_premid(v!1)(conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)))
  to FALSE
rho_premid rewrites rho_premid(v!1)(nlist(cons(i!1, i!2`1)))
  to NOT elt(cons(i!1, i!2`1), n_mid)
rho_premid rewrites rho_premid(v!1)(ilist(i!2`2))
  to TRUE
rho_premid rewrites 
  rho_premid(v!1)(conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)))
  to NOT elt(cons(i!1, i!2`1), n_mid)
rho_premid rewrites rho_premid(v!1)(ilist(cons(u!1, cdr(i!2`2))))
  to TRUE
rho_premid rewrites rho_premid(v!1)(nlist(i!2`1))
  to TRUE
rho_premid rewrites 
  rho_premid(v!1)(conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1)))
  to TRUE
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_premid rewrites 
  rho_premid(v!1)
            (code(public(car(i!2`2)),
                  conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpremid_init.1.2.2.1.2.1.

restrictpremid_init.1.2.2.1.2.2 : 
;;; explore the 3 options that could make -1 true

{-1}  EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(u!1) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)) =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[-2]  2 <= P!1
  |-------
[1]   v!1 = 0 AND
       cons(u!1, i!2`2) = hu_list AND
        nth(i!2`1,
            floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
         = n_mid
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2 : 
;;; explore the 3 options that could make -1 true

{-1}  public(u!1) = public(hu(rem(p)(i!3)))
{-2}  conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, rem(p)(i!3))))
[-3]  2 <= P!1
  |-------
[1]   v!1 = 0 AND
       cons(u!1, i!2`2) = hu_list AND
        nth(i!2`1,
            floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
         = n_mid
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2 : 
;;; explore the 3 options that could make -1 true

{-1}  u!1 = hu(rem(p)(i!3))
[-2]  conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, rem(p)(i!3))))
[-3]  2 <= P!1
  |-------
[1]   v!1 = 0 AND
       cons(u!1, i!2`2) = hu_list AND
        nth(i!2`1,
            floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
         = n_mid
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2 : 
;;; explore the 3 options that could make -1 true

{-1}  nlist(cons(i!1, i!2`1)) = nlist(append(nl1!1, cons(n_mid, nl2!1)))
{-2}  ilist(i!2`2) = ilist(remove(hu_list, rem(p)(i!3)))
[-3]  u!1 = hu(rem(p)(i!3))
[-4]  2 <= P!1
  |-------
[1]   v!1 = 0 AND
       cons(u!1, i!2`2) = hu_list AND
        nth(i!2`1,
            floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
         = n_mid
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2 : 
;;; explore the 3 options that could make -1 true

{-1}  cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-2]  ilist(i!2`2) = ilist(remove(hu_list, rem(p)(i!3)))
[-3]  u!1 = hu(rem(p)(i!3))
[-4]  2 <= P!1
  |-------
[1]   v!1 = 0 AND
       cons(u!1, i!2`2) = hu_list AND
        nth(i!2`1,
            floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
         = n_mid
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2 : 
;;; explore the 3 options that could make -1 true

{-1}  i!2`2 = remove(hu_list, rem(p)(i!3))
[-2]  cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-3]  u!1 = hu(rem(p)(i!3))
[-4]  2 <= P!1
  |-------
[1]   v!1 = 0 AND
       cons(u!1, i!2`2) = hu_list AND
        nth(i!2`1,
            floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
         = n_mid
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (typepred "nl1!1" "nl2!1" "i!2`1" "i!2`2" "i!3"
                 "hu_list" "v!1" "p")
Adding type constraints for  nl1!1, nl2!1, i!2`1, i!2`2, i!3, hu_list, v!1, p,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2 : 
;;; explore the 3 options that could make -1 true

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl1!1)
{-2}  length(nl1!1) = mid
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
{-4}  length(nl2!1) = -1 - mid + i!3
{-5}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`1)
{-6}  length(i!2`1) = P!1 - 1
{-7}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`2)
{-8}  length(i!2`2) = P!1 - 1
{-9}  mid < i!3
{-10} i!3 <= p
{-11} every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-12} (length(hu_list) = p)
{-13} FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
{-14} v!1 < mid
{-15} 3 <= p
[-16] i!2`2 = remove(hu_list, rem(p)(i!3))
[-17] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-18] u!1 = hu(rem(p)(i!3))
[-19] 2 <= P!1
  |-------
[1]   v!1 = 0 AND
       cons(u!1, i!2`2) = hu_list AND
        nth(i!2`1,
            floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
         = n_mid
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (delete -1 -3 -5 -7 -11)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2 : 
;;; explore the 3 options that could make -1 true

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  mid < i!3
[-6]  i!3 <= p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  v!1 < mid
[-10] 3 <= p
[-11] i!2`2 = remove(hu_list, rem(p)(i!3))
[-12] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-13] u!1 = hu(rem(p)(i!3))
[-14] 2 <= P!1
  |-------
[1]   v!1 = 0 AND
       cons(u!1, i!2`2) = hu_list AND
        nth(i!2`1,
            floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
         = n_mid
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (comment "prove all three conjuncts in 1, except for one (which is necessary to prove 2)")
Adding comment: prove all three conjuncts in 1, except for one (which is necessary to prove 2)
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2 : 
;;; prove all three conjuncts in 1, except for one (which is necessary to prove 2)

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  mid < i!3
[-6]  i!3 <= p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  v!1 < mid
[-10] 3 <= p
[-11] i!2`2 = remove(hu_list, rem(p)(i!3))
[-12] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-13] u!1 = hu(rem(p)(i!3))
[-14] 2 <= P!1
  |-------
[1]   v!1 = 0 AND
       cons(u!1, i!2`2) = hu_list AND
        nth(i!2`1,
            floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
         = n_mid
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (comment "establish some equalities first")
Adding comment: establish some equalities first
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2 : 
;;; establish some equalities first

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  mid < i!3
[-6]  i!3 <= p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  v!1 < mid
[-10] 3 <= p
[-11] i!2`2 = remove(hu_list, rem(p)(i!3))
[-12] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-13] u!1 = hu(rem(p)(i!3))
[-14] 2 <= P!1
  |-------
[1]   v!1 = 0 AND
       cons(u!1, i!2`2) = hu_list AND
        nth(i!2`1,
            floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
         = n_mid
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (case "P!1=p" "i!3=p" "rem(p)(i!3)=0")
Case splitting on 
   P!1 = p, 
   i!3 = p, 
   rem(p)(i!3) = 0, 
this yields  4 subgoals: 
restrictpremid_init.1.2.2.1.2.2.1 : 
;;; establish some equalities first

{-1}  rem(p)(i!3) = 0
{-2}  i!3 = p
{-3}  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  length(i!2`1) = P!1 - 1
[-7]  length(i!2`2) = P!1 - 1
[-8]  mid < i!3
[-9]  i!3 <= p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, rem(p)(i!3))
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(rem(p)(i!3))
[-17] 2 <= P!1
  |-------
[1]   v!1 = 0 AND
       cons(u!1, i!2`2) = hu_list AND
        nth(i!2`1,
            floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
         = n_mid
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (comment "split up 1")
Adding comment: split up 1
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1 : 
;;; split up 1

[-1]  rem(p)(i!3) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  length(i!2`1) = P!1 - 1
[-7]  length(i!2`2) = P!1 - 1
[-8]  mid < i!3
[-9]  i!3 <= p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, rem(p)(i!3))
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(rem(p)(i!3))
[-17] 2 <= P!1
  |-------
[1]   v!1 = 0 AND
       cons(u!1, i!2`2) = hu_list AND
        nth(i!2`1,
            floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
         = n_mid
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (split)
Splitting conjunctions,
this yields  3 subgoals: 
restrictpremid_init.1.2.2.1.2.2.1.1 : 
;;; split up 1

[-1]  rem(p)(i!3) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  length(i!2`1) = P!1 - 1
[-7]  length(i!2`2) = P!1 - 1
[-8]  mid < i!3
[-9]  i!3 <= p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, rem(p)(i!3))
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(rem(p)(i!3))
[-17] 2 <= P!1
  |-------
{1}   v!1 = 0
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (expand "rho_premid" 2)
Expanding the definition of rho_premid,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1 : 
;;; split up 1

[-1]  rem(p)(i!3) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  length(i!2`1) = P!1 - 1
[-7]  length(i!2`2) = P!1 - 1
[-8]  mid < i!3
[-9]  i!3 <= p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, rem(p)(i!3))
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(rem(p)(i!3))
[-17] 2 <= P!1
  |-------
[1]   v!1 = 0
{2}   rho_premid(v!1)(conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))) OR
       (EXISTS (i: {x: nat | mid < x AND x <= p}):
          public(car(i!2`2)) = public(hu(rem(p)(i))) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                   nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
             conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1)) =
              conc(nlist(append(nl1, cons(n_mid, nl2))),
                   ilist(remove(hu_list, rem(p)(i)))))
        OR
        EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
          public(car(i!2`2)) = public(hu(i)) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                   nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
             conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1)) =
              conc(ilist(remove(hu_list, i)),
                   nlist(append(nl1, cons(n_mid, nl2))))

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1 : 
;;; split up 1

[-1]  rem(p)(i!3) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  length(i!2`1) = P!1 - 1
[-7]  length(i!2`2) = P!1 - 1
[-8]  mid < i!3
[-9]  i!3 <= p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, rem(p)(i!3))
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(rem(p)(i!3))
[-17] 2 <= P!1
  |-------
[1]   v!1 = 0
{2}   rho_premid(v!1)(conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1)))
{3}   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`2)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1)) =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
{4}   EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(car(i!2`2)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1)) =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1 : 
;;; split up 1

[-1]  rem(p)(i!3) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  length(i!2`1) = P!1 - 1
[-7]  length(i!2`2) = P!1 - 1
[-8]  mid < i!3
[-9]  i!3 <= p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, rem(p)(i!3))
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(rem(p)(i!3))
[-17] 2 <= P!1
  |-------
[1]   v!1 = 0
[2]   EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(car(i!2`2)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1)) =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))

Rerunning step: (comment "the next message is sent to 1")
Adding comment: the next message is sent to 1
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1 : 
;;; the next message is sent to 1

[-1]  rem(p)(i!3) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  length(i!2`1) = P!1 - 1
[-7]  length(i!2`2) = P!1 - 1
[-8]  mid < i!3
[-9]  i!3 <= p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, rem(p)(i!3))
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(rem(p)(i!3))
[-17] 2 <= P!1
  |-------
[1]   v!1 = 0
[2]   EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(car(i!2`2)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1)) =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))

Rerunning step: (inst 2 "1")
Instantiating the top quantifier in 2 with the terms: 
 1,
this yields  2 subgoals: 
restrictpremid_init.1.2.2.1.2.2.1.1.1 : 
;;; the next message is sent to 1

[-1]  rem(p)(i!3) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  length(i!2`1) = P!1 - 1
[-7]  length(i!2`2) = P!1 - 1
[-8]  mid < i!3
[-9]  i!3 <= p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, rem(p)(i!3))
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(rem(p)(i!3))
[-17] 2 <= P!1
  |-------
[1]   v!1 = 0
{2}   public(car(i!2`2)) = public(hu(1)) AND
       EXISTS (nl1: {x: list[Nonce] | length(x) = mid - 1},
               nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
         conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1)) =
          conc(ilist(remove(hu_list, 1)),
               nlist(append(nl1, cons(n_mid, nl2))))

Rerunning step: (replace* -1 -2 -3)
Repeatedly applying the replace rule,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1.1 : 
;;; the next message is sent to 1

{-1}  rem(p)(p) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
{-5}  length(nl2!1) = -1 - mid + p
{-6}  length(i!2`1) = p - 1
{-7}  length(i!2`2) = p - 1
{-8}  mid < p
{-9}  p <= p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 3 <= p
{-14} i!2`2 = remove(hu_list, 0)
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
{-16} u!1 = hu(0)
{-17} 2 <= p
  |-------
[1]   v!1 = 0
[2]   public(car(i!2`2)) = public(hu(1)) AND
       EXISTS (nl1: {x: list[Nonce] | length(x) = mid - 1},
               nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
         conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1)) =
          conc(ilist(remove(hu_list, 1)),
               nlist(append(nl1, cons(n_mid, nl2))))

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
restrictpremid_init.1.2.2.1.2.2.1.1.1.1 : 
;;; the next message is sent to 1

[-1]  rem(p)(p) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + p
[-6]  length(i!2`1) = p - 1
[-7]  length(i!2`2) = p - 1
[-8]  mid < p
[-9]  p <= p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, 0)
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(0)
[-17] 2 <= p
  |-------
{1}   public(car(i!2`2)) = public(hu(1))
[2]   v!1 = 0

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1.1.1 : 
;;; the next message is sent to 1

[-1]  rem(p)(p) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + p
[-6]  length(i!2`1) = p - 1
[-7]  length(i!2`2) = p - 1
[-8]  mid < p
[-9]  p <= p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, 0)
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(0)
[-17] 2 <= p
  |-------
{1}   car(i!2`2) = hu(1)
[2]   v!1 = 0

Rerunning step: (inst -11 "1")
Instantiating the top quantifier in -11 with the terms: 
 1,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1.1.1 : 
;;; the next message is sent to 1

[-1]  rem(p)(p) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + p
[-6]  length(i!2`1) = p - 1
[-7]  length(i!2`2) = p - 1
[-8]  mid < p
[-9]  p <= p
[-10] (length(hu_list) = p)
{-11} nth(hu_list, 1) = hu(1)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, 0)
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(0)
[-17] 2 <= p
  |-------
[1]   car(i!2`2) = hu(1)
[2]   v!1 = 0

Rerunning step: (replace -14 1)
Replacing using formula -14,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1.1.1 : 
;;; the next message is sent to 1

[-1]  rem(p)(p) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + p
[-6]  length(i!2`1) = p - 1
[-7]  length(i!2`2) = p - 1
[-8]  mid < p
[-9]  p <= p
[-10] (length(hu_list) = p)
[-11] nth(hu_list, 1) = hu(1)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, 0)
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(0)
[-17] 2 <= p
  |-------
{1}   car(remove(hu_list, 0)) = hu(1)
[2]   v!1 = 0

Rerunning step: (replace -11 1 rl)
Replacing using formula -11,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1.1.1 : 
;;; the next message is sent to 1

[-1]  rem(p)(p) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + p
[-6]  length(i!2`1) = p - 1
[-7]  length(i!2`2) = p - 1
[-8]  mid < p
[-9]  p <= p
[-10] (length(hu_list) = p)
[-11] nth(hu_list, 1) = hu(1)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, 0)
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(0)
[-17] 2 <= p
  |-------
{1}   car(remove(hu_list, 0)) = nth(hu_list, 1)
[2]   v!1 = 0

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1.1.1 : 
;;; the next message is sent to 1

  |-------
[1]   car(remove(hu_list, 0)) = nth(hu_list, 1)

Rerunning step: (grind)
remove rewrites remove(hu_list, 0)
  to cdr(hu_list)
nth rewrites nth(cdr(hu_list), 0)
  to car(cdr(hu_list))
nth rewrites nth(hu_list, 1)
  to car(cdr(hu_list))
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpremid_init.1.2.2.1.2.2.1.1.1.1.

restrictpremid_init.1.2.2.1.2.2.1.1.1.2 : 
;;; the next message is sent to 1

[-1]  rem(p)(p) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + p
[-6]  length(i!2`1) = p - 1
[-7]  length(i!2`2) = p - 1
[-8]  mid < p
[-9]  p <= p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, 0)
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(0)
[-17] 2 <= p
  |-------
{1}   EXISTS (nl1: {x: list[Nonce] | length(x) = mid - 1},
              nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
        conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1)) =
         conc(ilist(remove(hu_list, 1)),
              nlist(append(nl1, cons(n_mid, nl2))))
[2]   v!1 = 0

Rerunning step: (inst 1 "cdr(nl1!1)" "nl2!1")
Instantiating the top quantifier in 1 with the terms: 
 cdr(nl1!1), nl2!1,
this yields  3 subgoals: 
restrictpremid_init.1.2.2.1.2.2.1.1.1.2.1 : 
;;; the next message is sent to 1

[-1]  rem(p)(p) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + p
[-6]  length(i!2`1) = p - 1
[-7]  length(i!2`2) = p - 1
[-8]  mid < p
[-9]  p <= p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, 0)
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(0)
[-17] 2 <= p
  |-------
{1}   conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1)) =
       conc(ilist(remove(hu_list, 1)),
            nlist(append(cdr(nl1!1), cons(n_mid, nl2!1))))
[2]   v!1 = 0

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this yields  2 subgoals: 
restrictpremid_init.1.2.2.1.2.2.1.1.1.2.1.1 : 
;;; the next message is sent to 1

[-1]  rem(p)(p) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + p
[-6]  length(i!2`1) = p - 1
[-7]  length(i!2`2) = p - 1
[-8]  mid < p
[-9]  p <= p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, 0)
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(0)
[-17] 2 <= p
  |-------
{1}   ilist(cons(u!1, cdr(i!2`2))) = ilist(remove(hu_list, 1))
[2]   v!1 = 0

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1.1.2.1.1 : 
;;; the next message is sent to 1

[-1]  rem(p)(p) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + p
[-6]  length(i!2`1) = p - 1
[-7]  length(i!2`2) = p - 1
[-8]  mid < p
[-9]  p <= p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, 0)
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(0)
[-17] 2 <= p
  |-------
{1}   cons(u!1, cdr(i!2`2)) = remove(hu_list, 1)
[2]   v!1 = 0

Rerunning step: (inst -11 "0")
Instantiating the top quantifier in -11 with the terms: 
 0,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1.1.2.1.1 : 
;;; the next message is sent to 1

[-1]  rem(p)(p) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + p
[-6]  length(i!2`1) = p - 1
[-7]  length(i!2`2) = p - 1
[-8]  mid < p
[-9]  p <= p
[-10] (length(hu_list) = p)
{-11} nth(hu_list, 0) = hu(0)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, 0)
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(0)
[-17] 2 <= p
  |-------
[1]   cons(u!1, cdr(i!2`2)) = remove(hu_list, 1)
[2]   v!1 = 0

Rerunning step: (replace -16 1)
Replacing using formula -16,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1.1.2.1.1 : 
;;; the next message is sent to 1

[-1]  rem(p)(p) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + p
[-6]  length(i!2`1) = p - 1
[-7]  length(i!2`2) = p - 1
[-8]  mid < p
[-9]  p <= p
[-10] (length(hu_list) = p)
[-11] nth(hu_list, 0) = hu(0)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, 0)
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(0)
[-17] 2 <= p
  |-------
{1}   cons(hu(0), cdr(i!2`2)) = remove(hu_list, 1)
[2]   v!1 = 0

Rerunning step: (replace -11 1 rl)
Replacing using formula -11,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1.1.2.1.1 : 
;;; the next message is sent to 1

[-1]  rem(p)(p) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + p
[-6]  length(i!2`1) = p - 1
[-7]  length(i!2`2) = p - 1
[-8]  mid < p
[-9]  p <= p
[-10] (length(hu_list) = p)
[-11] nth(hu_list, 0) = hu(0)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, 0)
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(0)
[-17] 2 <= p
  |-------
{1}   cons(nth(hu_list, 0), cdr(i!2`2)) = remove(hu_list, 1)
[2]   v!1 = 0

Rerunning step: (replace -14 1)
Replacing using formula -14,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1.1.2.1.1 : 
;;; the next message is sent to 1

[-1]  rem(p)(p) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + p
[-6]  length(i!2`1) = p - 1
[-7]  length(i!2`2) = p - 1
[-8]  mid < p
[-9]  p <= p
[-10] (length(hu_list) = p)
[-11] nth(hu_list, 0) = hu(0)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, 0)
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(0)
[-17] 2 <= p
  |-------
{1}   cons(nth(hu_list, 0), cdr(remove(hu_list, 0))) = remove(hu_list, 1)
[2]   v!1 = 0

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1.1.2.1.1 : 
;;; the next message is sent to 1

  |-------
[1]   cons(nth(hu_list, 0), cdr(remove(hu_list, 0))) = remove(hu_list, 1)

Rerunning step: (grind)
nth rewrites nth(hu_list, 0)
  to car(hu_list)
remove rewrites remove(hu_list, 0)
  to cdr(hu_list)
remove rewrites remove(cdr(hu_list), 0)
  to cdr(cdr(hu_list))
remove rewrites remove(hu_list, 1)
  to cons(car(hu_list), cdr(cdr(hu_list)))
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpremid_init.1.2.2.1.2.2.1.1.1.2.1.1.

restrictpremid_init.1.2.2.1.2.2.1.1.1.2.1.2 : 
;;; the next message is sent to 1

[-1]  rem(p)(p) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + p
[-6]  length(i!2`1) = p - 1
[-7]  length(i!2`2) = p - 1
[-8]  mid < p
[-9]  p <= p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, 0)
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(0)
[-17] 2 <= p
  |-------
{1}   nlist(i!2`1) = nlist(append(cdr(nl1!1), cons(n_mid, nl2!1)))
[2]   v!1 = 0

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1.1.2.1.2 : 
;;; the next message is sent to 1

[-1]  rem(p)(p) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + p
[-6]  length(i!2`1) = p - 1
[-7]  length(i!2`2) = p - 1
[-8]  mid < p
[-9]  p <= p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, 0)
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(0)
[-17] 2 <= p
  |-------
{1}   i!2`1 = append(cdr(nl1!1), cons(n_mid, nl2!1))
[2]   v!1 = 0

Rerunning step: (typepred "mid")
Adding type constraints for  mid,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1.1.2.1.2 : 
;;; the next message is sent to 1

{-1}  0 < mid
{-2}  mid < p - 1
[-3]  rem(p)(p) = 0
[-4]  i!3 = p
[-5]  P!1 = p
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + p
[-8]  length(i!2`1) = p - 1
[-9]  length(i!2`2) = p - 1
[-10] mid < p
[-11] p <= p
[-12] (length(hu_list) = p)
[-13] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-14] v!1 < mid
[-15] 3 <= p
[-16] i!2`2 = remove(hu_list, 0)
[-17] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-18] u!1 = hu(0)
[-19] 2 <= p
  |-------
[1]   i!2`1 = append(cdr(nl1!1), cons(n_mid, nl2!1))
[2]   v!1 = 0

Rerunning step: (delete -2 -3
                  -4 -5
                  -7 -8
                  -9 -10
                  -11 -12
                  -13 -14
                  -15 -16
                  -18 -19
                  2)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1.1.2.1.2 : 
;;; the next message is sent to 1

[-1]  0 < mid
[-2]  length(nl1!1) = mid
[-3]  cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
  |-------
[1]   i!2`1 = append(cdr(nl1!1), cons(n_mid, nl2!1))

Rerunning step: (lemma "more_list_props[Identity].length_non_zero"
                 ("l" "nl1!1"))
Applying more_list_props[Identity].length_non_zero where 
  l gets nl1!1,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1.1.2.1.2 : 
;;; the next message is sent to 1

{-1}  length(nl1!1) > 0 IFF cons?(nl1!1)
[-2]  0 < mid
[-3]  length(nl1!1) = mid
[-4]  cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
  |-------
[1]   i!2`1 = append(cdr(nl1!1), cons(n_mid, nl2!1))

Rerunning step: (expand "append" -4)
Expanding the definition of append,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1.1.2.1.2 : 
;;; the next message is sent to 1

[-1]  length(nl1!1) > 0 IFF cons?(nl1!1)
[-2]  0 < mid
[-3]  length(nl1!1) = mid
{-4}  cons(i!1, i!2`1) =
       CASES nl1!1
         OF null: cons(n_mid, nl2!1),
            cons(x, y): cons(x, append(y, cons(n_mid, nl2!1)))
         ENDCASES
  |-------
[1]   i!2`1 = append(cdr(nl1!1), cons(n_mid, nl2!1))

Rerunning step: (ground)
Applying propositional simplification and decision procedures,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1.1.2.1.2 : 
;;; the next message is sent to 1

{-1}  length(nl1!1) > 0
{-2}  cons?(nl1!1)
[-3]  0 < mid
[-4]  length(nl1!1) = mid
{-5}  cons(i!1, i!2`1) =
       cons(car(nl1!1), append(cdr(nl1!1), cons(n_mid, nl2!1)))
  |-------
[1]   i!2`1 = append(cdr(nl1!1), cons(n_mid, nl2!1))

Rerunning step: (decompose-equality -5)
Applying decompose-equality,

This completes the proof of restrictpremid_init.1.2.2.1.2.2.1.1.1.2.1.2.


This completes the proof of restrictpremid_init.1.2.2.1.2.2.1.1.1.2.1.

restrictpremid_init.1.2.2.1.2.2.1.1.1.2.2 (TCC):   

[-1]  rem(p)(p) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + p
[-6]  length(i!2`1) = p - 1
[-7]  length(i!2`2) = p - 1
[-8]  mid < p
[-9]  p <= p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, 0)
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(0)
[-17] 2 <= p
  |-------
{1}   length[Nonce](cdr[Nonce](nl1!1)) = mid - 1
[2]   v!1 = 0

Rerunning step: (rewrite "length_cdr" 1)
Found matching substitution:
cons_l: (cons?[T]) gets nl1!1,
Rewriting using length_cdr, matching in 1,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1.1.2.2 : 
;;; the next message is sent to 1

[-1]  rem(p)(p) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + p
[-6]  length(i!2`1) = p - 1
[-7]  length(i!2`2) = p - 1
[-8]  mid < p
[-9]  p <= p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, 0)
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(0)
[-17] 2 <= p
  |-------
{1}   length(nl1!1) - 1 = mid - 1
[2]   v!1 = 0

Rerunning step: (replace -4 1)
Replacing using formula -4,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1.1.2.2 : 
;;; the next message is sent to 1

[-1]  rem(p)(p) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + p
[-6]  length(i!2`1) = p - 1
[-7]  length(i!2`2) = p - 1
[-8]  mid < p
[-9]  p <= p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, 0)
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(0)
[-17] 2 <= p
  |-------
{1}   TRUE
[2]   v!1 = 0

which is trivially true.

This completes the proof of restrictpremid_init.1.2.2.1.2.2.1.1.1.2.2.

restrictpremid_init.1.2.2.1.2.2.1.1.1.2.3 (TCC):   

[-1]  rem(p)(p) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + p
[-6]  length(i!2`1) = p - 1
[-7]  length(i!2`2) = p - 1
[-8]  mid < p
[-9]  p <= p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, 0)
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(0)
[-17] 2 <= p
  |-------
{1}   cons?[Nonce](nl1!1)
[2]   v!1 = 0

Rerunning step: (typepred "mid")
Adding type constraints for  mid,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1.1.2.3 : 
;;; the next message is sent to 1

{-1}  0 < mid
{-2}  mid < p - 1
[-3]  rem(p)(p) = 0
[-4]  i!3 = p
[-5]  P!1 = p
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + p
[-8]  length(i!2`1) = p - 1
[-9]  length(i!2`2) = p - 1
[-10] mid < p
[-11] p <= p
[-12] (length(hu_list) = p)
[-13] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-14] v!1 < mid
[-15] 3 <= p
[-16] i!2`2 = remove(hu_list, 0)
[-17] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-18] u!1 = hu(0)
[-19] 2 <= p
  |-------
[1]   cons?[Nonce](nl1!1)
[2]   v!1 = 0

Rerunning step: (lemma "more_list_props[Identity].length_non_zero"
                 ("l" "nl1!1"))
Applying more_list_props[Identity].length_non_zero where 
  l gets nl1!1,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1.1.2.3 : 
;;; the next message is sent to 1

{-1}  length(nl1!1) > 0 IFF cons?(nl1!1)
[-2]  0 < mid
[-3]  mid < p - 1
[-4]  rem(p)(p) = 0
[-5]  i!3 = p
[-6]  P!1 = p
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -1 - mid + p
[-9]  length(i!2`1) = p - 1
[-10] length(i!2`2) = p - 1
[-11] mid < p
[-12] p <= p
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] v!1 < mid
[-16] 3 <= p
[-17] i!2`2 = remove(hu_list, 0)
[-18] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-19] u!1 = hu(0)
[-20] 2 <= p
  |-------
[1]   cons?[Nonce](nl1!1)
[2]   v!1 = 0

Rerunning step: (delete -3 -4
                  -5 -6
                  -8 -9
                  -10 -11
                  -12 -13
                  -14 -15
                  -16 -17
                  -18 -19
                  -20 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1.1.2.3 : 
;;; the next message is sent to 1

[-1]  length(nl1!1) > 0 IFF cons?(nl1!1)
[-2]  0 < mid
[-3]  length(nl1!1) = mid
  |-------
[1]   cons?[Nonce](nl1!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_init.1.2.2.1.2.2.1.1.1.2.3.


This completes the proof of restrictpremid_init.1.2.2.1.2.2.1.1.1.2.


This completes the proof of restrictpremid_init.1.2.2.1.2.2.1.1.1.

restrictpremid_init.1.2.2.1.2.2.1.1.2 (TCC):   

[-1]  rem(p)(i!3) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  length(i!2`1) = P!1 - 1
[-7]  length(i!2`2) = P!1 - 1
[-8]  mid < i!3
[-9]  i!3 <= p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, rem(p)(i!3))
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(rem(p)(i!3))
[-17] 2 <= P!1
  |-------
{1}   1 <= v!1
[2]   v!1 = 0

Rerunning step: (comment "this is why we needed the v!1=0 consequent")
Adding comment: this is why we needed the v!1=0 consequent
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1.2 : 
;;; this is why we needed the v!1=0 consequent

[-1]  rem(p)(i!3) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  length(i!2`1) = P!1 - 1
[-7]  length(i!2`2) = P!1 - 1
[-8]  mid < i!3
[-9]  i!3 <= p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, rem(p)(i!3))
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(rem(p)(i!3))
[-17] 2 <= P!1
  |-------
[1]   1 <= v!1
[2]   v!1 = 0

Rerunning step: (delete -)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.1.2 : 
;;; this is why we needed the v!1=0 consequent

  |-------
[1]   1 <= v!1
[2]   v!1 = 0

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_init.1.2.2.1.2.2.1.1.2.


This completes the proof of restrictpremid_init.1.2.2.1.2.2.1.1.

restrictpremid_init.1.2.2.1.2.2.1.2 : 
;;; split up 1

[-1]  rem(p)(i!3) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  length(i!2`1) = P!1 - 1
[-7]  length(i!2`2) = P!1 - 1
[-8]  mid < i!3
[-9]  i!3 <= p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, rem(p)(i!3))
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(rem(p)(i!3))
[-17] 2 <= P!1
  |-------
{1}   cons(u!1, i!2`2) = hu_list
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (replace* -1)
Repeatedly applying the replace rule,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.2 : 
;;; split up 1

[-1]  rem(p)(i!3) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  length(i!2`1) = P!1 - 1
[-7]  length(i!2`2) = P!1 - 1
[-8]  mid < i!3
[-9]  i!3 <= p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 3 <= p
{-14} i!2`2 = remove(hu_list, 0)
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
{-16} u!1 = hu(0)
[-17] 2 <= P!1
  |-------
[1]   cons(u!1, i!2`2) = hu_list
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (inst -11 "0")
Instantiating the top quantifier in -11 with the terms: 
 0,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.2 : 
;;; split up 1

[-1]  rem(p)(i!3) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  length(i!2`1) = P!1 - 1
[-7]  length(i!2`2) = P!1 - 1
[-8]  mid < i!3
[-9]  i!3 <= p
[-10] (length(hu_list) = p)
{-11} nth(hu_list, 0) = hu(0)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, 0)
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(0)
[-17] 2 <= P!1
  |-------
[1]   cons(u!1, i!2`2) = hu_list
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (expand "remove" -14)
Expanding the definition of remove,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.2 : 
;;; split up 1

[-1]  rem(p)(i!3) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  length(i!2`1) = P!1 - 1
[-7]  length(i!2`2) = P!1 - 1
[-8]  mid < i!3
[-9]  i!3 <= p
[-10] (length(hu_list) = p)
[-11] nth(hu_list, 0) = hu(0)
[-12] v!1 < mid
[-13] 3 <= p
{-14} i!2`2 = cdr(hu_list)
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(0)
[-17] 2 <= P!1
  |-------
[1]   cons(u!1, i!2`2) = hu_list
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (replace -14 1)
Replacing using formula -14,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.2 : 
;;; split up 1

[-1]  rem(p)(i!3) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  length(i!2`1) = P!1 - 1
[-7]  length(i!2`2) = P!1 - 1
[-8]  mid < i!3
[-9]  i!3 <= p
[-10] (length(hu_list) = p)
[-11] nth(hu_list, 0) = hu(0)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = cdr(hu_list)
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(0)
[-17] 2 <= P!1
  |-------
{1}   cons(u!1, cdr(hu_list)) = hu_list
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (replace -16 1)
Replacing using formula -16,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.2 : 
;;; split up 1

[-1]  rem(p)(i!3) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  length(i!2`1) = P!1 - 1
[-7]  length(i!2`2) = P!1 - 1
[-8]  mid < i!3
[-9]  i!3 <= p
[-10] (length(hu_list) = p)
[-11] nth(hu_list, 0) = hu(0)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = cdr(hu_list)
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(0)
[-17] 2 <= P!1
  |-------
{1}   cons(hu(0), cdr(hu_list)) = hu_list
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (replace -11 1 rl)
Replacing using formula -11,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.2 : 
;;; split up 1

[-1]  rem(p)(i!3) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  length(i!2`1) = P!1 - 1
[-7]  length(i!2`2) = P!1 - 1
[-8]  mid < i!3
[-9]  i!3 <= p
[-10] (length(hu_list) = p)
[-11] nth(hu_list, 0) = hu(0)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = cdr(hu_list)
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(0)
[-17] 2 <= P!1
  |-------
{1}   cons(nth(hu_list, 0), cdr(hu_list)) = hu_list
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.2 : 
;;; split up 1

  |-------
[1]   cons(nth(hu_list, 0), cdr(hu_list)) = hu_list

Rerunning step: (expand "nth")
Expanding the definition of nth,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.2 : 
;;; split up 1

  |-------
{1}   cons(car(hu_list), cdr(hu_list)) = hu_list

Rerunning step: (rewrite "list_cons_eta")
Found matching substitution:
cons?_var: (cons?) gets hu_list,
Rewriting using list_cons_eta, matching in *,

This completes the proof of restrictpremid_init.1.2.2.1.2.2.1.2.

restrictpremid_init.1.2.2.1.2.2.1.3 : 
;;; split up 1

[-1]  rem(p)(i!3) = 0
[-2]  i!3 = p
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  length(i!2`1) = P!1 - 1
[-7]  length(i!2`2) = P!1 - 1
[-8]  mid < i!3
[-9]  i!3 <= p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 3 <= p
[-14] i!2`2 = remove(hu_list, rem(p)(i!3))
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(rem(p)(i!3))
[-17] 2 <= P!1
  |-------
{1}   nth(i!2`1,
          floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
       = n_mid
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (lemma "select_right_nonce1" ("P" "P!1"))
Applying select_right_nonce1 where 
  P gets P!1,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.3 : 
;;; split up 1

{-1}  (P!1 = p IMPLIES floor(((mid - 1) / (p - 2)) * (P!1 - 2)) = mid - 1)
       AND
       floor(((mid - 1) / (p - 2)) * (P!1 - 2)) >= 0 AND
        floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1
[-2]  rem(p)(i!3) = 0
[-3]  i!3 = p
[-4]  P!1 = p
[-5]  length(nl1!1) = mid
[-6]  length(nl2!1) = -1 - mid + i!3
[-7]  length(i!2`1) = P!1 - 1
[-8]  length(i!2`2) = P!1 - 1
[-9]  mid < i!3
[-10] i!3 <= p
[-11] (length(hu_list) = p)
[-12] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-13] v!1 < mid
[-14] 3 <= p
[-15] i!2`2 = remove(hu_list, rem(p)(i!3))
[-16] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-17] u!1 = hu(rem(p)(i!3))
[-18] 2 <= P!1
  |-------
[1]   nth(i!2`1,
          floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
       = n_mid
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.3 : 
;;; split up 1

{-1}  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) = mid - 1
{-2}  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) >= 0
{-3}  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1
[-4]  rem(p)(i!3) = 0
[-5]  i!3 = p
[-6]  P!1 = p
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -1 - mid + i!3
[-9]  length(i!2`1) = P!1 - 1
[-10] length(i!2`2) = P!1 - 1
[-11] mid < i!3
[-12] i!3 <= p
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] v!1 < mid
[-16] 3 <= p
[-17] i!2`2 = remove(hu_list, rem(p)(i!3))
[-18] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-19] u!1 = hu(rem(p)(i!3))
[-20] 2 <= P!1
  |-------
[1]   nth(i!2`1,
          floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
       = n_mid
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.3 : 
;;; split up 1

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) = mid - 1
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) >= 0
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1
[-4]  rem(p)(i!3) = 0
[-5]  i!3 = p
[-6]  P!1 = p
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -1 - mid + i!3
[-9]  length(i!2`1) = P!1 - 1
[-10] length(i!2`2) = P!1 - 1
[-11] mid < i!3
[-12] i!3 <= p
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] v!1 < mid
[-16] 3 <= p
[-17] i!2`2 = remove(hu_list, rem(p)(i!3))
[-18] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-19] u!1 = hu(rem(p)(i!3))
[-20] 2 <= P!1
  |-------
{1}   nth(i!2`1, mid - 1) = n_mid
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (lemma "listprops[Identity].equality_nth"
                 ("l1" "cons(i!1,i!2`1)" "l2"
                  "append(nl1!1,cons(n_mid,nl2!1))"))
Applying listprops[Identity].equality_nth where 
  l1 gets cons(i!1, i!2`1),
  l2 gets append(nl1!1, cons(n_mid, nl2!1)),
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.3 : 
;;; split up 1

{-1}  cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1)) IMPLIES
       FORALL (i: below[length[Identity](cons(i!1, i!2`1))]):
         nth(cons(i!1, i!2`1), i) =
          nth(append(nl1!1, cons(n_mid, nl2!1)), i)
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) = mid - 1
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) >= 0
[-4]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1
[-5]  rem(p)(i!3) = 0
[-6]  i!3 = p
[-7]  P!1 = p
[-8]  length(nl1!1) = mid
[-9]  length(nl2!1) = -1 - mid + i!3
[-10] length(i!2`1) = P!1 - 1
[-11] length(i!2`2) = P!1 - 1
[-12] mid < i!3
[-13] i!3 <= p
[-14] (length(hu_list) = p)
[-15] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-16] v!1 < mid
[-17] 3 <= p
[-18] i!2`2 = remove(hu_list, rem(p)(i!3))
[-19] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-20] u!1 = hu(rem(p)(i!3))
[-21] 2 <= P!1
  |-------
[1]   nth(i!2`1, mid - 1) = n_mid
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.3 : 
;;; split up 1

{-1}  FORALL (i: below[length[Identity](cons(i!1, i!2`1))]):
        nth(cons(i!1, i!2`1), i) = nth(append(nl1!1, cons(n_mid, nl2!1)), i)
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) = mid - 1
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) >= 0
[-4]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1
[-5]  rem(p)(i!3) = 0
[-6]  i!3 = p
[-7]  P!1 = p
[-8]  length(nl1!1) = mid
[-9]  length(nl2!1) = -1 - mid + i!3
[-10] length(i!2`1) = P!1 - 1
[-11] length(i!2`2) = P!1 - 1
[-12] mid < i!3
[-13] i!3 <= p
[-14] (length(hu_list) = p)
[-15] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-16] v!1 < mid
[-17] 3 <= p
[-18] i!2`2 = remove(hu_list, rem(p)(i!3))
[-19] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-20] u!1 = hu(rem(p)(i!3))
[-21] 2 <= P!1
  |-------
[1]   nth(i!2`1, mid - 1) = n_mid
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (inst -1 "mid")
Instantiating the top quantifier in -1 with the terms: 
 mid,
this yields  2 subgoals: 
restrictpremid_init.1.2.2.1.2.2.1.3.1 : 
;;; split up 1

{-1}  nth(cons(i!1, i!2`1), mid) =
       nth(append(nl1!1, cons(n_mid, nl2!1)), mid)
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) = mid - 1
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) >= 0
[-4]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1
[-5]  rem(p)(i!3) = 0
[-6]  i!3 = p
[-7]  P!1 = p
[-8]  length(nl1!1) = mid
[-9]  length(nl2!1) = -1 - mid + i!3
[-10] length(i!2`1) = P!1 - 1
[-11] length(i!2`2) = P!1 - 1
[-12] mid < i!3
[-13] i!3 <= p
[-14] (length(hu_list) = p)
[-15] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-16] v!1 < mid
[-17] 3 <= p
[-18] i!2`2 = remove(hu_list, rem(p)(i!3))
[-19] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-20] u!1 = hu(rem(p)(i!3))
[-21] 2 <= P!1
  |-------
[1]   nth(i!2`1, mid - 1) = n_mid
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (rewrite "nth_append" -1)
Found matching substitution:
i: below[length(l1) + length(l2)] gets mid,
l2: list[T] gets cons(n_mid, nl2!1),
l1: list[T] gets nl1!1,
Rewriting using nth_append, matching in -1,
this yields  2 subgoals: 
restrictpremid_init.1.2.2.1.2.2.1.3.1.1 : 
;;; split up 1

{-1}  nth(cons(i!1, i!2`1), mid) =
       nth(cons(n_mid, nl2!1), mid - length[Identity](nl1!1))
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) = mid - 1
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) >= 0
[-4]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1
[-5]  rem(p)(i!3) = 0
[-6]  i!3 = p
[-7]  P!1 = p
[-8]  length(nl1!1) = mid
[-9]  length(nl2!1) = -1 - mid + i!3
[-10] length(i!2`1) = P!1 - 1
[-11] length(i!2`2) = P!1 - 1
[-12] mid < i!3
[-13] i!3 <= p
[-14] (length(hu_list) = p)
[-15] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-16] v!1 < mid
[-17] 3 <= p
[-18] i!2`2 = remove(hu_list, rem(p)(i!3))
[-19] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-20] u!1 = hu(rem(p)(i!3))
[-21] 2 <= P!1
  |-------
[1]   nth(i!2`1, mid - 1) = n_mid
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (replace -8 -1)
Replacing using formula -8,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.3.1.1 : 
;;; split up 1

{-1}  nth(cons(i!1, i!2`1), mid) = nth(cons(n_mid, nl2!1), mid - mid)
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) = mid - 1
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) >= 0
[-4]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1
[-5]  rem(p)(i!3) = 0
[-6]  i!3 = p
[-7]  P!1 = p
[-8]  length(nl1!1) = mid
[-9]  length(nl2!1) = -1 - mid + i!3
[-10] length(i!2`1) = P!1 - 1
[-11] length(i!2`2) = P!1 - 1
[-12] mid < i!3
[-13] i!3 <= p
[-14] (length(hu_list) = p)
[-15] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-16] v!1 < mid
[-17] 3 <= p
[-18] i!2`2 = remove(hu_list, rem(p)(i!3))
[-19] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-20] u!1 = hu(rem(p)(i!3))
[-21] 2 <= P!1
  |-------
[1]   nth(i!2`1, mid - 1) = n_mid
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (delete -2 -3
                  -4 -5
                  -6 -7
                  -8 -9
                  -10 -11
                  -12 -13
                  -14 -15
                  -16 -17
                  -18 -19
                  -20 -21
                  2)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.3.1.1 : 
;;; split up 1

[-1]  nth(cons(i!1, i!2`1), mid) = nth(cons(n_mid, nl2!1), mid - mid)
  |-------
[1]   nth(i!2`1, mid - 1) = n_mid

Rerunning step: (expand "nth" -1)
Expanding the definition of nth,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.3.1.1 : 
;;; split up 1

{-1}  nth(i!2`1, mid - 1) = n_mid
  |-------
[1]   nth(i!2`1, mid - 1) = n_mid

which is trivially true.

This completes the proof of restrictpremid_init.1.2.2.1.2.2.1.3.1.1.

restrictpremid_init.1.2.2.1.2.2.1.3.1.2 : 
;;; split up 1

[-1]  nth(cons(i!1, i!2`1), mid) =
       nth(append(nl1!1, cons(n_mid, nl2!1)), mid)
{-2}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) =
       mid - 1
{-3}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
{-4}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-5]  rem(p)(i!3) = 0
[-6]  i!3 = p
[-7]  P!1 = p
[-8]  length(nl1!1) = mid
[-9]  length(nl2!1) = -1 - mid + i!3
[-10] length(i!2`1) = P!1 - 1
[-11] length(i!2`2) = P!1 - 1
[-12] mid < i!3
[-13] i!3 <= p
[-14] (length(hu_list) = p)
[-15] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-16] v!1 < mid
[-17] 3 <= p
[-18] i!2`2 = remove(hu_list, rem(p)(i!3))
[-19] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-20] u!1 = hu(rem(p)(i!3))
[-21] 2 <= P!1
  |-------
{1}   mid <
       length[Identity](cons[Nonce](n_mid, nl2!1)) + length[Identity](nl1!1)
[2]   nth(i!2`1, mid - 1) = n_mid
[3]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (expand "length" 1 1)
Expanding the definition of length,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.3.1.2 : 
;;; split up 1

[-1]  nth(cons(i!1, i!2`1), mid) =
       nth(append(nl1!1, cons(n_mid, nl2!1)), mid)
[-2]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) =
       mid - 1
[-3]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
[-4]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-5]  rem(p)(i!3) = 0
[-6]  i!3 = p
[-7]  P!1 = p
[-8]  length(nl1!1) = mid
[-9]  length(nl2!1) = -1 - mid + i!3
[-10] length(i!2`1) = P!1 - 1
[-11] length(i!2`2) = P!1 - 1
[-12] mid < i!3
[-13] i!3 <= p
[-14] (length(hu_list) = p)
[-15] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-16] v!1 < mid
[-17] 3 <= p
[-18] i!2`2 = remove(hu_list, rem(p)(i!3))
[-19] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-20] u!1 = hu(rem(p)(i!3))
[-21] 2 <= P!1
  |-------
{1}   mid < 1 + length[Identity](nl1!1) + length[Identity](nl2!1)
[2]   nth(i!2`1, mid - 1) = n_mid
[3]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (delete -1 -2
                  -3 -4
                  -5 -6
                  -7 -10
                  -11 -13
                  -14 -15
                  -16 -17
                  -18 -19
                  -20 -21
                  2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.3.1.2 : 
;;; split up 1

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  mid < i!3
  |-------
[1]   mid < 1 + length[Identity](nl1!1) + length[Identity](nl2!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_init.1.2.2.1.2.2.1.3.1.2.


This completes the proof of restrictpremid_init.1.2.2.1.2.2.1.3.1.

restrictpremid_init.1.2.2.1.2.2.1.3.2 (TCC):   

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) = mid - 1
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) >= 0
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1
[-4]  rem(p)(i!3) = 0
[-5]  i!3 = p
[-6]  P!1 = p
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -1 - mid + i!3
[-9]  length(i!2`1) = P!1 - 1
[-10] length(i!2`2) = P!1 - 1
[-11] mid < i!3
[-12] i!3 <= p
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] v!1 < mid
[-16] 3 <= p
[-17] i!2`2 = remove(hu_list, rem(p)(i!3))
[-18] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-19] u!1 = hu(rem(p)(i!3))
[-20] 2 <= P!1
  |-------
{1}   mid < length[Identity](cons[Nonce](i!1, i!2`1))
[2]   nth(i!2`1, mid - 1) = n_mid
[3]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (expand "length" 1)
Expanding the definition of length,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.3.2 : 
;;; split up 1

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) = mid - 1
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) >= 0
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1
[-4]  rem(p)(i!3) = 0
[-5]  i!3 = p
[-6]  P!1 = p
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -1 - mid + i!3
[-9]  length(i!2`1) = P!1 - 1
[-10] length(i!2`2) = P!1 - 1
[-11] mid < i!3
[-12] i!3 <= p
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] v!1 < mid
[-16] 3 <= p
[-17] i!2`2 = remove(hu_list, rem(p)(i!3))
[-18] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-19] u!1 = hu(rem(p)(i!3))
[-20] 2 <= P!1
  |-------
{1}   mid < 1 + length[Identity](i!2`1)
[2]   nth(i!2`1, mid - 1) = n_mid
[3]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (replace -9 1)
Replacing using formula -9,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.1.3.2 : 
;;; split up 1

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) = mid - 1
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) >= 0
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1
[-4]  rem(p)(i!3) = 0
[-5]  i!3 = p
[-6]  P!1 = p
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -1 - mid + i!3
[-9]  length(i!2`1) = P!1 - 1
[-10] length(i!2`2) = P!1 - 1
[-11] mid < i!3
[-12] i!3 <= p
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] v!1 < mid
[-16] 3 <= p
[-17] i!2`2 = remove(hu_list, rem(p)(i!3))
[-18] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-19] u!1 = hu(rem(p)(i!3))
[-20] 2 <= P!1
  |-------
{1}   mid < 1 + (P!1 - 1)
[2]   nth(i!2`1, mid - 1) = n_mid
[3]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (replace* -5 -6)
Repeatedly applying the replace rule,

This completes the proof of restrictpremid_init.1.2.2.1.2.2.1.3.2.


This completes the proof of restrictpremid_init.1.2.2.1.2.2.1.3.


This completes the proof of restrictpremid_init.1.2.2.1.2.2.1.

restrictpremid_init.1.2.2.1.2.2.2 : 
;;; establish some equalities first

{-1}  i!3 = p
{-2}  P!1 = p
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + i!3
[-5]  length(i!2`1) = P!1 - 1
[-6]  length(i!2`2) = P!1 - 1
[-7]  mid < i!3
[-8]  i!3 <= p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] v!1 < mid
[-12] 3 <= p
[-13] i!2`2 = remove(hu_list, rem(p)(i!3))
[-14] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-15] u!1 = hu(rem(p)(i!3))
[-16] 2 <= P!1
  |-------
{1}   rem(p)(i!3) = 0
[2]   v!1 = 0 AND
       cons(u!1, i!2`2) = hu_list AND
        nth(i!2`1,
            floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
         = n_mid
[3]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.2 : 
;;; establish some equalities first

[-1]  i!3 = p
[-2]  P!1 = p
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + i!3
[-5]  length(i!2`1) = P!1 - 1
[-6]  length(i!2`2) = P!1 - 1
[-7]  mid < i!3
[-8]  i!3 <= p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] v!1 < mid
[-12] 3 <= p
[-13] i!2`2 = remove(hu_list, rem(p)(i!3))
[-14] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-15] u!1 = hu(rem(p)(i!3))
[-16] 2 <= P!1
  |-------
{1}   rem(p)(p) = 0
[2]   v!1 = 0 AND
       cons(u!1, i!2`2) = hu_list AND
        nth(i!2`1,
            floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
         = n_mid
[3]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.2 : 
;;; establish some equalities first

  |-------
[1]   rem(p)(p) = 0

Rerunning step: (rewrite "rem_def")
Found matching substitution:
r: mod(b) gets 0,
x: int gets p,
b: posnat gets p,
Rewriting using rem_def, matching in *,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.2 : 
;;; establish some equalities first

  |-------
{1}   EXISTS q: p = p * q

Rerunning step: (inst 1 "1")
Instantiating the top quantifier in 1 with the terms: 
 1,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.2 : 
;;; establish some equalities first

  |-------
{1}   p = p * 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_init.1.2.2.1.2.2.2.

restrictpremid_init.1.2.2.1.2.2.3 : 
;;; establish some equalities first

{-1}  P!1 = p
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  length(i!2`1) = P!1 - 1
[-5]  length(i!2`2) = P!1 - 1
[-6]  mid < i!3
[-7]  i!3 <= p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] v!1 < mid
[-11] 3 <= p
[-12] i!2`2 = remove(hu_list, rem(p)(i!3))
[-13] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-14] u!1 = hu(rem(p)(i!3))
[-15] 2 <= P!1
  |-------
{1}   i!3 = p
[2]   v!1 = 0 AND
       cons(u!1, i!2`2) = hu_list AND
        nth(i!2`1,
            floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
         = n_mid
[3]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (delete -5 -6 -7 -8 -9 -10 -11 -12 -14 -15 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.3 : 
;;; establish some equalities first

[-1]  P!1 = p
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  length(i!2`1) = P!1 - 1
[-5]  cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
  |-------
[1]   i!3 = p

Rerunning step: (lemma "listprops[Identity].equality_length"
                 ("l1" "cons(i!1,i!2`1)" "l2"
                  "append(nl1!1,cons(n_mid,nl2!1))"))
Applying listprops[Identity].equality_length where 
  l1 gets cons(i!1, i!2`1),
  l2 gets append(nl1!1, cons(n_mid, nl2!1)),
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.3 : 
;;; establish some equalities first

{-1}  cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1)) IMPLIES
       length[Identity](cons(i!1, i!2`1)) =
        length[Identity](append(nl1!1, cons(n_mid, nl2!1)))
[-2]  P!1 = p
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + i!3
[-5]  length(i!2`1) = P!1 - 1
[-6]  cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
  |-------
[1]   i!3 = p

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.3 : 
;;; establish some equalities first

{-1}  length[Identity](cons(i!1, i!2`1)) =
       length[Identity](append(nl1!1, cons(n_mid, nl2!1)))
[-2]  P!1 = p
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + i!3
[-5]  length(i!2`1) = P!1 - 1
[-6]  cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
  |-------
[1]   i!3 = p

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets cons(n_mid, nl2!1),
l1: list[T] gets nl1!1,
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.3 : 
;;; establish some equalities first

{-1}  length[Identity](cons(i!1, i!2`1)) =
       length(cons(n_mid, nl2!1)) + length(nl1!1)
[-2]  P!1 = p
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + i!3
[-5]  length(i!2`1) = P!1 - 1
[-6]  cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
  |-------
[1]   i!3 = p

Rerunning step: (expand "length" -1 (1 2))
Expanding the definition of length,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.3 : 
;;; establish some equalities first

{-1}  length[Identity](i!2`1) = length(nl1!1) + length[Identity](nl2!1)
[-2]  P!1 = p
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + i!3
[-5]  length(i!2`1) = P!1 - 1
[-6]  cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
  |-------
[1]   i!3 = p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_init.1.2.2.1.2.2.3.

restrictpremid_init.1.2.2.1.2.2.4 : 
;;; establish some equalities first

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  mid < i!3
[-6]  i!3 <= p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  v!1 < mid
[-10] 3 <= p
[-11] i!2`2 = remove(hu_list, rem(p)(i!3))
[-12] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-13] u!1 = hu(rem(p)(i!3))
[-14] 2 <= P!1
  |-------
{1}   P!1 = p
[2]   v!1 = 0 AND
       cons(u!1, i!2`2) = hu_list AND
        nth(i!2`1,
            floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
         = n_mid
[3]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (delete -1 -2 -3 -5 -6 -8 -9 -12 -13 -14 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.4 : 
;;; establish some equalities first

[-1]  length(i!2`2) = P!1 - 1
[-2]  (length(hu_list) = p)
[-3]  3 <= p
[-4]  i!2`2 = remove(hu_list, rem(p)(i!3))
  |-------
[1]   P!1 = p

Rerunning step: (replace -4 -1)
Replacing using formula -4,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.4 : 
;;; establish some equalities first

{-1}  length(remove(hu_list, rem(p)(i!3))) = P!1 - 1
[-2]  (length(hu_list) = p)
[-3]  3 <= p
[-4]  i!2`2 = remove(hu_list, rem(p)(i!3))
  |-------
[1]   P!1 = p

Rerunning step: (rewrite "length_remove" -1 :dir rl)
Found matching substitution:
i: below[length(c)] gets rem(p)(i!3),
c: (cons?[T]) gets hu_list,
Rewriting using length_remove, matching in -1,
this yields  2 subgoals: 
restrictpremid_init.1.2.2.1.2.2.4.1 : 
;;; establish some equalities first

{-1}  length[Identity](hu_list) - 1 = P!1 - 1
[-2]  (length(hu_list) = p)
[-3]  3 <= p
[-4]  i!2`2 = remove(hu_list, rem(p)(i!3))
  |-------
[1]   P!1 = p

Rerunning step: (replace -2 -1)
Replacing using formula -2,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.4.1 : 
;;; establish some equalities first

{-1}  p - 1 = P!1 - 1
[-2]  (length(hu_list) = p)
[-3]  3 <= p
[-4]  i!2`2 = remove(hu_list, rem(p)(i!3))
  |-------
[1]   P!1 = p

Rerunning step: (delete -2 -3 -4)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.4.1 : 
;;; establish some equalities first

[-1]  p - 1 = P!1 - 1
  |-------
[1]   P!1 = p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_init.1.2.2.1.2.2.4.1.

restrictpremid_init.1.2.2.1.2.2.4.2 : 
;;; establish some equalities first

[-1]  length(remove(hu_list, rem(p)(i!3))) = P!1 - 1
[-2]  (length(hu_list) = p)
[-3]  3 <= p
[-4]  i!2`2 = remove(hu_list, rem(p)(i!3))
  |-------
{1}   cons?[Identity](hu_list)
[2]   P!1 = p

Rerunning step: (delete -1 -2 -4 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.2.4.2 : 
;;; establish some equalities first

[-1]  3 <= p
  |-------
[1]   cons?[Identity](hu_list)

Rerunning step: (nonemptylist "hu_list")
Relating existence of a tail to a list's length,

This completes the proof of restrictpremid_init.1.2.2.1.2.2.4.2.


This completes the proof of restrictpremid_init.1.2.2.1.2.2.4.


This completes the proof of restrictpremid_init.1.2.2.1.2.2.

restrictpremid_init.1.2.2.1.2.3 : 
;;; explore the 3 options that could make -1 true

{-1}  EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(u!1) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)) =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))
[-2]  2 <= P!1
  |-------
[1]   v!1 = 0 AND
       cons(u!1, i!2`2) = hu_list AND
        nth(i!2`1,
            floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))))
         = n_mid
[2]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (delete -2 +)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.3 : 
;;; explore the 3 options that could make -1 true

[-1]  EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(u!1) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)) =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))
  |-------

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictpremid_init.1.2.2.1.2.3 : 
;;; explore the 3 options that could make -1 true

{-1}  public(u!1) = public(hu(i!3))
{-2}  conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)) =
       conc(ilist(remove(hu_list, i!3)),
            nlist(append(nl1!1, cons(n_mid, nl2!1))))
  |-------

Rerunning step: (decompose-equality -2)
Applying decompose-equality,

This completes the proof of restrictpremid_init.1.2.2.1.2.3.


This completes the proof of restrictpremid_init.1.2.2.1.2.


This completes the proof of restrictpremid_init.1.2.2.1.

restrictpremid_init.1.2.2.2 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
[-3]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-4]  2 <= P!1
  |-------
{1}   (Stop[event] # R_premid(v!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
{2}   R_premid(v!1)
              (trans(u!1, car(i!2`2),
                     E(public(car(i!2`2)),
                       conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1)))))
{3}   trans(u!1, car(i!2`2),
            E(public(car(i!2`2)),
              conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
       >> (Stop[event] # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   R_premid(v!1)
              (signal(running(0, cons(u!1, i!2`2),
                              nth(i!2`1,
                                  floor(((mid - 1) / (p - 2)) * P!1
                                        -
                                        2 * ((mid - 1) / (p - 2)))))))

Rerunning step: (delete - 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.1.2.2.2 :  

  |-------
[1]   (Stop[event] # R_premid(v!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictpremid_init.1.2.2.2.


This completes the proof of restrictpremid_init.1.2.2.


This completes the proof of restrictpremid_init.1.2.


This completes the proof of restrictpremid_init.1.

restrictpremid_init.2 :  

{-1}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
{-2}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       length[Nonce](i!2`1)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, i`1)), ilist(i`2))))
            >>
            (signal(running(0, cons(u!1, i`2),
                            nth(i`1,
                                floor(((mid - 1) / (p - 2)) * P!1
                                      -
                                      2 * ((mid - 1) / (p - 2))))))
              >>
              (trans(u!1, car(i`2),
                     E(public(car(i`2)),
                       conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
                >> Stop[event]))))
         # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (typepred "i!2`1")
Adding type constraints for  i!2`1,
this simplifies to: 
restrictpremid_init.2 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`1)
{-2}  length(i!2`1) = P!1 - 1
[-3]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
[-4]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       length[Nonce](i!2`1)
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, i`1)), ilist(i`2))))
            >>
            (signal(running(0, cons(u!1, i`2),
                            nth(i`1,
                                floor(((mid - 1) / (p - 2)) * P!1
                                      -
                                      2 * ((mid - 1) / (p - 2))))))
              >>
              (trans(u!1, car(i`2),
                     E(public(car(i`2)),
                       conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
                >> Stop[event]))))
         # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -3 -5 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.2 :  

[-1]  length(i!2`1) = P!1 - 1
[-2]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
  |-------
[1]   floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       length[Nonce](i!2`1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_init.2.

restrictpremid_init.3 :  

{-1}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
{-2}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   P!1 - 2 < length[Identity](i!2`2)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, i`1)), ilist(i`2))))
            >>
            (signal(running(0, cons(u!1, i`2),
                            nth(i`1,
                                floor(((mid - 1) / (p - 2)) * P!1
                                      -
                                      2 * ((mid - 1) / (p - 2))))))
              >>
              (trans(u!1, car(i`2),
                     E(public(car(i`2)),
                       conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
                >> Stop[event]))))
         # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (typepred "i!2`2")
Adding type constraints for  i!2`2,
this simplifies to: 
restrictpremid_init.3 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`2)
{-2}  length(i!2`2) = P!1 - 1
[-3]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
[-4]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   P!1 - 2 < length[Identity](i!2`2)
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, i`1)), ilist(i`2))))
            >>
            (signal(running(0, cons(u!1, i`2),
                            nth(i`1,
                                floor(((mid - 1) / (p - 2)) * P!1
                                      -
                                      2 * ((mid - 1) / (p - 2))))))
              >>
              (trans(u!1, car(i`2),
                     E(public(car(i`2)),
                       conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
                >> Stop[event]))))
         # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -3 -4 -5 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.3 :  

[-1]  length(i!2`2) = P!1 - 1
  |-------
[1]   P!1 - 2 < length[Identity](i!2`2)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_init.3.

restrictpremid_init.4 :  

{-1}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
{-2}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!1 :))
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, i`1)), ilist(i`2))))
            >>
            (signal(running(0, cons(u!1, i`2),
                            nth(i`1,
                                floor(((mid - 1) / (p - 2)) * P!1
                                      -
                                      2 * ((mid - 1) / (p - 2))))))
              >>
              (trans(u!1, car(i`2),
                     E(public(car(i`2)),
                       conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
                >> Stop[event]))))
         # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.4 :  

  |-------
[1]   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!1 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!1 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpremid_init.4.

restrictpremid_init.5 :  

{-1}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
{-2}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   cons?[Identity](i!2`2)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, i`1)), ilist(i`2))))
            >>
            (signal(running(0, cons(u!1, i`2),
                            nth(i`1,
                                floor(((mid - 1) / (p - 2)) * P!1
                                      -
                                      2 * ((mid - 1) / (p - 2))))))
              >>
              (trans(u!1, car(i`2),
                     E(public(car(i`2)),
                       conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
                >> Stop[event]))))
         # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -2 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.5 :  

[-1]  2 <= P!1
  |-------
[1]   cons?[Identity](i!2`2)

Rerunning step: (nonemptylist "i!2`2")
Relating existence of a tail to a list's length,

This completes the proof of restrictpremid_init.5.

restrictpremid_init.6 :  

{-1}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
{-2}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!1 :))
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (signal(running(0, cons(u!1, il),
                            nth(nl,
                                floor(((mid - 1) / (p - 2)) * P!1
                                      -
                                      2 * ((mid - 1) / (p - 2))))))
              >>
              (trans(u!1, car(il),
                     E(public(car(il)),
                       conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                >> Stop[event]))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.6 :  

  |-------
[1]   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!1 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!1 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpremid_init.6.

restrictpremid_init.7 :  

{-1}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
{-2}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        cons?[Identity](il)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (signal(running(0, cons(u!1, il),
                            nth(nl,
                                floor(((mid - 1) / (p - 2)) * P!1
                                      -
                                      2 * ((mid - 1) / (p - 2))))))
              >>
              (trans(u!1, car(il),
                     E(public(car(il)),
                       conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                >> Stop[event]))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -2 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_init.7 :  

[-1]  2 <= P!1
  |-------
[1]   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        cons?[Identity](il)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictpremid_init.7 :  

[-1]  2 <= P!1
  |-------
{1}   cons?[Identity](il!1)

Rerunning step: (nonemptylist "il!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictpremid_init.7.

Q.E.D.


Run time  = 8.82 secs.
Real time = 10.15 secs.
nil
pvs(57): 
Installing rewrite rule sets.singleton_rew (all instances)
restrictpremid_middle :  

  |-------
{1}   FORALL (P: nat_from_2, u: Identity, v: below[mid]):
        P /= 2 =>
         (((Interleave! (k: nat_1_to(P), nnK: Nonces(P, u, k)):
              UROLE_MIDDLE(P, k, u, nnK))
            # R_premid(v))
           |> RankUser(rho_premid(v)))

Rerunning step: (auto-rewrite-theory "sets")
Rewriting relative to the theory: sets,
this simplifies to: 
restrictpremid_middle :  

  |-------
[1]   FORALL (P: nat_from_2, u: Identity, v: below[mid]):
        P /= 2 =>
         (((Interleave! (k: nat_1_to(P), nnK: Nonces(P, u, k)):
              UROLE_MIDDLE(P, k, u, nnK))
            # R_premid(v))
           |> RankUser(rho_premid(v)))

Rerunning step: (auto-rewrite "USER_TCC2")
Installing rewrite rule gnsl_middle.USER_TCC2
Installing automatic rewrites from: 
  USER_TCC2
this simplifies to: 
restrictpremid_middle :  

  |-------
[1]   FORALL (P: nat_from_2, u: Identity, v: below[mid]):
        P /= 2 =>
         (((Interleave! (k: nat_1_to(P), nnK: Nonces(P, u, k)):
              UROLE_MIDDLE(P, k, u, nnK))
            # R_premid(v))
           |> RankUser(rho_premid(v)))

Rerunning step: (skosimp)
Skolemizing and flattening,
this simplifies to: 
restrictpremid_middle :  

  |-------
{1}   P!1 = 2
{2}   (((Interleave! (k: nat_1_to(P!1), nnK: Nonces(P!1, u!1, k)):
           UROLE_MIDDLE(P!1, k, u!1, nnK))
         # R_premid(v!1))
        |> RankUser(rho_premid(v!1)))

Rerunning step: (expand "RankUser")
Expanding the definition of RankUser,
this simplifies to: 
restrictpremid_middle :  

  |-------
[1]   P!1 = 2
{2}   (((Interleave! (k: nat_1_to(P!1), nnK: Nonces(P!1, u!1, k)):
           UROLE_MIDDLE(P!1, k, u!1, nnK))
         # R_premid(v!1))
        |>
        LAMBDA (tr: list[event]):
          every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(tr)
           =>
           every(LAMBDA (e: event):
                   complement(rec?)(e) => rho_premid(v!1)(msg(e)))
                (tr))

Rerunning step: (interleaving2)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
USER_TCC2 rewrites EXISTS (x: [k: nat_1_to(P!1), Nonces(P!1, u!1, k)]): TRUE
  to TRUE
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
USER_TCC2 rewrites EXISTS (x: [k: nat_1_to(P!1), Nonces(P!1, u!1, k)]): TRUE
  to TRUE
Applying interleaving rule,
this simplifies to: 
restrictpremid_middle :  

  |-------
[1]   P!1 = 2
{2}   UROLE_MIDDLE(P!1, i!1`1, u!1, i!1`2) # R_premid(v!1) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (typepred "i!1`1" "P!1")
Adding type constraints for  i!1`1, P!1,
this simplifies to: 
restrictpremid_middle :  

{-1}  0 < i!1`1
{-2}  i!1`1 < P!1 - 1
{-3}  2 <= P!1
  |-------
[1]   P!1 = 2
[2]   UROLE_MIDDLE(P!1, i!1`1, u!1, i!1`2) # R_premid(v!1) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (lemma "select_right_nonce2" ("P" "P!1"))
Applying select_right_nonce2 where 
  P gets P!1,
this simplifies to: 
restrictpremid_middle :  

{-1}  (P!1 = p IMPLIES floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid)
       AND
       floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1 AND
        floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-2]  0 < i!1`1
[-3]  i!1`1 < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   P!1 = 2
[2]   UROLE_MIDDLE(P!1, i!1`1, u!1, i!1`2) # R_premid(v!1) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictpremid_middle :  

{-1}  (P!1 = p IMPLIES floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid)
{-2}  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
{-3}  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   P!1 = 2
[2]   UROLE_MIDDLE(P!1, i!1`1, u!1, i!1`2) # R_premid(v!1) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle :  

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   P!1 = 2
[2]   UROLE_MIDDLE(P!1, i!1`1, u!1, i!1`2) # R_premid(v!1) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (expand "UROLE_MIDDLE")
Expanding the definition of UROLE_MIDDLE,
this simplifies to: 
restrictpremid_middle :  

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   P!1 = 2
{2}   IF i!1`2 = n_mid
        THEN Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
                      nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                      il1:
                        {x: list[Identity] |
                           (length(x) = i!1`1) AND
                            FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
                      il2:
                        {x: list[Identity] |
                           (length(x) = P!1 - 1 - i!1`1) AND
                            FORALL (k: below[P!1 - 1 - i!1`1]):
                              nth(x, k) = hu(1 + k + i!1`1)}):
               (rec(u!1, nth(il1, i!1`1 - 1),
                    E(public(u!1),
                      conc(nlist(nl1), ilist(append(il1, il2)))))
                 >>
                 (trans(u!1, car(il2),
                        E(public(car(il2)),
                          conc(nlist(append(nl1, (: i!1`2 :))),
                               ilist(append(il1, cons(u!1, cdr(il2)))))))
                   >>
                   (rec(u!1, nth(il1, i!1`1 - 1),
                        E(public(u!1),
                          conc(ilist(append(il1, il2)),
                               nlist(cons(i!1`2, nl2)))))
                     >>
                     ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                       (signal(commit(mid,
                                      append(il1, cons(u!1, il2)),
                                      i!1`2))
                         >> Stop[event])))))
      ELSE IF i!1`1 <=
               floor(1 - 2 * ((mid - 1) / (p - 2)) +
                      ((mid - 1) / (p - 2)) * P!1)
             THEN Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
                           nl2:
                             {x: list[Nonce] |
                                length(x) = P!1 - 1 - i!1`1},
                           il1: {x: list[Identity] | length(x) = i!1`1},
                           il2:
                             {x: list[Identity] |
                                length(x) = P!1 - 1 - i!1`1}):
                    (rec(u!1, nth(il1, i!1`1 - 1),
                         E(public(u!1),
                           conc(nlist(nl1), ilist(append(il1, il2)))))
                      >>
                      (trans(u!1, car(il2),
                             E(public(car(il2)),
                               conc(nlist(append(nl1, (: i!1`2 :))),
                                    ilist
                                    (append(il1, cons(u!1, cdr(il2)))))))
                        >>
                        (rec(u!1, nth(il1, i!1`1 - 1),
                             E(public(u!1),
                               conc(ilist(append(il1, il2)),
                                    nlist(cons(i!1`2, nl2)))))
                          >>
                          (signal(running(i!1`1,
                                          append(il1, cons(u!1, il2)),
                                          nth
                                          (cons(i!1`2, nl2),
                                           floor
                                           (1 - 2 * ((mid - 1) / (p - 2))
                                            +
                                            ((mid - 1) / (p - 2)) * P!1)
                                           -
                                           i!1`1)))
                            >>
                            ((LastMessage(P!1,
                                          i!1`1,
                                          u!1,
                                          nl1,
                                          nl2,
                                          il1,
                                          il2))
                              >> Stop[event])))))
           ELSE Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
                         nl2:
                           {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                         il1: {x: list[Identity] | length(x) = i!1`1},
                         il2:
                           {x: list[Identity] |
                              length(x) = P!1 - 1 - i!1`1}):
                  (rec(u!1, nth(il1, i!1`1 - 1),
                       E(public(u!1),
                         conc(nlist(nl1), ilist(append(il1, il2)))))
                    >>
                    (signal(running(i!1`1,
                                    append(il1, cons(u!1, il2)),
                                    nth
                                    (nl1,
                                     floor
                                     (1 - 2 * ((mid - 1) / (p - 2))
                                      +
                                      ((mid - 1) / (p - 2)) * P!1))))
                      >>
                      (trans(u!1, car(il2),
                             E(public(car(il2)),
                               conc(nlist(append(nl1, (: i!1`2 :))),
                                    ilist
                                    (append(il1, cons(u!1, cdr(il2)))))))
                        >>
                        (rec(u!1, nth(il1, i!1`1 - 1),
                             E(public(u!1),
                               conc(ilist(append(il1, il2)),
                                    nlist(cons(i!1`2, nl2)))))
                          >>
                          ((LastMessage(P!1,
                                        i!1`1,
                                        u!1,
                                        nl1,
                                        nl2,
                                        il1,
                                        il2))
                            >> Stop[event])))))
           ENDIF
      ENDIF
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (lift-if)
Lifting IF-conditions to the top level,
this simplifies to: 
restrictpremid_middle :  

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   P!1 = 2
{2}   IF i!1`2 = n_mid
        THEN Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
                      nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                      il1:
                        {x: list[Identity] |
                           (length(x) = i!1`1) AND
                            FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
                      il2:
                        {x: list[Identity] |
                           (length(x) = P!1 - 1 - i!1`1) AND
                            FORALL (k: below[P!1 - 1 - i!1`1]):
                              nth(x, k) = hu(1 + k + i!1`1)}):
               (rec(u!1, nth(il1, i!1`1 - 1),
                    E(public(u!1),
                      conc(nlist(nl1), ilist(append(il1, il2)))))
                 >>
                 (trans(u!1, car(il2),
                        E(public(car(il2)),
                          conc(nlist(append(nl1, (: i!1`2 :))),
                               ilist(append(il1, cons(u!1, cdr(il2)))))))
                   >>
                   (rec(u!1, nth(il1, i!1`1 - 1),
                        E(public(u!1),
                          conc(ilist(append(il1, il2)),
                               nlist(cons(i!1`2, nl2)))))
                     >>
                     ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                       (signal(commit(mid,
                                      append(il1, cons(u!1, il2)),
                                      i!1`2))
                         >> Stop[event])))))
              # R_premid(v!1)
              |>
              LAMBDA (t: list[event]):
                every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))
                     (t)
                 =>
                 every(LAMBDA (e: event):
                         NOT rec?(e) => rho_premid(v!1)(msg(e)))
                      (t)
      ELSE IF i!1`1 <=
               floor(1 - 2 * ((mid - 1) / (p - 2)) +
                      ((mid - 1) / (p - 2)) * P!1)
             THEN Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
                           nl2:
                             {x: list[Nonce] |
                                length(x) = P!1 - 1 - i!1`1},
                           il1: {x: list[Identity] | length(x) = i!1`1},
                           il2:
                             {x: list[Identity] |
                                length(x) = P!1 - 1 - i!1`1}):
                    (rec(u!1, nth(il1, i!1`1 - 1),
                         E(public(u!1),
                           conc(nlist(nl1), ilist(append(il1, il2)))))
                      >>
                      (trans(u!1, car(il2),
                             E(public(car(il2)),
                               conc(nlist(append(nl1, (: i!1`2 :))),
                                    ilist
                                    (append(il1, cons(u!1, cdr(il2)))))))
                        >>
                        (rec(u!1, nth(il1, i!1`1 - 1),
                             E(public(u!1),
                               conc(ilist(append(il1, il2)),
                                    nlist(cons(i!1`2, nl2)))))
                          >>
                          (signal(running(i!1`1,
                                          append(il1, cons(u!1, il2)),
                                          nth
                                          (cons(i!1`2, nl2),
                                           floor
                                           (1 - 2 * ((mid - 1) / (p - 2))
                                            +
                                            ((mid - 1) / (p - 2)) * P!1)
                                           -
                                           i!1`1)))
                            >>
                            ((LastMessage(P!1,
                                          i!1`1,
                                          u!1,
                                          nl1,
                                          nl2,
                                          il1,
                                          il2))
                              >> Stop[event])))))
                   # R_premid(v!1)
                   |>
                   LAMBDA (t: list[event]):
                     every(LAMBDA (e: event):
                             rec?(e) => rho_premid(v!1)(msg(e)))
                          (t)
                      =>
                      every(LAMBDA (e: event):
                              NOT rec?(e) => rho_premid(v!1)(msg(e)))
                           (t)
           ELSE Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
                         nl2:
                           {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                         il1: {x: list[Identity] | length(x) = i!1`1},
                         il2:
                           {x: list[Identity] |
                              length(x) = P!1 - 1 - i!1`1}):
                  (rec(u!1, nth(il1, i!1`1 - 1),
                       E(public(u!1),
                         conc(nlist(nl1), ilist(append(il1, il2)))))
                    >>
                    (signal(running(i!1`1,
                                    append(il1, cons(u!1, il2)),
                                    nth
                                    (nl1,
                                     floor
                                     (1 - 2 * ((mid - 1) / (p - 2))
                                      +
                                      ((mid - 1) / (p - 2)) * P!1))))
                      >>
                      (trans(u!1, car(il2),
                             E(public(car(il2)),
                               conc(nlist(append(nl1, (: i!1`2 :))),
                                    ilist
                                    (append(il1, cons(u!1, cdr(il2)))))))
                        >>
                        (rec(u!1, nth(il1, i!1`1 - 1),
                             E(public(u!1),
                               conc(ilist(append(il1, il2)),
                                    nlist(cons(i!1`2, nl2)))))
                          >>
                          ((LastMessage(P!1,
                                        i!1`1,
                                        u!1,
                                        nl1,
                                        nl2,
                                        il1,
                                        il2))
                            >> Stop[event])))))
                 # R_premid(v!1)
                 |>
                 LAMBDA (t: list[event]):
                   every(LAMBDA (e: event):
                           rec?(e) => rho_premid(v!1)(msg(e)))
                        (t)
                    =>
                    every(LAMBDA (e: event):
                            NOT rec?(e) => rho_premid(v!1)(msg(e)))
                         (t)
           ENDIF
      ENDIF

Rerunning step: (prop)
Applying propositional simplification,
this yields  3 subgoals: 
restrictpremid_middle.1 :  

{-1}  i!1`2 = n_mid
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1:
                 {x: list[Identity] |
                    (length(x) = i!1`1) AND
                     FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
               il2:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1 - i!1`1) AND
                     FORALL (k: below[P!1 - 1 - i!1`1]):
                       nth(x, k) = hu(1 + k + i!1`1)}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                (signal(commit(mid, append(il1, cons(u!1, il2)), i!1`2)) >>
                  Stop[event])))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[2]   P!1 = 2

Rerunning step: (case "P!1=p AND u!1=hu(mid) AND i!1`1=mid")
Case splitting on 
   P!1 = p AND u!1 = hu(mid) AND i!1`1 = mid, 
this yields  3 subgoals: 
restrictpremid_middle.1.1 :  

{-1}  P!1 = p AND u!1 = hu(mid) AND i!1`1 = mid
[-2]  i!1`2 = n_mid
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-4]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1:
                 {x: list[Identity] |
                    (length(x) = i!1`1) AND
                     FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
               il2:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1 - i!1`1) AND
                     FORALL (k: below[P!1 - 1 - i!1`1]):
                       nth(x, k) = hu(1 + k + i!1`1)}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                (signal(commit(mid, append(il1, cons(u!1, il2)), i!1`2)) >>
                  Stop[event])))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[2]   P!1 = 2

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictpremid_middle.1.1 :  

{-1}  P!1 = p
{-2}  u!1 = hu(mid)
{-3}  i!1`1 = mid
[-4]  i!1`2 = n_mid
[-5]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-6]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-7]  0 < i!1`1
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
[1]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1:
                 {x: list[Identity] |
                    (length(x) = i!1`1) AND
                     FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
               il2:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1 - i!1`1) AND
                     FORALL (k: below[P!1 - 1 - i!1`1]):
                       nth(x, k) = hu(1 + k + i!1`1)}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                (signal(commit(mid, append(il1, cons(u!1, il2)), i!1`2)) >>
                  Stop[event])))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[2]   P!1 = 2

Rerunning step: (choice3)
Applying choice rule,
this yields  10 subgoals: 
restrictpremid_middle.1.1.1 :  

[-1]  P!1 = p
[-2]  u!1 = hu(mid)
[-3]  i!1`1 = mid
[-4]  i!1`2 = n_mid
[-5]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-6]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-7]  0 < i!1`1
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
{1}   (rec(u!1, nth(i!2`3, i!1`1 - 1),
           E(public(u!1), conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
        >>
        (trans(u!1, car(i!2`4),
               E(public(car(i!2`4)),
                 conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
          >>
          (rec(u!1, nth(i!2`3, i!1`1 - 1),
               E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
            >>
            ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
              (signal(commit(mid, append(i!2`3, cons(u!1, i!2`4)), i!1`2))
                >> Stop[event])))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[2]   P!1 = 2

Rerunning step: (replace* -1 -2 -3 -4)
Repeatedly applying the replace rule,
this simplifies to: 
restrictpremid_middle.1.1.1 :  

[-1]  P!1 = p
[-2]  u!1 = hu(mid)
[-3]  i!1`1 = mid
[-4]  i!1`2 = n_mid
{-5}  floor(((mid - 1) / (p - 2)) * (p - 2) + 1) >= 1
{-6}  floor(((mid - 1) / (p - 2)) * (p - 2) + 1) < p - 1
{-7}  0 < mid
{-8}  mid < p - 1
{-9}  2 <= p
  |-------
{1}   (rec(hu(mid), nth(i!2`3, mid - 1),
           E(public(hu(mid)),
             conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
        >>
        (trans(hu(mid), car(i!2`4),
               E(public(car(i!2`4)),
                 conc(nlist(append(i!2`1, (: n_mid :))),
                      ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))))
          >>
          (rec(hu(mid), nth(i!2`3, mid - 1),
               E(public(hu(mid)),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(n_mid, i!2`2)))))
            >>
            ((LastMessage(p, mid, hu(mid), i!2`1, i!2`2, i!2`3, i!2`4)) >>
              (signal(commit(mid, append(i!2`3, cons(hu(mid), i!2`4)),
                             n_mid))
                >> Stop[event])))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
{2}   p = 2

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictpremid_middle.1.1.1 :  

{-1}  rho_premid(v!1)
                (E(public(hu(mid)),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  P!1 = p
[-3]  u!1 = hu(mid)
[-4]  i!1`1 = mid
[-5]  i!1`2 = n_mid
{-6}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p) >= 1
{-7}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p) <
       p - 1
[-8]  0 < mid
[-9]  mid < p - 1
[-10] 2 <= p
  |-------
{1}   ((trans(hu(mid), car(i!2`4),
              E(public(car(i!2`4)),
                conc(nlist(append(i!2`1, (: n_mid :))),
                     ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))))
         >>
         (rec(hu(mid), nth(i!2`3, mid - 1),
              E(public(hu(mid)),
                conc(ilist(append(i!2`3, i!2`4)),
                     nlist(cons(n_mid, i!2`2)))))
           >>
           ((LastMessage(p, mid, hu(mid), i!2`1, i!2`2, i!2`3, i!2`4)) >>
             (signal(commit(mid, append(i!2`3, cons(hu(mid), i!2`4)),
                            n_mid))
               >> Stop[event]))))
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
{2}   R_premid(v!1)
              (rec(hu(mid), nth(i!2`3, mid - 1),
                   E(public(hu(mid)),
                     conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))))
{3}   rec(hu(mid), nth(i!2`3, mid - 1),
          E(public(hu(mid)),
            conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
       >>
       ((trans(hu(mid), car(i!2`4),
               E(public(car(i!2`4)),
                 conc(nlist(append(i!2`1, (: n_mid :))),
                      ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))))
          >>
          (rec(hu(mid), nth(i!2`3, mid - 1),
               E(public(hu(mid)),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(n_mid, i!2`2)))))
            >>
            ((LastMessage(p, mid, hu(mid), i!2`1, i!2`2, i!2`3, i!2`4)) >>
              (signal(commit(mid, append(i!2`3, cons(hu(mid), i!2`4)),
                             n_mid))
                >> Stop[event]))))
         # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   p = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.1 :  

[-1]  rho_premid(v!1)
                (E(public(hu(mid)),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  P!1 = p
[-3]  u!1 = hu(mid)
[-4]  i!1`1 = mid
[-5]  i!1`2 = n_mid
[-6]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p) >= 1
[-7]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p) <
       p - 1
[-8]  0 < mid
[-9]  mid < p - 1
[-10] 2 <= p
  |-------
[1]   ((trans(hu(mid), car(i!2`4),
              E(public(car(i!2`4)),
                conc(nlist(append(i!2`1, (: n_mid :))),
                     ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))))
         >>
         (rec(hu(mid), nth(i!2`3, mid - 1),
              E(public(hu(mid)),
                conc(ilist(append(i!2`3, i!2`4)),
                     nlist(cons(n_mid, i!2`2)))))
           >>
           ((LastMessage(p, mid, hu(mid), i!2`1, i!2`2, i!2`3, i!2`4)) >>
             (signal(commit(mid, append(i!2`3, cons(hu(mid), i!2`4)),
                            n_mid))
               >> Stop[event]))))
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[2]   p = 2

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictpremid_middle.1.1.1.1 :  

[-1]  rho_premid(v!1)
                (E(public(hu(mid)),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  P!1 = p
[-3]  u!1 = hu(mid)
[-4]  i!1`1 = mid
[-5]  i!1`2 = n_mid
[-6]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p) >= 1
[-7]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p) <
       p - 1
[-8]  0 < mid
[-9]  mid < p - 1
[-10] 2 <= p
  |-------
{1}   rho_premid(v!1)
                (E(public(car(i!2`4)),
                   conc(nlist(append(i!2`1, (: n_mid :))),
                        ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))))
{2}   R_premid(v!1)
              (trans(hu(mid), car(i!2`4),
                     E(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: n_mid :))),
                            ilist(append(i!2`3,
                                         cons(hu(mid), cdr(i!2`4))))))))
{3}   trans(hu(mid), car(i!2`4),
            E(public(car(i!2`4)),
              conc(nlist(append(i!2`1, (: n_mid :))),
                   ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))))
       >>
       ((rec(hu(mid), nth(i!2`3, mid - 1),
             E(public(hu(mid)),
               conc(ilist(append(i!2`3, i!2`4)),
                    nlist(cons(n_mid, i!2`2)))))
          >>
          ((LastMessage(p, mid, hu(mid), i!2`1, i!2`2, i!2`3, i!2`4)) >>
            (signal(commit(mid, append(i!2`3, cons(hu(mid), i!2`4)),
                           n_mid))
              >> Stop[event])))
         # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   p = 2

Rerunning step: (delete -6 -7 -8 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.1.1 :  

[-1]  rho_premid(v!1)
                (E(public(hu(mid)),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  P!1 = p
[-3]  u!1 = hu(mid)
[-4]  i!1`1 = mid
[-5]  i!1`2 = n_mid
[-6]  mid < p - 1
[-7]  2 <= p
  |-------
[1]   rho_premid(v!1)
                (E(public(car(i!2`4)),
                   conc(nlist(append(i!2`1, (: n_mid :))),
                        ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))))
[2]   p = 2

Rerunning step: (grind :if-match nil :exclude ("remove" "elt"))
E rewrites 
  E(public(car(i!2`4)),
    conc(nlist(append(i!2`1, (: n_mid :))),
         ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4))))))
  to code(public(car(i!2`4)),
           conc(nlist(append(i!2`1, (: n_mid :))),
                ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4))))))
rho_premid rewrites rho_premid(v!1)(nlist(append(i!2`1, (: n_mid :))))
  to NOT elt(append(i!2`1, (: n_mid :)), n_mid)
rho_premid rewrites 
  rho_premid(v!1)(ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))
  to TRUE
rho_premid rewrites 
  rho_premid(v!1)
            (conc(nlist(append(i!2`1, (: n_mid :))),
                  ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4))))))
  to NOT elt(append(i!2`1, (: n_mid :)), n_mid)
rho_premid rewrites 
  rho_premid(v!1)
            (code(public(car(i!2`4)),
                  conc(nlist(append(i!2`1, (: n_mid :))),
                       ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))))
  to NOT elt(append(i!2`1, (: n_mid :)), n_mid) OR
       (EXISTS (i: {x: nat | mid < x AND x <= p}):
          public(car(i!2`4)) = public(hu(rem(p)(i))) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                   nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
             conc(nlist(append(i!2`1, (: n_mid :))),
                  ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))
              =
              conc(nlist(append(nl1, cons(n_mid, nl2))),
                   ilist(remove(hu_list, rem(p)(i)))))
        OR
        EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
          public(car(i!2`4)) = public(hu(i)) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                   nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
             conc(nlist(append(i!2`1, (: n_mid :))),
                  ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))
              =
              conc(ilist(remove(hu_list, i)),
                   nlist(append(nl1, cons(n_mid, nl2))))
E rewrites 
  E(public(hu(mid)), conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
  to code(public(hu(mid)), conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
rho_premid rewrites rho_premid(v!1)(nlist(i!2`1))
  to NOT elt(i!2`1, n_mid)
rho_premid rewrites rho_premid(v!1)(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_premid rewrites 
  rho_premid(v!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
  to NOT elt(i!2`1, n_mid)
rho_premid rewrites 
  rho_premid(v!1)
            (code(public(hu(mid)),
                  conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
  to NOT elt(i!2`1, n_mid) OR
       (EXISTS (i: {x: nat | mid < x AND x <= p}):
          public(hu(mid)) = public(hu(rem(p)(i))) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                   nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
             conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
              conc(nlist(append(nl1, cons(n_mid, nl2))),
                   ilist(remove(hu_list, rem(p)(i)))))
        OR
        EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
          public(hu(mid)) = public(hu(i)) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                   nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
             conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
              conc(ilist(remove(hu_list, i)),
                   nlist(append(nl1, cons(n_mid, nl2))))
Trying repeated skolemization, instantiation, and if-lifting,
this yields  3 subgoals: 
restrictpremid_middle.1.1.1.1.1 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl1!1)
{-2}  length(nl1!1) = mid
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
{-4}  length(nl2!1) = -1 - mid + i!3
{-5}  mid < i!3
{-6}  i!3 <= p
{-7}  elt(append(i!2`1, (: n_mid :)), n_mid)
{-8}  public(hu(mid)) = public(hu(rem(p)(i!3)))
{-9}  conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, rem(p)(i!3))))
[-10] P!1 = p
[-11] u!1 = hu(mid)
[-12] i!1`1 = mid
[-13] i!1`2 = n_mid
[-14] mid < p - 1
[-15] 2 <= p
  |-------
{1}   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: n_mid :))),
                ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
{2}   EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(car(i!2`4)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(nlist(append(i!2`1, (: n_mid :))),
                ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))
            =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))
[3]   p = 2

Rerunning step: (comment "contradiction in -5 and i!1`1=mid")
Adding comment: contradiction in -5 and i!1`1=mid
this simplifies to: 
restrictpremid_middle.1.1.1.1.1 : 
;;; contradiction in -5 and i!1`1=mid

[-1]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl1!1)
[-2]  length(nl1!1) = mid
[-3]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
[-4]  length(nl2!1) = -1 - mid + i!3
[-5]  mid < i!3
[-6]  i!3 <= p
[-7]  elt(append(i!2`1, (: n_mid :)), n_mid)
[-8]  public(hu(mid)) = public(hu(rem(p)(i!3)))
[-9]  conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, rem(p)(i!3))))
[-10] P!1 = p
[-11] u!1 = hu(mid)
[-12] i!1`1 = mid
[-13] i!1`2 = n_mid
[-14] mid < p - 1
[-15] 2 <= p
  |-------
[1]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: n_mid :))),
                ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[2]   EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(car(i!2`4)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(nlist(append(i!2`1, (: n_mid :))),
                ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))
            =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))
[3]   p = 2

Rerunning step: (typepred "i!2`1")
Adding type constraints for  i!2`1,
this simplifies to: 
restrictpremid_middle.1.1.1.1.1 : 
;;; contradiction in -5 and i!1`1=mid

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`1)
{-2}  length(i!2`1) = i!1`1
[-3]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl1!1)
[-4]  length(nl1!1) = mid
[-5]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
[-6]  length(nl2!1) = -1 - mid + i!3
[-7]  mid < i!3
[-8]  i!3 <= p
[-9]  elt(append(i!2`1, (: n_mid :)), n_mid)
[-10] public(hu(mid)) = public(hu(rem(p)(i!3)))
[-11] conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, rem(p)(i!3))))
[-12] P!1 = p
[-13] u!1 = hu(mid)
[-14] i!1`1 = mid
[-15] i!1`2 = n_mid
[-16] mid < p - 1
[-17] 2 <= p
  |-------
[1]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: n_mid :))),
                ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[2]   EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(car(i!2`4)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(nlist(append(i!2`1, (: n_mid :))),
                ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))
            =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))
[3]   p = 2

Rerunning step: (delete -1 -3 -5 -8 -9 -10 -13 -15 -17 +)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.1.1.1 : 
;;; contradiction in -5 and i!1`1=mid

[-1]  length(i!2`1) = i!1`1
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  mid < i!3
[-5]  conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, rem(p)(i!3))))
[-6]  P!1 = p
[-7]  i!1`1 = mid
[-8]  mid < p - 1
  |-------

Rerunning step: (decompose-equality -5)
Applying decompose-equality,
this simplifies to: 
restrictpremid_middle.1.1.1.1.1 : 
;;; contradiction in -5 and i!1`1=mid

{-1}  nlist(i!2`1) = nlist(append(nl1!1, cons(n_mid, nl2!1)))
{-2}  ilist(append(i!2`3, i!2`4)) = ilist(remove(hu_list, rem(p)(i!3)))
[-3]  length(i!2`1) = i!1`1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  mid < i!3
[-7]  P!1 = p
[-8]  i!1`1 = mid
[-9]  mid < p - 1
  |-------

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictpremid_middle.1.1.1.1.1 : 
;;; contradiction in -5 and i!1`1=mid

{-1}  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-2]  ilist(append(i!2`3, i!2`4)) = ilist(remove(hu_list, rem(p)(i!3)))
[-3]  length(i!2`1) = i!1`1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  mid < i!3
[-7]  P!1 = p
[-8]  i!1`1 = mid
[-9]  mid < p - 1
  |-------

Rerunning step: (replace -1 -3)
Replacing using formula -1,
this simplifies to: 
restrictpremid_middle.1.1.1.1.1 : 
;;; contradiction in -5 and i!1`1=mid

[-1]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-2]  ilist(append(i!2`3, i!2`4)) = ilist(remove(hu_list, rem(p)(i!3)))
{-3}  length(append(nl1!1, cons(n_mid, nl2!1))) = i!1`1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  mid < i!3
[-7]  P!1 = p
[-8]  i!1`1 = mid
[-9]  mid < p - 1
  |-------

Rerunning step: (rewrite "length_append" -3)
Found matching substitution:
l2: list[T] gets cons(n_mid, nl2!1),
l1: list[T] gets nl1!1,
length rewrites length(cons(n_mid, nl2!1))
  to 1 + length[Nonce](nl2!1)
Rewriting using length_append, matching in -3,
this simplifies to: 
restrictpremid_middle.1.1.1.1.1 : 
;;; contradiction in -5 and i!1`1=mid

[-1]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-2]  ilist(append(i!2`3, i!2`4)) = ilist(remove(hu_list, rem(p)(i!3)))
{-3}  1 + length(nl1!1) + length[Nonce](nl2!1) = i!1`1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  mid < i!3
[-7]  P!1 = p
[-8]  i!1`1 = mid
[-9]  mid < p - 1
  |-------

Rerunning step: (delete -1 -2 -7 -9 -10)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.1.1.1 : 
;;; contradiction in -5 and i!1`1=mid

[-1]  1 + length(nl1!1) + length[Nonce](nl2!1) = i!1`1
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  mid < i!3
[-5]  i!1`1 = mid
  |-------

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.1.1.1.1.1.

restrictpremid_middle.1.1.1.1.2 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl1!1)
{-2}  length(nl1!1) = mid - i!3
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
{-4}  length(nl2!1) = -1 - mid + p
{-5}  0 < i!3
{-6}  i!3 <= v!1
{-7}  elt(append(i!2`1, (: n_mid :)), n_mid)
{-8}  public(hu(mid)) = public(hu(i!3))
{-9}  conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
       conc(ilist(remove(hu_list, i!3)),
            nlist(append(nl1!1, cons(n_mid, nl2!1))))
[-10] P!1 = p
[-11] u!1 = hu(mid)
[-12] i!1`1 = mid
[-13] i!1`2 = n_mid
[-14] mid < p - 1
[-15] 2 <= p
  |-------
{1}   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: n_mid :))),
                ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
{2}   EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(car(i!2`4)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(nlist(append(i!2`1, (: n_mid :))),
                ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))
            =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))
[3]   p = 2

Rerunning step: (comment "contradiction in -9")
Adding comment: contradiction in -9
this simplifies to: 
restrictpremid_middle.1.1.1.1.2 : 
;;; contradiction in -9

[-1]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl1!1)
[-2]  length(nl1!1) = mid - i!3
[-3]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
[-4]  length(nl2!1) = -1 - mid + p
[-5]  0 < i!3
[-6]  i!3 <= v!1
[-7]  elt(append(i!2`1, (: n_mid :)), n_mid)
[-8]  public(hu(mid)) = public(hu(i!3))
[-9]  conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
       conc(ilist(remove(hu_list, i!3)),
            nlist(append(nl1!1, cons(n_mid, nl2!1))))
[-10] P!1 = p
[-11] u!1 = hu(mid)
[-12] i!1`1 = mid
[-13] i!1`2 = n_mid
[-14] mid < p - 1
[-15] 2 <= p
  |-------
[1]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: n_mid :))),
                ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[2]   EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(car(i!2`4)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(nlist(append(i!2`1, (: n_mid :))),
                ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))
            =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))
[3]   p = 2

Rerunning step: (decompose-equality -9)
Applying decompose-equality,

This completes the proof of restrictpremid_middle.1.1.1.1.2.

restrictpremid_middle.1.1.1.1.3 :  

{-1}  elt(append(i!2`1, (: n_mid :)), n_mid)
[-2]  P!1 = p
[-3]  u!1 = hu(mid)
[-4]  i!1`1 = mid
[-5]  i!1`2 = n_mid
[-6]  mid < p - 1
[-7]  2 <= p
  |-------
{1}   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: n_mid :))),
                ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
{2}   EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(car(i!2`4)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(nlist(append(i!2`1, (: n_mid :))),
                ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))
            =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))
{3}   elt(i!2`1, n_mid)
[4]   p = 2

Rerunning step: (comment "prove the outgoing message conforms to 1")
Adding comment: prove the outgoing message conforms to 1
this simplifies to: 
restrictpremid_middle.1.1.1.1.3 : 
;;; prove the outgoing message conforms to 1

[-1]  elt(append(i!2`1, (: n_mid :)), n_mid)
[-2]  P!1 = p
[-3]  u!1 = hu(mid)
[-4]  i!1`1 = mid
[-5]  i!1`2 = n_mid
[-6]  mid < p - 1
[-7]  2 <= p
  |-------
[1]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: n_mid :))),
                ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[2]   EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(car(i!2`4)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(nlist(append(i!2`1, (: n_mid :))),
                ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))
            =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))
[3]   elt(i!2`1, n_mid)
[4]   p = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3 : 
;;; prove the outgoing message conforms to 1

[-1]  elt(append(i!2`1, (: n_mid :)), n_mid)
[-2]  P!1 = p
[-3]  u!1 = hu(mid)
[-4]  i!1`1 = mid
[-5]  i!1`2 = n_mid
[-6]  mid < p - 1
[-7]  2 <= p
  |-------
[1]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: n_mid :))),
                ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[2]   p = 2

Rerunning step: (typepred "i!2`1" "i!2`3" "i!2`4" "hu_list")
Adding type constraints for  i!2`1, i!2`3, i!2`4, hu_list,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3 : 
;;; prove the outgoing message conforms to 1

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`1)
{-2}  length(i!2`1) = i!1`1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`3)
{-4}  (length(i!2`3) = i!1`1)
{-5}  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
{-6}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`4)
{-7}  (length(i!2`4) = P!1 - 1 - i!1`1)
{-8}  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
{-9}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-10} (length(hu_list) = p)
{-11} FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] elt(append(i!2`1, (: n_mid :)), n_mid)
[-13] P!1 = p
[-14] u!1 = hu(mid)
[-15] i!1`1 = mid
[-16] i!1`2 = n_mid
[-17] mid < p - 1
[-18] 2 <= p
  |-------
[1]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: n_mid :))),
                ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[2]   p = 2

Rerunning step: (delete -1 -3 -6 -9)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3 : 
;;; prove the outgoing message conforms to 1

[-1]  length(i!2`1) = i!1`1
[-2]  (length(i!2`3) = i!1`1)
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-5]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  elt(append(i!2`1, (: n_mid :)), n_mid)
[-9]  P!1 = p
[-10] u!1 = hu(mid)
[-11] i!1`1 = mid
[-12] i!1`2 = n_mid
[-13] mid < p - 1
[-14] 2 <= p
  |-------
[1]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: n_mid :))),
                ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[2]   p = 2

Rerunning step: (inst 1 "mid+1")
Instantiating the top quantifier in 1 with the terms: 
 mid+1,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3 : 
;;; prove the outgoing message conforms to 1

[-1]  length(i!2`1) = i!1`1
[-2]  (length(i!2`3) = i!1`1)
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-5]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  elt(append(i!2`1, (: n_mid :)), n_mid)
[-9]  P!1 = p
[-10] u!1 = hu(mid)
[-11] i!1`1 = mid
[-12] i!1`2 = n_mid
[-13] mid < p - 1
[-14] 2 <= p
  |-------
{1}   public(car(i!2`4)) = public(hu(rem(p)(mid + 1))) AND
       EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
               nl2: {x: list[Nonce] | length(x) = 0}):
         conc(nlist(append(i!2`1, (: n_mid :))),
              ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))
          =
          conc(nlist(append(nl1, cons(n_mid, nl2))),
               ilist(remove(hu_list, rem(p)(mid + 1))))
[2]   p = 2

Rerunning step: (comment "simplify using the rem-function")
Adding comment: simplify using the rem-function
this simplifies to: 
restrictpremid_middle.1.1.1.1.3 : 
;;; simplify using the rem-function

[-1]  length(i!2`1) = i!1`1
[-2]  (length(i!2`3) = i!1`1)
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-5]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  elt(append(i!2`1, (: n_mid :)), n_mid)
[-9]  P!1 = p
[-10] u!1 = hu(mid)
[-11] i!1`1 = mid
[-12] i!1`2 = n_mid
[-13] mid < p - 1
[-14] 2 <= p
  |-------
[1]   public(car(i!2`4)) = public(hu(rem(p)(mid + 1))) AND
       EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
               nl2: {x: list[Nonce] | length(x) = 0}):
         conc(nlist(append(i!2`1, (: n_mid :))),
              ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))
          =
          conc(nlist(append(nl1, cons(n_mid, nl2))),
               ilist(remove(hu_list, rem(p)(mid + 1))))
[2]   p = 2

Rerunning step: (case "rem(p)(mid+1)=mid+1")
Case splitting on 
   rem(p)(mid + 1) = mid + 1, 
this yields  2 subgoals: 
restrictpremid_middle.1.1.1.1.3.1 : 
;;; simplify using the rem-function

{-1}  rem(p)(mid + 1) = mid + 1
[-2]  length(i!2`1) = i!1`1
[-3]  (length(i!2`3) = i!1`1)
[-4]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-5]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-6]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  elt(append(i!2`1, (: n_mid :)), n_mid)
[-10] P!1 = p
[-11] u!1 = hu(mid)
[-12] i!1`1 = mid
[-13] i!1`2 = n_mid
[-14] mid < p - 1
[-15] 2 <= p
  |-------
[1]   public(car(i!2`4)) = public(hu(rem(p)(mid + 1))) AND
       EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
               nl2: {x: list[Nonce] | length(x) = 0}):
         conc(nlist(append(i!2`1, (: n_mid :))),
              ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))
          =
          conc(nlist(append(nl1, cons(n_mid, nl2))),
               ilist(remove(hu_list, rem(p)(mid + 1))))
[2]   p = 2

Rerunning step: (replace* -1)
Repeatedly applying the replace rule,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.1 : 
;;; simplify using the rem-function

[-1]  rem(p)(mid + 1) = mid + 1
[-2]  length(i!2`1) = i!1`1
[-3]  (length(i!2`3) = i!1`1)
[-4]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-5]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-6]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  elt(append(i!2`1, (: n_mid :)), n_mid)
[-10] P!1 = p
[-11] u!1 = hu(mid)
[-12] i!1`1 = mid
[-13] i!1`2 = n_mid
[-14] mid < p - 1
[-15] 2 <= p
  |-------
{1}   public(car(i!2`4)) = public(hu(mid + 1)) AND
       EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
               nl2: {x: list[Nonce] | length(x) = 0}):
         conc(nlist(append(i!2`1, (: n_mid :))),
              ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))
          =
          conc(nlist(append(nl1, cons(n_mid, nl2))),
               ilist(remove(hu_list, mid + 1)))
[2]   p = 2

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
restrictpremid_middle.1.1.1.1.3.1.1 : 
;;; simplify using the rem-function

[-1]  rem(p)(mid + 1) = mid + 1
[-2]  length(i!2`1) = i!1`1
[-3]  (length(i!2`3) = i!1`1)
[-4]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-5]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-6]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  elt(append(i!2`1, (: n_mid :)), n_mid)
[-10] P!1 = p
[-11] u!1 = hu(mid)
[-12] i!1`1 = mid
[-13] i!1`2 = n_mid
[-14] mid < p - 1
[-15] 2 <= p
  |-------
{1}   public(car(i!2`4)) = public(hu(mid + 1))
[2]   p = 2

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.1.1 : 
;;; simplify using the rem-function

{-1}  rem(p)(1 + mid) = 1 + mid
[-2]  length(i!2`1) = i!1`1
[-3]  (length(i!2`3) = i!1`1)
[-4]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-5]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-6]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  elt(append(i!2`1, (: n_mid :)), n_mid)
[-10] P!1 = p
[-11] u!1 = hu(mid)
[-12] i!1`1 = mid
[-13] i!1`2 = n_mid
[-14] mid < p - 1
[-15] 2 <= p
  |-------
{1}   car(i!2`4) = hu(1 + mid)
[2]   p = 2

Rerunning step: (inst -6 "0")
Instantiating the top quantifier in -6 with the terms: 
 0,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.1.1 : 
;;; simplify using the rem-function

[-1]  rem(p)(1 + mid) = 1 + mid
[-2]  length(i!2`1) = i!1`1
[-3]  (length(i!2`3) = i!1`1)
[-4]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-5]  (length(i!2`4) = P!1 - 1 - i!1`1)
{-6}  nth(i!2`4, 0) = hu(1 + 0 + i!1`1)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  elt(append(i!2`1, (: n_mid :)), n_mid)
[-10] P!1 = p
[-11] u!1 = hu(mid)
[-12] i!1`1 = mid
[-13] i!1`2 = n_mid
[-14] mid < p - 1
[-15] 2 <= p
  |-------
[1]   car(i!2`4) = hu(1 + mid)
[2]   p = 2

Rerunning step: (delete -1 -2 -3 -4 -5 -7 -8 -9 -10 -11 -13 -14 -15 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.1.1 : 
;;; simplify using the rem-function

[-1]  nth(i!2`4, 0) = hu(1 + 0 + i!1`1)
[-2]  i!1`1 = mid
  |-------
[1]   car(i!2`4) = hu(1 + mid)

Rerunning step: (grind)
nth rewrites nth(i!2`4, 0)
  to car(i!2`4)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpremid_middle.1.1.1.1.3.1.1.

restrictpremid_middle.1.1.1.1.3.1.2 : 
;;; simplify using the rem-function

[-1]  rem(p)(mid + 1) = mid + 1
[-2]  length(i!2`1) = i!1`1
[-3]  (length(i!2`3) = i!1`1)
[-4]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-5]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-6]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  elt(append(i!2`1, (: n_mid :)), n_mid)
[-10] P!1 = p
[-11] u!1 = hu(mid)
[-12] i!1`1 = mid
[-13] i!1`2 = n_mid
[-14] mid < p - 1
[-15] 2 <= p
  |-------
{1}   EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
              nl2: {x: list[Nonce] | length(x) = 0}):
        conc(nlist(append(i!2`1, (: n_mid :))),
             ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))
         =
         conc(nlist(append(nl1, cons(n_mid, nl2))),
              ilist(remove(hu_list, mid + 1)))
[2]   p = 2

Rerunning step: (inst 1 "i!2`1" "null")
length rewrites length[Nonce](null[Nonce])
  to 0
Instantiating the top quantifier in 1 with the terms: 
 i!2`1, null,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.1.2 : 
;;; simplify using the rem-function

[-1]  rem(p)(mid + 1) = mid + 1
[-2]  length(i!2`1) = i!1`1
[-3]  (length(i!2`3) = i!1`1)
[-4]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-5]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-6]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  elt(append(i!2`1, (: n_mid :)), n_mid)
[-10] P!1 = p
[-11] u!1 = hu(mid)
[-12] i!1`1 = mid
[-13] i!1`2 = n_mid
[-14] mid < p - 1
[-15] 2 <= p
  |-------
{1}   conc(nlist(append(i!2`1, (: n_mid :))),
           ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))
       =
       conc(nlist(append(i!2`1, cons(n_mid, null))),
            ilist(remove(hu_list, mid + 1)))
[2]   p = 2

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.1.2 : 
;;; simplify using the rem-function

{-1}  rem(p)(1 + mid) = 1 + mid
[-2]  length(i!2`1) = i!1`1
[-3]  (length(i!2`3) = i!1`1)
[-4]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-5]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-6]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  elt(append(i!2`1, (: n_mid :)), n_mid)
[-10] P!1 = p
[-11] u!1 = hu(mid)
[-12] i!1`1 = mid
[-13] i!1`2 = n_mid
[-14] mid < p - 1
[-15] 2 <= p
  |-------
{1}   ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))) =
       ilist(remove(hu_list, 1 + mid))
[2]   p = 2

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.1.2 : 
;;; simplify using the rem-function

[-1]  rem(p)(1 + mid) = 1 + mid
[-2]  length(i!2`1) = i!1`1
[-3]  (length(i!2`3) = i!1`1)
[-4]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-5]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-6]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  elt(append(i!2`1, (: n_mid :)), n_mid)
[-10] P!1 = p
[-11] u!1 = hu(mid)
[-12] i!1`1 = mid
[-13] i!1`2 = n_mid
[-14] mid < p - 1
[-15] 2 <= p
  |-------
{1}   append(i!2`3, cons(hu(mid), cdr(i!2`4))) = remove(hu_list, 1 + mid)
[2]   p = 2

Rerunning step: (comment "prove the equality of these lists by equality of their lengths and elements")
Adding comment: prove the equality of these lists by equality of their lengths and elements
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.1.2 : 
;;; prove the equality of these lists by equality of their lengths and elements

[-1]  rem(p)(1 + mid) = 1 + mid
[-2]  length(i!2`1) = i!1`1
[-3]  (length(i!2`3) = i!1`1)
[-4]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-5]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-6]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  elt(append(i!2`1, (: n_mid :)), n_mid)
[-10] P!1 = p
[-11] u!1 = hu(mid)
[-12] i!1`1 = mid
[-13] i!1`2 = n_mid
[-14] mid < p - 1
[-15] 2 <= p
  |-------
[1]   append(i!2`3, cons(hu(mid), cdr(i!2`4))) = remove(hu_list, 1 + mid)
[2]   p = 2

Rerunning step: (rewrite "length_nth_equality[Identity]" 1)
Found matching substitution:
l2: list[Identity] gets remove(hu_list, 1 + mid),
l1: list[Identity] gets append(i!2`3, cons(hu(mid), cdr(i!2`4))),
Rewriting using length_nth_equality[Identity], matching in 1,
this yields  2 subgoals: 
restrictpremid_middle.1.1.1.1.3.1.2.1 : 
;;; prove the equality of these lists by equality of their lengths and elements

[-1]  rem(p)(1 + mid) = 1 + mid
[-2]  length(i!2`1) = i!1`1
[-3]  (length(i!2`3) = i!1`1)
[-4]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-5]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-6]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  elt(append(i!2`1, (: n_mid :)), n_mid)
[-10] P!1 = p
[-11] u!1 = hu(mid)
[-12] i!1`1 = mid
[-13] i!1`2 = n_mid
[-14] mid < p - 1
[-15] 2 <= p
  |-------
{1}   length[Identity](append(i!2`3, cons(hu(mid), cdr(i!2`4)))) =
       length[Identity](remove(hu_list, 1 + mid))
[2]   append(i!2`3, cons(hu(mid), cdr(i!2`4))) = remove(hu_list, 1 + mid)
[3]   p = 2

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets cons(hu(mid), cdr(i!2`4)),
l1: list[T] gets i!2`3,
length rewrites length(cons(hu(mid), cdr(i!2`4)))
  to 1 + length[Nonce](cdr(i!2`4))
Rewriting using length_append, matching in 1,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.1.2.1 : 
;;; prove the equality of these lists by equality of their lengths and elements

[-1]  rem(p)(1 + mid) = 1 + mid
[-2]  length(i!2`1) = i!1`1
[-3]  (length(i!2`3) = i!1`1)
[-4]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-5]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-6]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  elt(append(i!2`1, (: n_mid :)), n_mid)
[-10] P!1 = p
[-11] u!1 = hu(mid)
[-12] i!1`1 = mid
[-13] i!1`2 = n_mid
[-14] mid < p - 1
[-15] 2 <= p
  |-------
{1}   1 + length[Nonce](cdr(i!2`4)) + length(i!2`3) =
       length[Identity](remove(hu_list, 1 + mid))
[2]   append(i!2`3, cons(hu(mid), cdr(i!2`4))) = remove(hu_list, 1 + mid)
[3]   p = 2

Rerunning step: (rewrite "length_remove" 1 :dir rl)
Found matching substitution:
i: below[length(c)] gets 1 + mid,
c: (cons?[T]) gets hu_list,
length rewrites length(hu_list)
  to 0
Rewriting using length_remove, matching in 1,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.1.2.1 : 
;;; prove the equality of these lists by equality of their lengths and elements

[-1]  rem(p)(1 + mid) = 1 + mid
[-2]  length(i!2`1) = i!1`1
[-3]  (length(i!2`3) = i!1`1)
[-4]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-5]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-6]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  elt(append(i!2`1, (: n_mid :)), n_mid)
[-10] P!1 = p
[-11] u!1 = hu(mid)
[-12] i!1`1 = mid
[-13] i!1`2 = n_mid
[-14] mid < p - 1
[-15] 2 <= p
  |-------
{1}   1 + length[Nonce](cdr(i!2`4)) + length(i!2`3) =
       length[Identity](hu_list) - 1
[2]   append(i!2`3, cons(hu(mid), cdr(i!2`4))) = remove(hu_list, 1 + mid)
[3]   p = 2

Rerunning step: (rewrite "length_cdr" 1)
Found matching substitution:
cons_l: (cons?[T]) gets i!2`4,
Rewriting using length_cdr, matching in 1,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.1.2.1 : 
;;; prove the equality of these lists by equality of their lengths and elements

[-1]  rem(p)(1 + mid) = 1 + mid
[-2]  length(i!2`1) = i!1`1
[-3]  (length(i!2`3) = i!1`1)
[-4]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-5]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-6]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  elt(append(i!2`1, (: n_mid :)), n_mid)
[-10] P!1 = p
[-11] u!1 = hu(mid)
[-12] i!1`1 = mid
[-13] i!1`2 = n_mid
[-14] mid < p - 1
[-15] 2 <= p
  |-------
{1}   1 + (length(i!2`4) - 1) + length(i!2`3) =
       length[Identity](hu_list) - 1
[2]   append(i!2`3, cons(hu(mid), cdr(i!2`4))) = remove(hu_list, 1 + mid)
[3]   p = 2

Rerunning step: (delete -1 -2 -4 -6 -8 -9 -11 -12 -13 -14 -15 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.1.2.1 : 
;;; prove the equality of these lists by equality of their lengths and elements

[-1]  (length(i!2`3) = i!1`1)
[-2]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-3]  (length(hu_list) = p)
[-4]  P!1 = p
  |-------
[1]   1 + (length(i!2`4) - 1) + length(i!2`3) =
       length[Identity](hu_list) - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.1.1.1.1.3.1.2.1.

restrictpremid_middle.1.1.1.1.3.1.2.2 : 
;;; prove the equality of these lists by equality of their lengths and elements

[-1]  rem(p)(1 + mid) = 1 + mid
[-2]  length(i!2`1) = i!1`1
[-3]  (length(i!2`3) = i!1`1)
[-4]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-5]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-6]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  elt(append(i!2`1, (: n_mid :)), n_mid)
[-10] P!1 = p
[-11] u!1 = hu(mid)
[-12] i!1`1 = mid
[-13] i!1`2 = n_mid
[-14] mid < p - 1
[-15] 2 <= p
  |-------
{1}   FORALL (i:
                below[length[Identity]
                          (append(i!2`3, cons(hu(mid), cdr(i!2`4))))]):
        nth(append(i!2`3, cons(hu(mid), cdr(i!2`4))), i) =
         nth(remove(hu_list, 1 + mid), i)
[2]   append(i!2`3, cons(hu(mid), cdr(i!2`4))) = remove(hu_list, 1 + mid)
[3]   p = 2

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.1.2.2 : 
;;; prove the equality of these lists by equality of their lengths and elements

{-1}  i!3 < length[Identity](append(i!2`3, cons(hu(mid), cdr(i!2`4))))
[-2]  rem(p)(1 + mid) = 1 + mid
[-3]  length(i!2`1) = i!1`1
[-4]  (length(i!2`3) = i!1`1)
[-5]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-6]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-7]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] elt(append(i!2`1, (: n_mid :)), n_mid)
[-11] P!1 = p
[-12] u!1 = hu(mid)
[-13] i!1`1 = mid
[-14] i!1`2 = n_mid
[-15] mid < p - 1
[-16] 2 <= p
  |-------
{1}   nth(append(i!2`3, cons(hu(mid), cdr(i!2`4))), i!3) =
       nth(remove(hu_list, 1 + mid), i!3)
[2]   append(i!2`3, cons(hu(mid), cdr(i!2`4))) = remove(hu_list, 1 + mid)
[3]   p = 2

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets cons(hu(mid), cdr(i!2`4)),
l1: list[T] gets i!2`3,
length rewrites length(cons(hu(mid), cdr(i!2`4)))
  to 1 + length[Nonce](cdr(i!2`4))
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.1.2.2 : 
;;; prove the equality of these lists by equality of their lengths and elements

{-1}  i!3 < 1 + length[Nonce](cdr(i!2`4)) + length(i!2`3)
[-2]  rem(p)(1 + mid) = 1 + mid
[-3]  length(i!2`1) = i!1`1
[-4]  (length(i!2`3) = i!1`1)
[-5]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-6]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-7]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] elt(append(i!2`1, (: n_mid :)), n_mid)
[-11] P!1 = p
[-12] u!1 = hu(mid)
[-13] i!1`1 = mid
[-14] i!1`2 = n_mid
[-15] mid < p - 1
[-16] 2 <= p
  |-------
[1]   nth(append(i!2`3, cons(hu(mid), cdr(i!2`4))), i!3) =
       nth(remove(hu_list, 1 + mid), i!3)
[2]   append(i!2`3, cons(hu(mid), cdr(i!2`4))) = remove(hu_list, 1 + mid)
[3]   p = 2

Rerunning step: (rewrite "length_cdr" -1)
Found matching substitution:
cons_l: (cons?[T]) gets i!2`4,
Rewriting using length_cdr, matching in -1,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.1.2.2 : 
;;; prove the equality of these lists by equality of their lengths and elements

{-1}  i!3 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-2]  rem(p)(1 + mid) = 1 + mid
[-3]  length(i!2`1) = i!1`1
[-4]  (length(i!2`3) = i!1`1)
[-5]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-6]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-7]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] elt(append(i!2`1, (: n_mid :)), n_mid)
[-11] P!1 = p
[-12] u!1 = hu(mid)
[-13] i!1`1 = mid
[-14] i!1`2 = n_mid
[-15] mid < p - 1
[-16] 2 <= p
  |-------
[1]   nth(append(i!2`3, cons(hu(mid), cdr(i!2`4))), i!3) =
       nth(remove(hu_list, 1 + mid), i!3)
[2]   append(i!2`3, cons(hu(mid), cdr(i!2`4))) = remove(hu_list, 1 + mid)
[3]   p = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.1.2.2 : 
;;; prove the equality of these lists by equality of their lengths and elements

[-1]  i!3 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-2]  rem(p)(1 + mid) = 1 + mid
[-3]  length(i!2`1) = i!1`1
[-4]  (length(i!2`3) = i!1`1)
[-5]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-6]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-7]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] elt(append(i!2`1, (: n_mid :)), n_mid)
[-11] P!1 = p
[-12] u!1 = hu(mid)
[-13] i!1`1 = mid
[-14] i!1`2 = n_mid
[-15] mid < p - 1
[-16] 2 <= p
  |-------
[1]   nth(append(i!2`3, cons(hu(mid), cdr(i!2`4))), i!3) =
       nth(remove(hu_list, 1 + mid), i!3)

Rerunning step: (lemma "listprops[Identity].nth_append"
                 ("l1" "i!2`3" "l2" "cons(hu(mid), cdr(i!2`4))" "i"
                  "i!3"))
length rewrites 
  length[Identity](cons[Identity](hu(mid), cdr[Identity](i!2`4)))
  to 1 + length[Nonce](cdr[Identity](i!2`4))
Applying listprops[Identity].nth_append where 
  l1 gets i!2`3,
  l2 gets cons(hu(mid), cdr(i!2`4)),
  i gets i!3,
this yields  2 subgoals: 
restrictpremid_middle.1.1.1.1.3.1.2.2.1 : 
;;; prove the equality of these lists by equality of their lengths and elements

{-1}  nth(append(i!2`3, cons(hu(mid), cdr(i!2`4))), i!3) =
       IF i!3 < length[Identity](i!2`3) THEN nth(i!2`3, i!3)
       ELSE nth(cons(hu(mid), cdr(i!2`4)), i!3 - length[Identity](i!2`3))
       ENDIF
[-2]  i!3 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-3]  rem(p)(1 + mid) = 1 + mid
[-4]  length(i!2`1) = i!1`1
[-5]  (length(i!2`3) = i!1`1)
[-6]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-7]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-8]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] elt(append(i!2`1, (: n_mid :)), n_mid)
[-12] P!1 = p
[-13] u!1 = hu(mid)
[-14] i!1`1 = mid
[-15] i!1`2 = n_mid
[-16] mid < p - 1
[-17] 2 <= p
  |-------
[1]   nth(append(i!2`3, cons(hu(mid), cdr(i!2`4))), i!3) =
       nth(remove(hu_list, 1 + mid), i!3)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.1.2.2.1 : 
;;; prove the equality of these lists by equality of their lengths and elements

[-1]  nth(append(i!2`3, cons(hu(mid), cdr(i!2`4))), i!3) =
       IF i!3 < length[Identity](i!2`3) THEN nth(i!2`3, i!3)
       ELSE nth(cons(hu(mid), cdr(i!2`4)), i!3 - length[Identity](i!2`3))
       ENDIF
[-2]  i!3 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-3]  rem(p)(1 + mid) = 1 + mid
[-4]  length(i!2`1) = i!1`1
[-5]  (length(i!2`3) = i!1`1)
[-6]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-7]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-8]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] elt(append(i!2`1, (: n_mid :)), n_mid)
[-12] P!1 = p
[-13] u!1 = hu(mid)
[-14] i!1`1 = mid
[-15] i!1`2 = n_mid
[-16] mid < p - 1
[-17] 2 <= p
  |-------
{1}   IF i!3 < length[Identity](i!2`3) THEN nth(i!2`3, i!3)
      ELSE nth(cons(hu(mid), cdr(i!2`4)), i!3 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, 1 + mid), i!3)

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.1.2.2.1 : 
;;; prove the equality of these lists by equality of their lengths and elements

[-1]  i!3 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-2]  rem(p)(1 + mid) = 1 + mid
[-3]  length(i!2`1) = i!1`1
[-4]  (length(i!2`3) = i!1`1)
[-5]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-6]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-7]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] elt(append(i!2`1, (: n_mid :)), n_mid)
[-11] P!1 = p
[-12] u!1 = hu(mid)
[-13] i!1`1 = mid
[-14] i!1`2 = n_mid
[-15] mid < p - 1
[-16] 2 <= p
  |-------
[1]   IF i!3 < length[Identity](i!2`3) THEN nth(i!2`3, i!3)
      ELSE nth(cons(hu(mid), cdr(i!2`4)), i!3 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, 1 + mid), i!3)

Rerunning step: (lemma "listprops[Identity].nth_remove"
                 ("l" "hu_list" "i" "1+mid" "j" "i!3"))
Applying listprops[Identity].nth_remove where 
  l gets hu_list,
  i gets 1 + mid,
  j gets i!3,
this yields  2 subgoals: 
restrictpremid_middle.1.1.1.1.3.1.2.2.1.1 : 
;;; prove the equality of these lists by equality of their lengths and elements

{-1}  nth(remove(hu_list, 1 + mid), i!3) =
       IF i!3 < 1 + mid THEN nth(hu_list, i!3)
       ELSE nth(hu_list, i!3 + 1)
       ENDIF
[-2]  i!3 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-3]  rem(p)(1 + mid) = 1 + mid
[-4]  length(i!2`1) = i!1`1
[-5]  (length(i!2`3) = i!1`1)
[-6]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-7]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-8]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] elt(append(i!2`1, (: n_mid :)), n_mid)
[-12] P!1 = p
[-13] u!1 = hu(mid)
[-14] i!1`1 = mid
[-15] i!1`2 = n_mid
[-16] mid < p - 1
[-17] 2 <= p
  |-------
[1]   IF i!3 < length[Identity](i!2`3) THEN nth(i!2`3, i!3)
      ELSE nth(cons(hu(mid), cdr(i!2`4)), i!3 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, 1 + mid), i!3)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.1.2.2.1.1 : 
;;; prove the equality of these lists by equality of their lengths and elements

[-1]  nth(remove(hu_list, 1 + mid), i!3) =
       IF i!3 < 1 + mid THEN nth(hu_list, i!3)
       ELSE nth(hu_list, i!3 + 1)
       ENDIF
[-2]  i!3 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-3]  rem(p)(1 + mid) = 1 + mid
[-4]  length(i!2`1) = i!1`1
[-5]  (length(i!2`3) = i!1`1)
[-6]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-7]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-8]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] elt(append(i!2`1, (: n_mid :)), n_mid)
[-12] P!1 = p
[-13] u!1 = hu(mid)
[-14] i!1`1 = mid
[-15] i!1`2 = n_mid
[-16] mid < p - 1
[-17] 2 <= p
  |-------
{1}   IF i!3 < length[Identity](i!2`3) THEN nth(i!2`3, i!3)
      ELSE nth(cons(hu(mid), cdr(i!2`4)), i!3 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!3 < 1 + mid THEN nth(hu_list, i!3)
       ELSE nth(hu_list, i!3 + 1)
       ENDIF

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.1.2.2.1.1 : 
;;; prove the equality of these lists by equality of their lengths and elements

[-1]  i!3 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-2]  rem(p)(1 + mid) = 1 + mid
[-3]  length(i!2`1) = i!1`1
[-4]  (length(i!2`3) = i!1`1)
[-5]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-6]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-7]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] elt(append(i!2`1, (: n_mid :)), n_mid)
[-11] P!1 = p
[-12] u!1 = hu(mid)
[-13] i!1`1 = mid
[-14] i!1`2 = n_mid
[-15] mid < p - 1
[-16] 2 <= p
  |-------
[1]   IF i!3 < length[Identity](i!2`3) THEN nth(i!2`3, i!3)
      ELSE nth(cons(hu(mid), cdr(i!2`4)), i!3 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!3 < 1 + mid THEN nth(hu_list, i!3)
       ELSE nth(hu_list, i!3 + 1)
       ENDIF

Rerunning step: (replace* -4 -6 -11 -13)
Repeatedly applying the replace rule,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.1.2.2.1.1 : 
;;; prove the equality of these lists by equality of their lengths and elements

{-1}  i!3 < p - 1 - mid + mid
[-2]  rem(p)(1 + mid) = 1 + mid
{-3}  length(i!2`1) = mid
{-4}  (length(i!2`3) = mid)
[-5]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
{-6}  (length(i!2`4) = p - 1 - mid)
{-7}  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + mid)
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] elt(append(i!2`1, (: n_mid :)), n_mid)
[-11] P!1 = p
[-12] u!1 = hu(mid)
[-13] i!1`1 = mid
[-14] i!1`2 = n_mid
[-15] mid < p - 1
[-16] 2 <= p
  |-------
{1}   IF i!3 < mid THEN nth(i!2`3, i!3)
      ELSE nth(cons(hu(mid), cdr(i!2`4)), i!3 - mid)
      ENDIF
       =
       IF i!3 < 1 + mid THEN nth(hu_list, i!3)
       ELSE nth(hu_list, i!3 + 1)
       ENDIF

Rerunning step: (delete -2 -3 -4 -6 -8 -10 -12 -14)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.1.2.2.1.1 : 
;;; prove the equality of these lists by equality of their lengths and elements

[-1]  i!3 < p - 1 - mid + mid
[-2]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-3]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + mid)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  P!1 = p
[-6]  i!1`1 = mid
[-7]  mid < p - 1
[-8]  2 <= p
  |-------
[1]   IF i!3 < mid THEN nth(i!2`3, i!3)
      ELSE nth(cons(hu(mid), cdr(i!2`4)), i!3 - mid)
      ENDIF
       =
       IF i!3 < 1 + mid THEN nth(hu_list, i!3)
       ELSE nth(hu_list, i!3 + 1)
       ENDIF

Rerunning step: (case "i!3<mid OR i!3=mid OR i!3>mid")
Case splitting on 
   i!3 < mid OR i!3 = mid OR i!3 > mid, 
this yields  2 subgoals: 
restrictpremid_middle.1.1.1.1.3.1.2.2.1.1.1 : 
;;; prove the equality of these lists by equality of their lengths and elements

{-1}  i!3 < mid OR i!3 = mid OR i!3 > mid
[-2]  i!3 < p - 1 - mid + mid
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + mid)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  P!1 = p
[-7]  i!1`1 = mid
[-8]  mid < p - 1
[-9]  2 <= p
  |-------
[1]   IF i!3 < mid THEN nth(i!2`3, i!3)
      ELSE nth(cons(hu(mid), cdr(i!2`4)), i!3 - mid)
      ENDIF
       =
       IF i!3 < 1 + mid THEN nth(hu_list, i!3)
       ELSE nth(hu_list, i!3 + 1)
       ENDIF

Rerunning step: (expand "nth" -4)
Expanding the definition of nth,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.1.2.2.1.1.1 : 
;;; prove the equality of these lists by equality of their lengths and elements

[-1]  i!3 < mid OR i!3 = mid OR i!3 > mid
[-2]  i!3 < p - 1 - mid + mid
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
{-4}  FORALL (k: below[P!1 - 1 - i!1`1]):
        IF k = 0 THEN car(i!2`4) ELSE nth(cdr(i!2`4), k - 1) ENDIF =
         hu(1 + k + mid)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  P!1 = p
[-7]  i!1`1 = mid
[-8]  mid < p - 1
[-9]  2 <= p
  |-------
[1]   IF i!3 < mid THEN nth(i!2`3, i!3)
      ELSE nth(cons(hu(mid), cdr(i!2`4)), i!3 - mid)
      ENDIF
       =
       IF i!3 < 1 + mid THEN nth(hu_list, i!3)
       ELSE nth(hu_list, i!3 + 1)
       ENDIF

Rerunning step: (expand "nth" 1 2)
Expanding the definition of nth,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.1.2.2.1.1.1 : 
;;; prove the equality of these lists by equality of their lengths and elements

[-1]  i!3 < mid OR i!3 = mid OR i!3 > mid
[-2]  i!3 < p - 1 - mid + mid
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  FORALL (k: below[P!1 - 1 - i!1`1]):
        IF k = 0 THEN car(i!2`4) ELSE nth(cdr(i!2`4), k - 1) ENDIF =
         hu(1 + k + mid)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  P!1 = p
[-7]  i!1`1 = mid
[-8]  mid < p - 1
[-9]  2 <= p
  |-------
{1}   IF i!3 < mid THEN nth(i!2`3, i!3)
      ELSE IF i!3 - mid = 0 THEN hu(mid)
           ELSE nth(cdr(i!2`4), -1 - mid + i!3)
           ENDIF
      ENDIF
       =
       IF i!3 < 1 + mid THEN nth(hu_list, i!3)
       ELSE nth(hu_list, 1 + i!3)
       ENDIF

Rerunning step: (grind :exclude "nth")
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpremid_middle.1.1.1.1.3.1.2.2.1.1.1.

restrictpremid_middle.1.1.1.1.3.1.2.2.1.1.2 : 
;;; prove the equality of these lists by equality of their lengths and elements

[-1]  i!3 < p - 1 - mid + mid
[-2]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-3]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + mid)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  P!1 = p
[-6]  i!1`1 = mid
[-7]  mid < p - 1
[-8]  2 <= p
  |-------
{1}   i!3 < mid OR i!3 = mid OR i!3 > mid
[2]   IF i!3 < mid THEN nth(i!2`3, i!3)
      ELSE nth(cons(hu(mid), cdr(i!2`4)), i!3 - mid)
      ENDIF
       =
       IF i!3 < 1 + mid THEN nth(hu_list, i!3)
       ELSE nth(hu_list, i!3 + 1)
       ENDIF

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.1.2.2.1.1.2 : 
;;; prove the equality of these lists by equality of their lengths and elements

  |-------
[1]   i!3 < mid OR i!3 = mid OR i!3 > mid

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.1.1.1.1.3.1.2.2.1.1.2.


This completes the proof of restrictpremid_middle.1.1.1.1.3.1.2.2.1.1.

restrictpremid_middle.1.1.1.1.3.1.2.2.1.2T (TCC):   

[-1]  i!3 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-2]  rem(p)(1 + mid) = 1 + mid
[-3]  length(i!2`1) = i!1`1
[-4]  (length(i!2`3) = i!1`1)
[-5]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-6]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-7]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] elt(append(i!2`1, (: n_mid :)), n_mid)
[-11] P!1 = p
[-12] u!1 = hu(mid)
[-13] i!1`1 = mid
[-14] i!1`2 = n_mid
[-15] mid < p - 1
[-16] 2 <= p
  |-------
{1}   i!3 < length[Identity](hu_list) - 1
[2]   IF i!3 < length[Identity](i!2`3) THEN nth(i!2`3, i!3)
      ELSE nth(cons(hu(mid), cdr(i!2`4)), i!3 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, 1 + mid), i!3)

Rerunning step: (delete -2 -3 -5 -7 -9 -10 -12 -14 -15 -16 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.1.2.2.1.2T : 
;;; prove the equality of these lists by equality of their lengths and elements

[-1]  i!3 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-2]  (length(i!2`3) = i!1`1)
[-3]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-4]  (length(hu_list) = p)
[-5]  P!1 = p
[-6]  i!1`1 = mid
  |-------
[1]   i!3 < length[Identity](hu_list) - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.1.1.1.1.3.1.2.2.1.2T.


This completes the proof of restrictpremid_middle.1.1.1.1.3.1.2.2.1.

restrictpremid_middle.1.1.1.1.3.1.2.2.2T (TCC):   

[-1]  i!3 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-2]  rem(p)(1 + mid) = 1 + mid
[-3]  length(i!2`1) = i!1`1
[-4]  (length(i!2`3) = i!1`1)
[-5]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-6]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-7]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] elt(append(i!2`1, (: n_mid :)), n_mid)
[-11] P!1 = p
[-12] u!1 = hu(mid)
[-13] i!1`1 = mid
[-14] i!1`2 = n_mid
[-15] mid < p - 1
[-16] 2 <= p
  |-------
{1}   i!3 <
       1 + length[Nonce](cdr[Identity](i!2`4)) + length[Identity](i!2`3)
[2]   nth(append(i!2`3, cons(hu(mid), cdr(i!2`4))), i!3) =
       nth(remove(hu_list, 1 + mid), i!3)

Rerunning step: (rewrite "length_cdr" 1)
Found matching substitution:
cons_l: (cons?[T]) gets i!2`4,
Rewriting using length_cdr, matching in 1,

This completes the proof of restrictpremid_middle.1.1.1.1.3.1.2.2.2T.


This completes the proof of restrictpremid_middle.1.1.1.1.3.1.2.2.


This completes the proof of restrictpremid_middle.1.1.1.1.3.1.2.


This completes the proof of restrictpremid_middle.1.1.1.1.3.1.

restrictpremid_middle.1.1.1.1.3.2 : 
;;; simplify using the rem-function

[-1]  length(i!2`1) = i!1`1
[-2]  (length(i!2`3) = i!1`1)
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-5]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  elt(append(i!2`1, (: n_mid :)), n_mid)
[-9]  P!1 = p
[-10] u!1 = hu(mid)
[-11] i!1`1 = mid
[-12] i!1`2 = n_mid
[-13] mid < p - 1
[-14] 2 <= p
  |-------
{1}   rem(p)(mid + 1) = mid + 1
[2]   public(car(i!2`4)) = public(hu(rem(p)(mid + 1))) AND
       EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
               nl2: {x: list[Nonce] | length(x) = 0}):
         conc(nlist(append(i!2`1, (: n_mid :))),
              ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))
          =
          conc(nlist(append(nl1, cons(n_mid, nl2))),
               ilist(remove(hu_list, rem(p)(mid + 1))))
[3]   p = 2

Rerunning step: (delete -1 -2
                  -3 -4
                  -5 -6
                  -7 -8
                  -9 -10
                  -11 -12
                  -13 -14
                  2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.2 : 
;;; simplify using the rem-function

  |-------
[1]   rem(p)(mid + 1) = mid + 1

Rerunning step: (rewrite "rem_def")
Found matching substitution:
r: mod(b) gets mid + 1,
x: int gets mid + 1,
b: posnat gets p,
Rewriting using rem_def, matching in *,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.2 : 
;;; simplify using the rem-function

  |-------
{1}   EXISTS q: 0 = p * q

Rerunning step: (inst 1 "0")
Instantiating the top quantifier in 1 with the terms: 
 0,
this simplifies to: 
restrictpremid_middle.1.1.1.1.3.2 : 
;;; simplify using the rem-function

  |-------
{1}   0 = p * 0

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.1.1.1.1.3.2.


This completes the proof of restrictpremid_middle.1.1.1.1.3.


This completes the proof of restrictpremid_middle.1.1.1.1.

restrictpremid_middle.1.1.1.2 :  

[-1]  rho_premid(v!1)
                (E(public(hu(mid)),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  P!1 = p
[-3]  u!1 = hu(mid)
[-4]  i!1`1 = mid
[-5]  i!1`2 = n_mid
[-6]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p) >= 1
[-7]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p) <
       p - 1
[-8]  0 < mid
[-9]  mid < p - 1
[-10] 2 <= p
  |-------
{1}   ((rec(hu(mid), nth(i!2`3, mid - 1),
            E(public(hu(mid)),
              conc(ilist(append(i!2`3, i!2`4)),
                   nlist(cons(n_mid, i!2`2)))))
         >>
         ((LastMessage(p, mid, hu(mid), i!2`1, i!2`2, i!2`3, i!2`4)) >>
           (signal(commit(mid, append(i!2`3, cons(hu(mid), i!2`4)), n_mid))
             >> Stop[event])))
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
{2}   R_premid(v!1)
              (trans(hu(mid), car(i!2`4),
                     E(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: n_mid :))),
                            ilist(append(i!2`3,
                                         cons(hu(mid), cdr(i!2`4))))))))
{3}   trans(hu(mid), car(i!2`4),
            E(public(car(i!2`4)),
              conc(nlist(append(i!2`1, (: n_mid :))),
                   ilist(append(i!2`3, cons(hu(mid), cdr(i!2`4)))))))
       >>
       ((rec(hu(mid), nth(i!2`3, mid - 1),
             E(public(hu(mid)),
               conc(ilist(append(i!2`3, i!2`4)),
                    nlist(cons(n_mid, i!2`2)))))
          >>
          ((LastMessage(p, mid, hu(mid), i!2`1, i!2`2, i!2`3, i!2`4)) >>
            (signal(commit(mid, append(i!2`3, cons(hu(mid), i!2`4)),
                           n_mid))
              >> Stop[event])))
         # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   p = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.1.2 :  

[-1]  rho_premid(v!1)
                (E(public(hu(mid)),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  P!1 = p
[-3]  u!1 = hu(mid)
[-4]  i!1`1 = mid
[-5]  i!1`2 = n_mid
[-6]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p) >= 1
[-7]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p) <
       p - 1
[-8]  0 < mid
[-9]  mid < p - 1
[-10] 2 <= p
  |-------
[1]   ((rec(hu(mid), nth(i!2`3, mid - 1),
            E(public(hu(mid)),
              conc(ilist(append(i!2`3, i!2`4)),
                   nlist(cons(n_mid, i!2`2)))))
         >>
         ((LastMessage(p, mid, hu(mid), i!2`1, i!2`2, i!2`3, i!2`4)) >>
           (signal(commit(mid, append(i!2`3, cons(hu(mid), i!2`4)), n_mid))
             >> Stop[event])))
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[2]   p = 2

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictpremid_middle.1.1.1.2 :  

{-1}  rho_premid(v!1)
                (E(public(hu(mid)),
                   conc(ilist(append(i!2`3, i!2`4)),
                        nlist(cons(n_mid, i!2`2)))))
[-2]  rho_premid(v!1)
                (E(public(hu(mid)),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-3]  P!1 = p
[-4]  u!1 = hu(mid)
[-5]  i!1`1 = mid
[-6]  i!1`2 = n_mid
[-7]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p) >= 1
[-8]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p) <
       p - 1
[-9]  0 < mid
[-10] mid < p - 1
[-11] 2 <= p
  |-------
{1}   (((LastMessage(p, mid, hu(mid), i!2`1, i!2`2, i!2`3, i!2`4)) >>
         (signal(commit(mid, append(i!2`3, cons(hu(mid), i!2`4)), n_mid))
           >> Stop[event]))
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
{2}   R_premid(v!1)
              (rec(hu(mid), nth(i!2`3, mid - 1),
                   E(public(hu(mid)),
                     conc(ilist(append(i!2`3, i!2`4)),
                          nlist(cons(n_mid, i!2`2))))))
{3}   rec(hu(mid), nth(i!2`3, mid - 1),
          E(public(hu(mid)),
            conc(ilist(append(i!2`3, i!2`4)), nlist(cons(n_mid, i!2`2)))))
       >>
       (((LastMessage(p, mid, hu(mid), i!2`1, i!2`2, i!2`3, i!2`4)) >>
          (signal(commit(mid, append(i!2`3, cons(hu(mid), i!2`4)), n_mid))
            >> Stop[event]))
         # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   p = 2

Rerunning step: (delete -2 -7 -8 -9 +)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.1.2 :  

[-1]  rho_premid(v!1)
                (E(public(hu(mid)),
                   conc(ilist(append(i!2`3, i!2`4)),
                        nlist(cons(n_mid, i!2`2)))))
[-2]  P!1 = p
[-3]  u!1 = hu(mid)
[-4]  i!1`1 = mid
[-5]  i!1`2 = n_mid
[-6]  mid < p - 1
[-7]  2 <= p
  |-------

Rerunning step: (comment "-1 should evaluate to false")
Adding comment: -1 should evaluate to false
this simplifies to: 
restrictpremid_middle.1.1.1.2 : 
;;; -1 should evaluate to false

[-1]  rho_premid(v!1)
                (E(public(hu(mid)),
                   conc(ilist(append(i!2`3, i!2`4)),
                        nlist(cons(n_mid, i!2`2)))))
[-2]  P!1 = p
[-3]  u!1 = hu(mid)
[-4]  i!1`1 = mid
[-5]  i!1`2 = n_mid
[-6]  mid < p - 1
[-7]  2 <= p
  |-------

Rerunning step: (grind :exclude ("remove" "elt"))
E rewrites 
  E(public(hu(mid)),
    conc(ilist(append(i!2`3, i!2`4)), nlist(cons(n_mid, i!2`2))))
  to code(public(hu(mid)),
           conc(ilist(append(i!2`3, i!2`4)), nlist(cons(n_mid, i!2`2))))
rho_premid rewrites rho_premid(v!1)(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_premid rewrites rho_premid(v!1)(nlist(cons(n_mid, i!2`2)))
  to NOT elt(cons(n_mid, i!2`2), n_mid)
rho_premid rewrites 
  rho_premid(v!1)
            (conc(ilist(append(i!2`3, i!2`4)), nlist(cons(n_mid, i!2`2))))
  to NOT elt(cons(n_mid, i!2`2), n_mid)
rho_premid rewrites 
  rho_premid(v!1)
            (code(public(hu(mid)),
                  conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(n_mid, i!2`2)))))
  to NOT elt(cons(n_mid, i!2`2), n_mid) OR
       (EXISTS (i: {x: nat | mid < x AND x <= p}):
          public(hu(mid)) = public(hu(rem(p)(i))) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                   nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
             conc(ilist(append(i!2`3, i!2`4)), nlist(cons(n_mid, i!2`2))) =
              conc(nlist(append(nl1, cons(n_mid, nl2))),
                   ilist(remove(hu_list, rem(p)(i)))))
        OR
        EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
          public(hu(mid)) = public(hu(i)) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                   nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
             conc(ilist(append(i!2`3, i!2`4)), nlist(cons(n_mid, i!2`2))) =
              conc(ilist(remove(hu_list, i)),
                   nlist(append(nl1, cons(n_mid, nl2))))
Trying repeated skolemization, instantiation, and if-lifting,
this yields  3 subgoals: 
restrictpremid_middle.1.1.1.2.1 : 
;;; -1 should evaluate to false

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl1!1)
{-2}  length(nl1!1) = mid
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
{-4}  length(nl2!1) = -1 - mid + i!3
{-5}  mid < i!3
{-6}  i!3 <= p
{-7}  public(hu(mid)) = public(hu(rem(p)(i!3)))
{-8}  conc(ilist(append(i!2`3, i!2`4)), nlist(cons(n_mid, i!2`2))) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, rem(p)(i!3))))
[-9]  P!1 = p
[-10] u!1 = hu(mid)
[-11] i!1`1 = mid
[-12] i!1`2 = n_mid
[-13] mid < p - 1
[-14] 2 <= p
  |-------

Rerunning step: (decompose-equality -8)
Applying decompose-equality,

This completes the proof of restrictpremid_middle.1.1.1.2.1.

restrictpremid_middle.1.1.1.2.2 : 
;;; -1 should evaluate to false

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl1!1)
{-2}  length(nl1!1) = mid - i!3
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
{-4}  length(nl2!1) = -1 - mid + p
{-5}  0 < i!3
{-6}  i!3 <= v!1
{-7}  public(hu(mid)) = public(hu(i!3))
{-8}  conc(ilist(append(i!2`3, i!2`4)), nlist(cons(n_mid, i!2`2))) =
       conc(ilist(remove(hu_list, i!3)),
            nlist(append(nl1!1, cons(n_mid, nl2!1))))
[-9]  P!1 = p
[-10] u!1 = hu(mid)
[-11] i!1`1 = mid
[-12] i!1`2 = n_mid
[-13] mid < p - 1
[-14] 2 <= p
  |-------

Rerunning step: (typepred "i!2`2" "v!1")
Adding type constraints for  i!2`2, v!1,
this simplifies to: 
restrictpremid_middle.1.1.1.2.2 : 
;;; -1 should evaluate to false

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`2)
{-2}  length(i!2`2) = P!1 - 1 - i!1`1
{-3}  v!1 < mid
[-4]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl1!1)
[-5]  length(nl1!1) = mid - i!3
[-6]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
[-7]  length(nl2!1) = -1 - mid + p
[-8]  0 < i!3
[-9]  i!3 <= v!1
[-10] public(hu(mid)) = public(hu(i!3))
[-11] conc(ilist(append(i!2`3, i!2`4)), nlist(cons(n_mid, i!2`2))) =
       conc(ilist(remove(hu_list, i!3)),
            nlist(append(nl1!1, cons(n_mid, nl2!1))))
[-12] P!1 = p
[-13] u!1 = hu(mid)
[-14] i!1`1 = mid
[-15] i!1`2 = n_mid
[-16] mid < p - 1
[-17] 2 <= p
  |-------

Rerunning step: (delete -1 -4 -6 -8 -10 -13 -15 -17)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.1.2.2 : 
;;; -1 should evaluate to false

[-1]  length(i!2`2) = P!1 - 1 - i!1`1
[-2]  v!1 < mid
[-3]  length(nl1!1) = mid - i!3
[-4]  length(nl2!1) = -1 - mid + p
[-5]  i!3 <= v!1
[-6]  conc(ilist(append(i!2`3, i!2`4)), nlist(cons(n_mid, i!2`2))) =
       conc(ilist(remove(hu_list, i!3)),
            nlist(append(nl1!1, cons(n_mid, nl2!1))))
[-7]  P!1 = p
[-8]  i!1`1 = mid
[-9]  mid < p - 1
  |-------

Rerunning step: (comment "contradiction in i!3=mid, -2 and -5")
Adding comment: contradiction in i!3=mid, -2 and -5
this simplifies to: 
restrictpremid_middle.1.1.1.2.2 : 
;;; contradiction in i!3=mid, -2 and -5

[-1]  length(i!2`2) = P!1 - 1 - i!1`1
[-2]  v!1 < mid
[-3]  length(nl1!1) = mid - i!3
[-4]  length(nl2!1) = -1 - mid + p
[-5]  i!3 <= v!1
[-6]  conc(ilist(append(i!2`3, i!2`4)), nlist(cons(n_mid, i!2`2))) =
       conc(ilist(remove(hu_list, i!3)),
            nlist(append(nl1!1, cons(n_mid, nl2!1))))
[-7]  P!1 = p
[-8]  i!1`1 = mid
[-9]  mid < p - 1
  |-------

Rerunning step: (case "i!3=mid")
Case splitting on 
   i!3 = mid, 
this yields  2 subgoals: 
restrictpremid_middle.1.1.1.2.2.1 : 
;;; contradiction in i!3=mid, -2 and -5

{-1}  i!3 = mid
[-2]  length(i!2`2) = P!1 - 1 - i!1`1
[-3]  v!1 < mid
[-4]  length(nl1!1) = mid - i!3
[-5]  length(nl2!1) = -1 - mid + p
[-6]  i!3 <= v!1
[-7]  conc(ilist(append(i!2`3, i!2`4)), nlist(cons(n_mid, i!2`2))) =
       conc(ilist(remove(hu_list, i!3)),
            nlist(append(nl1!1, cons(n_mid, nl2!1))))
[-8]  P!1 = p
[-9]  i!1`1 = mid
[-10] mid < p - 1
  |-------

Rerunning step: (delete -2 -4 -5 -7 -8 -9 -10)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.1.2.2.1 : 
;;; contradiction in i!3=mid, -2 and -5

[-1]  i!3 = mid
[-2]  v!1 < mid
[-3]  i!3 <= v!1
  |-------

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.1.1.1.2.2.1.

restrictpremid_middle.1.1.1.2.2.2 : 
;;; contradiction in i!3=mid, -2 and -5

[-1]  length(i!2`2) = P!1 - 1 - i!1`1
[-2]  v!1 < mid
[-3]  length(nl1!1) = mid - i!3
[-4]  length(nl2!1) = -1 - mid + p
[-5]  i!3 <= v!1
[-6]  conc(ilist(append(i!2`3, i!2`4)), nlist(cons(n_mid, i!2`2))) =
       conc(ilist(remove(hu_list, i!3)),
            nlist(append(nl1!1, cons(n_mid, nl2!1))))
[-7]  P!1 = p
[-8]  i!1`1 = mid
[-9]  mid < p - 1
  |-------
{1}   i!3 = mid

Rerunning step: (decompose-equality -6)
Applying decompose-equality,
this simplifies to: 
restrictpremid_middle.1.1.1.2.2.2 : 
;;; contradiction in i!3=mid, -2 and -5

{-1}  ilist(append(i!2`3, i!2`4)) = ilist(remove(hu_list, i!3))
{-2}  nlist(cons(n_mid, i!2`2)) = nlist(append(nl1!1, cons(n_mid, nl2!1)))
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  v!1 < mid
[-5]  length(nl1!1) = mid - i!3
[-6]  length(nl2!1) = -1 - mid + p
[-7]  i!3 <= v!1
[-8]  P!1 = p
[-9]  i!1`1 = mid
[-10] mid < p - 1
  |-------
[1]   i!3 = mid

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictpremid_middle.1.1.1.2.2.2 : 
;;; contradiction in i!3=mid, -2 and -5

{-1}  cons(n_mid, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-2]  ilist(append(i!2`3, i!2`4)) = ilist(remove(hu_list, i!3))
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  v!1 < mid
[-5]  length(nl1!1) = mid - i!3
[-6]  length(nl2!1) = -1 - mid + p
[-7]  i!3 <= v!1
[-8]  P!1 = p
[-9]  i!1`1 = mid
[-10] mid < p - 1
  |-------
[1]   i!3 = mid

Rerunning step: (lemma "listprops[Identity].equality_length"
                 ("l1" "cons(n_mid,i!2`2)" "l2"
                  "append(nl1!1,cons(n_mid,nl2!1))"))
Applying listprops[Identity].equality_length where 
  l1 gets cons(n_mid, i!2`2),
  l2 gets append(nl1!1, cons(n_mid, nl2!1)),
this simplifies to: 
restrictpremid_middle.1.1.1.2.2.2 : 
;;; contradiction in i!3=mid, -2 and -5

{-1}  cons(n_mid, i!2`2) = append(nl1!1, cons(n_mid, nl2!1)) IMPLIES
       length[Identity](cons(n_mid, i!2`2)) =
        length[Identity](append(nl1!1, cons(n_mid, nl2!1)))
[-2]  cons(n_mid, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-3]  ilist(append(i!2`3, i!2`4)) = ilist(remove(hu_list, i!3))
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  v!1 < mid
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  i!3 <= v!1
[-9]  P!1 = p
[-10] i!1`1 = mid
[-11] mid < p - 1
  |-------
[1]   i!3 = mid

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpremid_middle.1.1.1.2.2.2 : 
;;; contradiction in i!3=mid, -2 and -5

{-1}  length[Identity](cons(n_mid, i!2`2)) =
       length[Identity](append(nl1!1, cons(n_mid, nl2!1)))
[-2]  cons(n_mid, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-3]  ilist(append(i!2`3, i!2`4)) = ilist(remove(hu_list, i!3))
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  v!1 < mid
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  i!3 <= v!1
[-9]  P!1 = p
[-10] i!1`1 = mid
[-11] mid < p - 1
  |-------
[1]   i!3 = mid

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets cons(n_mid, nl2!1),
l1: list[T] gets nl1!1,
length rewrites length(cons(n_mid, nl2!1))
  to 1 + length[Nonce](nl2!1)
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictpremid_middle.1.1.1.2.2.2 : 
;;; contradiction in i!3=mid, -2 and -5

{-1}  length[Identity](cons(n_mid, i!2`2)) =
       1 + length(nl1!1) + length[Nonce](nl2!1)
[-2]  cons(n_mid, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-3]  ilist(append(i!2`3, i!2`4)) = ilist(remove(hu_list, i!3))
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  v!1 < mid
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  i!3 <= v!1
[-9]  P!1 = p
[-10] i!1`1 = mid
[-11] mid < p - 1
  |-------
[1]   i!3 = mid

Rerunning step: (expand "length" -1 1)
Expanding the definition of length,
this simplifies to: 
restrictpremid_middle.1.1.1.2.2.2 : 
;;; contradiction in i!3=mid, -2 and -5

{-1}  length[Identity](i!2`2) = length(nl1!1) + length[Nonce](nl2!1)
[-2]  cons(n_mid, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-3]  ilist(append(i!2`3, i!2`4)) = ilist(remove(hu_list, i!3))
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  v!1 < mid
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  i!3 <= v!1
[-9]  P!1 = p
[-10] i!1`1 = mid
[-11] mid < p - 1
  |-------
[1]   i!3 = mid

Rerunning step: (delete -2 -3 -5 -8 -11)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.1.2.2.2 : 
;;; contradiction in i!3=mid, -2 and -5

[-1]  length[Identity](i!2`2) = length(nl1!1) + length[Nonce](nl2!1)
[-2]  length(i!2`2) = P!1 - 1 - i!1`1
[-3]  length(nl1!1) = mid - i!3
[-4]  length(nl2!1) = -1 - mid + p
[-5]  P!1 = p
[-6]  i!1`1 = mid
  |-------
[1]   i!3 = mid

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.1.1.1.2.2.2.


This completes the proof of restrictpremid_middle.1.1.1.2.2.

restrictpremid_middle.1.1.1.2.3 : 
;;; -1 should evaluate to false

[-1]  P!1 = p
[-2]  u!1 = hu(mid)
[-3]  i!1`1 = mid
[-4]  i!1`2 = n_mid
[-5]  mid < p - 1
[-6]  2 <= p
  |-------
{1}   elt(cons(n_mid, i!2`2), n_mid)

Rerunning step: (expand "elt")
Expanding the definition of elt,
this simplifies to: 
restrictpremid_middle.1.1.1.2.3 : 
;;; -1 should evaluate to false

[-1]  P!1 = p
[-2]  u!1 = hu(mid)
[-3]  i!1`1 = mid
[-4]  i!1`2 = n_mid
[-5]  mid < p - 1
[-6]  2 <= p
  |-------
{1}   EXISTS (i: below[length(cons(n_mid, i!2`2))]):
        nth(cons(n_mid, i!2`2), i) = n_mid

Rerunning step: (inst 1 "0")
length rewrites length[Nonce](cons[Nonce](n_mid, i!2`2))
  to 1 + length[Nonce](i!2`2)
Instantiating the top quantifier in 1 with the terms: 
 0,
this simplifies to: 
restrictpremid_middle.1.1.1.2.3 : 
;;; -1 should evaluate to false

[-1]  P!1 = p
[-2]  u!1 = hu(mid)
[-3]  i!1`1 = mid
[-4]  i!1`2 = n_mid
[-5]  mid < p - 1
[-6]  2 <= p
  |-------
{1}   nth(cons(n_mid, i!2`2), 0) = n_mid

Rerunning step: (expand "nth")
Expanding the definition of nth,
this simplifies to: 
restrictpremid_middle.1.1.1.2.3 : 
;;; -1 should evaluate to false

[-1]  P!1 = p
[-2]  u!1 = hu(mid)
[-3]  i!1`1 = mid
[-4]  i!1`2 = n_mid
[-5]  mid < p - 1
[-6]  2 <= p
  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictpremid_middle.1.1.1.2.3.


This completes the proof of restrictpremid_middle.1.1.1.2.


This completes the proof of restrictpremid_middle.1.1.1.

restrictpremid_middle.1.1.2 :  

[-1]  P!1 = p
[-2]  u!1 = hu(mid)
[-3]  i!1`1 = mid
[-4]  i!1`2 = n_mid
{-5}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-6}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-7]  0 < i!1`1
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
{1}   cons?[Identity](i!2`4)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] |
                     (length(x) = i!1`1) AND
                      FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
                  {x: list[Identity] |
                     (length(x) = P!1 - 1 - i!1`1) AND
                      FORALL (k: below[P!1 - 1 - i!1`1]):
                        nth(x, k) = hu(1 + k + i!1`1)}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!1`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!1`2, i`2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                (signal(commit(mid, append(i`3, cons(u!1, i`4)), i!1`2)) >>
                  Stop[event])))))
         # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (delete -1 -2 -3 -4 -5 -6 -7 -9 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.2 :  

[-1]  i!1`1 < P!1 - 1
  |-------
[1]   cons?[Identity](i!2`4)

Rerunning step: (nonemptylist "i!2`4")
Relating existence of a tail to a list's length,

This completes the proof of restrictpremid_middle.1.1.2.

restrictpremid_middle.1.1.3 :  

[-1]  P!1 = p
[-2]  u!1 = hu(mid)
[-3]  i!1`1 = mid
[-4]  i!1`2 = n_mid
{-5}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-6}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-7]  0 < i!1`1
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
{1}   i!1`1 - 1 < length[Identity](i!2`3)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] |
                     (length(x) = i!1`1) AND
                      FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
                  {x: list[Identity] |
                     (length(x) = P!1 - 1 - i!1`1) AND
                      FORALL (k: below[P!1 - 1 - i!1`1]):
                        nth(x, k) = hu(1 + k + i!1`1)}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!1`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!1`2, i`2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                (signal(commit(mid, append(i`3, cons(u!1, i`4)), i!1`2)) >>
                  Stop[event])))))
         # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (nonemptylist "i!2`3")
Relating existence of a tail to a list's length,

This completes the proof of restrictpremid_middle.1.1.3.

restrictpremid_middle.1.1.4 :  

[-1]  P!1 = p
[-2]  u!1 = hu(mid)
[-3]  i!1`1 = mid
[-4]  i!1`2 = n_mid
{-5}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-6}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-7]  0 < i!1`1
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
{1}   (length(x!1) = P!1 - 1 - i!1`1) IMPLIES
       FORALL (k: below[P!1 - 1 - i!1`1]): k < length[Identity](x!1)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] |
                     (length(x) = i!1`1) AND
                      FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
                  {x: list[Identity] |
                     (length(x) = P!1 - 1 - i!1`1) AND
                      FORALL (k: below[P!1 - 1 - i!1`1]):
                        nth(x, k) = hu(1 + k + i!1`1)}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!1`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!1`2, i`2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                (signal(commit(mid, append(i`3, cons(u!1, i`4)), i!1`2)) >>
                  Stop[event])))))
         # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.4 :  

  |-------
[1]   (length(x!1) = P!1 - 1 - i!1`1) IMPLIES
       FORALL (k: below[P!1 - 1 - i!1`1]): k < length[Identity](x!1)

Rerunning step: (skosimp* 1)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictpremid_middle.1.1.4 :  

{-1}  k!1 < P!1 - 1 - i!1`1
{-2}  (length(x!1) = P!1 - 1 - i!1`1)
  |-------
{1}   k!1 < length[Identity](x!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.1.1.4.

restrictpremid_middle.1.1.5 :  

[-1]  P!1 = p
[-2]  u!1 = hu(mid)
[-3]  i!1`1 = mid
[-4]  i!1`2 = n_mid
{-5}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-6}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-7]  0 < i!1`1
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
{1}   (length(x!1) = i!1`1) IMPLIES
       FORALL (k: below[i!1`1]): k < length[Identity](x!1)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] |
                     (length(x) = i!1`1) AND
                      FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
                  {x: list[Identity] |
                     (length(x) = P!1 - 1 - i!1`1) AND
                      FORALL (k: below[P!1 - 1 - i!1`1]):
                        nth(x, k) = hu(1 + k + i!1`1)}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!1`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!1`2, i`2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                (signal(commit(mid, append(i`3, cons(u!1, i`4)), i!1`2)) >>
                  Stop[event])))))
         # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.5 :  

  |-------
[1]   (length(x!1) = i!1`1) IMPLIES
       FORALL (k: below[i!1`1]): k < length[Identity](x!1)

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictpremid_middle.1.1.5 :  

{-1}  (length(x!1) = i!1`1)
  |-------
{1}   k!1 < length[Identity](x!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.1.1.5.

restrictpremid_middle.1.1.6 :  

[-1]  P!1 = p
[-2]  u!1 = hu(mid)
[-3]  i!1`1 = mid
[-4]  i!1`2 = n_mid
{-5}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-6}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-7]  0 < i!1`1
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
{1}   FORALL (nl1: {x: list[Nonce] | length[Nonce](x) = i!1`1},
              nl2: {x: list[Nonce] | length[Nonce](x) = P!1 - 1 - i!1`1},
              il1:
                {x: list[Identity] |
                   (length[Identity](x) = i!1`1) AND
                    FORALL (k: below[i!1`1]): nth[Identity](x, k) = hu(k)},
              il2:
                {x: list[Identity] |
                   (length[Identity](x) = P!1 - 1 - i!1`1) AND
                    FORALL (k: below[P!1 - 1 - i!1`1]):
                      nth[Identity](x, k) = hu(1 + k + i!1`1)}):
        cons?[Identity](il2)
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1:
                 {x: list[Identity] |
                    (length(x) = i!1`1) AND
                     FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
               il2:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1 - i!1`1) AND
                     FORALL (k: below[P!1 - 1 - i!1`1]):
                       nth(x, k) = hu(1 + k + i!1`1)}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                (signal(commit(mid, append(il1, cons(u!1, il2)), i!1`2)) >>
                  Stop[event])))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictpremid_middle.1.1.6 :  

[-1]  P!1 = p
[-2]  u!1 = hu(mid)
[-3]  i!1`1 = mid
[-4]  i!1`2 = n_mid
[-5]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-6]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-7]  0 < i!1`1
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
{1}   cons?[Identity](il2!1)
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1:
                 {x: list[Identity] |
                    (length(x) = i!1`1) AND
                     FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
               il2:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1 - i!1`1) AND
                     FORALL (k: below[P!1 - 1 - i!1`1]):
                       nth(x, k) = hu(1 + k + i!1`1)}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                (signal(commit(mid, append(il1, cons(u!1, il2)), i!1`2)) >>
                  Stop[event])))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (delete -1 -2 -3 -4 -5 -6 -7 -9 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.6 :  

[-1]  i!1`1 < P!1 - 1
  |-------
[1]   cons?[Identity](il2!1)

Rerunning step: (nonemptylist "il2!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictpremid_middle.1.1.6.

restrictpremid_middle.1.1.7 :  

[-1]  P!1 = p
[-2]  u!1 = hu(mid)
[-3]  i!1`1 = mid
[-4]  i!1`2 = n_mid
{-5}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-6}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-7]  0 < i!1`1
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
{1}   FORALL (nl1: {x: list[Nonce] | length[Nonce](x) = i!1`1},
              nl2: {x: list[Nonce] | length[Nonce](x) = P!1 - 1 - i!1`1},
              il1:
                {x: list[Identity] |
                   (length[Identity](x) = i!1`1) AND
                    FORALL (k: below[i!1`1]): nth[Identity](x, k) = hu(k)},
              x: list[Identity]):
        (length(x) = P!1 - 1 - i!1`1) IMPLIES
         FORALL (k: below[P!1 - 1 - i!1`1]): k < length[Identity](x)
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1:
                 {x: list[Identity] |
                    (length(x) = i!1`1) AND
                     FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
               il2:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1 - i!1`1) AND
                     FORALL (k: below[P!1 - 1 - i!1`1]):
                       nth(x, k) = hu(1 + k + i!1`1)}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                (signal(commit(mid, append(il1, cons(u!1, il2)), i!1`2)) >>
                  Stop[event])))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.7 :  

  |-------
[1]   FORALL (nl1: {x: list[Nonce] | length[Nonce](x) = i!1`1},
              nl2: {x: list[Nonce] | length[Nonce](x) = P!1 - 1 - i!1`1},
              il1:
                {x: list[Identity] |
                   (length[Identity](x) = i!1`1) AND
                    FORALL (k: below[i!1`1]): nth[Identity](x, k) = hu(k)},
              x: list[Identity]):
        (length(x) = P!1 - 1 - i!1`1) IMPLIES
         FORALL (k: below[P!1 - 1 - i!1`1]): k < length[Identity](x)

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictpremid_middle.1.1.7 :  

{-1}  (length(x!1) = P!1 - 1 - i!1`1)
  |-------
{1}   k!1 < length[Identity](x!1)

Rerunning step: (typepred "k!1")
Adding type constraints for  k!1,
this simplifies to: 
restrictpremid_middle.1.1.7 :  

{-1}  k!1 < P!1 - 1 - i!1`1
[-2]  (length(x!1) = P!1 - 1 - i!1`1)
  |-------
[1]   k!1 < length[Identity](x!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.1.1.7.

restrictpremid_middle.1.1.8 :  

[-1]  P!1 = p
[-2]  u!1 = hu(mid)
[-3]  i!1`1 = mid
[-4]  i!1`2 = n_mid
{-5}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-6}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-7]  0 < i!1`1
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
{1}   FORALL (nl1: {x: list[Nonce] | length[Nonce](x) = i!1`1},
              nl2: {x: list[Nonce] | length[Nonce](x) = P!1 - 1 - i!1`1},
              x: list[Identity]):
        (length(x) = i!1`1) IMPLIES
         FORALL (k: below[i!1`1]): k < length[Identity](x)
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1:
                 {x: list[Identity] |
                    (length(x) = i!1`1) AND
                     FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
               il2:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1 - i!1`1) AND
                     FORALL (k: below[P!1 - 1 - i!1`1]):
                       nth(x, k) = hu(1 + k + i!1`1)}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                (signal(commit(mid, append(il1, cons(u!1, il2)), i!1`2)) >>
                  Stop[event])))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.8 :  

  |-------
[1]   FORALL (nl1: {x: list[Nonce] | length[Nonce](x) = i!1`1},
              nl2: {x: list[Nonce] | length[Nonce](x) = P!1 - 1 - i!1`1},
              x: list[Identity]):
        (length(x) = i!1`1) IMPLIES
         FORALL (k: below[i!1`1]): k < length[Identity](x)

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictpremid_middle.1.1.8 :  

{-1}  (length(x!1) = i!1`1)
  |-------
{1}   k!1 < length[Identity](x!1)

Rerunning step: (typepred "k!1")
Adding type constraints for  k!1,
this simplifies to: 
restrictpremid_middle.1.1.8 :  

{-1}  k!1 < i!1`1
[-2]  (length(x!1) = i!1`1)
  |-------
[1]   k!1 < length[Identity](x!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.1.1.8.

restrictpremid_middle.1.1.9 :  

[-1]  P!1 = p
[-2]  u!1 = hu(mid)
[-3]  i!1`1 = mid
[-4]  i!1`2 = n_mid
{-5}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-6}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-7]  0 < i!1`1
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
{1}   FORALL (x: list[Identity]):
        (length(x) = P!1 - 1 - i!1`1) IMPLIES
         FORALL (k: below[P!1 - 1 - i!1`1]): k < length[Identity](x)
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1:
                 {x: list[Identity] |
                    (length(x) = i!1`1) AND
                     FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
               il2:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1 - i!1`1) AND
                     FORALL (k: below[P!1 - 1 - i!1`1]):
                       nth(x, k) = hu(1 + k + i!1`1)}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                (signal(commit(mid, append(il1, cons(u!1, il2)), i!1`2)) >>
                  Stop[event])))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.9 :  

  |-------
[1]   FORALL (x: list[Identity]):
        (length(x) = P!1 - 1 - i!1`1) IMPLIES
         FORALL (k: below[P!1 - 1 - i!1`1]): k < length[Identity](x)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictpremid_middle.1.1.9 :  

  |-------
{1}   (length(x!1) = P!1 - 1 - i!1`1) IMPLIES
       FORALL (k: below[P!1 - 1 - i!1`1]): k < length[Identity](x!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.1.1.9.

restrictpremid_middle.1.1.10 :  

[-1]  P!1 = p
[-2]  u!1 = hu(mid)
[-3]  i!1`1 = mid
[-4]  i!1`2 = n_mid
{-5}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-6}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-7]  0 < i!1`1
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
{1}   FORALL (x: list[Identity]):
        (length(x) = i!1`1) IMPLIES
         FORALL (k: below[i!1`1]): k < length[Identity](x)
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1:
                 {x: list[Identity] |
                    (length(x) = i!1`1) AND
                     FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
               il2:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1 - i!1`1) AND
                     FORALL (k: below[P!1 - 1 - i!1`1]):
                       nth(x, k) = hu(1 + k + i!1`1)}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                (signal(commit(mid, append(il1, cons(u!1, il2)), i!1`2)) >>
                  Stop[event])))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.1.10 :  

  |-------
[1]   FORALL (x: list[Identity]):
        (length(x) = i!1`1) IMPLIES
         FORALL (k: below[i!1`1]): k < length[Identity](x)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictpremid_middle.1.1.10 :  

  |-------
{1}   (length(x!1) = i!1`1) IMPLIES
       FORALL (k: below[i!1`1]): k < length[Identity](x!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.1.1.10.


This completes the proof of restrictpremid_middle.1.1.

restrictpremid_middle.1.2 :  

[-1]  i!1`2 = n_mid
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   P!1 = p AND u!1 = hu(mid) AND i!1`1 = mid
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1:
                 {x: list[Identity] |
                    (length(x) = i!1`1) AND
                     FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
               il2:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1 - i!1`1) AND
                     FORALL (k: below[P!1 - 1 - i!1`1]):
                       nth(x, k) = hu(1 + k + i!1`1)}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                (signal(commit(mid, append(il1, cons(u!1, il2)), i!1`2)) >>
                  Stop[event])))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (delete -2 -3 -4 -5 -6 -7 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.2 :  

[-1]  i!1`2 = n_mid
  |-------
[1]   P!1 = p AND u!1 = hu(mid) AND i!1`1 = mid

Rerunning step: (typepred "i!1`2")
Adding type constraints for  i!1`2,
this simplifies to: 
restrictpremid_middle.1.2 :  

{-1}  IRpart(P!1, u!1, i!1`1)(i!1`2)
[-2]  i!1`2 = n_mid
  |-------
[1]   P!1 = p AND u!1 = hu(mid) AND i!1`1 = mid

Rerunning step: (lemma "n_orig" ("P" "P!1" "u" "u!1" "r" "i!1`1"))
Applying n_orig where 
  P gets P!1,
  u gets u!1,
  r gets i!1`1,
this simplifies to: 
restrictpremid_middle.1.2 :  

{-1}  IRpart(P!1, u!1, i!1`1)(n_mid) =>
       (P!1 = p AND u!1 = hu(mid) AND i!1`1 = mid)
[-2]  IRpart(P!1, u!1, i!1`1)(i!1`2)
[-3]  i!1`2 = n_mid
  |-------
[1]   P!1 = p AND u!1 = hu(mid) AND i!1`1 = mid

Rerunning step: (grind)
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpremid_middle.1.2.

restrictpremid_middle.1.3T (TCC):   

[-1]  i!1`2 = n_mid
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   P!1 = p IMPLIES mid < p
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1:
                 {x: list[Identity] |
                    (length(x) = i!1`1) AND
                     FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
               il2:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1 - i!1`1) AND
                     FORALL (k: below[P!1 - 1 - i!1`1]):
                       nth(x, k) = hu(1 + k + i!1`1)}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                (signal(commit(mid, append(il1, cons(u!1, il2)), i!1`2)) >>
                  Stop[event])))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (typepred "mid")
Adding type constraints for  mid,
this simplifies to: 
restrictpremid_middle.1.3T :  

{-1}  0 < mid
{-2}  mid < p - 1
[-3]  i!1`2 = n_mid
[-4]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-5]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-6]  0 < i!1`1
[-7]  i!1`1 < P!1 - 1
[-8]  2 <= P!1
  |-------
[1]   P!1 = p IMPLIES mid < p
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1:
                 {x: list[Identity] |
                    (length(x) = i!1`1) AND
                     FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
               il2:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1 - i!1`1) AND
                     FORALL (k: below[P!1 - 1 - i!1`1]):
                       nth(x, k) = hu(1 + k + i!1`1)}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                (signal(commit(mid, append(il1, cons(u!1, il2)), i!1`2)) >>
                  Stop[event])))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (delete -1 -3 -4 -5 -6 -7 -8 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.1.3T :  

[-1]  mid < p - 1
  |-------
[1]   P!1 = p IMPLIES mid < p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.1.3T.


This completes the proof of restrictpremid_middle.1.

restrictpremid_middle.2 :  

{-1}  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1: {x: list[Identity] | length(x) = i!1`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              (signal(running(i!1`1, append(il1, cons(u!1, il2)),
                              nth(cons(i!1`2, nl2),
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)
                                   - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
{2}   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (choice3)
Applying choice rule,
this yields  6 subgoals: 
restrictpremid_middle.2.1 :  

[-1]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   (rec(u!1, nth(i!2`3, i!1`1 - 1),
           E(public(u!1), conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
        >>
        (trans(u!1, car(i!2`4),
               E(public(car(i!2`4)),
                 conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
          >>
          (rec(u!1, nth(i!2`3, i!1`1 - 1),
               E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
            >>
            (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                            nth(cons(i!1`2, i!2`2),
                                floor(1 - 2 * ((mid - 1) / (p - 2))
                                      +
                                      ((mid - 1) / (p - 2)) * P!1)
                                 - i!1`1)))
              >>
              ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4))
                >> Stop[event])))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictpremid_middle.2.1 :  

{-1}  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
{-3}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-4}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
{1}   ((trans(u!1, car(i!2`4),
              E(public(car(i!2`4)),
                conc(nlist(append(i!2`1, (: i!1`2 :))),
                     ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
         >>
         (rec(u!1, nth(i!2`3, i!1`1 - 1),
              E(public(u!1),
                conc(ilist(append(i!2`3, i!2`4)),
                     nlist(cons(i!1`2, i!2`2)))))
           >>
           (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                           nth(cons(i!1`2, i!2`2),
                               floor(1 - 2 * ((mid - 1) / (p - 2))
                                     +
                                     ((mid - 1) / (p - 2)) * P!1)
                                - i!1`1)))
             >>
             ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
               Stop[event]))))
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
{2}   R_premid(v!1)
              (rec(u!1, nth(i!2`3, i!1`1 - 1),
                   E(public(u!1),
                     conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))))
{3}   rec(u!1, nth(i!2`3, i!1`1 - 1),
          E(public(u!1), conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
       >>
       ((trans(u!1, car(i!2`4),
               E(public(car(i!2`4)),
                 conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
          >>
          (rec(u!1, nth(i!2`3, i!1`1 - 1),
               E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
            >>
            (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                            nth(cons(i!1`2, i!2`2),
                                floor(1 - 2 * ((mid - 1) / (p - 2))
                                      +
                                      ((mid - 1) / (p - 2)) * P!1)
                                 - i!1`1)))
              >>
              ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4))
                >> Stop[event]))))
         # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   ((trans(u!1, car(i!2`4),
              E(public(car(i!2`4)),
                conc(nlist(append(i!2`1, (: i!1`2 :))),
                     ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
         >>
         (rec(u!1, nth(i!2`3, i!1`1 - 1),
              E(public(u!1),
                conc(ilist(append(i!2`3, i!2`4)),
                     nlist(cons(i!1`2, i!2`2)))))
           >>
           (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                           nth(cons(i!1`2, i!2`2),
                               floor(1 - 2 * ((mid - 1) / (p - 2))
                                     +
                                     ((mid - 1) / (p - 2)) * P!1)
                                - i!1`1)))
             >>
             ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
               Stop[event]))))
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictpremid_middle.2.1.1 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
{1}   rho_premid(v!1)
                (E(public(car(i!2`4)),
                   conc(nlist(append(i!2`1, (: i!1`2 :))),
                        ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
{2}   R_premid(v!1)
              (trans(u!1, car(i!2`4),
                     E(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))))
{3}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(nlist(append(i!2`1, (: i!1`2 :))),
                   ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
       >>
       ((rec(u!1, nth(i!2`3, i!1`1 - 1),
             E(public(u!1),
               conc(ilist(append(i!2`3, i!2`4)),
                    nlist(cons(i!1`2, i!2`2)))))
          >>
          (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                          nth(cons(i!1`2, i!2`2),
                              floor(1 - 2 * ((mid - 1) / (p - 2))
                                    +
                                    ((mid - 1) / (p - 2)) * P!1)
                               - i!1`1)))
            >>
            ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
              Stop[event])))
         # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete -3 -4 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.1 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (E(public(car(i!2`4)),
                   conc(nlist(append(i!2`1, (: i!1`2 :))),
                        ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (expand "E")
Expanding the definition of E,
this simplifies to: 
restrictpremid_middle.2.1.1 :  

{-1}  rho_premid(v!1)
                (code(public(u!1),
                      conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
{1}   rho_premid(v!1)
                (code(public(car(i!2`4)),
                      conc(nlist(append(i!2`1, (: i!1`2 :))),
                           ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (expand "rho_premid" -1)
Expanding the definition of rho_premid,
this simplifies to: 
restrictpremid_middle.2.1.1 :  

{-1}  rho_premid(v!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))) OR
       (EXISTS (i: {x: nat | mid < x AND x <= p}):
          public(u!1) = public(hu(rem(p)(i))) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                   nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
             conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
              conc(nlist(append(nl1, cons(n_mid, nl2))),
                   ilist(remove(hu_list, rem(p)(i)))))
        OR
        EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
          public(u!1) = public(hu(i)) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                   nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
             conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
              conc(ilist(remove(hu_list, i)),
                   nlist(append(nl1, cons(n_mid, nl2))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`4)),
                      conc(nlist(append(i!2`1, (: i!1`2 :))),
                           ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (comment "3 different cases are to be distinguished amongst for the (assumed) validity of the received message")
Adding comment: 3 different cases are to be distinguished amongst for the (assumed) validity of the received message
this simplifies to: 
restrictpremid_middle.2.1.1 : 
;;; 3 different cases are to be distinguished amongst for the (assumed) validity of the received message

[-1]  rho_premid(v!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))) OR
       (EXISTS (i: {x: nat | mid < x AND x <= p}):
          public(u!1) = public(hu(rem(p)(i))) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                   nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
             conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
              conc(nlist(append(nl1, cons(n_mid, nl2))),
                   ilist(remove(hu_list, rem(p)(i)))))
        OR
        EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
          public(u!1) = public(hu(i)) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                   nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
             conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
              conc(ilist(remove(hu_list, i)),
                   nlist(append(nl1, cons(n_mid, nl2))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`4)),
                      conc(nlist(append(i!2`1, (: i!1`2 :))),
                           ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (split)
Splitting conjunctions,
this yields  3 subgoals: 
restrictpremid_middle.2.1.1.1 : 
;;; 3 different cases are to be distinguished amongst for the (assumed) validity of the received message

{-1}  rho_premid(v!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`4)),
                      conc(nlist(append(i!2`1, (: i!1`2 :))),
                           ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (comment "n_mid is not contained in a list of nonces")
Adding comment: n_mid is not contained in a list of nonces
this simplifies to: 
restrictpremid_middle.2.1.1.1 : 
;;; n_mid is not contained in a list of nonces

[-1]  rho_premid(v!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`4)),
                      conc(nlist(append(i!2`1, (: i!1`2 :))),
                           ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (expand "rho_premid" 1)
Expanding the definition of rho_premid,
this simplifies to: 
restrictpremid_middle.2.1.1.1 : 
;;; n_mid is not contained in a list of nonces

[-1]  rho_premid(v!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
{1}   rho_premid(v!1)
                (conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))
       OR
       (EXISTS (i: {x: nat | mid < x AND x <= p}):
          public(car(i!2`4)) = public(hu(rem(p)(i))) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                   nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
             conc(nlist(append(i!2`1, (: i!1`2 :))),
                  ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
              =
              conc(nlist(append(nl1, cons(n_mid, nl2))),
                   ilist(remove(hu_list, rem(p)(i)))))
        OR
        EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
          public(car(i!2`4)) = public(hu(i)) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                   nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
             conc(nlist(append(i!2`1, (: i!1`2 :))),
                  ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
              =
              conc(ilist(remove(hu_list, i)),
                   nlist(append(nl1, cons(n_mid, nl2))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictpremid_middle.2.1.1.1 : 
;;; n_mid is not contained in a list of nonces

[-1]  rho_premid(v!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
{1}   rho_premid(v!1)
                (conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))
{2}   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
{3}   EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(car(i!2`4)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.1.1 : 
;;; n_mid is not contained in a list of nonces

[-1]  rho_premid(v!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (lemma "listprops[Nonce].elt_append3"
                 ("l1" "i!2`1" "l2" "(:i!1`2:)" "t" "n_mid"))
Applying listprops[Nonce].elt_append3 where 
  l1 gets i!2`1,
  l2 gets (: i!1`2 :),
  t gets n_mid,
this simplifies to: 
restrictpremid_middle.2.1.1.1 : 
;;; n_mid is not contained in a list of nonces

{-1}  elt(append(i!2`1, (: i!1`2 :)), n_mid) IMPLIES
       elt(i!2`1, n_mid) OR elt((: i!1`2 :), n_mid)
[-2]  rho_premid(v!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
[-3]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (lemma "listprops[Nonce].elt_singleton"
                 ("t1" "i!1`2" "t2" "n_mid"))
Applying listprops[Nonce].elt_singleton where 
  t1 gets i!1`2,
  t2 gets n_mid,
this simplifies to: 
restrictpremid_middle.2.1.1.1 : 
;;; n_mid is not contained in a list of nonces

{-1}  elt((: i!1`2 :), n_mid) IFF i!1`2 = n_mid
[-2]  elt(append(i!2`1, (: i!1`2 :)), n_mid) IMPLIES
       elt(i!2`1, n_mid) OR elt((: i!1`2 :), n_mid)
[-3]  rho_premid(v!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
[-4]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (grind :exclude "elt")
rho_premid rewrites rho_premid(v!1)(nlist(i!2`1))
  to FALSE
rho_premid rewrites rho_premid(v!1)(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_premid rewrites 
  rho_premid(v!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
  to FALSE
rho_premid rewrites rho_premid(v!1)(nlist(i!2`1))
  to NOT elt(i!2`1, n_mid)
rho_premid rewrites rho_premid(v!1)(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_premid rewrites 
  rho_premid(v!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
  to NOT elt(i!2`1, n_mid)
rho_premid rewrites rho_premid(v!1)(nlist(append(i!2`1, (: i!1`2 :))))
  to TRUE
rho_premid rewrites 
  rho_premid(v!1)(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
  to TRUE
rho_premid rewrites 
  rho_premid(v!1)
            (conc(nlist(append(i!2`1, (: i!1`2 :))),
                  ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpremid_middle.2.1.1.1.

restrictpremid_middle.2.1.1.2 : 
;;; 3 different cases are to be distinguished amongst for the (assumed) validity of the received message

{-1}  EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(u!1) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`4)),
                      conc(nlist(append(i!2`1, (: i!1`2 :))),
                           ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictpremid_middle.2.1.1.2 : 
;;; 3 different cases are to be distinguished amongst for the (assumed) validity of the received message

{-1}  public(u!1) = public(hu(rem(p)(i!3)))
{-2}  conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, rem(p)(i!3))))
[-3]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`4)),
                      conc(nlist(append(i!2`1, (: i!1`2 :))),
                           ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictpremid_middle.2.1.1.2 : 
;;; 3 different cases are to be distinguished amongst for the (assumed) validity of the received message

{-1}  nlist(i!2`1) = nlist(append(nl1!1, cons(n_mid, nl2!1)))
{-2}  ilist(append(i!2`3, i!2`4)) = ilist(remove(hu_list, rem(p)(i!3)))
[-3]  public(u!1) = public(hu(rem(p)(i!3)))
[-4]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`4)),
                      conc(nlist(append(i!2`1, (: i!1`2 :))),
                           ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictpremid_middle.2.1.1.2 : 
;;; 3 different cases are to be distinguished amongst for the (assumed) validity of the received message

{-1}  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-2]  ilist(append(i!2`3, i!2`4)) = ilist(remove(hu_list, rem(p)(i!3)))
[-3]  public(u!1) = public(hu(rem(p)(i!3)))
[-4]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`4)),
                      conc(nlist(append(i!2`1, (: i!1`2 :))),
                           ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictpremid_middle.2.1.1.2 : 
;;; 3 different cases are to be distinguished amongst for the (assumed) validity of the received message

{-1}  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-2]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-3]  public(u!1) = public(hu(rem(p)(i!3)))
[-4]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`4)),
                      conc(nlist(append(i!2`1, (: i!1`2 :))),
                           ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (typepred "i!3" "i!2`1" "i!2`3" "i!2`4" "nl1!1" "nl2!1"
                 "hu_list")
Adding type constraints for  i!3, i!2`1, i!2`3, i!2`4, nl1!1, nl2!1, hu_list,
this simplifies to: 
restrictpremid_middle.2.1.1.2 : 
;;; 3 different cases are to be distinguished amongst for the (assumed) validity of the received message

{-1}  mid < i!3
{-2}  i!3 <= p
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`1)
{-4}  length(i!2`1) = i!1`1
{-5}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`3)
{-6}  length(i!2`3) = i!1`1
{-7}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`4)
{-8}  length(i!2`4) = P!1 - 1 - i!1`1
{-9}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl1!1)
{-10} length(nl1!1) = mid
{-11} every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
{-12} length(nl2!1) = -1 - mid + i!3
{-13} every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-14} (length(hu_list) = p)
{-15} FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-16] append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-17] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-18] public(u!1) = public(hu(rem(p)(i!3)))
[-19] i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-20] 0 < i!1`1
[-21] i!1`1 < P!1 - 1
[-22] 2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`4)),
                      conc(nlist(append(i!2`1, (: i!1`2 :))),
                           ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (delete -2 -3 -5 -7 -9 -11 -13 -15 -18 -20 -22 +)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.1.2 : 
;;; 3 different cases are to be distinguished amongst for the (assumed) validity of the received message

[-1]  mid < i!3
[-2]  length(i!2`1) = i!1`1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  length(nl1!1) = mid
[-6]  length(nl2!1) = -1 - mid + i!3
[-7]  (length(hu_list) = p)
[-8]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-9]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-10] i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-11] i!1`1 < P!1 - 1
  |-------

Rerunning step: (comment "contradiction in -1, -10 and i!3=i!1`1")
Adding comment: contradiction in -1, -10 and i!3=i!1`1
this simplifies to: 
restrictpremid_middle.2.1.1.2 : 
;;; contradiction in -1, -10 and i!3=i!1`1

[-1]  mid < i!3
[-2]  length(i!2`1) = i!1`1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  length(nl1!1) = mid
[-6]  length(nl2!1) = -1 - mid + i!3
[-7]  (length(hu_list) = p)
[-8]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-9]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-10] i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-11] i!1`1 < P!1 - 1
  |-------

Rerunning step: (case "P!1=p" "i!1`1=i!3")
Case splitting on 
   P!1 = p, 
   i!1`1 = i!3, 
this yields  3 subgoals: 
restrictpremid_middle.2.1.1.2.1 : 
;;; contradiction in -1, -10 and i!3=i!1`1

{-1}  i!1`1 = i!3
{-2}  P!1 = p
[-3]  mid < i!3
[-4]  length(i!2`1) = i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -1 - mid + i!3
[-9]  (length(hu_list) = p)
[-10] append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-13] i!1`1 < P!1 - 1
  |-------

Rerunning step: (lemma "select_right_nonce2" ("P" "P!1"))
Applying select_right_nonce2 where 
  P gets P!1,
this simplifies to: 
restrictpremid_middle.2.1.1.2.1 : 
;;; contradiction in -1, -10 and i!3=i!1`1

{-1}  (P!1 = p IMPLIES floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid)
       AND
       floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1 AND
        floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-2]  i!1`1 = i!3
[-3]  P!1 = p
[-4]  mid < i!3
[-5]  length(i!2`1) = i!1`1
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = P!1 - 1 - i!1`1
[-8]  length(nl1!1) = mid
[-9]  length(nl2!1) = -1 - mid + i!3
[-10] (length(hu_list) = p)
[-11] append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-12] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-13] i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-14] i!1`1 < P!1 - 1
  |-------

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpremid_middle.2.1.1.2.1 : 
;;; contradiction in -1, -10 and i!3=i!1`1

{-1}  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid
{-2}  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
{-3}  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-4]  i!1`1 = i!3
[-5]  P!1 = p
[-6]  mid < i!3
[-7]  length(i!2`1) = i!1`1
[-8]  length(i!2`3) = i!1`1
[-9]  length(i!2`4) = P!1 - 1 - i!1`1
[-10] length(nl1!1) = mid
[-11] length(nl2!1) = -1 - mid + i!3
[-12] (length(hu_list) = p)
[-13] append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-14] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-15] i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-16] i!1`1 < P!1 - 1
  |-------

Rerunning step: (delete -2 -3 -5 -7 -8 -9 -10 -11 -12 -13 -14 -16)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.1.2.1 : 
;;; contradiction in -1, -10 and i!3=i!1`1

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid
[-2]  i!1`1 = i!3
[-3]  mid < i!3
[-4]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
  |-------

Rerunning step: (replace -1 -4)
Replacing using formula -1,
this simplifies to: 
restrictpremid_middle.2.1.1.2.1 : 
;;; contradiction in -1, -10 and i!3=i!1`1

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid
[-2]  i!1`1 = i!3
[-3]  mid < i!3
{-4}  i!1`1 <= mid
  |-------

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.1.2.1 : 
;;; contradiction in -1, -10 and i!3=i!1`1

[-1]  i!1`1 = i!3
[-2]  mid < i!3
[-3]  i!1`1 <= mid
  |-------

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.1.1.2.1.

restrictpremid_middle.2.1.1.2.2 : 
;;; contradiction in -1, -10 and i!3=i!1`1

{-1}  P!1 = p
[-2]  mid < i!3
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!3
[-8]  (length(hu_list) = p)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-12] i!1`1 < P!1 - 1
  |-------
{1}   i!1`1 = i!3

Rerunning step: (replace -10 -3)
Replacing using formula -10,
this simplifies to: 
restrictpremid_middle.2.1.1.2.2 : 
;;; contradiction in -1, -10 and i!3=i!1`1

[-1]  P!1 = p
[-2]  mid < i!3
{-3}  length(append(nl1!1, cons(n_mid, nl2!1))) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!3
[-8]  (length(hu_list) = p)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-12] i!1`1 < P!1 - 1
  |-------
[1]   i!1`1 = i!3

Rerunning step: (rewrite "length_append" -3)
Found matching substitution:
l2: list[T] gets cons(n_mid, nl2!1),
l1: list[T] gets nl1!1,
Rewriting using length_append, matching in -3,
this simplifies to: 
restrictpremid_middle.2.1.1.2.2 : 
;;; contradiction in -1, -10 and i!3=i!1`1

[-1]  P!1 = p
[-2]  mid < i!3
{-3}  length(cons(n_mid, nl2!1)) + length(nl1!1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!3
[-8]  (length(hu_list) = p)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-12] i!1`1 < P!1 - 1
  |-------
[1]   i!1`1 = i!3

Rerunning step: (expand "length" -3 1)
Expanding the definition of length,
this simplifies to: 
restrictpremid_middle.2.1.1.2.2 : 
;;; contradiction in -1, -10 and i!3=i!1`1

[-1]  P!1 = p
[-2]  mid < i!3
{-3}  1 + length(nl1!1) + length[Nonce](nl2!1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!3
[-8]  (length(hu_list) = p)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-12] i!1`1 < P!1 - 1
  |-------
[1]   i!1`1 = i!3

Rerunning step: (delete -1 -2 -4 -5 -8 -9 -10 -11 -12)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.1.2.2 : 
;;; contradiction in -1, -10 and i!3=i!1`1

[-1]  1 + length(nl1!1) + length[Nonce](nl2!1) = i!1`1
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
  |-------
[1]   i!1`1 = i!3

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.1.1.2.2.

restrictpremid_middle.2.1.1.2.3 : 
;;; contradiction in -1, -10 and i!3=i!1`1

[-1]  mid < i!3
[-2]  length(i!2`1) = i!1`1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  length(nl1!1) = mid
[-6]  length(nl2!1) = -1 - mid + i!3
[-7]  (length(hu_list) = p)
[-8]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-9]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-10] i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-11] i!1`1 < P!1 - 1
  |-------
{1}   P!1 = p

Rerunning step: (lemma "listprops[Identity].equality_length"
                 ("l1" "append(i!2`3,i!2`4)" "l2"
                  "remove(hu_list,rem(p)(i!3))"))
Applying listprops[Identity].equality_length where 
  l1 gets append(i!2`3, i!2`4),
  l2 gets remove(hu_list, rem(p)(i!3)),
this simplifies to: 
restrictpremid_middle.2.1.1.2.3 : 
;;; contradiction in -1, -10 and i!3=i!1`1

{-1}  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3)) IMPLIES
       length[Identity](append(i!2`3, i!2`4)) =
        length[Identity](remove(hu_list, rem(p)(i!3)))
[-2]  mid < i!3
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!3
[-8]  (length(hu_list) = p)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-12] i!1`1 < P!1 - 1
  |-------
[1]   P!1 = p

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpremid_middle.2.1.1.2.3 : 
;;; contradiction in -1, -10 and i!3=i!1`1

{-1}  length[Identity](append(i!2`3, i!2`4)) =
       length[Identity](remove(hu_list, rem(p)(i!3)))
[-2]  mid < i!3
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!3
[-8]  (length(hu_list) = p)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-12] i!1`1 < P!1 - 1
  |-------
[1]   P!1 = p

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets i!2`4,
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictpremid_middle.2.1.1.2.3 : 
;;; contradiction in -1, -10 and i!3=i!1`1

{-1}  length(i!2`3) + length(i!2`4) =
       length[Identity](remove(hu_list, rem(p)(i!3)))
[-2]  mid < i!3
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!3
[-8]  (length(hu_list) = p)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-12] i!1`1 < P!1 - 1
  |-------
[1]   P!1 = p

Rerunning step: (rewrite "length_remove" -1 :dir rl)
Found matching substitution:
i: below[length(c)] gets rem(p)(i!3),
c: (cons?[T]) gets hu_list,
Rewriting using length_remove, matching in -1,
this yields  2 subgoals: 
restrictpremid_middle.2.1.1.2.3.1 : 
;;; contradiction in -1, -10 and i!3=i!1`1

{-1}  length(i!2`3) + length(i!2`4) = length[Identity](hu_list) - 1
[-2]  mid < i!3
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!3
[-8]  (length(hu_list) = p)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-12] i!1`1 < P!1 - 1
  |-------
[1]   P!1 = p

Rerunning step: (delete -2 -3 -6 -7 -9 -10 -11 -12)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.1.2.3.1 : 
;;; contradiction in -1, -10 and i!3=i!1`1

[-1]  length(i!2`3) + length(i!2`4) = length[Identity](hu_list) - 1
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  (length(hu_list) = p)
  |-------
[1]   P!1 = p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.1.1.2.3.1.

restrictpremid_middle.2.1.1.2.3.2 : 
;;; contradiction in -1, -10 and i!3=i!1`1

[-1]  length(i!2`3) + length(i!2`4) =
       length[Identity](remove(hu_list, rem(p)(i!3)))
[-2]  mid < i!3
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!3
[-8]  (length(hu_list) = p)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-12] i!1`1 < P!1 - 1
  |-------
{1}   cons?[Identity](hu_list)
[2]   P!1 = p

Rerunning step: (lemma "more_list_props[Identity].length_non_zero"
                 ("l" "hu_list"))
Applying more_list_props[Identity].length_non_zero where 
  l gets hu_list,
this simplifies to: 
restrictpremid_middle.2.1.1.2.3.2 : 
;;; contradiction in -1, -10 and i!3=i!1`1

{-1}  length(hu_list) > 0 IFF cons?(hu_list)
[-2]  length(i!2`3) + length(i!2`4) =
       length[Identity](remove(hu_list, rem(p)(i!3)))
[-3]  mid < i!3
[-4]  length(i!2`1) = i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -1 - mid + i!3
[-9]  (length(hu_list) = p)
[-10] append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-13] i!1`1 < P!1 - 1
  |-------
[1]   cons?[Identity](hu_list)
[2]   P!1 = p

Rerunning step: (typepred "p")
Adding type constraints for  p,
this simplifies to: 
restrictpremid_middle.2.1.1.2.3.2 : 
;;; contradiction in -1, -10 and i!3=i!1`1

{-1}  3 <= p
[-2]  length(hu_list) > 0 IFF cons?(hu_list)
[-3]  length(i!2`3) + length(i!2`4) =
       length[Identity](remove(hu_list, rem(p)(i!3)))
[-4]  mid < i!3
[-5]  length(i!2`1) = i!1`1
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = P!1 - 1 - i!1`1
[-8]  length(nl1!1) = mid
[-9]  length(nl2!1) = -1 - mid + i!3
[-10] (length(hu_list) = p)
[-11] append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-12] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-13] i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-14] i!1`1 < P!1 - 1
  |-------
[1]   cons?[Identity](hu_list)
[2]   P!1 = p

Rerunning step: (delete -3 -4 -5 -6 -7 -8 -9 -11 -12 -13 -14 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.1.2.3.2 : 
;;; contradiction in -1, -10 and i!3=i!1`1

[-1]  3 <= p
[-2]  length(hu_list) > 0 IFF cons?(hu_list)
[-3]  (length(hu_list) = p)
  |-------
[1]   cons?[Identity](hu_list)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.1.1.2.3.2.


This completes the proof of restrictpremid_middle.2.1.1.2.3.


This completes the proof of restrictpremid_middle.2.1.1.2.

restrictpremid_middle.2.1.1.3 : 
;;; 3 different cases are to be distinguished amongst for the (assumed) validity of the received message

{-1}  EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(u!1) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`4)),
                      conc(nlist(append(i!2`1, (: i!1`2 :))),
                           ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictpremid_middle.2.1.1.3 : 
;;; 3 different cases are to be distinguished amongst for the (assumed) validity of the received message

{-1}  public(u!1) = public(hu(i!3))
{-2}  conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
       conc(ilist(remove(hu_list, i!3)),
            nlist(append(nl1!1, cons(n_mid, nl2!1))))
[-3]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`4)),
                      conc(nlist(append(i!2`1, (: i!1`2 :))),
                           ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (delete -1 -3 -4 -5 -6 +)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.1.3 : 
;;; 3 different cases are to be distinguished amongst for the (assumed) validity of the received message

[-1]  conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
       conc(ilist(remove(hu_list, i!3)),
            nlist(append(nl1!1, cons(n_mid, nl2!1))))
  |-------

Rerunning step: (assert :flush? t)
Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
restrictpremid_middle.2.1.1.3 : 
;;; 3 different cases are to be distinguished amongst for the (assumed) validity of the received message

[-1]  conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
       conc(ilist(remove(hu_list, i!3)),
            nlist(append(nl1!1, cons(n_mid, nl2!1))))
  |-------

Rerunning step: (decompose-equality -1)
Applying decompose-equality,

This completes the proof of restrictpremid_middle.2.1.1.3.


This completes the proof of restrictpremid_middle.2.1.1.

restrictpremid_middle.2.1.2 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
{1}   ((rec(u!1, nth(i!2`3, i!1`1 - 1),
            E(public(u!1),
              conc(ilist(append(i!2`3, i!2`4)),
                   nlist(cons(i!1`2, i!2`2)))))
         >>
         (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                         nth(cons(i!1`2, i!2`2),
                             floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                    ((mid - 1) / (p - 2)) * P!1)
                              - i!1`1)))
           >>
           ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
             Stop[event])))
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
{2}   R_premid(v!1)
              (trans(u!1, car(i!2`4),
                     E(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))))
{3}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(nlist(append(i!2`1, (: i!1`2 :))),
                   ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
       >>
       ((rec(u!1, nth(i!2`3, i!1`1 - 1),
             E(public(u!1),
               conc(ilist(append(i!2`3, i!2`4)),
                    nlist(cons(i!1`2, i!2`2)))))
          >>
          (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                          nth(cons(i!1`2, i!2`2),
                              floor(1 - 2 * ((mid - 1) / (p - 2))
                                    +
                                    ((mid - 1) / (p - 2)) * P!1)
                               - i!1`1)))
            >>
            ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
              Stop[event])))
         # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   ((rec(u!1, nth(i!2`3, i!1`1 - 1),
            E(public(u!1),
              conc(ilist(append(i!2`3, i!2`4)),
                   nlist(cons(i!1`2, i!2`2)))))
         >>
         (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                         nth(cons(i!1`2, i!2`2),
                             floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                    ((mid - 1) / (p - 2)) * P!1)
                              - i!1`1)))
           >>
           ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
             Stop[event])))
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictpremid_middle.2.1.2 :  

{-1}  rho_premid(v!1)
                (E(public(u!1),
                   conc(ilist(append(i!2`3, i!2`4)),
                        nlist(cons(i!1`2, i!2`2)))))
[-2]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-3]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-5]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-6]  0 < i!1`1
[-7]  i!1`1 < P!1 - 1
[-8]  2 <= P!1
  |-------
{1}   ((signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                       nth(cons(i!1`2, i!2`2),
                           floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                  ((mid - 1) / (p - 2)) * P!1)
                            - i!1`1)))
         >>
         ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
           Stop[event]))
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
{2}   R_premid(v!1)
              (rec(u!1, nth(i!2`3, i!1`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(i!2`3, i!2`4)),
                          nlist(cons(i!1`2, i!2`2))))))
{3}   rec(u!1, nth(i!2`3, i!1`1 - 1),
          E(public(u!1),
            conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2)))))
       >>
       ((signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                        nth(cons(i!1`2, i!2`2),
                            floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                   ((mid - 1) / (p - 2)) * P!1)
                             - i!1`1)))
          >>
          ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
            Stop[event]))
         # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(ilist(append(i!2`3, i!2`4)),
                        nlist(cons(i!1`2, i!2`2)))))
[-2]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-3]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-5]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-6]  0 < i!1`1
[-7]  i!1`1 < P!1 - 1
[-8]  2 <= P!1
  |-------
[1]   ((signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                       nth(cons(i!1`2, i!2`2),
                           floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                  ((mid - 1) / (p - 2)) * P!1)
                            - i!1`1)))
         >>
         ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
           Stop[event]))
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictpremid_middle.2.1.2.1 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(ilist(append(i!2`3, i!2`4)),
                        nlist(cons(i!1`2, i!2`2)))))
[-2]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-3]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-5]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-6]  0 < i!1`1
[-7]  i!1`1 < P!1 - 1
[-8]  2 <= P!1
  |-------
{1}   rho_premid(v!1)
                (running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                         nth(cons(i!1`2, i!2`2),
                             floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                    ((mid - 1) / (p - 2)) * P!1)
                              - i!1`1)))
{2}   R_premid(v!1)
              (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                              nth(cons(i!1`2, i!2`2),
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)
                                   - i!1`1))))
{3}   signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                     nth(cons(i!1`2, i!2`2),
                         floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                ((mid - 1) / (p - 2)) * P!1)
                          - i!1`1)))
       >>
       (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
          Stop[event])
         # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete - 2 3 4 5)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.1 :  

  |-------
[1]   rho_premid(v!1)
                (running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                         nth(cons(i!1`2, i!2`2),
                             floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                    ((mid - 1) / (p - 2)) * P!1)
                              - i!1`1)))

Rerunning step: (expand "rho_premid")
Expanding the definition of rho_premid,
this simplifies to: 
restrictpremid_middle.2.1.2.1 :  

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictpremid_middle.2.1.2.1.

restrictpremid_middle.2.1.2.2 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(ilist(append(i!2`3, i!2`4)),
                        nlist(cons(i!1`2, i!2`2)))))
[-2]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-3]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-5]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-6]  0 < i!1`1
[-7]  i!1`1 < P!1 - 1
[-8]  2 <= P!1
  |-------
{1}   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
{2}   R_premid(v!1)
              (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                              nth(cons(i!1`2, i!2`2),
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)
                                   - i!1`1))))
{3}   signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                     nth(cons(i!1`2, i!2`2),
                         floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                ((mid - 1) / (p - 2)) * P!1)
                          - i!1`1)))
       >>
       (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
          Stop[event])
         # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete -2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(ilist(append(i!2`3, i!2`4)),
                        nlist(cons(i!1`2, i!2`2)))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[2]   R_premid(v!1)
              (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                              nth(cons(i!1`2, i!2`2),
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)
                                   - i!1`1))))
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (comment "consider the case where the process is blocked and the case where the process is not blocked")
Adding comment: consider the case where the process is blocked and the case where the process is not blocked
this simplifies to: 
restrictpremid_middle.2.1.2.2 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(ilist(append(i!2`3, i!2`4)),
                        nlist(cons(i!1`2, i!2`2)))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[2]   R_premid(v!1)
              (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                              nth(cons(i!1`2, i!2`2),
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)
                                   - i!1`1))))
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (expand "R_premid")
Expanding the definition of R_premid,
this simplifies to: 
restrictpremid_middle.2.1.2.2 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(ilist(append(i!2`3, i!2`4)),
                        nlist(cons(i!1`2, i!2`2)))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
{1}   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
{2}   signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                     nth(cons(i!1`2, i!2`2),
                         floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                ((mid - 1) / (p - 2)) * P!1)
                          - i!1`1)))
       = signal(running(v!1, hu_list, n_mid))
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (case "i!1`1=v!1 AND append(i!2`3,cons(u!1,i!2`4))=hu_list AND nth(cons(i!1`2,i!2`2),floor(1+((mid-1)/(p-2))*(P!1-2))-i!1`1)=n_mid")
Case splitting on 
   i!1`1 = v!1 AND
    append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
     nth(cons(i!1`2, i!2`2),
         floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2)) - i!1`1)
      = n_mid, 
this yields  3 subgoals: 
restrictpremid_middle.2.1.2.2.1 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

{-1}  i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2)) - i!1`1)
         = n_mid
[-2]  rho_premid(v!1)
                (E(public(u!1),
                   conc(ilist(append(i!2`3, i!2`4)),
                        nlist(cons(i!1`2, i!2`2)))))
[-3]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-5]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-6]  0 < i!1`1
[-7]  i!1`1 < P!1 - 1
[-8]  2 <= P!1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[2]   signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                     nth(cons(i!1`2, i!2`2),
                         floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                ((mid - 1) / (p - 2)) * P!1)
                          - i!1`1)))
       = signal(running(v!1, hu_list, n_mid))
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (delete -2 -3 -4 -5 -6 -7 -8 1 3 4)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.1 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

[-1]  i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2)) - i!1`1)
         = n_mid
  |-------
[1]   signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                     nth(cons(i!1`2, i!2`2),
                         floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                ((mid - 1) / (p - 2)) * P!1)
                          - i!1`1)))
       = signal(running(v!1, hu_list, n_mid))

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.1.2.2.1.

restrictpremid_middle.2.1.2.2.2 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(ilist(append(i!2`3, i!2`4)),
                        nlist(cons(i!1`2, i!2`2)))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
{1}   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2)) - i!1`1)
         = n_mid
[2]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                     nth(cons(i!1`2, i!2`2),
                         floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                ((mid - 1) / (p - 2)) * P!1)
                          - i!1`1)))
       = signal(running(v!1, hu_list, n_mid))
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete -2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(ilist(append(i!2`3, i!2`4)),
                        nlist(cons(i!1`2, i!2`2)))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2)) - i!1`1)
         = n_mid
[2]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (expand "E")
Expanding the definition of E,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

{-1}  rho_premid(v!1)
                (code(public(u!1),
                      conc(ilist(append(i!2`3, i!2`4)),
                           nlist(cons(i!1`2, i!2`2)))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2)) - i!1`1)
         = n_mid
[2]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (expand "rho_premid" -1)
Expanding the definition of rho_premid,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

{-1}  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
       OR
       (EXISTS (i: {x: nat | mid < x AND x <= p}):
          public(u!1) = public(hu(rem(p)(i))) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                   nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
             conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
              conc(nlist(append(nl1, cons(n_mid, nl2))),
                   ilist(remove(hu_list, rem(p)(i)))))
        OR
        EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
          public(u!1) = public(hu(i)) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                   nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
             conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
              conc(ilist(remove(hu_list, i)),
                   nlist(append(nl1, cons(n_mid, nl2))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2)) - i!1`1)
         = n_mid
[2]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (split -1)
Splitting conjunctions,
this yields  3 subgoals: 
restrictpremid_middle.2.1.2.2.2.1 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

{-1}  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2)) - i!1`1)
         = n_mid
[2]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (delete -2 -3 -4 -5 -6 1 3 4)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.1 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

[-1]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (expand "LastMessage")
Expanding the definition of LastMessage,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.1 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

[-1]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   ((IF i!1`1 = P!1 - 2
          THEN trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2)))
        ELSE trans(u!1, car(i!2`4),
                   E(public(car(i!2`4)),
                     conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                          nlist(i!2`2))))
        ENDIF
         >> Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (lift-if)
Lifting IF-conditions to the top level,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.1 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

[-1]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   IF i!1`1 = P!1 - 2
        THEN ((trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2)))
                >> Stop[event])
               # {e: event | e = signal(running(v!1, hu_list, n_mid))})
              |>
              LAMBDA (t: list[event]):
                every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))
                     (t)
                 =>
                 every(LAMBDA (e: event):
                         NOT rec?(e) => rho_premid(v!1)(msg(e)))
                      (t)
      ELSE ((trans(u!1, car(i!2`4),
                   E(public(car(i!2`4)),
                     conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                          nlist(i!2`2))))
              >> Stop[event])
             # {e: event | e = signal(running(v!1, hu_list, n_mid))})
            |>
            LAMBDA (t: list[event]):
              every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))
                   (t)
               =>
               every(LAMBDA (e: event):
                       NOT rec?(e) => rho_premid(v!1)(msg(e)))
                    (t)
      ENDIF

Rerunning step: (prop)
Applying propositional simplification,
this yields  2 subgoals: 
restrictpremid_middle.2.1.2.2.2.1.1 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

{-1}  i!1`1 = P!1 - 2
[-2]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   ((trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictpremid_middle.2.1.2.2.2.1.1.1 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

[-1]  i!1`1 = P!1 - 2
[-2]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   rho_premid(v!1)(E(public(car(i!2`4)), nlist(i!2`2)))
{2}   trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))) >>
       (Stop[event] #
         {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete -1 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.1.1.1 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

[-1]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
[1]   rho_premid(v!1)(E(public(car(i!2`4)), nlist(i!2`2)))

Rerunning step: (lemma "listprops[Nonce].elt_append2"
                 ("l1" "(:i!1`2:)" "l2" "i!2`2" "t" "n_mid"))
Applying listprops[Nonce].elt_append2 where 
  l1 gets (: i!1`2 :),
  l2 gets i!2`2,
  t gets n_mid,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.1.1.1 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

{-1}  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
[1]   rho_premid(v!1)(E(public(car(i!2`4)), nlist(i!2`2)))

Rerunning step: (grind :exclude "elt")
append rewrites append((: :), i!2`2)
  to i!2`2
append rewrites append((: i!1`2 :), i!2`2)
  to cons(i!1`2, i!2`2)
E rewrites E(public(car(i!2`4)), nlist(i!2`2))
  to code(public(car(i!2`4)), nlist(i!2`2))
rho_premid rewrites rho_premid(v!1)(nlist(i!2`2))
  to NOT elt(i!2`2, n_mid)
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_premid rewrites rho_premid(v!1)(code(public(car(i!2`4)), nlist(i!2`2)))
  to NOT elt(i!2`2, n_mid)
rho_premid rewrites rho_premid(v!1)(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_premid rewrites rho_premid(v!1)(nlist(cons(i!1`2, i!2`2)))
  to FALSE
rho_premid rewrites 
  rho_premid(v!1)
            (conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
  to FALSE
E rewrites E(public(car(i!2`4)), nlist(i!2`2))
  to code(public(car(i!2`4)), nlist(i!2`2))
rho_premid rewrites rho_premid(v!1)(nlist(i!2`2))
  to TRUE
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_premid rewrites rho_premid(v!1)(code(public(car(i!2`4)), nlist(i!2`2)))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpremid_middle.2.1.2.2.2.1.1.1.

restrictpremid_middle.2.1.2.2.2.1.1.2 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

[-1]  i!1`1 = P!1 - 2
[-2]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   (Stop[event] # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
{2}   trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))) >>
       (Stop[event] #
         {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.1.1.2 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

  |-------
[1]   (Stop[event] # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictpremid_middle.2.1.2.2.2.1.1.2.


This completes the proof of restrictpremid_middle.2.1.2.2.2.1.1.

restrictpremid_middle.2.1.2.2.2.1.2 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

[-1]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   i!1`1 = P!1 - 2
{2}   ((trans(u!1, car(i!2`4),
              E(public(car(i!2`4)),
                conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                     nlist(i!2`2))))
         >> Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictpremid_middle.2.1.2.2.2.1.2.1 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

[-1]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   rho_premid(v!1)
                (E(public(car(i!2`4)),
                   conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                        nlist(i!2`2))))
[2]   i!1`1 = P!1 - 2
{3}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                   nlist(i!2`2))))
       >>
       (Stop[event] #
         {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.1.2.1 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

[-1]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
[1]   rho_premid(v!1)
                (E(public(car(i!2`4)),
                   conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                        nlist(i!2`2))))

Rerunning step: (lemma "listprops[Nonce].elt_append2"
                 ("l1" "(:i!1`2:)" "l2" "i!2`2" "t" "n_mid"))
Applying listprops[Nonce].elt_append2 where 
  l1 gets (: i!1`2 :),
  l2 gets i!2`2,
  t gets n_mid,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.1.2.1 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

{-1}  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
[1]   rho_premid(v!1)
                (E(public(car(i!2`4)),
                   conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                        nlist(i!2`2))))

Rerunning step: (grind :exclude "elt")
append rewrites append((: :), i!2`2)
  to i!2`2
append rewrites append((: i!1`2 :), i!2`2)
  to cons(i!1`2, i!2`2)
E rewrites 
  E(public(car(i!2`4)),
    conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)))
  to code(public(car(i!2`4)),
           conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)))
rho_premid rewrites 
  rho_premid(v!1)(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
  to TRUE
rho_premid rewrites rho_premid(v!1)(nlist(i!2`2))
  to NOT elt(i!2`2, n_mid)
rho_premid rewrites 
  rho_premid(v!1)
            (conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                  nlist(i!2`2)))
  to NOT elt(i!2`2, n_mid)
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_premid rewrites 
  rho_premid(v!1)
            (code(public(car(i!2`4)),
                  conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                       nlist(i!2`2))))
  to NOT elt(i!2`2, n_mid) OR
       (EXISTS (i: {x: nat | mid < x AND x <= p}):
          public(car(i!2`4)) = public(hu(rem(p)(i))) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                   nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
             conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                  nlist(i!2`2))
              =
              conc(nlist(append(nl1, cons(n_mid, nl2))),
                   ilist(remove(hu_list, rem(p)(i)))))
        OR
        EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
          public(car(i!2`4)) = public(hu(i)) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                   nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
             conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                  nlist(i!2`2))
              =
              conc(ilist(cons(car(hu_list), remove(cdr(hu_list), i - 1))),
                   nlist(append(nl1, cons(n_mid, nl2))))
rho_premid rewrites rho_premid(v!1)(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_premid rewrites rho_premid(v!1)(nlist(cons(i!1`2, i!2`2)))
  to FALSE
rho_premid rewrites 
  rho_premid(v!1)
            (conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
  to FALSE
E rewrites 
  E(public(car(i!2`4)),
    conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)))
  to code(public(car(i!2`4)),
           conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)))
rho_premid rewrites 
  rho_premid(v!1)(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
  to TRUE
rho_premid rewrites rho_premid(v!1)(nlist(i!2`2))
  to TRUE
rho_premid rewrites 
  rho_premid(v!1)
            (conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                  nlist(i!2`2)))
  to TRUE
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_premid rewrites 
  rho_premid(v!1)
            (code(public(car(i!2`4)),
                  conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                       nlist(i!2`2))))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpremid_middle.2.1.2.2.2.1.2.1.

restrictpremid_middle.2.1.2.2.2.1.2.2 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

[-1]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   (Stop[event] # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[2]   i!1`1 = P!1 - 2
{3}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                   nlist(i!2`2))))
       >>
       (Stop[event] #
         {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.1.2.2 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

  |-------
[1]   (Stop[event] # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictpremid_middle.2.1.2.2.2.1.2.2.


This completes the proof of restrictpremid_middle.2.1.2.2.2.1.2.


This completes the proof of restrictpremid_middle.2.1.2.2.2.1.

restrictpremid_middle.2.1.2.2.2.2 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

{-1}  EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(u!1) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2)) - i!1`1)
         = n_mid
[2]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.2 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

{-1}  public(u!1) = public(hu(rem(p)(i!3)))
{-2}  conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, rem(p)(i!3))))
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2)) - i!1`1)
         = n_mid
[2]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (delete -1 -3 -4 -5 -6 -7 +)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.2 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

[-1]  conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, rem(p)(i!3))))
  |-------

Rerunning step: (decompose-equality -1)
Applying decompose-equality,

This completes the proof of restrictpremid_middle.2.1.2.2.2.2.

restrictpremid_middle.2.1.2.2.2.3 : 
;;; consider the case where the process is blocked and the case where the process is not blocked

{-1}  EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(u!1) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2)) - i!1`1)
         = n_mid
[2]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (comment "the process is not blocked, and the message previously received is escaped in rho")
Adding comment: the process is not blocked, and the message previously received is escaped in rho
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3 : 
;;; the process is not blocked, and the message previously received is escaped in rho

[-1]  EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(u!1) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2)) - i!1`1)
         = n_mid
[2]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (comment "establish some convenient equalities first")
Adding comment: establish some convenient equalities first
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3 : 
;;; establish some convenient equalities first

[-1]  EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(u!1) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2)) - i!1`1)
         = n_mid
[2]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3 : 
;;; establish some convenient equalities first

{-1}  public(u!1) = public(hu(i!3))
{-2}  conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
       conc(ilist(remove(hu_list, i!3)),
            nlist(append(nl1!1, cons(n_mid, nl2!1))))
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2)) - i!1`1)
         = n_mid
[2]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3 : 
;;; establish some convenient equalities first

{-1}  u!1 = hu(i!3)
[-2]  conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
       conc(ilist(remove(hu_list, i!3)),
            nlist(append(nl1!1, cons(n_mid, nl2!1))))
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2)) - i!1`1)
         = n_mid
[2]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (assert :flush? t)
Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3 : 
;;; establish some convenient equalities first

[-1]  u!1 = hu(i!3)
[-2]  conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
       conc(ilist(remove(hu_list, i!3)),
            nlist(append(nl1!1, cons(n_mid, nl2!1))))
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
{1}   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 - 2 * ((mid - 1) / (p - 2)) +
                   ((mid - 1) / (p - 2)) * P!1)
             - i!1`1)
         = n_mid
[2]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3 : 
;;; establish some convenient equalities first

{-1}  ilist(append(i!2`3, i!2`4)) = ilist(remove(hu_list, i!3))
{-2}  nlist(cons(i!1`2, i!2`2)) = nlist(append(nl1!1, cons(n_mid, nl2!1)))
[-3]  u!1 = hu(i!3)
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-5]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-6]  0 < i!1`1
[-7]  i!1`1 < P!1 - 1
[-8]  2 <= P!1
  |-------
[1]   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 - 2 * ((mid - 1) / (p - 2)) +
                   ((mid - 1) / (p - 2)) * P!1)
             - i!1`1)
         = n_mid
[2]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3 : 
;;; establish some convenient equalities first

{-1}  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-2]  nlist(cons(i!1`2, i!2`2)) = nlist(append(nl1!1, cons(n_mid, nl2!1)))
[-3]  u!1 = hu(i!3)
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-5]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-6]  0 < i!1`1
[-7]  i!1`1 < P!1 - 1
[-8]  2 <= P!1
  |-------
[1]   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 - 2 * ((mid - 1) / (p - 2)) +
                   ((mid - 1) / (p - 2)) * P!1)
             - i!1`1)
         = n_mid
[2]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3 : 
;;; establish some convenient equalities first

{-1}  cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-2]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-3]  u!1 = hu(i!3)
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-5]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-6]  0 < i!1`1
[-7]  i!1`1 < P!1 - 1
[-8]  2 <= P!1
  |-------
[1]   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 - 2 * ((mid - 1) / (p - 2)) +
                   ((mid - 1) / (p - 2)) * P!1)
             - i!1`1)
         = n_mid
[2]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (typepred "i!2`2" "i!2`3" "i!2`4" "nl1!1" "nl2!1"
                 "hu_list" "v!1" "i!3")
Adding type constraints for  i!2`2, i!2`3, i!2`4, nl1!1, nl2!1, hu_list, v!1, i!3,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3 : 
;;; establish some convenient equalities first

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`2)
{-2}  length(i!2`2) = P!1 - 1 - i!1`1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`3)
{-4}  length(i!2`3) = i!1`1
{-5}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`4)
{-6}  length(i!2`4) = P!1 - 1 - i!1`1
{-7}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl1!1)
{-8}  length(nl1!1) = mid - i!3
{-9}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
{-10} length(nl2!1) = -1 - mid + p
{-11} every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-12} (length(hu_list) = p)
{-13} FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
{-14} v!1 < mid
{-15} 0 < i!3
{-16} i!3 <= v!1
[-17] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-18] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-19] u!1 = hu(i!3)
[-20] floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-21] floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-22] 0 < i!1`1
[-23] i!1`1 < P!1 - 1
[-24] 2 <= P!1
  |-------
[1]   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 - 2 * ((mid - 1) / (p - 2)) +
                   ((mid - 1) / (p - 2)) * P!1)
             - i!1`1)
         = n_mid
[2]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (delete -1 -3 -5 -7 -9 -11 -20 -21)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3 : 
;;; establish some convenient equalities first

[-1]  length(i!2`2) = P!1 - 1 - i!1`1
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  length(nl1!1) = mid - i!3
[-5]  length(nl2!1) = -1 - mid + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  v!1 < mid
[-9]  0 < i!3
[-10] i!3 <= v!1
[-11] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-12] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-13] u!1 = hu(i!3)
[-14] 0 < i!1`1
[-15] i!1`1 < P!1 - 1
[-16] 2 <= P!1
  |-------
[1]   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 - 2 * ((mid - 1) / (p - 2)) +
                   ((mid - 1) / (p - 2)) * P!1)
             - i!1`1)
         = n_mid
[2]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (case "P!1=p" "i!3=i!1`1")
Case splitting on 
   P!1 = p, 
   i!3 = i!1`1, 
this yields  3 subgoals: 
restrictpremid_middle.2.1.2.2.2.3.1 : 
;;; establish some convenient equalities first

{-1}  i!3 = i!1`1
{-2}  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] v!1 < mid
[-11] 0 < i!3
[-12] i!3 <= v!1
[-13] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = hu(i!3)
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
[-18] 2 <= P!1
  |-------
[1]   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 - 2 * ((mid - 1) / (p - 2)) +
                   ((mid - 1) / (p - 2)) * P!1)
             - i!1`1)
         = n_mid
[2]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (comment "split LastMessage up, since one part will be trivial")
Adding comment: split LastMessage up, since one part will be trivial
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] v!1 < mid
[-11] 0 < i!3
[-12] i!3 <= v!1
[-13] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = hu(i!3)
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
[-18] 2 <= P!1
  |-------
[1]   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 - 2 * ((mid - 1) / (p - 2)) +
                   ((mid - 1) / (p - 2)) * P!1)
             - i!1`1)
         = n_mid
[2]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (expand "LastMessage")
Expanding the definition of LastMessage,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] v!1 < mid
[-11] 0 < i!3
[-12] i!3 <= v!1
[-13] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = hu(i!3)
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
[-18] 2 <= P!1
  |-------
[1]   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 - 2 * ((mid - 1) / (p - 2)) +
                   ((mid - 1) / (p - 2)) * P!1)
             - i!1`1)
         = n_mid
{2}   ((IF i!1`1 = P!1 - 2
          THEN trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2)))
        ELSE trans(u!1, car(i!2`4),
                   E(public(car(i!2`4)),
                     conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                          nlist(i!2`2))))
        ENDIF
         >> Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (lift-if)
Lifting IF-conditions to the top level,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] v!1 < mid
[-11] 0 < i!3
[-12] i!3 <= v!1
[-13] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = hu(i!3)
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
[-18] 2 <= P!1
  |-------
[1]   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 - 2 * ((mid - 1) / (p - 2)) +
                   ((mid - 1) / (p - 2)) * P!1)
             - i!1`1)
         = n_mid
{2}   IF i!1`1 = P!1 - 2
        THEN ((trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2)))
                >> Stop[event])
               # {e: event | e = signal(running(v!1, hu_list, n_mid))})
              |>
              LAMBDA (t: list[event]):
                every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))
                     (t)
                 =>
                 every(LAMBDA (e: event):
                         NOT rec?(e) => rho_premid(v!1)(msg(e)))
                      (t)
      ELSE ((trans(u!1, car(i!2`4),
                   E(public(car(i!2`4)),
                     conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                          nlist(i!2`2))))
              >> Stop[event])
             # {e: event | e = signal(running(v!1, hu_list, n_mid))})
            |>
            LAMBDA (t: list[event]):
              every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))
                   (t)
               =>
               every(LAMBDA (e: event):
                       NOT rec?(e) => rho_premid(v!1)(msg(e)))
                    (t)
      ENDIF
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (split 2)
Splitting conjunctions,
this yields  2 subgoals: 
restrictpremid_middle.2.1.2.2.2.3.1.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] v!1 < mid
[-11] 0 < i!3
[-12] i!3 <= v!1
[-13] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = hu(i!3)
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
[-18] 2 <= P!1
  |-------
{1}   i!1`1 = P!1 - 2 IMPLIES
       ((trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))) >>
          Stop[event])
         # {e: event | e = signal(running(v!1, hu_list, n_mid))})
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t)
           =>
           every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
                (t)
[2]   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 - 2 * ((mid - 1) / (p - 2)) +
                   ((mid - 1) / (p - 2)) * P!1)
             - i!1`1)
         = n_mid
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (delete -3 -4
                  -5 -6
                  -7 -8
                  -9 -11
                  -13 -14
                  -15 -16
                  -17 -18
                  2 3
                  4)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  v!1 < mid
[-4]  i!3 <= v!1
  |-------
[1]   i!1`1 = P!1 - 2 IMPLIES
       ((trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))) >>
          Stop[event])
         # {e: event | e = signal(running(v!1, hu_list, n_mid))})
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t)
           =>
           every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
                (t)

Rerunning step: (typepred "mid")
Adding type constraints for  mid,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.1 : 
;;; split LastMessage up, since one part will be trivial

{-1}  0 < mid
{-2}  mid < p - 1
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  v!1 < mid
[-6]  i!3 <= v!1
  |-------
[1]   i!1`1 = P!1 - 2 IMPLIES
       ((trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))) >>
          Stop[event])
         # {e: event | e = signal(running(v!1, hu_list, n_mid))})
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t)
           =>
           every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
                (t)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  0 < mid
[-2]  mid < p - 1
{-3}  i!1`1 = P!1 - 2
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  v!1 < mid
[-7]  i!3 <= v!1
  |-------
{1}   ((trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete -1 1)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  mid < p - 1
[-2]  i!1`1 = P!1 - 2
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  v!1 < mid
[-6]  i!3 <= v!1
  |-------

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.1.

restrictpremid_middle.2.1.2.2.2.3.1.2 : 
;;; split LastMessage up, since one part will be trivial

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] v!1 < mid
[-11] 0 < i!3
[-12] i!3 <= v!1
[-13] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = hu(i!3)
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
[-18] 2 <= P!1
  |-------
{1}   NOT i!1`1 = P!1 - 2 IMPLIES
       ((trans(u!1, car(i!2`4),
               E(public(car(i!2`4)),
                 conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                      nlist(i!2`2))))
          >> Stop[event])
         # {e: event | e = signal(running(v!1, hu_list, n_mid))})
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t)
           =>
           every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
                (t)
[2]   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 - 2 * ((mid - 1) / (p - 2)) +
                   ((mid - 1) / (p - 2)) * P!1)
             - i!1`1)
         = n_mid
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (split 2)
Splitting conjunctions,
this yields  3 subgoals: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] v!1 < mid
[-11] 0 < i!3
[-12] i!3 <= v!1
[-13] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = hu(i!3)
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
[-18] 2 <= P!1
  |-------
{1}   i!1`1 = v!1
[2]   NOT i!1`1 = P!1 - 2 IMPLIES
       ((trans(u!1, car(i!2`4),
               E(public(car(i!2`4)),
                 conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                      nlist(i!2`2))))
          >> Stop[event])
         # {e: event | e = signal(running(v!1, hu_list, n_mid))})
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t)
           =>
           every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
                (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] v!1 < mid
[-11] 0 < i!3
[-12] i!3 <= v!1
[-13] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = hu(i!3)
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
[-18] 2 <= P!1
  |-------
[1]   i!1`1 = v!1
{2}   i!1`1 = P!1 - 2
{3}   ((trans(u!1, car(i!2`4),
              E(public(car(i!2`4)),
                conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                     nlist(i!2`2))))
         >> Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] v!1 < mid
[-11] 0 < i!3
[-12] i!3 <= v!1
[-13] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = hu(i!3)
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
[-18] 2 <= P!1
  |-------
{1}   rho_premid(v!1)
                (E(public(car(i!2`4)),
                   conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                        nlist(i!2`2))))
[2]   i!1`1 = v!1
[3]   i!1`1 = P!1 - 2
{4}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                   nlist(i!2`2))))
       >>
       (Stop[event] #
         {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[5]   i!1`2 = n_mid
[6]   P!1 = 2

Rerunning step: (expand "E" 1)
Expanding the definition of E,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] v!1 < mid
[-11] 0 < i!3
[-12] i!3 <= v!1
[-13] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = hu(i!3)
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
[-18] 2 <= P!1
  |-------
{1}   rho_premid(v!1)
                (code(public(car(i!2`4)),
                      conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                           nlist(i!2`2))))
[2]   i!1`1 = v!1
[3]   i!1`1 = P!1 - 2
[4]   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                   nlist(i!2`2))))
       >>
       (Stop[event] #
         {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[5]   i!1`2 = n_mid
[6]   P!1 = 2

Rerunning step: (expand "rho_premid" 1)
Expanding the definition of rho_premid,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] v!1 < mid
[-11] 0 < i!3
[-12] i!3 <= v!1
[-13] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = hu(i!3)
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
[-18] 2 <= P!1
  |-------
{1}   rho_premid(v!1)
                (conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                      nlist(i!2`2)))
       OR
       (EXISTS (i: {x: nat | mid < x AND x <= p}):
          public(car(i!2`4)) = public(hu(rem(p)(i))) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                   nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
             conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                  nlist(i!2`2))
              =
              conc(nlist(append(nl1, cons(n_mid, nl2))),
                   ilist(remove(hu_list, rem(p)(i)))))
        OR
        EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
          public(car(i!2`4)) = public(hu(i)) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                   nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
             conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                  nlist(i!2`2))
              =
              conc(ilist(remove(hu_list, i)),
                   nlist(append(nl1, cons(n_mid, nl2))))
[2]   i!1`1 = v!1
[3]   i!1`1 = P!1 - 2
[4]   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                   nlist(i!2`2))))
       >>
       (Stop[event] #
         {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[5]   i!1`2 = n_mid
[6]   P!1 = 2

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] v!1 < mid
[-11] 0 < i!3
[-12] i!3 <= v!1
[-13] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = hu(i!3)
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
[-18] 2 <= P!1
  |-------
{1}   rho_premid(v!1)
                (conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                      nlist(i!2`2)))
{2}   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
{3}   EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(car(i!2`4)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2))
            =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))
[4]   i!1`1 = v!1
[5]   i!1`1 = P!1 - 2
[6]   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                   nlist(i!2`2))))
       >>
       (Stop[event] #
         {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[7]   i!1`2 = n_mid
[8]   P!1 = 2

Rerunning step: (delete 1 2 5 6 7 8)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] v!1 < mid
[-11] 0 < i!3
[-12] i!3 <= v!1
[-13] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = hu(i!3)
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
[-18] 2 <= P!1
  |-------
[1]   EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(car(i!2`4)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2))
            =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))
[2]   i!1`1 = v!1

Rerunning step: (comment "next message is sent to i!1`1+1")
Adding comment: next message is sent to i!1`1+1
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1 : 
;;; next message is sent to i!1`1+1

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] v!1 < mid
[-11] 0 < i!3
[-12] i!3 <= v!1
[-13] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = hu(i!3)
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
[-18] 2 <= P!1
  |-------
[1]   EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(car(i!2`4)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2))
            =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))
[2]   i!1`1 = v!1

Rerunning step: (comment "the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1")
Adding comment: the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] v!1 < mid
[-11] 0 < i!3
[-12] i!3 <= v!1
[-13] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = hu(i!3)
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
[-18] 2 <= P!1
  |-------
[1]   EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(car(i!2`4)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2))
            =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))
[2]   i!1`1 = v!1

Rerunning step: (inst 1 "i!1`1+1")
Instantiating the top quantifier in 1 with the terms: 
 i!1`1+1,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] v!1 < mid
[-11] 0 < i!3
[-12] i!3 <= v!1
[-13] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = hu(i!3)
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
[-18] 2 <= P!1
  |-------
{1}   public(car(i!2`4)) = public(hu(i!1`1 + 1)) AND
       EXISTS (nl1: {x: list[Nonce] | length(x) = -1 - i!1`1 + mid},
               nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
         conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)) =
          conc(ilist(remove(hu_list, i!1`1 + 1)),
               nlist(append(nl1, cons(n_mid, nl2))))
[2]   i!1`1 = v!1

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] v!1 < mid
[-11] 0 < i!3
[-12] i!3 <= v!1
[-13] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = hu(i!3)
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
[-18] 2 <= P!1
  |-------
{1}   public(car(i!2`4)) = public(hu(i!1`1 + 1))
[2]   i!1`1 = v!1

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] v!1 < mid
[-11] 0 < i!3
[-12] i!3 <= v!1
[-13] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = hu(i!3)
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
[-18] 2 <= P!1
  |-------
{1}   car(i!2`4) = hu(1 + i!1`1)
[2]   i!1`1 = v!1

Rerunning step: (lemma "listprops[Identity].equality_nth"
                 ("l1" "append(i!2`3,i!2`4)" "l2"
                  "remove(hu_list,i!3)"))
Applying listprops[Identity].equality_nth where 
  l1 gets append(i!2`3, i!2`4),
  l2 gets remove(hu_list, i!3),
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

{-1}  append(i!2`3, i!2`4) = remove(hu_list, i!3) IMPLIES
       FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
         nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!3), i)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  length(nl1!1) = mid - i!3
[-8]  length(nl2!1) = -1 - mid + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] v!1 < mid
[-12] 0 < i!3
[-13] i!3 <= v!1
[-14] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-15] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-16] u!1 = hu(i!3)
[-17] 0 < i!1`1
[-18] i!1`1 < P!1 - 1
[-19] 2 <= P!1
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)
[2]   i!1`1 = v!1

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

{-1}  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!3), i)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  length(nl1!1) = mid - i!3
[-8]  length(nl2!1) = -1 - mid + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] v!1 < mid
[-12] 0 < i!3
[-13] i!3 <= v!1
[-14] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-15] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-16] u!1 = hu(i!3)
[-17] 0 < i!1`1
[-18] i!1`1 < P!1 - 1
[-19] 2 <= P!1
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)
[2]   i!1`1 = v!1

Rerunning step: (inst -1 "i!1`1")
Instantiating the top quantifier in -1 with the terms: 
 i!1`1,
this yields  2 subgoals: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

{-1}  nth(append(i!2`3, i!2`4), i!1`1) = nth(remove(hu_list, i!3), i!1`1)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  length(nl1!1) = mid - i!3
[-8]  length(nl2!1) = -1 - mid + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] v!1 < mid
[-12] 0 < i!3
[-13] i!3 <= v!1
[-14] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-15] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-16] u!1 = hu(i!3)
[-17] 0 < i!1`1
[-18] i!1`1 < P!1 - 1
[-19] 2 <= P!1
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)
[2]   i!1`1 = v!1

Rerunning step: (rewrite "nth_append" -1)
Found matching substitution:
i: below[length(l1) + length(l2)] gets i!1`1,
l2: list[T] gets i!2`4,
l1: list[T] gets i!2`3,
Rewriting using nth_append, matching in -1,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

{-1}  nth(i!2`4, i!1`1 - length[Identity](i!2`3)) =
       nth(remove(hu_list, i!3), i!1`1)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  length(nl1!1) = mid - i!3
[-8]  length(nl2!1) = -1 - mid + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] v!1 < mid
[-12] 0 < i!3
[-13] i!3 <= v!1
[-14] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-15] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-16] u!1 = hu(i!3)
[-17] 0 < i!1`1
[-18] i!1`1 < P!1 - 1
[-19] 2 <= P!1
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)
[2]   i!1`1 = v!1

Rerunning step: (rewrite "nth_remove" -1)
Found matching substitution:
j: below[length(l) - 1] gets i!1`1,
i: below[length(l)] gets i!3,
l: list[T] gets hu_list,
Rewriting using nth_remove, matching in -1,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

{-1}  nth(i!2`4, i!1`1 - length[Identity](i!2`3)) = nth(hu_list, 1 + i!1`1)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  length(nl1!1) = mid - i!3
[-8]  length(nl2!1) = -1 - mid + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] v!1 < mid
[-12] 0 < i!3
[-13] i!3 <= v!1
[-14] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-15] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-16] u!1 = hu(i!3)
[-17] 0 < i!1`1
[-18] i!1`1 < P!1 - 1
[-19] 2 <= P!1
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)
[2]   i!1`1 = v!1

Rerunning step: (inst -10 "1+i!1`1")
Instantiating the top quantifier in -10 with the terms: 
 1+i!1`1,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  nth(i!2`4, i!1`1 - length[Identity](i!2`3)) = nth(hu_list, 1 + i!1`1)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  length(nl1!1) = mid - i!3
[-8]  length(nl2!1) = -1 - mid + p
[-9]  (length(hu_list) = p)
{-10} nth(hu_list, 1 + i!1`1) = hu(1 + i!1`1)
[-11] v!1 < mid
[-12] 0 < i!3
[-13] i!3 <= v!1
[-14] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-15] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-16] u!1 = hu(i!3)
[-17] 0 < i!1`1
[-18] i!1`1 < P!1 - 1
[-19] 2 <= P!1
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)
[2]   i!1`1 = v!1

Rerunning step: (delete -2 -3
                  -4 -6
                  -7 -8
                  -9 -11
                  -12 -13
                  -14 -15
                  -16 -17
                  -18 -19
                  2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  nth(i!2`4, i!1`1 - length[Identity](i!2`3)) = nth(hu_list, 1 + i!1`1)
[-2]  length(i!2`3) = i!1`1
[-3]  nth(hu_list, 1 + i!1`1) = hu(1 + i!1`1)
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)

Rerunning step: (expand "nth" -1 1)
Expanding the definition of nth,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

{-1}  car(i!2`4) = nth(hu_list, 1 + i!1`1)
[-2]  length(i!2`3) = i!1`1
[-3]  nth(hu_list, 1 + i!1`1) = hu(1 + i!1`1)
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.1.1.

restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.1.2 (TCC):   

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] v!1 < mid
[-11] 0 < i!3
[-12] i!3 <= v!1
[-13] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = hu(i!3)
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
[-18] 2 <= P!1
  |-------
{1}   i!1`1 < length[Identity](append[Identity](i!2`3, i!2`4))
[2]   car(i!2`4) = hu(1 + i!1`1)
[3]   i!1`1 = v!1

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets i!2`4,
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in 1,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.1.2 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] v!1 < mid
[-11] 0 < i!3
[-12] i!3 <= v!1
[-13] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = hu(i!3)
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
[-18] 2 <= P!1
  |-------
{1}   i!1`1 < length(i!2`3) + length(i!2`4)
[2]   car(i!2`4) = hu(1 + i!1`1)
[3]   i!1`1 = v!1

Rerunning step: (delete -1 -2
                  -3 -6
                  -7 -8
                  -9 -10
                  -11 -12
                  -13 -14
                  -15 -16
                  -18 2
                  3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.1.2 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = P!1 - 1 - i!1`1
[-3]  i!1`1 < P!1 - 1
  |-------
[1]   i!1`1 < length(i!2`3) + length(i!2`4)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.1.2.


This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.1.

restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] v!1 < mid
[-11] 0 < i!3
[-12] i!3 <= v!1
[-13] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = hu(i!3)
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
[-18] 2 <= P!1
  |-------
{1}   EXISTS (nl1: {x: list[Nonce] | length(x) = -1 - i!1`1 + mid},
              nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
        conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)) =
         conc(ilist(remove(hu_list, i!1`1 + 1)),
              nlist(append(nl1, cons(n_mid, nl2))))
[2]   i!1`1 = v!1

Rerunning step: (case "cons?(nl1!1)")
Case splitting on 
   cons?(nl1!1), 
this yields  2 subgoals: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

{-1}  cons?(nl1!1)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  length(nl1!1) = mid - i!3
[-8]  length(nl2!1) = -1 - mid + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] v!1 < mid
[-12] 0 < i!3
[-13] i!3 <= v!1
[-14] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-15] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-16] u!1 = hu(i!3)
[-17] 0 < i!1`1
[-18] i!1`1 < P!1 - 1
[-19] 2 <= P!1
  |-------
[1]   EXISTS (nl1: {x: list[Nonce] | length(x) = -1 - i!1`1 + mid},
              nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
        conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)) =
         conc(ilist(remove(hu_list, i!1`1 + 1)),
              nlist(append(nl1, cons(n_mid, nl2))))
[2]   i!1`1 = v!1

Rerunning step: (inst 1 "cdr(nl1!1)" "nl2!1")
Instantiating the top quantifier in 1 with the terms: 
 cdr(nl1!1), nl2!1,
this yields  2 subgoals: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  cons?(nl1!1)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  length(nl1!1) = mid - i!3
[-8]  length(nl2!1) = -1 - mid + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] v!1 < mid
[-12] 0 < i!3
[-13] i!3 <= v!1
[-14] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-15] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-16] u!1 = hu(i!3)
[-17] 0 < i!1`1
[-18] i!1`1 < P!1 - 1
[-19] 2 <= P!1
  |-------
{1}   conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)) =
       conc(ilist(remove(hu_list, i!1`1 + 1)),
            nlist(append(cdr(nl1!1), cons(n_mid, nl2!1))))
[2]   i!1`1 = v!1

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this yields  2 subgoals: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  cons?(nl1!1)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  length(nl1!1) = mid - i!3
[-8]  length(nl2!1) = -1 - mid + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] v!1 < mid
[-12] 0 < i!3
[-13] i!3 <= v!1
[-14] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-15] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-16] u!1 = hu(i!3)
[-17] 0 < i!1`1
[-18] i!1`1 < P!1 - 1
[-19] 2 <= P!1
  |-------
{1}   ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))) =
       ilist(remove(hu_list, 1 + i!1`1))
[2]   i!1`1 = v!1

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  cons?(nl1!1)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  length(nl1!1) = mid - i!3
[-8]  length(nl2!1) = -1 - mid + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] v!1 < mid
[-12] 0 < i!3
[-13] i!3 <= v!1
[-14] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-15] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-16] u!1 = hu(i!3)
[-17] 0 < i!1`1
[-18] i!1`1 < P!1 - 1
[-19] 2 <= P!1
  |-------
{1}   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + i!1`1)
[2]   i!1`1 = v!1

Rerunning step: (case "length(append(i!2`3,cons(u!1,cdr(i!2`4))))=p-1")
Case splitting on 
   length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1, 
this yields  2 subgoals: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

{-1}  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-2]  cons?(nl1!1)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`2) = P!1 - 1 - i!1`1
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = P!1 - 1 - i!1`1
[-8]  length(nl1!1) = mid - i!3
[-9]  length(nl2!1) = -1 - mid + p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 0 < i!3
[-14] i!3 <= v!1
[-15] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-16] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-17] u!1 = hu(i!3)
[-18] 0 < i!1`1
[-19] i!1`1 < P!1 - 1
[-20] 2 <= P!1
  |-------
[1]   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + i!1`1)
[2]   i!1`1 = v!1

Rerunning step: (rewrite "length_nth_equality[Identity]" 1)
Found matching substitution:
l2: list[Identity] gets remove(hu_list, 1 + i!1`1),
l1: list[Identity] gets append(i!2`3, cons(u!1, cdr(i!2`4))),
Rewriting using length_nth_equality[Identity], matching in 1,
this yields  2 subgoals: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-2]  cons?(nl1!1)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`2) = P!1 - 1 - i!1`1
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = P!1 - 1 - i!1`1
[-8]  length(nl1!1) = mid - i!3
[-9]  length(nl2!1) = -1 - mid + p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 0 < i!3
[-14] i!3 <= v!1
[-15] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-16] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-17] u!1 = hu(i!3)
[-18] 0 < i!1`1
[-19] i!1`1 < P!1 - 1
[-20] 2 <= P!1
  |-------
{1}   length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4)))) =
       length[Identity](remove(hu_list, 1 + i!1`1))
[2]   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + i!1`1)
[3]   i!1`1 = v!1

Rerunning step: (rewrite "length_remove" 1 :dir rl)
Found matching substitution:
i: below[length(c)] gets 1 + i!1`1,
c: (cons?[T]) gets hu_list,
Rewriting using length_remove, matching in 1,
this yields  2 subgoals: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-2]  cons?(nl1!1)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`2) = P!1 - 1 - i!1`1
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = P!1 - 1 - i!1`1
[-8]  length(nl1!1) = mid - i!3
[-9]  length(nl2!1) = -1 - mid + p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 0 < i!3
[-14] i!3 <= v!1
[-15] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-16] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-17] u!1 = hu(i!3)
[-18] 0 < i!1`1
[-19] i!1`1 < P!1 - 1
[-20] 2 <= P!1
  |-------
{1}   length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4)))) =
       length[Identity](hu_list) - 1
[2]   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + i!1`1)
[3]   i!1`1 = v!1

Rerunning step: (delete -2 -3
                  -4 -5
                  -6 -7
                  -8 -9
                  -11 -12
                  -13 -14
                  -15 -16
                  -17 -18
                  -19 -20
                  2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-2]  (length(hu_list) = p)
  |-------
[1]   length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4)))) =
       length[Identity](hu_list) - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.1.1.

restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.1.2 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-2]  cons?(nl1!1)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`2) = P!1 - 1 - i!1`1
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = P!1 - 1 - i!1`1
[-8]  length(nl1!1) = mid - i!3
[-9]  length(nl2!1) = -1 - mid + p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 0 < i!3
[-14] i!3 <= v!1
[-15] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-16] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-17] u!1 = hu(i!3)
[-18] 0 < i!1`1
[-19] i!1`1 < P!1 - 1
[-20] 2 <= P!1
  |-------
{1}   cons?[Identity](hu_list)
[2]   length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4)))) =
       length[Identity](remove(hu_list, 1 + i!1`1))
[3]   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + i!1`1)
[4]   i!1`1 = v!1

Rerunning step: (delete -1 -2
                  -3 -5
                  -6 -7
                  -8 -9
                  -10 -11
                  -12 -13
                  -14 -15
                  -16 -17
                  -18 -19
                  2 3
                  4)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.1.2 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  P!1 = p
[-2]  2 <= P!1
  |-------
[1]   cons?[Identity](hu_list)

Rerunning step: (nonemptylist "hu_list")
Relating existence of a tail to a list's length,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.1.2.


This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.1.

restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-2]  cons?(nl1!1)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`2) = P!1 - 1 - i!1`1
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = P!1 - 1 - i!1`1
[-8]  length(nl1!1) = mid - i!3
[-9]  length(nl2!1) = -1 - mid + p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] v!1 < mid
[-13] 0 < i!3
[-14] i!3 <= v!1
[-15] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-16] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-17] u!1 = hu(i!3)
[-18] 0 < i!1`1
[-19] i!1`1 < P!1 - 1
[-20] 2 <= P!1
  |-------
{1}   FORALL (i:
                below[length[Identity]
                          (append(i!2`3, cons(u!1, cdr(i!2`4))))]):
        nth(append(i!2`3, cons(u!1, cdr(i!2`4))), i) =
         nth(remove(hu_list, 1 + i!1`1), i)
[2]   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + i!1`1)
[3]   i!1`1 = v!1

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

{-1}  i!4 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-2]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-3]  cons?(nl1!1)
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`2) = P!1 - 1 - i!1`1
[-7]  length(i!2`3) = i!1`1
[-8]  length(i!2`4) = P!1 - 1 - i!1`1
[-9]  length(nl1!1) = mid - i!3
[-10] length(nl2!1) = -1 - mid + p
[-11] (length(hu_list) = p)
[-12] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-13] v!1 < mid
[-14] 0 < i!3
[-15] i!3 <= v!1
[-16] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-17] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-18] u!1 = hu(i!3)
[-19] 0 < i!1`1
[-20] i!1`1 < P!1 - 1
[-21] 2 <= P!1
  |-------
{1}   nth(append(i!2`3, cons(u!1, cdr(i!2`4))), i!4) =
       nth(remove(hu_list, 1 + i!1`1), i!4)
[2]   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + i!1`1)
[3]   i!1`1 = v!1

Rerunning step: (lemma "listprops[Identity].nth_append"
                 ("l1" "i!2`3" "l2" "cons(u!1,cdr(i!2`4))" "i" "i!4"))
Applying listprops[Identity].nth_append where 
  l1 gets i!2`3,
  l2 gets cons(u!1, cdr(i!2`4)),
  i gets i!4,
this yields  2 subgoals: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

{-1}  nth(append(i!2`3, cons(u!1, cdr(i!2`4))), i!4) =
       IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
       ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
       ENDIF
[-2]  i!4 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-3]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-4]  cons?(nl1!1)
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  length(i!2`2) = P!1 - 1 - i!1`1
[-8]  length(i!2`3) = i!1`1
[-9]  length(i!2`4) = P!1 - 1 - i!1`1
[-10] length(nl1!1) = mid - i!3
[-11] length(nl2!1) = -1 - mid + p
[-12] (length(hu_list) = p)
[-13] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-14] v!1 < mid
[-15] 0 < i!3
[-16] i!3 <= v!1
[-17] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-18] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-19] u!1 = hu(i!3)
[-20] 0 < i!1`1
[-21] i!1`1 < P!1 - 1
[-22] 2 <= P!1
  |-------
[1]   nth(append(i!2`3, cons(u!1, cdr(i!2`4))), i!4) =
       nth(remove(hu_list, 1 + i!1`1), i!4)
[2]   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + i!1`1)
[3]   i!1`1 = v!1

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  nth(append(i!2`3, cons(u!1, cdr(i!2`4))), i!4) =
       IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
       ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
       ENDIF
[-2]  i!4 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-3]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-4]  cons?(nl1!1)
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  length(i!2`2) = P!1 - 1 - i!1`1
[-8]  length(i!2`3) = i!1`1
[-9]  length(i!2`4) = P!1 - 1 - i!1`1
[-10] length(nl1!1) = mid - i!3
[-11] length(nl2!1) = -1 - mid + p
[-12] (length(hu_list) = p)
[-13] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-14] v!1 < mid
[-15] 0 < i!3
[-16] i!3 <= v!1
[-17] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-18] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-19] u!1 = hu(i!3)
[-20] 0 < i!1`1
[-21] i!1`1 < P!1 - 1
[-22] 2 <= P!1
  |-------
{1}   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, 1 + i!1`1), i!4)
[2]   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + i!1`1)
[3]   i!1`1 = v!1

Rerunning step: (delete -1 -4 -7 -10 -11 -14 -15 -16 -17 -20 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  i!4 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-2]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-10] u!1 = hu(i!3)
[-11] i!1`1 < P!1 - 1
[-12] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, 1 + i!1`1), i!4)

Rerunning step: (lemma "listprops[Identity].nth_remove"
                 ("l" "hu_list" "i" "1+i!1`1" "j" "i!4"))
Applying listprops[Identity].nth_remove where 
  l gets hu_list,
  i gets 1 + i!1`1,
  j gets i!4,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

{-1}  nth(remove(hu_list, 1 + i!1`1), i!4) =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF
[-2]  i!4 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-3]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = P!1 - 1 - i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-11] u!1 = hu(i!3)
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, 1 + i!1`1), i!4)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  nth(remove(hu_list, 1 + i!1`1), i!4) =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF
[-2]  i!4 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-3]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = P!1 - 1 - i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-11] u!1 = hu(i!3)
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
{1}   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  i!4 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-2]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-10] u!1 = hu(i!3)
[-11] i!1`1 < P!1 - 1
[-12] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (expand "nth" 1 2)
Expanding the definition of nth,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  i!4 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-2]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-10] u!1 = hu(i!3)
[-11] i!1`1 < P!1 - 1
[-12] 2 <= P!1
  |-------
{1}   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (lemma "listprops[Identity].equality_nth"
                 ("l1" "append(i!2`3,i!2`4)" "l2"
                  "remove(hu_list,i!3)"))
Applying listprops[Identity].equality_nth where 
  l1 gets append(i!2`3, i!2`4),
  l2 gets remove(hu_list, i!3),
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

{-1}  append(i!2`3, i!2`4) = remove(hu_list, i!3) IMPLIES
       FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
         nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!3), i)
[-2]  i!4 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-3]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = P!1 - 1 - i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-11] u!1 = hu(i!3)
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

{-1}  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!3), i)
[-2]  i!4 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-3]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = P!1 - 1 - i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-11] u!1 = hu(i!3)
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (inst -1 "i!4")
Instantiating the top quantifier in -1 with the terms: 
 i!4,
this yields  2 subgoals: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

{-1}  nth(append(i!2`3, i!2`4), i!4) = nth(remove(hu_list, i!3), i!4)
[-2]  i!4 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-3]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = P!1 - 1 - i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-11] u!1 = hu(i!3)
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (lemma "listprops[Identity].nth_append"
                 ("l1" "i!2`3" "l2" "i!2`4" "i" "i!4"))
Applying listprops[Identity].nth_append where 
  l1 gets i!2`3,
  l2 gets i!2`4,
  i gets i!4,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

{-1}  nth(append(i!2`3, i!2`4), i!4) =
       IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
       ELSE nth(i!2`4, i!4 - length[Identity](i!2`3))
       ENDIF
[-2]  nth(append(i!2`3, i!2`4), i!4) = nth(remove(hu_list, i!3), i!4)
[-3]  i!4 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-4]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  length(i!2`3) = i!1`1
[-8]  length(i!2`4) = P!1 - 1 - i!1`1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-12] u!1 = hu(i!3)
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (replace -1 -2)
Replacing using formula -1,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  nth(append(i!2`3, i!2`4), i!4) =
       IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
       ELSE nth(i!2`4, i!4 - length[Identity](i!2`3))
       ENDIF
{-2}  IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(i!2`4, i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, i!3), i!4)
[-3]  i!4 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-4]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  length(i!2`3) = i!1`1
[-8]  length(i!2`4) = P!1 - 1 - i!1`1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-12] u!1 = hu(i!3)
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(i!2`4, i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, i!3), i!4)
[-2]  i!4 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-3]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = P!1 - 1 - i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-11] u!1 = hu(i!3)
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (lemma "listprops[Identity].nth_remove"
                 ("l" "hu_list" "i" "i!3" "j" "i!4"))
Ignoring 1 repeated TCCs.
Applying listprops[Identity].nth_remove where 
  l gets hu_list,
  i gets i!3,
  j gets i!4,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

{-1}  nth(remove(hu_list, i!3), i!4) =
       IF i!4 < i!3 THEN nth(hu_list, i!4) ELSE nth(hu_list, i!4 + 1) ENDIF
[-2]  IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(i!2`4, i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, i!3), i!4)
[-3]  i!4 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-4]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  length(i!2`3) = i!1`1
[-8]  length(i!2`4) = P!1 - 1 - i!1`1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-12] u!1 = hu(i!3)
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (replace -1 -2)
Replacing using formula -1,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  nth(remove(hu_list, i!3), i!4) =
       IF i!4 < i!3 THEN nth(hu_list, i!4) ELSE nth(hu_list, i!4 + 1) ENDIF
{-2}  IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(i!2`4, i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < i!3 THEN nth(hu_list, i!4) ELSE nth(hu_list, i!4 + 1) ENDIF
[-3]  i!4 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-4]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  length(i!2`3) = i!1`1
[-8]  length(i!2`4) = P!1 - 1 - i!1`1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-12] u!1 = hu(i!3)
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(i!2`4, i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < i!3 THEN nth(hu_list, i!4) ELSE nth(hu_list, i!4 + 1) ENDIF
[-2]  i!4 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-3]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = P!1 - 1 - i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-11] u!1 = hu(i!3)
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (case "i!4<i!1`1 OR i!4=i!1`1 OR i!4>i!1`1")
Case splitting on 
   i!4 < i!1`1 OR i!4 = i!1`1 OR i!4 > i!1`1, 
this yields  2 subgoals: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

{-1}  i!4 < i!1`1 OR i!4 = i!1`1 OR i!4 > i!1`1
[-2]  IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(i!2`4, i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < i!3 THEN nth(hu_list, i!4) ELSE nth(hu_list, i!4 + 1) ENDIF
[-3]  i!4 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-4]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  length(i!2`3) = i!1`1
[-8]  length(i!2`4) = P!1 - 1 - i!1`1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-12] u!1 = hu(i!3)
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (inst -10 "i!3")
Instantiating the top quantifier in -10 with the terms: 
 i!3,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  i!4 < i!1`1 OR i!4 = i!1`1 OR i!4 > i!1`1
[-2]  IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(i!2`4, i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < i!3 THEN nth(hu_list, i!4) ELSE nth(hu_list, i!4 + 1) ENDIF
[-3]  i!4 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-4]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  length(i!2`3) = i!1`1
[-8]  length(i!2`4) = P!1 - 1 - i!1`1
[-9]  (length(hu_list) = p)
{-10} nth(hu_list, i!3) = hu(i!3)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-12] u!1 = hu(i!3)
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (expand "nth" -2 2)
Expanding the definition of nth,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1.1.1 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  i!4 < i!1`1 OR i!4 = i!1`1 OR i!4 > i!1`1
{-2}  IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN car(i!2`4)
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < i!3 THEN nth(hu_list, i!4) ELSE nth(hu_list, 1 + i!4) ENDIF
[-3]  i!4 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-4]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  length(i!2`3) = i!1`1
[-8]  length(i!2`4) = P!1 - 1 - i!1`1
[-9]  (length(hu_list) = p)
[-10] nth(hu_list, i!3) = hu(i!3)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-12] u!1 = hu(i!3)
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (grind :exclude ("nth" "append" "remove"))
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1.1.1.

restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1.1.2 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(i!2`4, i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < i!3 THEN nth(hu_list, i!4) ELSE nth(hu_list, i!4 + 1) ENDIF
[-2]  i!4 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-3]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = P!1 - 1 - i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-11] u!1 = hu(i!3)
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
{1}   i!4 < i!1`1 OR i!4 = i!1`1 OR i!4 > i!1`1
[2]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1.1.2 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

  |-------
[1]   i!4 < i!1`1 OR i!4 = i!1`1 OR i!4 > i!1`1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1.1.2.


This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1.1.

restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1.2 (TCC):   

[-1]  i!4 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-2]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-10] u!1 = hu(i!3)
[-11] i!1`1 < P!1 - 1
[-12] 2 <= P!1
  |-------
{1}   i!4 < length[Identity](append[Identity](i!2`3, i!2`4))
[2]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets i!2`4,
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in 1,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1.2 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  i!4 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-2]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-10] u!1 = hu(i!3)
[-11] i!1`1 < P!1 - 1
[-12] 2 <= P!1
  |-------
{1}   i!4 < length(i!2`3) + length(i!2`4)
[2]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (delete -3 -7 -8 -9 -10 -11 -12 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1.2 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  i!4 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-2]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-3]  P!1 = p
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
  |-------
[1]   i!4 < length(i!2`3) + length(i!2`4)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1.2.


This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.1.

restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.2T (TCC):   

[-1]  i!4 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-2]  length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[-3]  cons?(nl1!1)
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`2) = P!1 - 1 - i!1`1
[-7]  length(i!2`3) = i!1`1
[-8]  length(i!2`4) = P!1 - 1 - i!1`1
[-9]  length(nl1!1) = mid - i!3
[-10] length(nl2!1) = -1 - mid + p
[-11] (length(hu_list) = p)
[-12] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-13] v!1 < mid
[-14] 0 < i!3
[-15] i!3 <= v!1
[-16] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-17] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-18] u!1 = hu(i!3)
[-19] 0 < i!1`1
[-20] i!1`1 < P!1 - 1
[-21] 2 <= P!1
  |-------
{1}   i!4 <
       length[Identity](cons[Identity](u!1, cdr[Identity](i!2`4))) +
        length[Identity](i!2`3)
[2]   nth(append(i!2`3, cons(u!1, cdr(i!2`4))), i!4) =
       nth(remove(hu_list, 1 + i!1`1), i!4)
[3]   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + i!1`1)
[4]   i!1`1 = v!1

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets cons(u!1, cdr(i!2`4)),
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in -1,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.2T.


This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.2.


This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.1.

restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.2 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  cons?(nl1!1)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  length(nl1!1) = mid - i!3
[-8]  length(nl2!1) = -1 - mid + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] v!1 < mid
[-12] 0 < i!3
[-13] i!3 <= v!1
[-14] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-15] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-16] u!1 = hu(i!3)
[-17] 0 < i!1`1
[-18] i!1`1 < P!1 - 1
[-19] 2 <= P!1
  |-------
{1}   length(append(i!2`3, cons(u!1, cdr(i!2`4)))) = p - 1
[2]   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + i!1`1)
[3]   i!1`1 = v!1

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets cons(u!1, cdr(i!2`4)),
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in 1,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.2 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  cons?(nl1!1)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  length(nl1!1) = mid - i!3
[-8]  length(nl2!1) = -1 - mid + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] v!1 < mid
[-12] 0 < i!3
[-13] i!3 <= v!1
[-14] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-15] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-16] u!1 = hu(i!3)
[-17] 0 < i!1`1
[-18] i!1`1 < P!1 - 1
[-19] 2 <= P!1
  |-------
{1}   length(cons(u!1, cdr(i!2`4))) + length(i!2`3) = p - 1
[2]   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + i!1`1)
[3]   i!1`1 = v!1

Rerunning step: (expand "length" 1 1)
Expanding the definition of length,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.2 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  cons?(nl1!1)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  length(nl1!1) = mid - i!3
[-8]  length(nl2!1) = -1 - mid + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] v!1 < mid
[-12] 0 < i!3
[-13] i!3 <= v!1
[-14] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-15] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-16] u!1 = hu(i!3)
[-17] 0 < i!1`1
[-18] i!1`1 < P!1 - 1
[-19] 2 <= P!1
  |-------
{1}   1 + length[Nonce](cdr(i!2`4)) + length(i!2`3) = p - 1
[2]   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + i!1`1)
[3]   i!1`1 = v!1

Rerunning step: (rewrite "length_cdr" 1)
Found matching substitution:
cons_l: (cons?[T]) gets i!2`4,
Rewriting using length_cdr, matching in 1,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.2 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  cons?(nl1!1)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  length(nl1!1) = mid - i!3
[-8]  length(nl2!1) = -1 - mid + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] v!1 < mid
[-12] 0 < i!3
[-13] i!3 <= v!1
[-14] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-15] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-16] u!1 = hu(i!3)
[-17] 0 < i!1`1
[-18] i!1`1 < P!1 - 1
[-19] 2 <= P!1
  |-------
{1}   1 + (length(i!2`4) - 1) + length(i!2`3) = p - 1
[2]   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + i!1`1)
[3]   i!1`1 = v!1

Rerunning step: (delete -1 -2
                  -4 -7
                  -8 -9
                  -10 -11
                  -12 -13
                  -14 -15
                  -16 -17
                  -18 -19
                  2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.2 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  P!1 = p
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
  |-------
[1]   1 + (length(i!2`4) - 1) + length(i!2`3) = p - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.2.


This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.1.

restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.2 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  cons?(nl1!1)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  length(nl1!1) = mid - i!3
[-8]  length(nl2!1) = -1 - mid + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] v!1 < mid
[-12] 0 < i!3
[-13] i!3 <= v!1
[-14] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-15] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-16] u!1 = hu(i!3)
[-17] 0 < i!1`1
[-18] i!1`1 < P!1 - 1
[-19] 2 <= P!1
  |-------
{1}   nlist(i!2`2) = nlist(append(cdr(nl1!1), cons(n_mid, nl2!1)))
[2]   i!1`1 = v!1

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.2 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  cons?(nl1!1)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  length(nl1!1) = mid - i!3
[-8]  length(nl2!1) = -1 - mid + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] v!1 < mid
[-12] 0 < i!3
[-13] i!3 <= v!1
[-14] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-15] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-16] u!1 = hu(i!3)
[-17] 0 < i!1`1
[-18] i!1`1 < P!1 - 1
[-19] 2 <= P!1
  |-------
{1}   i!2`2 = append(cdr(nl1!1), cons(n_mid, nl2!1))
[2]   i!1`1 = v!1

Rerunning step: (delete -2 -3
                  -4 -5
                  -6 -7
                  -8 -9
                  -10 -11
                  -12 -13
                  -15 -16
                  -17 -18
                  -19 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.2 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  cons?(nl1!1)
[-2]  cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
  |-------
[1]   i!2`2 = append(cdr(nl1!1), cons(n_mid, nl2!1))

Rerunning step: (expand "append" -2)
Expanding the definition of append,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.2 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  cons?(nl1!1)
{-2}  cons(i!1`2, i!2`2) =
       cons(car(nl1!1), append(cdr(nl1!1), cons(n_mid, nl2!1)))
  |-------
[1]   i!2`2 = append(cdr(nl1!1), cons(n_mid, nl2!1))

Rerunning step: (decompose-equality -2)
Applying decompose-equality,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.2.


This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.1.

restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.2 (TCC):   

[-1]  cons?(nl1!1)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  length(nl1!1) = mid - i!3
[-8]  length(nl2!1) = -1 - mid + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] v!1 < mid
[-12] 0 < i!3
[-13] i!3 <= v!1
[-14] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-15] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-16] u!1 = hu(i!3)
[-17] 0 < i!1`1
[-18] i!1`1 < P!1 - 1
[-19] 2 <= P!1
  |-------
{1}   length[Nonce](cdr[Nonce](nl1!1)) = -1 - i!1`1 + mid
[2]   i!1`1 = v!1

Rerunning step: (rewrite "length_cdr" 1)
Found matching substitution:
cons_l: (cons?[T]) gets nl1!1,
Rewriting using length_cdr, matching in 1,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.2 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  cons?(nl1!1)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  length(nl1!1) = mid - i!3
[-8]  length(nl2!1) = -1 - mid + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] v!1 < mid
[-12] 0 < i!3
[-13] i!3 <= v!1
[-14] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-15] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-16] u!1 = hu(i!3)
[-17] 0 < i!1`1
[-18] i!1`1 < P!1 - 1
[-19] 2 <= P!1
  |-------
{1}   length(nl1!1) - 1 = -1 - i!1`1 + mid
[2]   i!1`1 = v!1

Rerunning step: (delete -1 -3
                  -4 -5
                  -6 -8
                  -9 -10
                  -11 -12
                  -13 -14
                  -15 -16
                  -17 -18
                  -19 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.2 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  i!3 = i!1`1
[-2]  length(nl1!1) = mid - i!3
  |-------
[1]   length(nl1!1) - 1 = -1 - i!1`1 + mid

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.2.


This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.1.

restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.2 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] v!1 < mid
[-11] 0 < i!3
[-12] i!3 <= v!1
[-13] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = hu(i!3)
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
[-18] 2 <= P!1
  |-------
{1}   cons?(nl1!1)
[2]   EXISTS (nl1: {x: list[Nonce] | length(x) = -1 - i!1`1 + mid},
              nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
        conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)) =
         conc(ilist(remove(hu_list, i!1`1 + 1)),
              nlist(append(nl1, cons(n_mid, nl2))))
[3]   i!1`1 = v!1

Rerunning step: (delete -1 -2
                  -3 -4
                  -5 -6
                  -7 -8
                  -9 -13
                  -14 -15
                  -16 -17
                  -18 2
                  3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.2 : 
;;; the consequent 2 is needed for the TCC's from instantianting 1 with i!1`1+1

[-1]  v!1 < mid
[-2]  0 < i!3
[-3]  i!3 <= v!1
  |-------
[1]   cons?(nl1!1)

Rerunning step: (nonemptylist "nl1!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.2.


This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.2.


This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.1.1.

restrictpremid_middle.2.1.2.2.2.3.1.2.1.2 : 
;;; split LastMessage up, since one part will be trivial

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] v!1 < mid
[-11] 0 < i!3
[-12] i!3 <= v!1
[-13] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = hu(i!3)
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
[-18] 2 <= P!1
  |-------
{1}   (Stop[event] # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[2]   i!1`1 = v!1
[3]   i!1`1 = P!1 - 2
{4}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                   nlist(i!2`2))))
       >>
       (Stop[event] #
         {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[5]   i!1`2 = n_mid
[6]   P!1 = 2

Rerunning step: (delete - 2 3 4 5 6)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.1.2 : 
;;; split LastMessage up, since one part will be trivial

  |-------
[1]   (Stop[event] # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.1.2.


This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.1.

restrictpremid_middle.2.1.2.2.2.3.1.2.2 : 
;;; split LastMessage up, since one part will be trivial

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] v!1 < mid
[-11] 0 < i!3
[-12] i!3 <= v!1
[-13] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = hu(i!3)
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
[-18] 2 <= P!1
  |-------
{1}   append(i!2`3, cons(u!1, i!2`4)) = hu_list
[2]   NOT i!1`1 = P!1 - 2 IMPLIES
       ((trans(u!1, car(i!2`4),
               E(public(car(i!2`4)),
                 conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                      nlist(i!2`2))))
          >> Stop[event])
         # {e: event | e = signal(running(v!1, hu_list, n_mid))})
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t)
           =>
           every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
                (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (delete -6 -7 -10 -11 -12 -13 -16 -17 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2 : 
;;; split LastMessage up, since one part will be trivial

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-9]  u!1 = hu(i!3)
[-10] 2 <= P!1
  |-------
[1]   append(i!2`3, cons(u!1, i!2`4)) = hu_list

Rerunning step: (rewrite "length_nth_equality[Identity]" 1)
Found matching substitution:
l2: list[Identity] gets hu_list,
l1: list[Identity] gets append(i!2`3, cons(u!1, i!2`4)),
Rewriting using length_nth_equality[Identity], matching in 1,
this yields  2 subgoals: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-9]  u!1 = hu(i!3)
[-10] 2 <= P!1
  |-------
{1}   length[Identity](append(i!2`3, cons(u!1, i!2`4))) =
       length[Identity](hu_list)
[2]   append(i!2`3, cons(u!1, i!2`4)) = hu_list

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets cons(u!1, i!2`4),
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in 1,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-9]  u!1 = hu(i!3)
[-10] 2 <= P!1
  |-------
{1}   length(cons(u!1, i!2`4)) + length(i!2`3) = length[Identity](hu_list)
[2]   append(i!2`3, cons(u!1, i!2`4)) = hu_list

Rerunning step: (expand "length" 1 1)
Expanding the definition of length,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-9]  u!1 = hu(i!3)
[-10] 2 <= P!1
  |-------
{1}   1 + length(i!2`3) + length[Nonce](i!2`4) = length[Identity](hu_list)
[2]   append(i!2`3, cons(u!1, i!2`4)) = hu_list

Rerunning step: (delete -1 -3 -7 -8 -9 -10 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  P!1 = p
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  (length(hu_list) = p)
  |-------
[1]   1 + length(i!2`3) + length[Nonce](i!2`4) = length[Identity](hu_list)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.2.1.

restrictpremid_middle.2.1.2.2.2.3.1.2.2.2 : 
;;; split LastMessage up, since one part will be trivial

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-9]  u!1 = hu(i!3)
[-10] 2 <= P!1
  |-------
{1}   FORALL (i: below[length[Identity](append(i!2`3, cons(u!1, i!2`4)))]):
        nth(append(i!2`3, cons(u!1, i!2`4)), i) = nth(hu_list, i)
[2]   append(i!2`3, cons(u!1, i!2`4)) = hu_list

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2 : 
;;; split LastMessage up, since one part will be trivial

{-1}  i!4 < length[Identity](append(i!2`3, cons(u!1, i!2`4)))
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-10] u!1 = hu(i!3)
[-11] 2 <= P!1
  |-------
{1}   nth(append(i!2`3, cons(u!1, i!2`4)), i!4) = nth(hu_list, i!4)
[2]   append(i!2`3, cons(u!1, i!2`4)) = hu_list

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets cons(u!1, i!2`4),
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2 : 
;;; split LastMessage up, since one part will be trivial

{-1}  i!4 < length(cons(u!1, i!2`4)) + length(i!2`3)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-10] u!1 = hu(i!3)
[-11] 2 <= P!1
  |-------
[1]   nth(append(i!2`3, cons(u!1, i!2`4)), i!4) = nth(hu_list, i!4)
[2]   append(i!2`3, cons(u!1, i!2`4)) = hu_list

Rerunning step: (expand "length" -1 1)
Expanding the definition of length,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2 : 
;;; split LastMessage up, since one part will be trivial

{-1}  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-10] u!1 = hu(i!3)
[-11] 2 <= P!1
  |-------
[1]   nth(append(i!2`3, cons(u!1, i!2`4)), i!4) = nth(hu_list, i!4)
[2]   append(i!2`3, cons(u!1, i!2`4)) = hu_list

Rerunning step: (lemma "listprops[Identity].equality_nth"
                 ("l1" "append(i!2`3,i!2`4)" "l2"
                  "remove(hu_list,i!3)"))
Applying listprops[Identity].equality_nth where 
  l1 gets append(i!2`3, i!2`4),
  l2 gets remove(hu_list, i!3),
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2 : 
;;; split LastMessage up, since one part will be trivial

{-1}  append(i!2`3, i!2`4) = remove(hu_list, i!3) IMPLIES
       FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
         nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!3), i)
[-2]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`2) = P!1 - 1 - i!1`1
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = P!1 - 1 - i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-11] u!1 = hu(i!3)
[-12] 2 <= P!1
  |-------
[1]   nth(append(i!2`3, cons(u!1, i!2`4)), i!4) = nth(hu_list, i!4)
[2]   append(i!2`3, cons(u!1, i!2`4)) = hu_list

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2 : 
;;; split LastMessage up, since one part will be trivial

{-1}  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!3), i)
[-2]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`2) = P!1 - 1 - i!1`1
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = P!1 - 1 - i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-11] u!1 = hu(i!3)
[-12] 2 <= P!1
  |-------
[1]   nth(append(i!2`3, cons(u!1, i!2`4)), i!4) = nth(hu_list, i!4)
[2]   append(i!2`3, cons(u!1, i!2`4)) = hu_list

Rerunning step: (lemma "listprops[Identity].nth_append"
                 ("l1" "i!2`3" "l2" "cons(u!1,i!2`4)" "i" "i!4"))
Applying listprops[Identity].nth_append where 
  l1 gets i!2`3,
  l2 gets cons(u!1, i!2`4),
  i gets i!4,
this yields  2 subgoals: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1 : 
;;; split LastMessage up, since one part will be trivial

{-1}  nth(append(i!2`3, cons(u!1, i!2`4)), i!4) =
       IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
       ELSE nth(cons(u!1, i!2`4), i!4 - length[Identity](i!2`3))
       ENDIF
[-2]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!3), i)
[-3]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`2) = P!1 - 1 - i!1`1
[-7]  length(i!2`3) = i!1`1
[-8]  length(i!2`4) = P!1 - 1 - i!1`1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-12] u!1 = hu(i!3)
[-13] 2 <= P!1
  |-------
[1]   nth(append(i!2`3, cons(u!1, i!2`4)), i!4) = nth(hu_list, i!4)
[2]   append(i!2`3, cons(u!1, i!2`4)) = hu_list

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  nth(append(i!2`3, cons(u!1, i!2`4)), i!4) =
       IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
       ELSE nth(cons(u!1, i!2`4), i!4 - length[Identity](i!2`3))
       ENDIF
[-2]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!3), i)
[-3]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`2) = P!1 - 1 - i!1`1
[-7]  length(i!2`3) = i!1`1
[-8]  length(i!2`4) = P!1 - 1 - i!1`1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-12] u!1 = hu(i!3)
[-13] 2 <= P!1
  |-------
{1}   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, i!2`4), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(hu_list, i!4)
[2]   append(i!2`3, cons(u!1, i!2`4)) = hu_list

Rerunning step: (delete -1 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!3), i)
[-2]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`2) = P!1 - 1 - i!1`1
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = P!1 - 1 - i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-11] u!1 = hu(i!3)
[-12] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, i!2`4), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (lemma "listprops[Identity].nth_append"
                 ("l1" "i!2`3" "l2" "i!2`4"))
Applying listprops[Identity].nth_append where 
  l1 gets i!2`3,
  l2 gets i!2`4,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1 : 
;;; split LastMessage up, since one part will be trivial

{-1}  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < length[Identity](i!2`3) THEN nth(i!2`3, i)
         ELSE nth(i!2`4, i - length[Identity](i!2`3))
         ENDIF
[-2]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!3), i)
[-3]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`2) = P!1 - 1 - i!1`1
[-7]  length(i!2`3) = i!1`1
[-8]  length(i!2`4) = P!1 - 1 - i!1`1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-12] u!1 = hu(i!3)
[-13] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, i!2`4), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (lemma "listprops[Identity].nth_remove"
                 ("l" "hu_list" "i" "i!3"))
Applying listprops[Identity].nth_remove where 
  l gets hu_list,
  i gets i!3,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1 : 
;;; split LastMessage up, since one part will be trivial

{-1}  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!3), j) =
         IF j < i!3 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-2]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < length[Identity](i!2`3) THEN nth(i!2`3, i)
         ELSE nth(i!2`4, i - length[Identity](i!2`3))
         ENDIF
[-3]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!3), i)
[-4]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  length(i!2`2) = P!1 - 1 - i!1`1
[-8]  length(i!2`3) = i!1`1
[-9]  length(i!2`4) = P!1 - 1 - i!1`1
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-13] u!1 = hu(i!3)
[-14] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, i!2`4), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (inst -11 "i!3")
Instantiating the top quantifier in -11 with the terms: 
 i!3,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!3), j) =
         IF j < i!3 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-2]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < length[Identity](i!2`3) THEN nth(i!2`3, i)
         ELSE nth(i!2`4, i - length[Identity](i!2`3))
         ENDIF
[-3]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!3), i)
[-4]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  length(i!2`2) = P!1 - 1 - i!1`1
[-8]  length(i!2`3) = i!1`1
[-9]  length(i!2`4) = P!1 - 1 - i!1`1
[-10] (length(hu_list) = p)
{-11} nth(hu_list, i!3) = hu(i!3)
[-12] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-13] u!1 = hu(i!3)
[-14] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, i!2`4), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (replace -11 -13 rl)
Replacing using formula -11,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!3), j) =
         IF j < i!3 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-2]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < length[Identity](i!2`3) THEN nth(i!2`3, i)
         ELSE nth(i!2`4, i - length[Identity](i!2`3))
         ENDIF
[-3]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!3), i)
[-4]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  length(i!2`2) = P!1 - 1 - i!1`1
[-8]  length(i!2`3) = i!1`1
[-9]  length(i!2`4) = P!1 - 1 - i!1`1
[-10] (length(hu_list) = p)
[-11] nth(hu_list, i!3) = hu(i!3)
[-12] append(i!2`3, i!2`4) = remove(hu_list, i!3)
{-13} u!1 = nth(hu_list, i!3)
[-14] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, i!2`4), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (replace -13 1)
Replacing using formula -13,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!3), j) =
         IF j < i!3 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-2]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < length[Identity](i!2`3) THEN nth(i!2`3, i)
         ELSE nth(i!2`4, i - length[Identity](i!2`3))
         ENDIF
[-3]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!3), i)
[-4]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  length(i!2`2) = P!1 - 1 - i!1`1
[-8]  length(i!2`3) = i!1`1
[-9]  length(i!2`4) = P!1 - 1 - i!1`1
[-10] (length(hu_list) = p)
[-11] nth(hu_list, i!3) = hu(i!3)
[-12] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-13] u!1 = nth(hu_list, i!3)
[-14] 2 <= P!1
  |-------
{1}   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(nth(hu_list, i!3), i!2`4),
               i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (expand "nth" 1 2)
Expanding the definition of nth,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!3), j) =
         IF j < i!3 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-2]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < length[Identity](i!2`3) THEN nth(i!2`3, i)
         ELSE nth(i!2`4, i - length[Identity](i!2`3))
         ENDIF
[-3]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!3), i)
[-4]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  length(i!2`2) = P!1 - 1 - i!1`1
[-8]  length(i!2`3) = i!1`1
[-9]  length(i!2`4) = P!1 - 1 - i!1`1
[-10] (length(hu_list) = p)
[-11] nth(hu_list, i!3) = hu(i!3)
[-12] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-13] u!1 = nth(hu_list, i!3)
[-14] 2 <= P!1
  |-------
{1}   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN nth(hu_list, i!3)
           ELSE nth(i!2`4, -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (case "i!4<i!1`1 OR i!4=i!1`1 OR i!4>i!1`1")
Case splitting on 
   i!4 < i!1`1 OR i!4 = i!1`1 OR i!4 > i!1`1, 
this yields  2 subgoals: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1 : 
;;; split LastMessage up, since one part will be trivial

{-1}  i!4 < i!1`1 OR i!4 = i!1`1 OR i!4 > i!1`1
[-2]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!3), j) =
         IF j < i!3 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-3]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < length[Identity](i!2`3) THEN nth(i!2`3, i)
         ELSE nth(i!2`4, i - length[Identity](i!2`3))
         ENDIF
[-4]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!3), i)
[-5]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  length(i!2`2) = P!1 - 1 - i!1`1
[-9]  length(i!2`3) = i!1`1
[-10] length(i!2`4) = P!1 - 1 - i!1`1
[-11] (length(hu_list) = p)
[-12] nth(hu_list, i!3) = hu(i!3)
[-13] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-14] u!1 = nth(hu_list, i!3)
[-15] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN nth(hu_list, i!3)
           ELSE nth(i!2`4, -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (split -1)
Splitting conjunctions,
this yields  3 subgoals: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.1 : 
;;; split LastMessage up, since one part will be trivial

{-1}  i!4 < i!1`1
[-2]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!3), j) =
         IF j < i!3 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-3]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < length[Identity](i!2`3) THEN nth(i!2`3, i)
         ELSE nth(i!2`4, i - length[Identity](i!2`3))
         ENDIF
[-4]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!3), i)
[-5]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  length(i!2`2) = P!1 - 1 - i!1`1
[-9]  length(i!2`3) = i!1`1
[-10] length(i!2`4) = P!1 - 1 - i!1`1
[-11] (length(hu_list) = p)
[-12] nth(hu_list, i!3) = hu(i!3)
[-13] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-14] u!1 = nth(hu_list, i!3)
[-15] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN nth(hu_list, i!3)
           ELSE nth(i!2`4, -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (grind :exclude ("nth" "remove" "append"))

Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.1.

restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.2 : 
;;; split LastMessage up, since one part will be trivial

{-1}  i!4 = i!1`1
[-2]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!3), j) =
         IF j < i!3 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-3]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < length[Identity](i!2`3) THEN nth(i!2`3, i)
         ELSE nth(i!2`4, i - length[Identity](i!2`3))
         ENDIF
[-4]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!3), i)
[-5]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  length(i!2`2) = P!1 - 1 - i!1`1
[-9]  length(i!2`3) = i!1`1
[-10] length(i!2`4) = P!1 - 1 - i!1`1
[-11] (length(hu_list) = p)
[-12] nth(hu_list, i!3) = hu(i!3)
[-13] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-14] u!1 = nth(hu_list, i!3)
[-15] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN nth(hu_list, i!3)
           ELSE nth(i!2`4, -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (grind :exclude ("nth" "remove" "append"))
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.2.

restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.3 : 
;;; split LastMessage up, since one part will be trivial

{-1}  i!4 > i!1`1
[-2]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!3), j) =
         IF j < i!3 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-3]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < length[Identity](i!2`3) THEN nth(i!2`3, i)
         ELSE nth(i!2`4, i - length[Identity](i!2`3))
         ENDIF
[-4]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!3), i)
[-5]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  length(i!2`2) = P!1 - 1 - i!1`1
[-9]  length(i!2`3) = i!1`1
[-10] length(i!2`4) = P!1 - 1 - i!1`1
[-11] (length(hu_list) = p)
[-12] nth(hu_list, i!3) = hu(i!3)
[-13] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-14] u!1 = nth(hu_list, i!3)
[-15] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN nth(hu_list, i!3)
           ELSE nth(i!2`4, -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (case "0<=i!4-1 AND i!4-1<p-1")
Case splitting on 
   0 <= i!4 - 1 AND i!4 - 1 < p - 1, 
this yields  2 subgoals: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.3.1 : 
;;; split LastMessage up, since one part will be trivial

{-1}  0 <= i!4 - 1 AND i!4 - 1 < p - 1
[-2]  i!4 > i!1`1
[-3]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!3), j) =
         IF j < i!3 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-4]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < length[Identity](i!2`3) THEN nth(i!2`3, i)
         ELSE nth(i!2`4, i - length[Identity](i!2`3))
         ENDIF
[-5]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!3), i)
[-6]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-7]  i!3 = i!1`1
[-8]  P!1 = p
[-9]  length(i!2`2) = P!1 - 1 - i!1`1
[-10] length(i!2`3) = i!1`1
[-11] length(i!2`4) = P!1 - 1 - i!1`1
[-12] (length(hu_list) = p)
[-13] nth(hu_list, i!3) = hu(i!3)
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = nth(hu_list, i!3)
[-16] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN nth(hu_list, i!3)
           ELSE nth(i!2`4, -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (flatten -1)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.3.1 : 
;;; split LastMessage up, since one part will be trivial

{-1}  0 <= i!4 - 1
{-2}  i!4 - 1 < p - 1
[-3]  i!4 > i!1`1
[-4]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!3), j) =
         IF j < i!3 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-5]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < length[Identity](i!2`3) THEN nth(i!2`3, i)
         ELSE nth(i!2`4, i - length[Identity](i!2`3))
         ENDIF
[-6]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!3), i)
[-7]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-8]  i!3 = i!1`1
[-9]  P!1 = p
[-10] length(i!2`2) = P!1 - 1 - i!1`1
[-11] length(i!2`3) = i!1`1
[-12] length(i!2`4) = P!1 - 1 - i!1`1
[-13] (length(hu_list) = p)
[-14] nth(hu_list, i!3) = hu(i!3)
[-15] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-16] u!1 = nth(hu_list, i!3)
[-17] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN nth(hu_list, i!3)
           ELSE nth(i!2`4, -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (inst -6 "i!4-1")
Instantiating the top quantifier in -6 with the terms: 
 i!4-1,
this yields  2 subgoals: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.3.1.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  0 <= i!4 - 1
[-2]  i!4 - 1 < p - 1
[-3]  i!4 > i!1`1
[-4]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!3), j) =
         IF j < i!3 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-5]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < length[Identity](i!2`3) THEN nth(i!2`3, i)
         ELSE nth(i!2`4, i - length[Identity](i!2`3))
         ENDIF
{-6}  nth(append(i!2`3, i!2`4), i!4 - 1) =
       nth(remove(hu_list, i!3), i!4 - 1)
[-7]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-8]  i!3 = i!1`1
[-9]  P!1 = p
[-10] length(i!2`2) = P!1 - 1 - i!1`1
[-11] length(i!2`3) = i!1`1
[-12] length(i!2`4) = P!1 - 1 - i!1`1
[-13] (length(hu_list) = p)
[-14] nth(hu_list, i!3) = hu(i!3)
[-15] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-16] u!1 = nth(hu_list, i!3)
[-17] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN nth(hu_list, i!3)
           ELSE nth(i!2`4, -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (inst -5 "i!4-1")
Instantiating the top quantifier in -5 with the terms: 
 i!4-1,
this yields  2 subgoals: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.3.1.1.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  0 <= i!4 - 1
[-2]  i!4 - 1 < p - 1
[-3]  i!4 > i!1`1
[-4]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!3), j) =
         IF j < i!3 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
{-5}  nth(append(i!2`3, i!2`4), i!4 - 1) =
       IF i!4 - 1 < length[Identity](i!2`3) THEN nth(i!2`3, i!4 - 1)
       ELSE nth(i!2`4, i!4 - 1 - length[Identity](i!2`3))
       ENDIF
[-6]  nth(append(i!2`3, i!2`4), i!4 - 1) =
       nth(remove(hu_list, i!3), i!4 - 1)
[-7]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-8]  i!3 = i!1`1
[-9]  P!1 = p
[-10] length(i!2`2) = P!1 - 1 - i!1`1
[-11] length(i!2`3) = i!1`1
[-12] length(i!2`4) = P!1 - 1 - i!1`1
[-13] (length(hu_list) = p)
[-14] nth(hu_list, i!3) = hu(i!3)
[-15] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-16] u!1 = nth(hu_list, i!3)
[-17] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN nth(hu_list, i!3)
           ELSE nth(i!2`4, -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (inst -4 "i!4-1")
Instantiating the top quantifier in -4 with the terms: 
 i!4-1,
this yields  2 subgoals: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.3.1.1.1.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  0 <= i!4 - 1
[-2]  i!4 - 1 < p - 1
[-3]  i!4 > i!1`1
{-4}  nth(remove(hu_list, i!3), i!4 - 1) =
       IF i!4 - 1 < i!3 THEN nth(hu_list, i!4 - 1)
       ELSE nth(hu_list, i!4 - 1 + 1)
       ENDIF
[-5]  nth(append(i!2`3, i!2`4), i!4 - 1) =
       IF i!4 - 1 < length[Identity](i!2`3) THEN nth(i!2`3, i!4 - 1)
       ELSE nth(i!2`4, i!4 - 1 - length[Identity](i!2`3))
       ENDIF
[-6]  nth(append(i!2`3, i!2`4), i!4 - 1) =
       nth(remove(hu_list, i!3), i!4 - 1)
[-7]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-8]  i!3 = i!1`1
[-9]  P!1 = p
[-10] length(i!2`2) = P!1 - 1 - i!1`1
[-11] length(i!2`3) = i!1`1
[-12] length(i!2`4) = P!1 - 1 - i!1`1
[-13] (length(hu_list) = p)
[-14] nth(hu_list, i!3) = hu(i!3)
[-15] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-16] u!1 = nth(hu_list, i!3)
[-17] 2 <= P!1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN nth(hu_list, i!3)
           ELSE nth(i!2`4, -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.3.1.1.1.1.

restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.3.1.1.1.2 (TCC):   

[-1]  0 <= i!4 - 1
[-2]  i!4 - 1 < p - 1
[-3]  i!4 > i!1`1
[-4]  nth(append(i!2`3, i!2`4), i!4 - 1) =
       IF i!4 - 1 < length[Identity](i!2`3) THEN nth(i!2`3, i!4 - 1)
       ELSE nth(i!2`4, i!4 - 1 - length[Identity](i!2`3))
       ENDIF
[-5]  nth(append(i!2`3, i!2`4), i!4 - 1) =
       nth(remove(hu_list, i!3), i!4 - 1)
[-6]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-7]  i!3 = i!1`1
[-8]  P!1 = p
[-9]  length(i!2`2) = P!1 - 1 - i!1`1
[-10] length(i!2`3) = i!1`1
[-11] length(i!2`4) = P!1 - 1 - i!1`1
[-12] (length(hu_list) = p)
[-13] nth(hu_list, i!3) = hu(i!3)
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = nth(hu_list, i!3)
[-16] 2 <= P!1
  |-------
{1}   i!4 - 1 >= 0 AND i!4 - 1 < length[Identity](hu_list) - 1
[2]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN nth(hu_list, i!3)
           ELSE nth(i!2`4, -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (delete -3 -4 -5 -6 -7 -8 -9 -10 -11 -13 -14 -15 -16 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.3.1.1.1.2 : 
;;; split LastMessage up, since one part will be trivial

[-1]  0 <= i!4 - 1
[-2]  i!4 - 1 < p - 1
[-3]  (length(hu_list) = p)
  |-------
[1]   i!4 - 1 >= 0 AND i!4 - 1 < length[Identity](hu_list) - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.3.1.1.1.2.


This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.3.1.1.1.

restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.3.1.1.2 (TCC):   

[-1]  0 <= i!4 - 1
[-2]  i!4 - 1 < p - 1
[-3]  i!4 > i!1`1
[-4]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!3), j) =
         IF j < i!3 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-5]  nth(append(i!2`3, i!2`4), i!4 - 1) =
       nth(remove(hu_list, i!3), i!4 - 1)
[-6]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-7]  i!3 = i!1`1
[-8]  P!1 = p
[-9]  length(i!2`2) = P!1 - 1 - i!1`1
[-10] length(i!2`3) = i!1`1
[-11] length(i!2`4) = P!1 - 1 - i!1`1
[-12] (length(hu_list) = p)
[-13] nth(hu_list, i!3) = hu(i!3)
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = nth(hu_list, i!3)
[-16] 2 <= P!1
  |-------
{1}   i!4 - 1 >= 0 AND
       i!4 - 1 < length[Identity](i!2`3) + length[Identity](i!2`4)
[2]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN nth(hu_list, i!3)
           ELSE nth(i!2`4, -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (delete -3 -4 -5 -6 -7 -9 -12 -13 -14 -15 -16 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.3.1.1.2 : 
;;; split LastMessage up, since one part will be trivial

[-1]  0 <= i!4 - 1
[-2]  i!4 - 1 < p - 1
[-3]  P!1 = p
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
  |-------
[1]   i!4 - 1 >= 0 AND
       i!4 - 1 < length[Identity](i!2`3) + length[Identity](i!2`4)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.3.1.1.2.


This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.3.1.1.

restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.3.1.2 (TCC):   

[-1]  0 <= i!4 - 1
[-2]  i!4 - 1 < p - 1
[-3]  i!4 > i!1`1
[-4]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!3), j) =
         IF j < i!3 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-5]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < length[Identity](i!2`3) THEN nth(i!2`3, i)
         ELSE nth(i!2`4, i - length[Identity](i!2`3))
         ENDIF
[-6]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-7]  i!3 = i!1`1
[-8]  P!1 = p
[-9]  length(i!2`2) = P!1 - 1 - i!1`1
[-10] length(i!2`3) = i!1`1
[-11] length(i!2`4) = P!1 - 1 - i!1`1
[-12] (length(hu_list) = p)
[-13] nth(hu_list, i!3) = hu(i!3)
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = nth(hu_list, i!3)
[-16] 2 <= P!1
  |-------
{1}   i!4 - 1 >= 0 AND
       i!4 - 1 < length[Identity](append[Identity](i!2`3, i!2`4))
[2]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN nth(hu_list, i!3)
           ELSE nth(i!2`4, -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (delete -3 -4 -5 -6 -7 -9 -12 -13 -14 -15 -16 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.3.1.2 : 
;;; split LastMessage up, since one part will be trivial

[-1]  0 <= i!4 - 1
[-2]  i!4 - 1 < p - 1
[-3]  P!1 = p
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
  |-------
[1]   i!4 - 1 >= 0 AND
       i!4 - 1 < length[Identity](append[Identity](i!2`3, i!2`4))

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets i!2`4,
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in 1,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.3.1.2 : 
;;; split LastMessage up, since one part will be trivial

[-1]  0 <= i!4 - 1
[-2]  i!4 - 1 < p - 1
[-3]  P!1 = p
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
  |-------
{1}   i!4 - 1 >= 0 AND i!4 - 1 < length(i!2`3) + length(i!2`4)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.3.1.2.


This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.3.1.

restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.3.2 : 
;;; split LastMessage up, since one part will be trivial

[-1]  i!4 > i!1`1
[-2]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!3), j) =
         IF j < i!3 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-3]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < length[Identity](i!2`3) THEN nth(i!2`3, i)
         ELSE nth(i!2`4, i - length[Identity](i!2`3))
         ENDIF
[-4]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!3), i)
[-5]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  length(i!2`2) = P!1 - 1 - i!1`1
[-9]  length(i!2`3) = i!1`1
[-10] length(i!2`4) = P!1 - 1 - i!1`1
[-11] (length(hu_list) = p)
[-12] nth(hu_list, i!3) = hu(i!3)
[-13] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-14] u!1 = nth(hu_list, i!3)
[-15] 2 <= P!1
  |-------
{1}   0 <= i!4 - 1 AND i!4 - 1 < p - 1
[2]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN nth(hu_list, i!3)
           ELSE nth(i!2`4, -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (delete -2 -3 -4 -6 -8 -11 -12 -13 -14 -15 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.3.2 : 
;;; split LastMessage up, since one part will be trivial

[-1]  i!4 > i!1`1
[-2]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-3]  P!1 = p
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
  |-------
[1]   0 <= i!4 - 1 AND i!4 - 1 < p - 1

Rerunning step: (typepred "i!1`1")
Adding type constraints for  i!1`1,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.3.2 : 
;;; split LastMessage up, since one part will be trivial

{-1}  0 < i!1`1
{-2}  i!1`1 < P!1 - 1
[-3]  i!4 > i!1`1
[-4]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-5]  P!1 = p
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = P!1 - 1 - i!1`1
  |-------
[1]   0 <= i!4 - 1 AND i!4 - 1 < p - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.3.2.


This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.3.


This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.1.

restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.2 : 
;;; split LastMessage up, since one part will be trivial

[-1]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!3), j) =
         IF j < i!3 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-2]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < length[Identity](i!2`3) THEN nth(i!2`3, i)
         ELSE nth(i!2`4, i - length[Identity](i!2`3))
         ENDIF
[-3]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!3), i)
[-4]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  length(i!2`2) = P!1 - 1 - i!1`1
[-8]  length(i!2`3) = i!1`1
[-9]  length(i!2`4) = P!1 - 1 - i!1`1
[-10] (length(hu_list) = p)
[-11] nth(hu_list, i!3) = hu(i!3)
[-12] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-13] u!1 = nth(hu_list, i!3)
[-14] 2 <= P!1
  |-------
{1}   i!4 < i!1`1 OR i!4 = i!1`1 OR i!4 > i!1`1
[2]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN nth(hu_list, i!3)
           ELSE nth(i!2`4, -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.2 : 
;;; split LastMessage up, since one part will be trivial

  |-------
[1]   i!4 < i!1`1 OR i!4 = i!1`1 OR i!4 > i!1`1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.2.


This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.1.

restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.2T (TCC):   

[-1]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!3), i)
[-2]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`2) = P!1 - 1 - i!1`1
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = P!1 - 1 - i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-11] u!1 = hu(i!3)
[-12] 2 <= P!1
  |-------
{1}   i!4 <
       length[Identity](cons[Identity](u!1, i!2`4)) +
        length[Identity](i!2`3)
[2]   nth(append(i!2`3, cons(u!1, i!2`4)), i!4) = nth(hu_list, i!4)
[3]   append(i!2`3, cons(u!1, i!2`4)) = hu_list

Rerunning step: (expand "length" 1 1)
Expanding the definition of length,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.2T : 
;;; split LastMessage up, since one part will be trivial

[-1]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!3), i)
[-2]  i!4 < 1 + length(i!2`3) + length[Nonce](i!2`4)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`2) = P!1 - 1 - i!1`1
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = P!1 - 1 - i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-11] u!1 = hu(i!3)
[-12] 2 <= P!1
  |-------
{1}   i!4 < 1 + length[Identity](i!2`3) + length[Identity](i!2`4)
[2]   nth(append(i!2`3, cons(u!1, i!2`4)), i!4) = nth(hu_list, i!4)
[3]   append(i!2`3, cons(u!1, i!2`4)) = hu_list

which is trivially true.

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.2T.


This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.2.2.


This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.2.

restrictpremid_middle.2.1.2.2.2.3.1.2.3 : 
;;; split LastMessage up, since one part will be trivial

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] v!1 < mid
[-11] 0 < i!3
[-12] i!3 <= v!1
[-13] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = hu(i!3)
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
[-18] 2 <= P!1
  |-------
{1}   nth(cons(i!1`2, i!2`2),
          floor(1 - 2 * ((mid - 1) / (p - 2)) +
                 ((mid - 1) / (p - 2)) * P!1)
           - i!1`1)
       = n_mid
[2]   NOT i!1`1 = P!1 - 2 IMPLIES
       ((trans(u!1, car(i!2`4),
               E(public(car(i!2`4)),
                 conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                      nlist(i!2`2))))
          >> Stop[event])
         # {e: event | e = signal(running(v!1, hu_list, n_mid))})
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t)
           =>
           every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
                (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (lemma "select_right_nonce2" ("P" "P!1"))
Applying select_right_nonce2 where 
  P gets P!1,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.3 : 
;;; split LastMessage up, since one part will be trivial

{-1}  (P!1 = p IMPLIES floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid)
       AND
       floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1 AND
        floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  length(nl1!1) = mid - i!3
[-8]  length(nl2!1) = -1 - mid + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] v!1 < mid
[-12] 0 < i!3
[-13] i!3 <= v!1
[-14] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-15] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-16] u!1 = hu(i!3)
[-17] 0 < i!1`1
[-18] i!1`1 < P!1 - 1
[-19] 2 <= P!1
  |-------
[1]   nth(cons(i!1`2, i!2`2),
          floor(1 - 2 * ((mid - 1) / (p - 2)) +
                 ((mid - 1) / (p - 2)) * P!1)
           - i!1`1)
       = n_mid
[2]   NOT i!1`1 = P!1 - 2 IMPLIES
       ((trans(u!1, car(i!2`4),
               E(public(car(i!2`4)),
                 conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                      nlist(i!2`2))))
          >> Stop[event])
         # {e: event | e = signal(running(v!1, hu_list, n_mid))})
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t)
           =>
           every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
                (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (delete -4 -5
                  -6 -8
                  -9 -10
                  -11 -12
                  -13 -15
                  -16 -17
                  -18 -19
                  2 3
                  4)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.3 : 
;;; split LastMessage up, since one part will be trivial

[-1]  (P!1 = p IMPLIES floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid)
       AND
       floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1 AND
        floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(nl1!1) = mid - i!3
[-5]  cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
  |-------
[1]   nth(cons(i!1`2, i!2`2),
          floor(1 - 2 * ((mid - 1) / (p - 2)) +
                 ((mid - 1) / (p - 2)) * P!1)
           - i!1`1)
       = n_mid

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.3 : 
;;; split LastMessage up, since one part will be trivial

{-1}  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid
{-2}  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
{-3}  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(nl1!1) = mid - i!3
[-7]  cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
  |-------
[1]   nth(cons(i!1`2, i!2`2),
          floor(1 - 2 * ((mid - 1) / (p - 2)) +
                 ((mid - 1) / (p - 2)) * P!1)
           - i!1`1)
       = n_mid

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.3 : 
;;; split LastMessage up, since one part will be trivial

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(nl1!1) = mid - i!3
[-7]  cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
  |-------
{1}   nth(cons(i!1`2, i!2`2), mid - i!1`1) = n_mid

Rerunning step: (replace -7 1)
Replacing using formula -7,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.3 : 
;;; split LastMessage up, since one part will be trivial

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(nl1!1) = mid - i!3
[-7]  cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
  |-------
{1}   nth(append(nl1!1, cons(n_mid, nl2!1)), mid - i!1`1) = n_mid

Rerunning step: (replace* -4)
Repeatedly applying the replace rule,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.3 : 
;;; split LastMessage up, since one part will be trivial

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
{-6}  length(nl1!1) = mid - i!1`1
[-7]  cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
  |-------
[1]   nth(append(nl1!1, cons(n_mid, nl2!1)), mid - i!1`1) = n_mid

Rerunning step: (rewrite "nth_append" 1)
Found matching substitution:
i: below[length(l1) + length(l2)] gets mid - i!1`1,
l2: list[T] gets cons(n_mid, nl2!1),
l1: list[T] gets nl1!1,
Rewriting using nth_append, matching in 1,
this yields  2 subgoals: 
restrictpremid_middle.2.1.2.2.2.3.1.2.3.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(nl1!1) = mid - i!1`1
[-7]  cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
  |-------
{1}   IF mid - i!1`1 < length[Identity](nl1!1) THEN nth(nl1!1, mid - i!1`1)
      ELSE nth(cons(n_mid, nl2!1),
               -1 * length[Identity](nl1!1) - i!1`1 + mid)
      ENDIF
       = n_mid

Rerunning step: (expand "nth" 1 2)
Expanding the definition of nth,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.3.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(nl1!1) = mid - i!1`1
[-7]  cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
  |-------
{1}   IF mid - i!1`1 < length[Identity](nl1!1) THEN nth(nl1!1, mid - i!1`1)
      ELSE IF -1 * length[Identity](nl1!1) - i!1`1 + mid = 0 THEN n_mid
           ELSE nth(nl2!1, -1 - length[Identity](nl1!1) - i!1`1 + mid)
           ENDIF
      ENDIF
       = n_mid

Rerunning step: (delete -1 -2 -3 -4 -5 -7)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.3.1 : 
;;; split LastMessage up, since one part will be trivial

[-1]  length(nl1!1) = mid - i!1`1
  |-------
[1]   IF mid - i!1`1 < length[Identity](nl1!1) THEN nth(nl1!1, mid - i!1`1)
      ELSE IF -1 * length[Identity](nl1!1) - i!1`1 + mid = 0 THEN n_mid
           ELSE nth(nl2!1, -1 - length[Identity](nl1!1) - i!1`1 + mid)
           ENDIF
      ENDIF
       = n_mid

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.3.1.

restrictpremid_middle.2.1.2.2.2.3.1.2.3.2 : 
;;; split LastMessage up, since one part will be trivial

{-1}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) =
       mid
{-2}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-3}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(nl1!1) = mid - i!1`1
[-7]  cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
  |-------
{1}   mid - i!1`1 <
       length[Identity](cons[Nonce](n_mid, nl2!1)) + length[Identity](nl1!1)
[2]   nth(append(nl1!1, cons(n_mid, nl2!1)), mid - i!1`1) = n_mid

Rerunning step: (expand "length" 1 1)
Expanding the definition of length,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.3.2 : 
;;; split LastMessage up, since one part will be trivial

[-1]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) =
       mid
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(nl1!1) = mid - i!1`1
[-7]  cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
  |-------
{1}   mid - i!1`1 < 1 + length[Identity](nl1!1) + length[Identity](nl2!1)
[2]   nth(append(nl1!1, cons(n_mid, nl2!1)), mid - i!1`1) = n_mid

Rerunning step: (delete -1 -2 -3 -4 -5 -7 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.1.2.3.2 : 
;;; split LastMessage up, since one part will be trivial

[-1]  length(nl1!1) = mid - i!1`1
  |-------
[1]   mid - i!1`1 < 1 + length[Identity](nl1!1) + length[Identity](nl2!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.3.2.


This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.3.


This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.2.


This completes the proof of restrictpremid_middle.2.1.2.2.2.3.1.

restrictpremid_middle.2.1.2.2.2.3.2 : 
;;; establish some convenient equalities first

{-1}  P!1 = p
[-2]  length(i!2`2) = P!1 - 1 - i!1`1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  length(nl1!1) = mid - i!3
[-6]  length(nl2!1) = -1 - mid + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  v!1 < mid
[-10] 0 < i!3
[-11] i!3 <= v!1
[-12] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-13] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-14] u!1 = hu(i!3)
[-15] 0 < i!1`1
[-16] i!1`1 < P!1 - 1
[-17] 2 <= P!1
  |-------
{1}   i!3 = i!1`1
[2]   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 - 2 * ((mid - 1) / (p - 2)) +
                   ((mid - 1) / (p - 2)) * P!1)
             - i!1`1)
         = n_mid
[3]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (lemma "listprops[Identity].equality_length"
                 ("l1" "cons(i!1`2,i!2`2)" "l2"
                  "append(nl1!1,cons(n_mid,nl2!1))"))
Applying listprops[Identity].equality_length where 
  l1 gets cons(i!1`2, i!2`2),
  l2 gets append(nl1!1, cons(n_mid, nl2!1)),
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.2 : 
;;; establish some convenient equalities first

{-1}  cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1)) IMPLIES
       length[Identity](cons(i!1`2, i!2`2)) =
        length[Identity](append(nl1!1, cons(n_mid, nl2!1)))
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] v!1 < mid
[-11] 0 < i!3
[-12] i!3 <= v!1
[-13] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] u!1 = hu(i!3)
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
[-18] 2 <= P!1
  |-------
[1]   i!3 = i!1`1
[2]   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 - 2 * ((mid - 1) / (p - 2)) +
                   ((mid - 1) / (p - 2)) * P!1)
             - i!1`1)
         = n_mid
[3]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete -4 -5
                  -8 -9
                  -10 -11
                  -12 -14
                  -15 -16
                  -17 -18
                  2 3
                  4 5)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.2 : 
;;; establish some convenient equalities first

[-1]  cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1)) IMPLIES
       length[Identity](cons(i!1`2, i!2`2)) =
        length[Identity](append(nl1!1, cons(n_mid, nl2!1)))
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(nl1!1) = mid - i!3
[-5]  length(nl2!1) = -1 - mid + p
[-6]  cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
  |-------
[1]   i!3 = i!1`1

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.2 : 
;;; establish some convenient equalities first

{-1}  length[Identity](cons(i!1`2, i!2`2)) =
       length[Identity](append(nl1!1, cons(n_mid, nl2!1)))
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(nl1!1) = mid - i!3
[-5]  length(nl2!1) = -1 - mid + p
[-6]  cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
  |-------
[1]   i!3 = i!1`1

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets cons(n_mid, nl2!1),
l1: list[T] gets nl1!1,
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.2 : 
;;; establish some convenient equalities first

{-1}  length[Identity](cons(i!1`2, i!2`2)) =
       length(cons(n_mid, nl2!1)) + length(nl1!1)
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(nl1!1) = mid - i!3
[-5]  length(nl2!1) = -1 - mid + p
[-6]  cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
  |-------
[1]   i!3 = i!1`1

Rerunning step: (expand "length" -1 (1 2))
Expanding the definition of length,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.2 : 
;;; establish some convenient equalities first

{-1}  length[Identity](i!2`2) = length(nl1!1) + length[Nonce](nl2!1)
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(nl1!1) = mid - i!3
[-5]  length(nl2!1) = -1 - mid + p
[-6]  cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
  |-------
[1]   i!3 = i!1`1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.2.

restrictpremid_middle.2.1.2.2.2.3.3 : 
;;; establish some convenient equalities first

[-1]  length(i!2`2) = P!1 - 1 - i!1`1
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  length(nl1!1) = mid - i!3
[-5]  length(nl2!1) = -1 - mid + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  v!1 < mid
[-9]  0 < i!3
[-10] i!3 <= v!1
[-11] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-12] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-13] u!1 = hu(i!3)
[-14] 0 < i!1`1
[-15] i!1`1 < P!1 - 1
[-16] 2 <= P!1
  |-------
{1}   P!1 = p
[2]   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 - 2 * ((mid - 1) / (p - 2)) +
                   ((mid - 1) / (p - 2)) * P!1)
             - i!1`1)
         = n_mid
[3]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (lemma "listprops[Identity].equality_length"
                 ("l1" "append(i!2`3,i!2`4)" "l2"
                  "remove(hu_list,i!3)"))
Applying listprops[Identity].equality_length where 
  l1 gets append(i!2`3, i!2`4),
  l2 gets remove(hu_list, i!3),
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.3 : 
;;; establish some convenient equalities first

{-1}  append(i!2`3, i!2`4) = remove(hu_list, i!3) IMPLIES
       length[Identity](append(i!2`3, i!2`4)) =
        length[Identity](remove(hu_list, i!3))
[-2]  length(i!2`2) = P!1 - 1 - i!1`1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  length(nl1!1) = mid - i!3
[-6]  length(nl2!1) = -1 - mid + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  v!1 < mid
[-10] 0 < i!3
[-11] i!3 <= v!1
[-12] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-13] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-14] u!1 = hu(i!3)
[-15] 0 < i!1`1
[-16] i!1`1 < P!1 - 1
[-17] 2 <= P!1
  |-------
[1]   P!1 = p
[2]   i!1`1 = v!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(cons(i!1`2, i!2`2),
            floor(1 - 2 * ((mid - 1) / (p - 2)) +
                   ((mid - 1) / (p - 2)) * P!1)
             - i!1`1)
         = n_mid
[3]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete -2 -5
                  -6 -8
                  -9 -10
                  -11 -12
                  -14 -15
                  -16 -17
                  2 3
                  4 5)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.3 : 
;;; establish some convenient equalities first

[-1]  append(i!2`3, i!2`4) = remove(hu_list, i!3) IMPLIES
       length[Identity](append(i!2`3, i!2`4)) =
        length[Identity](remove(hu_list, i!3))
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  (length(hu_list) = p)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
  |-------
[1]   P!1 = p

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.3 : 
;;; establish some convenient equalities first

{-1}  length[Identity](append(i!2`3, i!2`4)) =
       length[Identity](remove(hu_list, i!3))
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  (length(hu_list) = p)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
  |-------
[1]   P!1 = p

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets i!2`4,
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.3 : 
;;; establish some convenient equalities first

{-1}  length(i!2`3) + length(i!2`4) = length[Identity](remove(hu_list, i!3))
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  (length(hu_list) = p)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
  |-------
[1]   P!1 = p

Rerunning step: (rewrite "length_remove" -1 :dir rl)
Found matching substitution:
i: below[length(c)] gets i!3,
c: (cons?[T]) gets hu_list,
Rewriting using length_remove, matching in -1,
this yields  2 subgoals: 
restrictpremid_middle.2.1.2.2.2.3.3.1 : 
;;; establish some convenient equalities first

{-1}  length(i!2`3) + length(i!2`4) = length[Identity](hu_list) - 1
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  (length(hu_list) = p)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
  |-------
[1]   P!1 = p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.3.1.

restrictpremid_middle.2.1.2.2.2.3.3.2 : 
;;; establish some convenient equalities first

[-1]  length(i!2`3) + length(i!2`4) = length[Identity](remove(hu_list, i!3))
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  (length(hu_list) = p)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
  |-------
{1}   cons?[Identity](hu_list)
[2]   P!1 = p

Rerunning step: (lemma "more_list_props[Identity].length_non_zero"
                 ("l" "hu_list"))
Applying more_list_props[Identity].length_non_zero where 
  l gets hu_list,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.3.2 : 
;;; establish some convenient equalities first

{-1}  length(hu_list) > 0 IFF cons?(hu_list)
[-2]  length(i!2`3) + length(i!2`4) = length[Identity](remove(hu_list, i!3))
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  (length(hu_list) = p)
[-6]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
  |-------
[1]   cons?[Identity](hu_list)
[2]   P!1 = p

Rerunning step: (typepred "p")
Adding type constraints for  p,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.3.2 : 
;;; establish some convenient equalities first

{-1}  3 <= p
[-2]  length(hu_list) > 0 IFF cons?(hu_list)
[-3]  length(i!2`3) + length(i!2`4) = length[Identity](remove(hu_list, i!3))
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  (length(hu_list) = p)
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
  |-------
[1]   cons?[Identity](hu_list)
[2]   P!1 = p

Rerunning step: (delete -3 -4 -5 -7 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.2.3.3.2 : 
;;; establish some convenient equalities first

[-1]  3 <= p
[-2]  length(hu_list) > 0 IFF cons?(hu_list)
[-3]  (length(hu_list) = p)
  |-------
[1]   cons?[Identity](hu_list)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.1.2.2.2.3.3.2.


This completes the proof of restrictpremid_middle.2.1.2.2.2.3.3.


This completes the proof of restrictpremid_middle.2.1.2.2.2.3.


This completes the proof of restrictpremid_middle.2.1.2.2.2.

restrictpremid_middle.2.1.2.2.3T (TCC):   

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(ilist(append(i!2`3, i!2`4)),
                        nlist(cons(i!1`2, i!2`2)))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
{1}   append(i!2`3, cons(u!1, i!2`4)) = hu_list AND i!1`1 = v!1 IMPLIES
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) -
        i!1`1
        < length[Nonce](cons[Nonce](i!1`2, i!2`2))
[2]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                     nth(cons(i!1`2, i!2`2),
                         floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                ((mid - 1) / (p - 2)) * P!1)
                          - i!1`1)))
       = signal(running(v!1, hu_list, n_mid))
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpremid_middle.2.1.2.2.3T : 
;;; consider the case where the process is blocked and the case where the process is not blocked

{-1}  append(i!2`3, cons(u!1, i!2`4)) = hu_list
{-2}  i!1`1 = v!1
[-3]  rho_premid(v!1)
                (E(public(u!1),
                   conc(ilist(append(i!2`3, i!2`4)),
                        nlist(cons(i!1`2, i!2`2)))))
[-4]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-5]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-6]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-7]  0 < i!1`1
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
{1}   floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) -
       i!1`1
       < length[Nonce](cons[Nonce](i!1`2, i!2`2))
[2]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                     nth(cons(i!1`2, i!2`2),
                         floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                ((mid - 1) / (p - 2)) * P!1)
                          - i!1`1)))
       = signal(running(v!1, hu_list, n_mid))
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (typepred "i!2`2")
Adding type constraints for  i!2`2,
this simplifies to: 
restrictpremid_middle.2.1.2.2.3T : 
;;; consider the case where the process is blocked and the case where the process is not blocked

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`2)
{-2}  length(i!2`2) = P!1 - 1 - i!1`1
[-3]  append(i!2`3, cons(u!1, i!2`4)) = hu_list
[-4]  i!1`1 = v!1
[-5]  rho_premid(v!1)
                (E(public(u!1),
                   conc(ilist(append(i!2`3, i!2`4)),
                        nlist(cons(i!1`2, i!2`2)))))
[-6]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-7]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-8]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-9]  0 < i!1`1
[-10] i!1`1 < P!1 - 1
[-11] 2 <= P!1
  |-------
[1]   floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) -
       i!1`1
       < length[Nonce](cons[Nonce](i!1`2, i!2`2))
[2]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # {e: event | e = signal(running(v!1, hu_list, n_mid))})
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                     nth(cons(i!1`2, i!2`2),
                         floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                ((mid - 1) / (p - 2)) * P!1)
                          - i!1`1)))
       = signal(running(v!1, hu_list, n_mid))
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete -1 -3 -4 -5 -6 -7 -9 -10 -11 2 3 4 5)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.1.2.2.3T : 
;;; consider the case where the process is blocked and the case where the process is not blocked

[-1]  length(i!2`2) = P!1 - 1 - i!1`1
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
  |-------
[1]   floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) -
       i!1`1
       < length[Nonce](cons[Nonce](i!1`2, i!2`2))

Rerunning step: (expand "length" 1)
Expanding the definition of length,
this simplifies to: 
restrictpremid_middle.2.1.2.2.3T : 
;;; consider the case where the process is blocked and the case where the process is not blocked

[-1]  length(i!2`2) = P!1 - 1 - i!1`1
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
  |-------
{1}   floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) -
       i!1`1
       < 1 + length[Nonce](i!2`2)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.1.2.2.3T.


This completes the proof of restrictpremid_middle.2.1.2.2.


This completes the proof of restrictpremid_middle.2.1.2.


This completes the proof of restrictpremid_middle.2.1.

restrictpremid_middle.2.2 :  

[-1]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
{-2}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-3}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) -
       i!1`1
       < length[Nonce](cons[Nonce](i!1`2, i!2`2))
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!1`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!1`2, i`2)))))
              >>
              (signal(running(i!1`1, append(i`3, cons(u!1, i`4)),
                              nth(cons(i!1`2, i`2),
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)
                                   - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (typepred "i!2`2")
Adding type constraints for  i!2`2,
this simplifies to: 
restrictpremid_middle.2.2 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`2)
{-2}  length(i!2`2) = P!1 - 1 - i!1`1
[-3]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-5]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-6]  0 < i!1`1
[-7]  i!1`1 < P!1 - 1
[-8]  2 <= P!1
  |-------
[1]   floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) -
       i!1`1
       < length[Nonce](cons[Nonce](i!1`2, i!2`2))
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!1`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!1`2, i`2)))))
              >>
              (signal(running(i!1`1, append(i`3, cons(u!1, i`4)),
                              nth(cons(i!1`2, i`2),
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)
                                   - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (delete -1 -3 -4 -6 -7 -8 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.2 :  

[-1]  length(i!2`2) = P!1 - 1 - i!1`1
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
  |-------
[1]   floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) -
       i!1`1
       < length[Nonce](cons[Nonce](i!1`2, i!2`2))

Rerunning step: (expand "length" 1)
Expanding the definition of length,
this simplifies to: 
restrictpremid_middle.2.2 :  

[-1]  length(i!2`2) = P!1 - 1 - i!1`1
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
  |-------
{1}   floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) -
       i!1`1
       < 1 + length[Nonce](i!2`2)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.2.

restrictpremid_middle.2.3 :  

[-1]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
{-2}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-3}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   cons?[Identity](i!2`4)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!1`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!1`2, i`2)))))
              >>
              (signal(running(i!1`1, append(i`3, cons(u!1, i`4)),
                              nth(cons(i!1`2, i`2),
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)
                                   - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (delete -1 -2 -3 -4 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.3 :  

[-1]  i!1`1 < P!1 - 1
[-2]  2 <= P!1
  |-------
[1]   cons?[Identity](i!2`4)

Rerunning step: (nonemptylist "i!2`4")
Relating existence of a tail to a list's length,

This completes the proof of restrictpremid_middle.2.3.

restrictpremid_middle.2.4 :  

[-1]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
{-2}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-3}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   i!1`1 - 1 < length[Identity](i!2`3)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!1`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!1`2, i`2)))))
              >>
              (signal(running(i!1`1, append(i`3, cons(u!1, i`4)),
                              nth(cons(i!1`2, i`2),
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)
                                   - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (typepred "i!2`3")
Adding type constraints for  i!2`3,
this simplifies to: 
restrictpremid_middle.2.4 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`3)
{-2}  length(i!2`3) = i!1`1
[-3]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-5]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-6]  0 < i!1`1
[-7]  i!1`1 < P!1 - 1
[-8]  2 <= P!1
  |-------
[1]   i!1`1 - 1 < length[Identity](i!2`3)
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!1`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!1`2, i`2)))))
              >>
              (signal(running(i!1`1, append(i`3, cons(u!1, i`4)),
                              nth(cons(i!1`2, i`2),
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)
                                   - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (delete -1 -3 -4 -5 -6 -7 -8 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.4 :  

[-1]  length(i!2`3) = i!1`1
  |-------
[1]   i!1`1 - 1 < length[Identity](i!2`3)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.4.

restrictpremid_middle.2.5 :  

[-1]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
{-2}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-3}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   FORALL (nl1: {x: list[Nonce] | length[Nonce](x) = i!1`1},
              nl2: {x: list[Nonce] | length[Nonce](x) = P!1 - 1 - i!1`1},
              il1: {x: list[Identity] | length[Identity](x) = i!1`1},
              il2:
                {x: list[Identity] |
                   length[Identity](x) = P!1 - 1 - i!1`1}):
        floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
         - i!1`1
         < length[Nonce](cons[Nonce](i!1`2, nl2))
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1: {x: list[Identity] | length(x) = i!1`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              (signal(running(i!1`1, append(il1, cons(u!1, il2)),
                              nth(cons(i!1`2, nl2),
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)
                                   - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictpremid_middle.2.5 :  

[-1]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) -
       i!1`1
       < length[Nonce](cons[Nonce](i!1`2, nl2!1))
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1: {x: list[Identity] | length(x) = i!1`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              (signal(running(i!1`1, append(il1, cons(u!1, il2)),
                              nth(cons(i!1`2, nl2),
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)
                                   - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (typepred "nl2!1")
Adding type constraints for  nl2!1,
this simplifies to: 
restrictpremid_middle.2.5 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
{-2}  length(nl2!1) = P!1 - 1 - i!1`1
[-3]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-5]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-6]  0 < i!1`1
[-7]  i!1`1 < P!1 - 1
[-8]  2 <= P!1
  |-------
[1]   floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) -
       i!1`1
       < length[Nonce](cons[Nonce](i!1`2, nl2!1))
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1: {x: list[Identity] | length(x) = i!1`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              (signal(running(i!1`1, append(il1, cons(u!1, il2)),
                              nth(cons(i!1`2, nl2),
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)
                                   - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (delete -1 -3 -4 -6 -7 -8 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.5 :  

[-1]  length(nl2!1) = P!1 - 1 - i!1`1
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
  |-------
[1]   floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) -
       i!1`1
       < length[Nonce](cons[Nonce](i!1`2, nl2!1))

Rerunning step: (expand "length" 1)
Expanding the definition of length,
this simplifies to: 
restrictpremid_middle.2.5 :  

[-1]  length(nl2!1) = P!1 - 1 - i!1`1
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
  |-------
{1}   floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) -
       i!1`1
       < 1 + length[Nonce](nl2!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.2.5.

restrictpremid_middle.2.6 :  

[-1]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
{-2}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-3}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   FORALL (nl1: {x: list[Nonce] | length[Nonce](x) = i!1`1},
              nl2: {x: list[Nonce] | length[Nonce](x) = P!1 - 1 - i!1`1},
              il1: {x: list[Identity] | length[Identity](x) = i!1`1},
              il2:
                {x: list[Identity] |
                   length[Identity](x) = P!1 - 1 - i!1`1}):
        cons?[Identity](il2)
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1: {x: list[Identity] | length(x) = i!1`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              (signal(running(i!1`1, append(il1, cons(u!1, il2)),
                              nth(cons(i!1`2, nl2),
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)
                                   - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictpremid_middle.2.6 :  

[-1]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   cons?[Identity](il2!1)
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1: {x: list[Identity] | length(x) = i!1`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              (signal(running(i!1`1, append(il1, cons(u!1, il2)),
                              nth(cons(i!1`2, nl2),
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)
                                   - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (delete -1 -2 -3 -4 -6 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.2.6 :  

[-1]  i!1`1 < P!1 - 1
  |-------
[1]   cons?[Identity](il2!1)

Rerunning step: (nonemptylist "il2!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictpremid_middle.2.6.


This completes the proof of restrictpremid_middle.2.

restrictpremid_middle.3 :  

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
{1}   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
{2}   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1: {x: list[Identity] | length(x) = i!1`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (signal(running(i!1`1, append(il1, cons(u!1, il2)),
                          nth(nl1,
                              floor(1 - 2 * ((mid - 1) / (p - 2))
                                    +
                                    ((mid - 1) / (p - 2)) * P!1))))
            >>
            (trans(u!1, car(il2),
                   E(public(car(il2)),
                     conc(nlist(append(nl1, (: i!1`2 :))),
                          ilist(append(il1, cons(u!1, cdr(il2)))))))
              >>
              (rec(u!1, nth(il1, i!1`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(il1, il2)),
                          nlist(cons(i!1`2, nl2)))))
                >>
                ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
{3}   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (choice3)
Applying choice rule,
this yields  5 subgoals: 
restrictpremid_middle.3.1 :  

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
{2}   (rec(u!1, nth(i!2`3, i!1`1 - 1),
           E(public(u!1), conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
        >>
        (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                        nth(i!2`1,
                            floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                   ((mid - 1) / (p - 2)) * P!1))))
          >>
          (trans(u!1, car(i!2`4),
                 E(public(car(i!2`4)),
                   conc(nlist(append(i!2`1, (: i!1`2 :))),
                        ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
            >>
            (rec(u!1, nth(i!2`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i!2`3, i!2`4)),
                        nlist(cons(i!1`2, i!2`2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4))
                >> Stop[event])))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictpremid_middle.3.1 :  

{-1}  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
{-2}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-3}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   ((signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                       nth(i!2`1,
                           floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                  ((mid - 1) / (p - 2)) * P!1))))
         >>
         (trans(u!1, car(i!2`4),
                E(public(car(i!2`4)),
                  conc(nlist(append(i!2`1, (: i!1`2 :))),
                       ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
           >>
           (rec(u!1, nth(i!2`3, i!1`1 - 1),
                E(public(u!1),
                  conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2)))))
             >>
             ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
               Stop[event]))))
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
{2}   R_premid(v!1)
              (rec(u!1, nth(i!2`3, i!1`1 - 1),
                   E(public(u!1),
                     conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))))
{3}   rec(u!1, nth(i!2`3, i!1`1 - 1),
          E(public(u!1), conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
       >>
       ((signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                        nth(i!2`1,
                            floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                   ((mid - 1) / (p - 2)) * P!1))))
          >>
          (trans(u!1, car(i!2`4),
                 E(public(car(i!2`4)),
                   conc(nlist(append(i!2`1, (: i!1`2 :))),
                        ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
            >>
            (rec(u!1, nth(i!2`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i!2`3, i!2`4)),
                        nlist(cons(i!1`2, i!2`2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4))
                >> Stop[event]))))
         # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[5]   i!1`2 = n_mid
[6]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   ((signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                       nth(i!2`1,
                           floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                  ((mid - 1) / (p - 2)) * P!1))))
         >>
         (trans(u!1, car(i!2`4),
                E(public(car(i!2`4)),
                  conc(nlist(append(i!2`1, (: i!1`2 :))),
                       ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
           >>
           (rec(u!1, nth(i!2`3, i!1`1 - 1),
                E(public(u!1),
                  conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2)))))
             >>
             ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
               Stop[event]))))
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictpremid_middle.3.1.1 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   rho_premid(v!1)
                (running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                         nth(i!2`1,
                             floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                    ((mid - 1) / (p - 2)) * P!1))))
{2}   R_premid(v!1)
              (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                              nth(i!2`1,
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)))))
{3}   signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                     nth(i!2`1,
                         floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                ((mid - 1) / (p - 2)) * P!1))))
       >>
       ((trans(u!1, car(i!2`4),
               E(public(car(i!2`4)),
                 conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
          >>
          (rec(u!1, nth(i!2`3, i!1`1 - 1),
               E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
            >>
            ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
              Stop[event])))
         # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[5]   i!1`2 = n_mid
[6]   P!1 = 2

Rerunning step: (delete - 2 3 4 5 6)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.1 :  

  |-------
[1]   rho_premid(v!1)
                (running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                         nth(i!2`1,
                             floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                    ((mid - 1) / (p - 2)) * P!1))))

Rerunning step: (expand "rho_premid")
Expanding the definition of rho_premid,
this simplifies to: 
restrictpremid_middle.3.1.1 :  

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictpremid_middle.3.1.1.

restrictpremid_middle.3.1.2 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   ((trans(u!1, car(i!2`4),
              E(public(car(i!2`4)),
                conc(nlist(append(i!2`1, (: i!1`2 :))),
                     ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
         >>
         (rec(u!1, nth(i!2`3, i!1`1 - 1),
              E(public(u!1),
                conc(ilist(append(i!2`3, i!2`4)),
                     nlist(cons(i!1`2, i!2`2)))))
           >>
           ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
             Stop[event])))
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
{2}   R_premid(v!1)
              (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                              nth(i!2`1,
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)))))
{3}   signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                     nth(i!2`1,
                         floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                ((mid - 1) / (p - 2)) * P!1))))
       >>
       ((trans(u!1, car(i!2`4),
               E(public(car(i!2`4)),
                 conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
          >>
          (rec(u!1, nth(i!2`3, i!1`1 - 1),
               E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
            >>
            ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
              Stop[event])))
         # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[5]   i!1`2 = n_mid
[6]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   ((trans(u!1, car(i!2`4),
              E(public(car(i!2`4)),
                conc(nlist(append(i!2`1, (: i!1`2 :))),
                     ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
         >>
         (rec(u!1, nth(i!2`3, i!1`1 - 1),
              E(public(u!1),
                conc(ilist(append(i!2`3, i!2`4)),
                     nlist(cons(i!1`2, i!2`2)))))
           >>
           ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
             Stop[event])))
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictpremid_middle.3.1.2.1 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   rho_premid(v!1)
                (E(public(car(i!2`4)),
                   conc(nlist(append(i!2`1, (: i!1`2 :))),
                        ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
{2}   R_premid(v!1)
              (trans(u!1, car(i!2`4),
                     E(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))))
{3}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(nlist(append(i!2`1, (: i!1`2 :))),
                   ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
       >>
       ((rec(u!1, nth(i!2`3, i!1`1 - 1),
             E(public(u!1),
               conc(ilist(append(i!2`3, i!2`4)),
                    nlist(cons(i!1`2, i!2`2)))))
          >>
          ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
            Stop[event]))
         # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[5]   i!1`2 = n_mid
[6]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (E(public(car(i!2`4)),
                   conc(nlist(append(i!2`1, (: i!1`2 :))),
                        ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (expand "E")
Expanding the definition of E,
this simplifies to: 
restrictpremid_middle.3.1.2.1 :  

{-1}  rho_premid(v!1)
                (code(public(u!1),
                      conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   rho_premid(v!1)
                (code(public(car(i!2`4)),
                      conc(nlist(append(i!2`1, (: i!1`2 :))),
                           ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (comment "consider the three cases which could make -1 true")
Adding comment: consider the three cases which could make -1 true
this simplifies to: 
restrictpremid_middle.3.1.2.1 : 
;;; consider the three cases which could make -1 true

[-1]  rho_premid(v!1)
                (code(public(u!1),
                      conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`4)),
                      conc(nlist(append(i!2`1, (: i!1`2 :))),
                           ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (expand "rho_premid" -1)
Expanding the definition of rho_premid,
this simplifies to: 
restrictpremid_middle.3.1.2.1 : 
;;; consider the three cases which could make -1 true

{-1}  rho_premid(v!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))) OR
       (EXISTS (i: {x: nat | mid < x AND x <= p}):
          public(u!1) = public(hu(rem(p)(i))) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                   nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
             conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
              conc(nlist(append(nl1, cons(n_mid, nl2))),
                   ilist(remove(hu_list, rem(p)(i)))))
        OR
        EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
          public(u!1) = public(hu(i)) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                   nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
             conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
              conc(ilist(remove(hu_list, i)),
                   nlist(append(nl1, cons(n_mid, nl2))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`4)),
                      conc(nlist(append(i!2`1, (: i!1`2 :))),
                           ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (split)
Splitting conjunctions,
this yields  3 subgoals: 
restrictpremid_middle.3.1.2.1.1 : 
;;; consider the three cases which could make -1 true

{-1}  rho_premid(v!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`4)),
                      conc(nlist(append(i!2`1, (: i!1`2 :))),
                           ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (comment "n_mid is not contained in any nonce list")
Adding comment: n_mid is not contained in any nonce list
this simplifies to: 
restrictpremid_middle.3.1.2.1.1 : 
;;; n_mid is not contained in any nonce list

[-1]  rho_premid(v!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`4)),
                      conc(nlist(append(i!2`1, (: i!1`2 :))),
                           ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (expand "rho_premid" 1)
Expanding the definition of rho_premid,
this simplifies to: 
restrictpremid_middle.3.1.2.1.1 : 
;;; n_mid is not contained in any nonce list

[-1]  rho_premid(v!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   rho_premid(v!1)
                (conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))
       OR
       (EXISTS (i: {x: nat | mid < x AND x <= p}):
          public(car(i!2`4)) = public(hu(rem(p)(i))) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                   nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
             conc(nlist(append(i!2`1, (: i!1`2 :))),
                  ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
              =
              conc(nlist(append(nl1, cons(n_mid, nl2))),
                   ilist(remove(hu_list, rem(p)(i)))))
        OR
        EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
          public(car(i!2`4)) = public(hu(i)) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                   nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
             conc(nlist(append(i!2`1, (: i!1`2 :))),
                  ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
              =
              conc(ilist(remove(hu_list, i)),
                   nlist(append(nl1, cons(n_mid, nl2))))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictpremid_middle.3.1.2.1.1 : 
;;; n_mid is not contained in any nonce list

[-1]  rho_premid(v!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   rho_premid(v!1)
                (conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))
{2}   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
{3}   EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(car(i!2`4)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))
[4]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[5]   i!1`2 = n_mid
[6]   P!1 = 2

Rerunning step: (delete -2 -3 -4 -5 -6 2 3 4 6)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1.1 : 
;;; n_mid is not contained in any nonce list

[-1]  rho_premid(v!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
  |-------
[1]   rho_premid(v!1)
                (conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))
[2]   i!1`2 = n_mid

Rerunning step: (lemma "listprops[Nonce].elt_append3"
                 ("l1" "i!2`1" "l2" "(:i!1`2:)" "t" "n_mid"))
Applying listprops[Nonce].elt_append3 where 
  l1 gets i!2`1,
  l2 gets (: i!1`2 :),
  t gets n_mid,
this simplifies to: 
restrictpremid_middle.3.1.2.1.1 : 
;;; n_mid is not contained in any nonce list

{-1}  elt(append(i!2`1, (: i!1`2 :)), n_mid) IMPLIES
       elt(i!2`1, n_mid) OR elt((: i!1`2 :), n_mid)
[-2]  rho_premid(v!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
  |-------
[1]   rho_premid(v!1)
                (conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))
[2]   i!1`2 = n_mid

Rerunning step: (lemma "listprops[Nonce].elt_singleton"
                 ("t1" "i!1`2" "t2" "n_mid"))
Applying listprops[Nonce].elt_singleton where 
  t1 gets i!1`2,
  t2 gets n_mid,
this simplifies to: 
restrictpremid_middle.3.1.2.1.1 : 
;;; n_mid is not contained in any nonce list

{-1}  elt((: i!1`2 :), n_mid) IFF i!1`2 = n_mid
[-2]  elt(append(i!2`1, (: i!1`2 :)), n_mid) IMPLIES
       elt(i!2`1, n_mid) OR elt((: i!1`2 :), n_mid)
[-3]  rho_premid(v!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
  |-------
[1]   rho_premid(v!1)
                (conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))
[2]   i!1`2 = n_mid

Rerunning step: (grind :exclude "elt")
rho_premid rewrites rho_premid(v!1)(nlist(i!2`1))
  to FALSE
rho_premid rewrites rho_premid(v!1)(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_premid rewrites 
  rho_premid(v!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
  to FALSE
rho_premid rewrites rho_premid(v!1)(nlist(i!2`1))
  to NOT elt(i!2`1, n_mid)
rho_premid rewrites rho_premid(v!1)(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_premid rewrites 
  rho_premid(v!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
  to NOT elt(i!2`1, n_mid)
rho_premid rewrites rho_premid(v!1)(nlist(append(i!2`1, (: i!1`2 :))))
  to TRUE
rho_premid rewrites 
  rho_premid(v!1)(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
  to TRUE
rho_premid rewrites 
  rho_premid(v!1)
            (conc(nlist(append(i!2`1, (: i!1`2 :))),
                  ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpremid_middle.3.1.2.1.1.

restrictpremid_middle.3.1.2.1.2 : 
;;; consider the three cases which could make -1 true

{-1}  EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(u!1) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`4)),
                      conc(nlist(append(i!2`1, (: i!1`2 :))),
                           ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2 : 
;;; consider the three cases which could make -1 true

{-1}  public(u!1) = public(hu(rem(p)(i!3)))
{-2}  conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, rem(p)(i!3))))
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`4)),
                      conc(nlist(append(i!2`1, (: i!1`2 :))),
                           ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (expand "rho_premid" 1)
Expanding the definition of rho_premid,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2 : 
;;; consider the three cases which could make -1 true

[-1]  public(u!1) = public(hu(rem(p)(i!3)))
[-2]  conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, rem(p)(i!3))))
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
{1}   rho_premid(v!1)
                (conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))
       OR
       (EXISTS (i: {x: nat | mid < x AND x <= p}):
          public(car(i!2`4)) = public(hu(rem(p)(i))) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                   nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
             conc(nlist(append(i!2`1, (: i!1`2 :))),
                  ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
              =
              conc(nlist(append(nl1, cons(n_mid, nl2))),
                   ilist(remove(hu_list, rem(p)(i)))))
        OR
        EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
          public(car(i!2`4)) = public(hu(i)) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                   nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
             conc(nlist(append(i!2`1, (: i!1`2 :))),
                  ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
              =
              conc(ilist(remove(hu_list, i)),
                   nlist(append(nl1, cons(n_mid, nl2))))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2 : 
;;; consider the three cases which could make -1 true

[-1]  public(u!1) = public(hu(rem(p)(i!3)))
[-2]  conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, rem(p)(i!3))))
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
{1}   rho_premid(v!1)
                (conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))
{2}   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
{3}   EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(car(i!2`4)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))
[4]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[5]   i!1`2 = n_mid
[6]   P!1 = 2

Rerunning step: (typepred "i!2`1" "i!2`3" "i!2`4" "hu_list")
Adding type constraints for  i!2`1, i!2`3, i!2`4, hu_list,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2 : 
;;; consider the three cases which could make -1 true

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`1)
{-2}  length(i!2`1) = i!1`1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`3)
{-4}  length(i!2`3) = i!1`1
{-5}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`4)
{-6}  length(i!2`4) = P!1 - 1 - i!1`1
{-7}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-8}  (length(hu_list) = p)
{-9}  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] public(u!1) = public(hu(rem(p)(i!3)))
[-11] conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, rem(p)(i!3))))
[-12] floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-13] floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-14] 0 < i!1`1
[-15] i!1`1 < P!1 - 1
[-16] 2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))
[2]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[3]   EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(car(i!2`4)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))
[4]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[5]   i!1`2 = n_mid
[6]   P!1 = 2

Rerunning step: (delete -1 -3 -5 -7 -12 -13 -14 1 3 5 6)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2 : 
;;; consider the three cases which could make -1 true

[-1]  length(i!2`1) = i!1`1
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  public(u!1) = public(hu(rem(p)(i!3)))
[-7]  conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, rem(p)(i!3))))
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
[1]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (decompose-equality -6)
Applying decompose-equality,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2 : 
;;; consider the three cases which could make -1 true

{-1}  u!1 = hu(rem(p)(i!3))
[-2]  length(i!2`1) = i!1`1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, rem(p)(i!3))))
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
[1]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (decompose-equality -7)
Applying decompose-equality,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2 : 
;;; consider the three cases which could make -1 true

{-1}  nlist(i!2`1) = nlist(append(nl1!1, cons(n_mid, nl2!1)))
{-2}  ilist(append(i!2`3, i!2`4)) = ilist(remove(hu_list, rem(p)(i!3)))
[-3]  u!1 = hu(rem(p)(i!3))
[-4]  length(i!2`1) = i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1`1 < P!1 - 1
[-10] 2 <= P!1
  |-------
[1]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2 : 
;;; consider the three cases which could make -1 true

{-1}  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-2]  ilist(append(i!2`3, i!2`4)) = ilist(remove(hu_list, rem(p)(i!3)))
[-3]  u!1 = hu(rem(p)(i!3))
[-4]  length(i!2`1) = i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1`1 < P!1 - 1
[-10] 2 <= P!1
  |-------
[1]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2 : 
;;; consider the three cases which could make -1 true

{-1}  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-2]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-3]  u!1 = hu(rem(p)(i!3))
[-4]  length(i!2`1) = i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1`1 < P!1 - 1
[-10] 2 <= P!1
  |-------
[1]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (case "P!1=p" "i!3=i!1`1" "rem(p)(i!1`1)=i!1`1")
Case splitting on 
   P!1 = p, 
   i!3 = i!1`1, 
   rem(p)(i!1`1) = i!1`1, 
this yields  4 subgoals: 
restrictpremid_middle.3.1.2.1.2.1 : 
;;; consider the three cases which could make -1 true

{-1}  rem(p)(i!1`1) = i!1`1
{-2}  i!3 = i!1`1
{-3}  P!1 = p
[-4]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-5]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-6]  u!1 = hu(rem(p)(i!3))
[-7]  length(i!2`1) = i!1`1
[-8]  length(i!2`3) = i!1`1
[-9]  length(i!2`4) = P!1 - 1 - i!1`1
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
[1]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (replace* -2 -3)
Repeatedly applying the replace rule,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1 : 
;;; consider the three cases which could make -1 true

[-1]  rem(p)(i!1`1) = i!1`1
[-2]  i!3 = i!1`1
[-3]  P!1 = p
{-4}  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!1`1))
[-5]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
{-6}  u!1 = hu(rem(p)(i!1`1))
[-7]  length(i!2`1) = i!1`1
[-8]  length(i!2`3) = i!1`1
{-9}  length(i!2`4) = p - 1 - i!1`1
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
{-12} i!1`1 < p - 1
{-13} 2 <= p
  |-------
[1]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
{2}   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (replace* -1)
Repeatedly applying the replace rule,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1 : 
;;; consider the three cases which could make -1 true

[-1]  rem(p)(i!1`1) = i!1`1
[-2]  i!3 = i!1`1
[-3]  P!1 = p
{-4}  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-5]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
{-6}  u!1 = hu(i!1`1)
[-7]  length(i!2`1) = i!1`1
[-8]  length(i!2`3) = i!1`1
[-9]  length(i!2`4) = p - 1 - i!1`1
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] i!1`1 < p - 1
[-13] 2 <= p
  |-------
[1]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (comment "the next message is sent to i=i!1`1+1")
Adding comment: the next message is sent to i=i!1`1+1
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  rem(p)(i!1`1) = i!1`1
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-5]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-6]  u!1 = hu(i!1`1)
[-7]  length(i!2`1) = i!1`1
[-8]  length(i!2`3) = i!1`1
[-9]  length(i!2`4) = p - 1 - i!1`1
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] i!1`1 < p - 1
[-13] 2 <= p
  |-------
[1]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (inst 1 "i!1`1+1")
Instantiating the top quantifier in 1 with the terms: 
 i!1`1+1,
this yields  2 subgoals: 
restrictpremid_middle.3.1.2.1.2.1.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  rem(p)(i!1`1) = i!1`1
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-5]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-6]  u!1 = hu(i!1`1)
[-7]  length(i!2`1) = i!1`1
[-8]  length(i!2`3) = i!1`1
[-9]  length(i!2`4) = p - 1 - i!1`1
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] i!1`1 < p - 1
[-13] 2 <= p
  |-------
{1}   public(car(i!2`4)) = public(hu(rem(p)(i!1`1 + 1))) AND
       EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
               nl2: {x: list[Nonce] | length(x) = i!1`1 - mid}):
         conc(nlist(append(i!2`1, (: i!1`2 :))),
              ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
          =
          conc(nlist(append(nl1, cons(n_mid, nl2))),
               ilist(remove(hu_list, rem(p)(i!1`1 + 1))))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (case "rem(p)(1+i!1`1)=i!1`1+1")
Case splitting on 
   rem(p)(1 + i!1`1) = i!1`1 + 1, 
this yields  2 subgoals: 
restrictpremid_middle.3.1.2.1.2.1.1.1 : 
;;; the next message is sent to i=i!1`1+1

{-1}  rem(p)(1 + i!1`1) = i!1`1 + 1
[-2]  rem(p)(i!1`1) = i!1`1
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-6]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-7]  u!1 = hu(i!1`1)
[-8]  length(i!2`1) = i!1`1
[-9]  length(i!2`3) = i!1`1
[-10] length(i!2`4) = p - 1 - i!1`1
[-11] (length(hu_list) = p)
[-12] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-13] i!1`1 < p - 1
[-14] 2 <= p
  |-------
[1]   public(car(i!2`4)) = public(hu(rem(p)(i!1`1 + 1))) AND
       EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
               nl2: {x: list[Nonce] | length(x) = i!1`1 - mid}):
         conc(nlist(append(i!2`1, (: i!1`2 :))),
              ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
          =
          conc(nlist(append(nl1, cons(n_mid, nl2))),
               ilist(remove(hu_list, rem(p)(i!1`1 + 1))))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
restrictpremid_middle.3.1.2.1.2.1.1.1.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  rem(p)(1 + i!1`1) = i!1`1 + 1
[-2]  rem(p)(i!1`1) = i!1`1
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-6]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-7]  u!1 = hu(i!1`1)
[-8]  length(i!2`1) = i!1`1
[-9]  length(i!2`3) = i!1`1
[-10] length(i!2`4) = p - 1 - i!1`1
[-11] (length(hu_list) = p)
[-12] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-13] i!1`1 < p - 1
[-14] 2 <= p
  |-------
{1}   public(car(i!2`4)) = public(hu(rem(p)(i!1`1 + 1)))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.1 : 
;;; the next message is sent to i=i!1`1+1

{-1}  rem(p)(1 + i!1`1) = 1 + i!1`1
[-2]  rem(p)(i!1`1) = i!1`1
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-6]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-7]  u!1 = hu(i!1`1)
[-8]  length(i!2`1) = i!1`1
[-9]  length(i!2`3) = i!1`1
{-10} length(i!2`4) = -1 - i!1`1 + p
[-11] (length(hu_list) = p)
[-12] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-13] i!1`1 < p - 1
[-14] 2 <= p
  |-------
{1}   car(i!2`4) = hu(rem(p)(1 + i!1`1))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (lemma "listprops[Identity].equality_nth"
                 ("l1" "append(i!2`3,i!2`4)" "l2"
                  "remove(hu_list,i!1`1)"))
Applying listprops[Identity].equality_nth where 
  l1 gets append(i!2`3, i!2`4),
  l2 gets remove(hu_list, i!1`1),
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.1 : 
;;; the next message is sent to i=i!1`1+1

{-1}  append(i!2`3, i!2`4) = remove(hu_list, i!1`1) IMPLIES
       FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
         nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-2]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-3]  rem(p)(i!1`1) = i!1`1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-7]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-8]  u!1 = hu(i!1`1)
[-9]  length(i!2`1) = i!1`1
[-10] length(i!2`3) = i!1`1
[-11] length(i!2`4) = -1 - i!1`1 + p
[-12] (length(hu_list) = p)
[-13] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
[1]   car(i!2`4) = hu(rem(p)(1 + i!1`1))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.1 : 
;;; the next message is sent to i=i!1`1+1

{-1}  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-2]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-3]  rem(p)(i!1`1) = i!1`1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-7]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-8]  u!1 = hu(i!1`1)
[-9]  length(i!2`1) = i!1`1
[-10] length(i!2`3) = i!1`1
[-11] length(i!2`4) = -1 - i!1`1 + p
[-12] (length(hu_list) = p)
[-13] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
[1]   car(i!2`4) = hu(rem(p)(1 + i!1`1))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (inst -1 "i!1`1")
Instantiating the top quantifier in -1 with the terms: 
 i!1`1,
this yields  2 subgoals: 
restrictpremid_middle.3.1.2.1.2.1.1.1.1.1 : 
;;; the next message is sent to i=i!1`1+1

{-1}  nth(append(i!2`3, i!2`4), i!1`1) = nth(remove(hu_list, i!1`1), i!1`1)
[-2]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-3]  rem(p)(i!1`1) = i!1`1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-7]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-8]  u!1 = hu(i!1`1)
[-9]  length(i!2`1) = i!1`1
[-10] length(i!2`3) = i!1`1
[-11] length(i!2`4) = -1 - i!1`1 + p
[-12] (length(hu_list) = p)
[-13] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
[1]   car(i!2`4) = hu(rem(p)(1 + i!1`1))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.1.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  nth(append(i!2`3, i!2`4), i!1`1) = nth(remove(hu_list, i!1`1), i!1`1)
[-2]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-3]  rem(p)(i!1`1) = i!1`1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-7]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-8]  u!1 = hu(i!1`1)
[-9]  length(i!2`1) = i!1`1
[-10] length(i!2`3) = i!1`1
[-11] length(i!2`4) = -1 - i!1`1 + p
[-12] (length(hu_list) = p)
[-13] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
{1}   car(i!2`4) = hu(1 + i!1`1)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (rewrite "nth_append" -1)
Found matching substitution:
i: below[length(l1) + length(l2)] gets i!1`1,
l2: list[T] gets i!2`4,
l1: list[T] gets i!2`3,
Rewriting using nth_append, matching in -1,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.1.1 : 
;;; the next message is sent to i=i!1`1+1

{-1}  nth(i!2`4, i!1`1 - length[Identity](i!2`3)) =
       nth(remove(hu_list, i!1`1), i!1`1)
[-2]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-3]  rem(p)(i!1`1) = i!1`1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-7]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-8]  u!1 = hu(i!1`1)
[-9]  length(i!2`1) = i!1`1
[-10] length(i!2`3) = i!1`1
[-11] length(i!2`4) = -1 - i!1`1 + p
[-12] (length(hu_list) = p)
[-13] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (rewrite "nth_remove" -1)
Found matching substitution:
j: below[length(l) - 1] gets i!1`1,
i: below[length(l)] gets i!1`1,
l: list[T] gets hu_list,
Rewriting using nth_remove, matching in -1,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.1.1 : 
;;; the next message is sent to i=i!1`1+1

{-1}  nth(i!2`4, i!1`1 - length[Identity](i!2`3)) = nth(hu_list, 1 + i!1`1)
[-2]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-3]  rem(p)(i!1`1) = i!1`1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-7]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-8]  u!1 = hu(i!1`1)
[-9]  length(i!2`1) = i!1`1
[-10] length(i!2`3) = i!1`1
[-11] length(i!2`4) = -1 - i!1`1 + p
[-12] (length(hu_list) = p)
[-13] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (expand "nth" -1 1)
Expanding the definition of nth,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.1.1 : 
;;; the next message is sent to i=i!1`1+1

{-1}  car(i!2`4) = nth(hu_list, 1 + i!1`1)
[-2]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-3]  rem(p)(i!1`1) = i!1`1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-7]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-8]  u!1 = hu(i!1`1)
[-9]  length(i!2`1) = i!1`1
[-10] length(i!2`3) = i!1`1
[-11] length(i!2`4) = -1 - i!1`1 + p
[-12] (length(hu_list) = p)
[-13] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (inst -13 "i!1`1+1")
Instantiating the top quantifier in -13 with the terms: 
 i!1`1+1,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.1.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  car(i!2`4) = nth(hu_list, 1 + i!1`1)
[-2]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-3]  rem(p)(i!1`1) = i!1`1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-7]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-8]  u!1 = hu(i!1`1)
[-9]  length(i!2`1) = i!1`1
[-10] length(i!2`3) = i!1`1
[-11] length(i!2`4) = -1 - i!1`1 + p
[-12] (length(hu_list) = p)
{-13} nth(hu_list, i!1`1 + 1) = hu(i!1`1 + 1)
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (delete -2 -3 -4 -5 -6 -7 -8 -9 -10 -11 -12 -14 -15 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.1.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  car(i!2`4) = nth(hu_list, 1 + i!1`1)
[-2]  nth(hu_list, i!1`1 + 1) = hu(i!1`1 + 1)
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.3.1.2.1.2.1.1.1.1.1.

restrictpremid_middle.3.1.2.1.2.1.1.1.1.2 (TCC):   

[-1]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-2]  rem(p)(i!1`1) = i!1`1
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-6]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-7]  u!1 = hu(i!1`1)
[-8]  length(i!2`1) = i!1`1
[-9]  length(i!2`3) = i!1`1
[-10] length(i!2`4) = -1 - i!1`1 + p
[-11] (length(hu_list) = p)
[-12] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-13] i!1`1 < p - 1
[-14] 2 <= p
  |-------
{1}   i!1`1 < length[Identity](append[Identity](i!2`3, i!2`4))
[2]   car(i!2`4) = hu(rem(p)(1 + i!1`1))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets i!2`4,
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in 1,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.1.2 : 
;;; the next message is sent to i=i!1`1+1

[-1]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-2]  rem(p)(i!1`1) = i!1`1
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-6]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-7]  u!1 = hu(i!1`1)
[-8]  length(i!2`1) = i!1`1
[-9]  length(i!2`3) = i!1`1
[-10] length(i!2`4) = -1 - i!1`1 + p
[-11] (length(hu_list) = p)
[-12] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-13] i!1`1 < p - 1
[-14] 2 <= p
  |-------
{1}   i!1`1 < length(i!2`3) + length(i!2`4)
[2]   car(i!2`4) = hu(rem(p)(1 + i!1`1))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (delete -1 -2 -3 -4 -5 -6 -7 -8 -12 -13 -14 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.1.2 : 
;;; the next message is sent to i=i!1`1+1

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  (length(hu_list) = p)
  |-------
[1]   i!1`1 < length(i!2`3) + length(i!2`4)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.3.1.2.1.2.1.1.1.1.2.


This completes the proof of restrictpremid_middle.3.1.2.1.2.1.1.1.1.

restrictpremid_middle.3.1.2.1.2.1.1.1.2 : 
;;; the next message is sent to i=i!1`1+1

[-1]  rem(p)(1 + i!1`1) = i!1`1 + 1
[-2]  rem(p)(i!1`1) = i!1`1
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-6]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-7]  u!1 = hu(i!1`1)
[-8]  length(i!2`1) = i!1`1
[-9]  length(i!2`3) = i!1`1
[-10] length(i!2`4) = p - 1 - i!1`1
[-11] (length(hu_list) = p)
[-12] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-13] i!1`1 < p - 1
[-14] 2 <= p
  |-------
{1}   EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
              nl2: {x: list[Nonce] | length(x) = i!1`1 - mid}):
        conc(nlist(append(i!2`1, (: i!1`2 :))),
             ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
         =
         conc(nlist(append(nl1, cons(n_mid, nl2))),
              ilist(remove(hu_list, rem(p)(i!1`1 + 1))))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2 : 
;;; the next message is sent to i=i!1`1+1

[-1]  rem(p)(1 + i!1`1) = i!1`1 + 1
[-2]  rem(p)(i!1`1) = i!1`1
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-6]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-7]  u!1 = hu(i!1`1)
[-8]  length(i!2`1) = i!1`1
[-9]  length(i!2`3) = i!1`1
[-10] length(i!2`4) = p - 1 - i!1`1
[-11] (length(hu_list) = p)
[-12] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-13] i!1`1 < p - 1
[-14] 2 <= p
  |-------
[1]   EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
              nl2: {x: list[Nonce] | length(x) = i!1`1 - mid}):
        conc(nlist(append(i!2`1, (: i!1`2 :))),
             ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
         =
         conc(nlist(append(nl1, cons(n_mid, nl2))),
              ilist(remove(hu_list, rem(p)(i!1`1 + 1))))

Rerunning step: (typepred "nl1!1" "nl2!1")
Adding type constraints for  nl1!1, nl2!1,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2 : 
;;; the next message is sent to i=i!1`1+1

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl1!1)
{-2}  length(nl1!1) = mid
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
{-4}  length(nl2!1) = -1 - mid + i!3
[-5]  rem(p)(1 + i!1`1) = i!1`1 + 1
[-6]  rem(p)(i!1`1) = i!1`1
[-7]  i!3 = i!1`1
[-8]  P!1 = p
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(i!1`1)
[-12] length(i!2`1) = i!1`1
[-13] length(i!2`3) = i!1`1
[-14] length(i!2`4) = p - 1 - i!1`1
[-15] (length(hu_list) = p)
[-16] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-17] i!1`1 < p - 1
[-18] 2 <= p
  |-------
[1]   EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
              nl2: {x: list[Nonce] | length(x) = i!1`1 - mid}):
        conc(nlist(append(i!2`1, (: i!1`2 :))),
             ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
         =
         conc(nlist(append(nl1, cons(n_mid, nl2))),
              ilist(remove(hu_list, rem(p)(i!1`1 + 1))))

Rerunning step: (delete -1 -3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2 : 
;;; the next message is sent to i=i!1`1+1

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  rem(p)(1 + i!1`1) = i!1`1 + 1
[-4]  rem(p)(i!1`1) = i!1`1
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-9]  u!1 = hu(i!1`1)
[-10] length(i!2`1) = i!1`1
[-11] length(i!2`3) = i!1`1
[-12] length(i!2`4) = p - 1 - i!1`1
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
[1]   EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
              nl2: {x: list[Nonce] | length(x) = i!1`1 - mid}):
        conc(nlist(append(i!2`1, (: i!1`2 :))),
             ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
         =
         conc(nlist(append(nl1, cons(n_mid, nl2))),
              ilist(remove(hu_list, rem(p)(i!1`1 + 1))))

Rerunning step: (inst 1 "nl1!1" "append(nl2!1,(:i!1`2:))")
Instantiating the top quantifier in 1 with the terms: 
 nl1!1, append(nl2!1,(:i!1`2:)),
this yields  2 subgoals: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  rem(p)(1 + i!1`1) = i!1`1 + 1
[-4]  rem(p)(i!1`1) = i!1`1
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-9]  u!1 = hu(i!1`1)
[-10] length(i!2`1) = i!1`1
[-11] length(i!2`3) = i!1`1
[-12] length(i!2`4) = p - 1 - i!1`1
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
{1}   conc(nlist(append(i!2`1, (: i!1`2 :))),
           ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
       =
       conc(nlist(append(nl1!1, cons(n_mid, append(nl2!1, (: i!1`2 :))))),
            ilist(remove(hu_list, rem(p)(i!1`1 + 1))))

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this yields  2 subgoals: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
{-3}  rem(p)(1 + i!1`1) = 1 + i!1`1
[-4]  rem(p)(i!1`1) = i!1`1
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-9]  u!1 = hu(i!1`1)
[-10] length(i!2`1) = i!1`1
[-11] length(i!2`3) = i!1`1
{-12} length(i!2`4) = -1 - i!1`1 + p
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
{1}   nlist(append(i!2`1, (: i!1`2 :))) =
       nlist(append(nl1!1, cons(n_mid, append(nl2!1, (: i!1`2 :)))))

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-4]  rem(p)(i!1`1) = i!1`1
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-9]  u!1 = hu(i!1`1)
[-10] length(i!2`1) = i!1`1
[-11] length(i!2`3) = i!1`1
[-12] length(i!2`4) = -1 - i!1`1 + p
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
{1}   append(i!2`1, (: i!1`2 :)) =
       append(nl1!1, cons(n_mid, append(nl2!1, (: i!1`2 :))))

Rerunning step: (replace -8 1)
Replacing using formula -8,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-4]  rem(p)(i!1`1) = i!1`1
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-9]  u!1 = hu(i!1`1)
[-10] length(i!2`1) = i!1`1
[-11] length(i!2`3) = i!1`1
[-12] length(i!2`4) = -1 - i!1`1 + p
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
{1}   append(append(nl1!1, cons(n_mid, nl2!1)), (: i!1`2 :)) =
       append(nl1!1, cons(n_mid, append(nl2!1, (: i!1`2 :))))

Rerunning step: (rewrite "append_assoc" 1)
Found matching substitution:
l3: list[T] gets (: i!1`2 :),
l2: list[T] gets cons(n_mid, nl2!1),
l1: list[T] gets nl1!1,
Rewriting using append_assoc, matching in 1,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-4]  rem(p)(i!1`1) = i!1`1
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-9]  u!1 = hu(i!1`1)
[-10] length(i!2`1) = i!1`1
[-11] length(i!2`3) = i!1`1
[-12] length(i!2`4) = -1 - i!1`1 + p
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
{1}   append(nl1!1, append(cons(n_mid, nl2!1), (: i!1`2 :))) =
       append(nl1!1, cons(n_mid, append(nl2!1, (: i!1`2 :))))

Rerunning step: (expand "append" 1 2)
Expanding the definition of append,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-4]  rem(p)(i!1`1) = i!1`1
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-9]  u!1 = hu(i!1`1)
[-10] length(i!2`1) = i!1`1
[-11] length(i!2`3) = i!1`1
[-12] length(i!2`4) = -1 - i!1`1 + p
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.1.

restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2 : 
;;; the next message is sent to i=i!1`1+1

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
{-3}  rem(p)(1 + i!1`1) = 1 + i!1`1
[-4]  rem(p)(i!1`1) = i!1`1
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-9]  u!1 = hu(i!1`1)
[-10] length(i!2`1) = i!1`1
[-11] length(i!2`3) = i!1`1
{-12} length(i!2`4) = -1 - i!1`1 + p
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
{1}   ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))) =
       ilist(remove(hu_list, rem(p)(1 + i!1`1)))

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2 : 
;;; the next message is sent to i=i!1`1+1

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-4]  rem(p)(i!1`1) = i!1`1
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-9]  u!1 = hu(i!1`1)
[-10] length(i!2`1) = i!1`1
[-11] length(i!2`3) = i!1`1
[-12] length(i!2`4) = -1 - i!1`1 + p
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
{1}   append(i!2`3, cons(u!1, cdr(i!2`4))) =
       remove(hu_list, rem(p)(1 + i!1`1))

Rerunning step: (rewrite "length_nth_equality[Identity]" 1)
Found matching substitution:
l2: list[Identity] gets remove(hu_list, rem(p)(1 + i!1`1)),
l1: list[Identity] gets append(i!2`3, cons(u!1, cdr(i!2`4))),
Rewriting using length_nth_equality[Identity], matching in 1,
this yields  2 subgoals: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-4]  rem(p)(i!1`1) = i!1`1
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-9]  u!1 = hu(i!1`1)
[-10] length(i!2`1) = i!1`1
[-11] length(i!2`3) = i!1`1
[-12] length(i!2`4) = -1 - i!1`1 + p
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
{1}   length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4)))) =
       length[Identity](remove(hu_list, rem(p)(1 + i!1`1)))
[2]   append(i!2`3, cons(u!1, cdr(i!2`4))) =
       remove(hu_list, rem(p)(1 + i!1`1))

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-4]  rem(p)(i!1`1) = i!1`1
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-9]  u!1 = hu(i!1`1)
[-10] length(i!2`1) = i!1`1
[-11] length(i!2`3) = i!1`1
[-12] length(i!2`4) = -1 - i!1`1 + p
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
[1]   length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4)))) =
       length[Identity](remove(hu_list, rem(p)(1 + i!1`1)))

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets cons(u!1, cdr(i!2`4)),
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in 1,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-4]  rem(p)(i!1`1) = i!1`1
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-9]  u!1 = hu(i!1`1)
[-10] length(i!2`1) = i!1`1
[-11] length(i!2`3) = i!1`1
[-12] length(i!2`4) = -1 - i!1`1 + p
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
{1}   length(cons(u!1, cdr(i!2`4))) + length(i!2`3) =
       length[Identity](remove(hu_list, rem(p)(1 + i!1`1)))

Rerunning step: (rewrite "length_remove" 1 :dir rl)
Found matching substitution:
i: below[length(c)] gets rem(p)(1 + i!1`1),
c: (cons?[T]) gets hu_list,
Rewriting using length_remove, matching in 1,
this yields  2 subgoals: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.1.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-4]  rem(p)(i!1`1) = i!1`1
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-9]  u!1 = hu(i!1`1)
[-10] length(i!2`1) = i!1`1
[-11] length(i!2`3) = i!1`1
[-12] length(i!2`4) = -1 - i!1`1 + p
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
{1}   length(cons(u!1, cdr(i!2`4))) + length(i!2`3) =
       length[Identity](hu_list) - 1

Rerunning step: (expand "length" 1 1)
Expanding the definition of length,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.1.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-4]  rem(p)(i!1`1) = i!1`1
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-9]  u!1 = hu(i!1`1)
[-10] length(i!2`1) = i!1`1
[-11] length(i!2`3) = i!1`1
[-12] length(i!2`4) = -1 - i!1`1 + p
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
{1}   1 + length[Nonce](cdr(i!2`4)) + length(i!2`3) =
       length[Identity](hu_list) - 1

Rerunning step: (rewrite "length_cdr" 1)
Found matching substitution:
cons_l: (cons?[T]) gets i!2`4,
Rewriting using length_cdr, matching in 1,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.1.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-4]  rem(p)(i!1`1) = i!1`1
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-9]  u!1 = hu(i!1`1)
[-10] length(i!2`1) = i!1`1
[-11] length(i!2`3) = i!1`1
[-12] length(i!2`4) = -1 - i!1`1 + p
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
{1}   1 + (length(i!2`4) - 1) + length(i!2`3) =
       length[Identity](hu_list) - 1

Rerunning step: (delete -1 -2 -3 -4 -5 -6 -7 -8 -9 -10 -14 -15 -16)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.1.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  (length(hu_list) = p)
  |-------
[1]   1 + (length(i!2`4) - 1) + length(i!2`3) =
       length[Identity](hu_list) - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.1.1.

restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.1.2 : 
;;; the next message is sent to i=i!1`1+1

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-4]  rem(p)(i!1`1) = i!1`1
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-9]  u!1 = hu(i!1`1)
[-10] length(i!2`1) = i!1`1
[-11] length(i!2`3) = i!1`1
[-12] length(i!2`4) = -1 - i!1`1 + p
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
{1}   cons?[Identity](hu_list)
[2]   length(cons(u!1, cdr(i!2`4))) + length(i!2`3) =
       length[Identity](remove(hu_list, rem(p)(1 + i!1`1)))

Rerunning step: (lemma "more_list_props[Identity].length_non_zero"
                 ("l" "hu_list"))
Applying more_list_props[Identity].length_non_zero where 
  l gets hu_list,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.1.2 : 
;;; the next message is sent to i=i!1`1+1

{-1}  length(hu_list) > 0 IFF cons?(hu_list)
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-5]  rem(p)(i!1`1) = i!1`1
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-10] u!1 = hu(i!1`1)
[-11] length(i!2`1) = i!1`1
[-12] length(i!2`3) = i!1`1
[-13] length(i!2`4) = -1 - i!1`1 + p
[-14] (length(hu_list) = p)
[-15] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-16] i!1`1 < p - 1
[-17] 2 <= p
  |-------
[1]   cons?[Identity](hu_list)
[2]   length(cons(u!1, cdr(i!2`4))) + length(i!2`3) =
       length[Identity](remove(hu_list, rem(p)(1 + i!1`1)))

Rerunning step: (delete -2 -3
                  -4 -5
                  -6 -7
                  -8 -9
                  -10 -11
                  -12 -13
                  -15 -17
                  2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.1.2 : 
;;; the next message is sent to i=i!1`1+1

[-1]  length(hu_list) > 0 IFF cons?(hu_list)
[-2]  (length(hu_list) = p)
[-3]  i!1`1 < p - 1
  |-------
[1]   cons?[Identity](hu_list)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.1.2.


This completes the proof of restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.1.

restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2 : 
;;; the next message is sent to i=i!1`1+1

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-4]  rem(p)(i!1`1) = i!1`1
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-9]  u!1 = hu(i!1`1)
[-10] length(i!2`1) = i!1`1
[-11] length(i!2`3) = i!1`1
[-12] length(i!2`4) = -1 - i!1`1 + p
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
{1}   FORALL (i:
                below[length[Identity]
                          (append(i!2`3, cons(u!1, cdr(i!2`4))))]):
        nth(append(i!2`3, cons(u!1, cdr(i!2`4))), i) =
         nth(remove(hu_list, rem(p)(1 + i!1`1)), i)
[2]   append(i!2`3, cons(u!1, cdr(i!2`4))) =
       remove(hu_list, rem(p)(1 + i!1`1))

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2 : 
;;; the next message is sent to i=i!1`1+1

{-1}  i!4 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-5]  rem(p)(i!1`1) = i!1`1
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-10] u!1 = hu(i!1`1)
[-11] length(i!2`1) = i!1`1
[-12] length(i!2`3) = i!1`1
[-13] length(i!2`4) = -1 - i!1`1 + p
[-14] (length(hu_list) = p)
[-15] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-16] i!1`1 < p - 1
[-17] 2 <= p
  |-------
{1}   nth(append(i!2`3, cons(u!1, cdr(i!2`4))), i!4) =
       nth(remove(hu_list, rem(p)(1 + i!1`1)), i!4)
[2]   append(i!2`3, cons(u!1, cdr(i!2`4))) =
       remove(hu_list, rem(p)(1 + i!1`1))

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2 : 
;;; the next message is sent to i=i!1`1+1

[-1]  i!4 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-5]  rem(p)(i!1`1) = i!1`1
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-10] u!1 = hu(i!1`1)
[-11] length(i!2`1) = i!1`1
[-12] length(i!2`3) = i!1`1
[-13] length(i!2`4) = -1 - i!1`1 + p
[-14] (length(hu_list) = p)
[-15] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-16] i!1`1 < p - 1
[-17] 2 <= p
  |-------
[1]   nth(append(i!2`3, cons(u!1, cdr(i!2`4))), i!4) =
       nth(remove(hu_list, rem(p)(1 + i!1`1)), i!4)

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets cons(u!1, cdr(i!2`4)),
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2 : 
;;; the next message is sent to i=i!1`1+1

{-1}  i!4 < length(cons(u!1, cdr(i!2`4))) + length(i!2`3)
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-5]  rem(p)(i!1`1) = i!1`1
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-10] u!1 = hu(i!1`1)
[-11] length(i!2`1) = i!1`1
[-12] length(i!2`3) = i!1`1
[-13] length(i!2`4) = -1 - i!1`1 + p
[-14] (length(hu_list) = p)
[-15] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-16] i!1`1 < p - 1
[-17] 2 <= p
  |-------
[1]   nth(append(i!2`3, cons(u!1, cdr(i!2`4))), i!4) =
       nth(remove(hu_list, rem(p)(1 + i!1`1)), i!4)

Rerunning step: (expand "length" -1 1)
Expanding the definition of length,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2 : 
;;; the next message is sent to i=i!1`1+1

{-1}  i!4 < 1 + length[Nonce](cdr(i!2`4)) + length(i!2`3)
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-5]  rem(p)(i!1`1) = i!1`1
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-10] u!1 = hu(i!1`1)
[-11] length(i!2`1) = i!1`1
[-12] length(i!2`3) = i!1`1
[-13] length(i!2`4) = -1 - i!1`1 + p
[-14] (length(hu_list) = p)
[-15] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-16] i!1`1 < p - 1
[-17] 2 <= p
  |-------
[1]   nth(append(i!2`3, cons(u!1, cdr(i!2`4))), i!4) =
       nth(remove(hu_list, rem(p)(1 + i!1`1)), i!4)

Rerunning step: (rewrite "length_cdr" -1)
Found matching substitution:
cons_l: (cons?[T]) gets i!2`4,
Rewriting using length_cdr, matching in -1,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2 : 
;;; the next message is sent to i=i!1`1+1

{-1}  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-5]  rem(p)(i!1`1) = i!1`1
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-10] u!1 = hu(i!1`1)
[-11] length(i!2`1) = i!1`1
[-12] length(i!2`3) = i!1`1
[-13] length(i!2`4) = -1 - i!1`1 + p
[-14] (length(hu_list) = p)
[-15] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-16] i!1`1 < p - 1
[-17] 2 <= p
  |-------
[1]   nth(append(i!2`3, cons(u!1, cdr(i!2`4))), i!4) =
       nth(remove(hu_list, rem(p)(1 + i!1`1)), i!4)

Rerunning step: (lemma "listprops[Identity].nth_append"
                 ("l1" "i!2`3" "l2" "cons(u!1,cdr(i!2`4))" "i" "i!4"))
Applying listprops[Identity].nth_append where 
  l1 gets i!2`3,
  l2 gets cons(u!1, cdr(i!2`4)),
  i gets i!4,
this yields  2 subgoals: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1 : 
;;; the next message is sent to i=i!1`1+1

{-1}  nth(append(i!2`3, cons(u!1, cdr(i!2`4))), i!4) =
       IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
       ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
       ENDIF
[-2]  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + i!3
[-5]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-6]  rem(p)(i!1`1) = i!1`1
[-7]  i!3 = i!1`1
[-8]  P!1 = p
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(i!1`1)
[-12] length(i!2`1) = i!1`1
[-13] length(i!2`3) = i!1`1
[-14] length(i!2`4) = -1 - i!1`1 + p
[-15] (length(hu_list) = p)
[-16] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-17] i!1`1 < p - 1
[-18] 2 <= p
  |-------
[1]   nth(append(i!2`3, cons(u!1, cdr(i!2`4))), i!4) =
       nth(remove(hu_list, rem(p)(1 + i!1`1)), i!4)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  nth(append(i!2`3, cons(u!1, cdr(i!2`4))), i!4) =
       IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
       ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
       ENDIF
[-2]  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + i!3
[-5]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-6]  rem(p)(i!1`1) = i!1`1
[-7]  i!3 = i!1`1
[-8]  P!1 = p
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(i!1`1)
[-12] length(i!2`1) = i!1`1
[-13] length(i!2`3) = i!1`1
[-14] length(i!2`4) = -1 - i!1`1 + p
[-15] (length(hu_list) = p)
[-16] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-17] i!1`1 < p - 1
[-18] 2 <= p
  |-------
{1}   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, rem(p)(1 + i!1`1)), i!4)

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-5]  rem(p)(i!1`1) = i!1`1
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-10] u!1 = hu(i!1`1)
[-11] length(i!2`1) = i!1`1
[-12] length(i!2`3) = i!1`1
[-13] length(i!2`4) = -1 - i!1`1 + p
[-14] (length(hu_list) = p)
[-15] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-16] i!1`1 < p - 1
[-17] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, rem(p)(1 + i!1`1)), i!4)

Rerunning step: (replace -4 1)
Replacing using formula -4,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-5]  rem(p)(i!1`1) = i!1`1
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-10] u!1 = hu(i!1`1)
[-11] length(i!2`1) = i!1`1
[-12] length(i!2`3) = i!1`1
[-13] length(i!2`4) = -1 - i!1`1 + p
[-14] (length(hu_list) = p)
[-15] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-16] i!1`1 < p - 1
[-17] 2 <= p
  |-------
{1}   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, 1 + i!1`1), i!4)

Rerunning step: (lemma "listprops[Identity].nth_remove"
                 ("l" "hu_list" "i" "1+i!1`1" "j" "i!4"))
Applying listprops[Identity].nth_remove where 
  l gets hu_list,
  i gets 1 + i!1`1,
  j gets i!4,
this yields  2 subgoals: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1 : 
;;; the next message is sent to i=i!1`1+1

{-1}  nth(remove(hu_list, 1 + i!1`1), i!4) =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF
[-2]  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + i!3
[-5]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-6]  rem(p)(i!1`1) = i!1`1
[-7]  i!3 = i!1`1
[-8]  P!1 = p
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(i!1`1)
[-12] length(i!2`1) = i!1`1
[-13] length(i!2`3) = i!1`1
[-14] length(i!2`4) = -1 - i!1`1 + p
[-15] (length(hu_list) = p)
[-16] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-17] i!1`1 < p - 1
[-18] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, 1 + i!1`1), i!4)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  nth(remove(hu_list, 1 + i!1`1), i!4) =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF
[-2]  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + i!3
[-5]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-6]  rem(p)(i!1`1) = i!1`1
[-7]  i!3 = i!1`1
[-8]  P!1 = p
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(i!1`1)
[-12] length(i!2`1) = i!1`1
[-13] length(i!2`3) = i!1`1
[-14] length(i!2`4) = -1 - i!1`1 + p
[-15] (length(hu_list) = p)
[-16] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-17] i!1`1 < p - 1
[-18] 2 <= p
  |-------
{1}   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-5]  rem(p)(i!1`1) = i!1`1
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-10] u!1 = hu(i!1`1)
[-11] length(i!2`1) = i!1`1
[-12] length(i!2`3) = i!1`1
[-13] length(i!2`4) = -1 - i!1`1 + p
[-14] (length(hu_list) = p)
[-15] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-16] i!1`1 < p - 1
[-17] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (lemma "listprops[Identity].equality_nth"
                 ("l1" "append(i!2`3,i!2`4)" "l2"
                  "remove(hu_list,i!1`1)"))
Applying listprops[Identity].equality_nth where 
  l1 gets append(i!2`3, i!2`4),
  l2 gets remove(hu_list, i!1`1),
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1 : 
;;; the next message is sent to i=i!1`1+1

{-1}  append(i!2`3, i!2`4) = remove(hu_list, i!1`1) IMPLIES
       FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
         nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-2]  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + i!3
[-5]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-6]  rem(p)(i!1`1) = i!1`1
[-7]  i!3 = i!1`1
[-8]  P!1 = p
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(i!1`1)
[-12] length(i!2`1) = i!1`1
[-13] length(i!2`3) = i!1`1
[-14] length(i!2`4) = -1 - i!1`1 + p
[-15] (length(hu_list) = p)
[-16] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-17] i!1`1 < p - 1
[-18] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1 : 
;;; the next message is sent to i=i!1`1+1

{-1}  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-2]  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + i!3
[-5]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-6]  rem(p)(i!1`1) = i!1`1
[-7]  i!3 = i!1`1
[-8]  P!1 = p
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(i!1`1)
[-12] length(i!2`1) = i!1`1
[-13] length(i!2`3) = i!1`1
[-14] length(i!2`4) = -1 - i!1`1 + p
[-15] (length(hu_list) = p)
[-16] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-17] i!1`1 < p - 1
[-18] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (inst -1 "i!4")
Instantiating the top quantifier in -1 with the terms: 
 i!4,
this yields  2 subgoals: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1.1 : 
;;; the next message is sent to i=i!1`1+1

{-1}  nth(append(i!2`3, i!2`4), i!4) = nth(remove(hu_list, i!1`1), i!4)
[-2]  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + i!3
[-5]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-6]  rem(p)(i!1`1) = i!1`1
[-7]  i!3 = i!1`1
[-8]  P!1 = p
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(i!1`1)
[-12] length(i!2`1) = i!1`1
[-13] length(i!2`3) = i!1`1
[-14] length(i!2`4) = -1 - i!1`1 + p
[-15] (length(hu_list) = p)
[-16] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-17] i!1`1 < p - 1
[-18] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (lemma "listprops[Identity].nth_append"
                 ("l1" "i!2`3" "l2" "i!2`4" "i" "i!4"))
Applying listprops[Identity].nth_append where 
  l1 gets i!2`3,
  l2 gets i!2`4,
  i gets i!4,
this yields  2 subgoals: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1.1.1 : 
;;; the next message is sent to i=i!1`1+1

{-1}  nth(append(i!2`3, i!2`4), i!4) =
       IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
       ELSE nth(i!2`4, i!4 - length[Identity](i!2`3))
       ENDIF
[-2]  nth(append(i!2`3, i!2`4), i!4) = nth(remove(hu_list, i!1`1), i!4)
[-3]  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-7]  rem(p)(i!1`1) = i!1`1
[-8]  i!3 = i!1`1
[-9]  P!1 = p
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] length(i!2`1) = i!1`1
[-14] length(i!2`3) = i!1`1
[-15] length(i!2`4) = -1 - i!1`1 + p
[-16] (length(hu_list) = p)
[-17] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-18] i!1`1 < p - 1
[-19] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (replace -1 -2)
Replacing using formula -1,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1.1.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  nth(append(i!2`3, i!2`4), i!4) =
       IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
       ELSE nth(i!2`4, i!4 - length[Identity](i!2`3))
       ENDIF
{-2}  IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(i!2`4, i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, i!1`1), i!4)
[-3]  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-7]  rem(p)(i!1`1) = i!1`1
[-8]  i!3 = i!1`1
[-9]  P!1 = p
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] length(i!2`1) = i!1`1
[-14] length(i!2`3) = i!1`1
[-15] length(i!2`4) = -1 - i!1`1 + p
[-16] (length(hu_list) = p)
[-17] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-18] i!1`1 < p - 1
[-19] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1.1.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(i!2`4, i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, i!1`1), i!4)
[-2]  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + i!3
[-5]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-6]  rem(p)(i!1`1) = i!1`1
[-7]  i!3 = i!1`1
[-8]  P!1 = p
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(i!1`1)
[-12] length(i!2`1) = i!1`1
[-13] length(i!2`3) = i!1`1
[-14] length(i!2`4) = -1 - i!1`1 + p
[-15] (length(hu_list) = p)
[-16] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-17] i!1`1 < p - 1
[-18] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (lemma "listprops[Identity].nth_remove"
                 ("l" "hu_list" "i" "i!1`1" "j" "i!4"))
Ignoring 1 repeated TCCs.
Applying listprops[Identity].nth_remove where 
  l gets hu_list,
  i gets i!1`1,
  j gets i!4,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1.1.1 : 
;;; the next message is sent to i=i!1`1+1

{-1}  nth(remove(hu_list, i!1`1), i!4) =
       IF i!4 < i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF
[-2]  IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(i!2`4, i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, i!1`1), i!4)
[-3]  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-7]  rem(p)(i!1`1) = i!1`1
[-8]  i!3 = i!1`1
[-9]  P!1 = p
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] length(i!2`1) = i!1`1
[-14] length(i!2`3) = i!1`1
[-15] length(i!2`4) = -1 - i!1`1 + p
[-16] (length(hu_list) = p)
[-17] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-18] i!1`1 < p - 1
[-19] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (replace -1 -2)
Replacing using formula -1,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1.1.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  nth(remove(hu_list, i!1`1), i!4) =
       IF i!4 < i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF
{-2}  IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(i!2`4, i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF
[-3]  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-7]  rem(p)(i!1`1) = i!1`1
[-8]  i!3 = i!1`1
[-9]  P!1 = p
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] length(i!2`1) = i!1`1
[-14] length(i!2`3) = i!1`1
[-15] length(i!2`4) = -1 - i!1`1 + p
[-16] (length(hu_list) = p)
[-17] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-18] i!1`1 < p - 1
[-19] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1.1.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(i!2`4, i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF
[-2]  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + i!3
[-5]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-6]  rem(p)(i!1`1) = i!1`1
[-7]  i!3 = i!1`1
[-8]  P!1 = p
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(i!1`1)
[-12] length(i!2`1) = i!1`1
[-13] length(i!2`3) = i!1`1
[-14] length(i!2`4) = -1 - i!1`1 + p
[-15] (length(hu_list) = p)
[-16] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-17] i!1`1 < p - 1
[-18] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (expand "nth" 1 2)
Expanding the definition of nth,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1.1.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(i!2`4, i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF
[-2]  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + i!3
[-5]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-6]  rem(p)(i!1`1) = i!1`1
[-7]  i!3 = i!1`1
[-8]  P!1 = p
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(i!1`1)
[-12] length(i!2`1) = i!1`1
[-13] length(i!2`3) = i!1`1
[-14] length(i!2`4) = -1 - i!1`1 + p
[-15] (length(hu_list) = p)
[-16] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-17] i!1`1 < p - 1
[-18] 2 <= p
  |-------
{1}   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (expand "nth" -1 2)
Expanding the definition of nth,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1.1.1 : 
;;; the next message is sent to i=i!1`1+1

{-1}  IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN car(i!2`4)
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF
[-2]  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + i!3
[-5]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-6]  rem(p)(i!1`1) = i!1`1
[-7]  i!3 = i!1`1
[-8]  P!1 = p
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(i!1`1)
[-12] length(i!2`1) = i!1`1
[-13] length(i!2`3) = i!1`1
[-14] length(i!2`4) = -1 - i!1`1 + p
[-15] (length(hu_list) = p)
[-16] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-17] i!1`1 < p - 1
[-18] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (replace* -13 -14)
Repeatedly applying the replace rule,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1.1.1 : 
;;; the next message is sent to i=i!1`1+1

{-1}  IF i!4 < i!1`1 THEN nth(i!2`3, i!4)
      ELSE IF i!4 - i!1`1 = 0 THEN car(i!2`4)
           ELSE nth(cdr(i!2`4), -1 - i!1`1 + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF
{-2}  i!4 < -1 - i!1`1 + p + i!1`1
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + i!3
[-5]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-6]  rem(p)(i!1`1) = i!1`1
[-7]  i!3 = i!1`1
[-8]  P!1 = p
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(i!1`1)
[-12] length(i!2`1) = i!1`1
[-13] length(i!2`3) = i!1`1
[-14] length(i!2`4) = -1 - i!1`1 + p
[-15] (length(hu_list) = p)
[-16] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-17] i!1`1 < p - 1
[-18] 2 <= p
  |-------
{1}   IF i!4 < i!1`1 THEN nth(i!2`3, i!4)
      ELSE IF i!4 - i!1`1 = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - i!1`1 + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (delete -3 -4 -5 -7 -8 -9 -10 -12 -18)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1.1.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  IF i!4 < i!1`1 THEN nth(i!2`3, i!4)
      ELSE IF i!4 - i!1`1 = 0 THEN car(i!2`4)
           ELSE nth(cdr(i!2`4), -1 - i!1`1 + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF
[-2]  i!4 < -1 - i!1`1 + p + i!1`1
[-3]  rem(p)(i!1`1) = i!1`1
[-4]  u!1 = hu(i!1`1)
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1`1 < p - 1
  |-------
[1]   IF i!4 < i!1`1 THEN nth(i!2`3, i!4)
      ELSE IF i!4 - i!1`1 = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - i!1`1 + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (case "i!4<i!1`1 OR i!4=i!1`1 OR i!4>i!1`1")
Case splitting on 
   i!4 < i!1`1 OR i!4 = i!1`1 OR i!4 > i!1`1, 
this yields  2 subgoals: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1.1.1.1 : 
;;; the next message is sent to i=i!1`1+1

{-1}  i!4 < i!1`1 OR i!4 = i!1`1 OR i!4 > i!1`1
[-2]  IF i!4 < i!1`1 THEN nth(i!2`3, i!4)
      ELSE IF i!4 - i!1`1 = 0 THEN car(i!2`4)
           ELSE nth(cdr(i!2`4), -1 - i!1`1 + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF
[-3]  i!4 < -1 - i!1`1 + p + i!1`1
[-4]  rem(p)(i!1`1) = i!1`1
[-5]  u!1 = hu(i!1`1)
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = -1 - i!1`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1`1 < p - 1
  |-------
[1]   IF i!4 < i!1`1 THEN nth(i!2`3, i!4)
      ELSE IF i!4 - i!1`1 = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - i!1`1 + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (inst -9 "i!1`1")
Instantiating the top quantifier in -9 with the terms: 
 i!1`1,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1.1.1.1 : 
;;; the next message is sent to i=i!1`1+1

[-1]  i!4 < i!1`1 OR i!4 = i!1`1 OR i!4 > i!1`1
[-2]  IF i!4 < i!1`1 THEN nth(i!2`3, i!4)
      ELSE IF i!4 - i!1`1 = 0 THEN car(i!2`4)
           ELSE nth(cdr(i!2`4), -1 - i!1`1 + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF
[-3]  i!4 < -1 - i!1`1 + p + i!1`1
[-4]  rem(p)(i!1`1) = i!1`1
[-5]  u!1 = hu(i!1`1)
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = -1 - i!1`1 + p
[-8]  (length(hu_list) = p)
{-9}  nth(hu_list, i!1`1) = hu(i!1`1)
[-10] i!1`1 < p - 1
  |-------
[1]   IF i!4 < i!1`1 THEN nth(i!2`3, i!4)
      ELSE IF i!4 - i!1`1 = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - i!1`1 + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (grind :exclude ("nth" "append" "remove"))
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1.1.1.1.

restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1.1.1.2 : 
;;; the next message is sent to i=i!1`1+1

[-1]  IF i!4 < i!1`1 THEN nth(i!2`3, i!4)
      ELSE IF i!4 - i!1`1 = 0 THEN car(i!2`4)
           ELSE nth(cdr(i!2`4), -1 - i!1`1 + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF
[-2]  i!4 < -1 - i!1`1 + p + i!1`1
[-3]  rem(p)(i!1`1) = i!1`1
[-4]  u!1 = hu(i!1`1)
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1`1 < p - 1
  |-------
{1}   i!4 < i!1`1 OR i!4 = i!1`1 OR i!4 > i!1`1
[2]   IF i!4 < i!1`1 THEN nth(i!2`3, i!4)
      ELSE IF i!4 - i!1`1 = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - i!1`1 + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1.1.1.2 : 
;;; the next message is sent to i=i!1`1+1

  |-------
[1]   i!4 < i!1`1 OR i!4 = i!1`1 OR i!4 > i!1`1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1.1.1.2.


This completes the proof of restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1.1.1.

restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1.1.2T (TCC):   

[-1]  nth(append(i!2`3, i!2`4), i!4) = nth(remove(hu_list, i!1`1), i!4)
[-2]  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + i!3
[-5]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-6]  rem(p)(i!1`1) = i!1`1
[-7]  i!3 = i!1`1
[-8]  P!1 = p
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(i!1`1)
[-12] length(i!2`1) = i!1`1
[-13] length(i!2`3) = i!1`1
[-14] length(i!2`4) = -1 - i!1`1 + p
[-15] (length(hu_list) = p)
[-16] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-17] i!1`1 < p - 1
[-18] 2 <= p
  |-------
{1}   i!4 < length[Identity](i!2`3) + length[Identity](i!2`4)
[2]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (delete -1 -3
                  -4 -5
                  -6 -7
                  -8 -9
                  -10 -11
                  -12 -13
                  -14 -15
                  -16 -17
                  -18 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1.1.2T : 
;;; the next message is sent to i=i!1`1+1

[-1]  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
  |-------
[1]   i!4 < length[Identity](i!2`3) + length[Identity](i!2`4)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1.1.2T.


This completes the proof of restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1.1.

restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1.2 (TCC):   

[-1]  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-5]  rem(p)(i!1`1) = i!1`1
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-10] u!1 = hu(i!1`1)
[-11] length(i!2`1) = i!1`1
[-12] length(i!2`3) = i!1`1
[-13] length(i!2`4) = -1 - i!1`1 + p
[-14] (length(hu_list) = p)
[-15] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-16] i!1`1 < p - 1
[-17] 2 <= p
  |-------
{1}   i!4 < length[Identity](append[Identity](i!2`3, i!2`4))
[2]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets i!2`4,
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in 1,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1.2 : 
;;; the next message is sent to i=i!1`1+1

[-1]  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-5]  rem(p)(i!1`1) = i!1`1
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-10] u!1 = hu(i!1`1)
[-11] length(i!2`1) = i!1`1
[-12] length(i!2`3) = i!1`1
[-13] length(i!2`4) = -1 - i!1`1 + p
[-14] (length(hu_list) = p)
[-15] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-16] i!1`1 < p - 1
[-17] 2 <= p
  |-------
{1}   i!4 < length(i!2`3) + length(i!2`4)
[2]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (delete -2 -3
                  -4 -5
                  -6 -7
                  -8 -9
                  -10 -11
                  -12 -13
                  -14 -15
                  -16 -17
                  2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1.2 : 
;;; the next message is sent to i=i!1`1+1

[-1]  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
  |-------
[1]   i!4 < length(i!2`3) + length(i!2`4)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1.2.


This completes the proof of restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.1.

restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.2T (TCC):   

[-1]  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-5]  rem(p)(i!1`1) = i!1`1
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-10] u!1 = hu(i!1`1)
[-11] length(i!2`1) = i!1`1
[-12] length(i!2`3) = i!1`1
[-13] length(i!2`4) = -1 - i!1`1 + p
[-14] (length(hu_list) = p)
[-15] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-16] i!1`1 < p - 1
[-17] 2 <= p
  |-------
{1}   i!4 < length[Identity](hu_list) - 1
[2]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, 1 + i!1`1), i!4)

Rerunning step: (delete -2 -3 -4 -5 -6 -7 -8 -9 -10 -11 -15 -16 -17 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.2T : 
;;; the next message is sent to i=i!1`1+1

[-1]  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = -1 - i!1`1 + p
[-4]  (length(hu_list) = p)
  |-------
[1]   i!4 < length[Identity](hu_list) - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.2T.


This completes the proof of restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.1.

restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.2T (TCC):   

[-1]  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-5]  rem(p)(i!1`1) = i!1`1
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-10] u!1 = hu(i!1`1)
[-11] length(i!2`1) = i!1`1
[-12] length(i!2`3) = i!1`1
[-13] length(i!2`4) = -1 - i!1`1 + p
[-14] (length(hu_list) = p)
[-15] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-16] i!1`1 < p - 1
[-17] 2 <= p
  |-------
{1}   i!4 <
       length[Identity](cons[Identity](u!1, cdr[Identity](i!2`4))) +
        length[Identity](i!2`3)
[2]   nth(append(i!2`3, cons(u!1, cdr(i!2`4))), i!4) =
       nth(remove(hu_list, rem(p)(1 + i!1`1)), i!4)

Rerunning step: (expand "length" 1 1)
Expanding the definition of length,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.2T : 
;;; the next message is sent to i=i!1`1+1

[-1]  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  rem(p)(1 + i!1`1) = 1 + i!1`1
[-5]  rem(p)(i!1`1) = i!1`1
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-10] u!1 = hu(i!1`1)
[-11] length(i!2`1) = i!1`1
[-12] length(i!2`3) = i!1`1
[-13] length(i!2`4) = -1 - i!1`1 + p
[-14] (length(hu_list) = p)
[-15] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-16] i!1`1 < p - 1
[-17] 2 <= p
  |-------
{1}   i!4 <
       1 + length[Identity](cdr[Identity](i!2`4)) + length[Identity](i!2`3)
[2]   nth(append(i!2`3, cons(u!1, cdr(i!2`4))), i!4) =
       nth(remove(hu_list, rem(p)(1 + i!1`1)), i!4)

Rerunning step: (rewrite "length_cdr" 1)
Found matching substitution:
cons_l: (cons?[T]) gets i!2`4,
Rewriting using length_cdr, matching in 1,

This completes the proof of restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.2T.


This completes the proof of restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.2.


This completes the proof of restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.2.


This completes the proof of restrictpremid_middle.3.1.2.1.2.1.1.1.2.1.

restrictpremid_middle.3.1.2.1.2.1.1.1.2.2 (TCC):   

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  rem(p)(1 + i!1`1) = i!1`1 + 1
[-4]  rem(p)(i!1`1) = i!1`1
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-9]  u!1 = hu(i!1`1)
[-10] length(i!2`1) = i!1`1
[-11] length(i!2`3) = i!1`1
[-12] length(i!2`4) = p - 1 - i!1`1
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
{1}   length[Nonce](append[Nonce](nl2!1, (: i!1`2 :))) = i!1`1 - mid

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets (: i!1`2 :),
l1: list[T] gets nl2!1,
Rewriting using length_append, matching in 1,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.2 : 
;;; the next message is sent to i=i!1`1+1

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  rem(p)(1 + i!1`1) = i!1`1 + 1
[-4]  rem(p)(i!1`1) = i!1`1
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-9]  u!1 = hu(i!1`1)
[-10] length(i!2`1) = i!1`1
[-11] length(i!2`3) = i!1`1
[-12] length(i!2`4) = p - 1 - i!1`1
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
{1}   length((: i!1`2 :)) + length(nl2!1) = i!1`1 - mid

Rerunning step: (delete -1 -3
                  -4 -6
                  -7 -8
                  -9 -10
                  -11 -12
                  -13 -14
                  -15 -16)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.1.2.2 : 
;;; the next message is sent to i=i!1`1+1

[-1]  length(nl2!1) = -1 - mid + i!3
[-2]  i!3 = i!1`1
  |-------
[1]   length((: i!1`2 :)) + length(nl2!1) = i!1`1 - mid

Rerunning step: (grind)
length rewrites length[Nonce]((: :))
  to 0
length rewrites length((: i!1`2 :))
  to 1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpremid_middle.3.1.2.1.2.1.1.1.2.2.


This completes the proof of restrictpremid_middle.3.1.2.1.2.1.1.1.2.


This completes the proof of restrictpremid_middle.3.1.2.1.2.1.1.1.

restrictpremid_middle.3.1.2.1.2.1.1.2 : 
;;; the next message is sent to i=i!1`1+1

[-1]  rem(p)(i!1`1) = i!1`1
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-5]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-6]  u!1 = hu(i!1`1)
[-7]  length(i!2`1) = i!1`1
[-8]  length(i!2`3) = i!1`1
[-9]  length(i!2`4) = p - 1 - i!1`1
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] i!1`1 < p - 1
[-13] 2 <= p
  |-------
{1}   rem(p)(1 + i!1`1) = i!1`1 + 1
[2]   public(car(i!2`4)) = public(hu(rem(p)(i!1`1 + 1))) AND
       EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
               nl2: {x: list[Nonce] | length(x) = i!1`1 - mid}):
         conc(nlist(append(i!2`1, (: i!1`2 :))),
              ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
          =
          conc(nlist(append(nl1, cons(n_mid, nl2))),
               ilist(remove(hu_list, rem(p)(i!1`1 + 1))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (lemma "select_right_nonce2" ("P" "p"))
Applying select_right_nonce2 where 
  P gets p,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.2 : 
;;; the next message is sent to i=i!1`1+1

{-1}  (p = p IMPLIES floor(((mid - 1) / (p - 2)) * (p - 2) + 1) = mid) AND
       floor(((mid - 1) / (p - 2)) * (p - 2) + 1) >= 1 AND
        floor(((mid - 1) / (p - 2)) * (p - 2) + 1) < p - 1
[-2]  rem(p)(i!1`1) = i!1`1
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-6]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-7]  u!1 = hu(i!1`1)
[-8]  length(i!2`1) = i!1`1
[-9]  length(i!2`3) = i!1`1
[-10] length(i!2`4) = p - 1 - i!1`1
[-11] (length(hu_list) = p)
[-12] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-13] i!1`1 < p - 1
[-14] 2 <= p
  |-------
[1]   rem(p)(1 + i!1`1) = i!1`1 + 1
[2]   public(car(i!2`4)) = public(hu(rem(p)(i!1`1 + 1))) AND
       EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
               nl2: {x: list[Nonce] | length(x) = i!1`1 - mid}):
         conc(nlist(append(i!2`1, (: i!1`2 :))),
              ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
          =
          conc(nlist(append(nl1, cons(n_mid, nl2))),
               ilist(remove(hu_list, rem(p)(i!1`1 + 1))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (delete -1 -2 -3 -4 -5 -6 -7 -8 -9 -10 -11 -12 -14 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.2 : 
;;; the next message is sent to i=i!1`1+1

[-1]  i!1`1 < p - 1
  |-------
[1]   rem(p)(1 + i!1`1) = i!1`1 + 1

Rerunning step: (rewrite "rem_def")
Found matching substitution:
r: mod(b) gets i!1`1 + 1,
x: int gets 1 + i!1`1,
b: posnat gets p,
Rewriting using rem_def, matching in *,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.2 : 
;;; the next message is sent to i=i!1`1+1

[-1]  i!1`1 < p - 1
  |-------
{1}   EXISTS q: 0 = p * q

Rerunning step: (inst 1 "0")
Instantiating the top quantifier in 1 with the terms: 
 0,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.1.2 : 
;;; the next message is sent to i=i!1`1+1

[-1]  i!1`1 < p - 1
  |-------
{1}   0 = p * 0

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.3.1.2.1.2.1.1.2.


This completes the proof of restrictpremid_middle.3.1.2.1.2.1.1.

restrictpremid_middle.3.1.2.1.2.1.2 (TCC):   

[-1]  rem(p)(i!1`1) = i!1`1
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-5]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-6]  u!1 = hu(i!1`1)
[-7]  length(i!2`1) = i!1`1
[-8]  length(i!2`3) = i!1`1
[-9]  length(i!2`4) = p - 1 - i!1`1
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] i!1`1 < p - 1
[-13] 2 <= p
  |-------
{1}   mid < 1 + i!1`1 AND 1 + i!1`1 <= p
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (typepred "i!3")
Adding type constraints for  i!3,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.2 : 
;;; the next message is sent to i=i!1`1+1

{-1}  mid < i!3
{-2}  i!3 <= p
[-3]  rem(p)(i!1`1) = i!1`1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-7]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-8]  u!1 = hu(i!1`1)
[-9]  length(i!2`1) = i!1`1
[-10] length(i!2`3) = i!1`1
[-11] length(i!2`4) = p - 1 - i!1`1
[-12] (length(hu_list) = p)
[-13] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
[1]   mid < 1 + i!1`1 AND 1 + i!1`1 <= p
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (delete -2 -3 -5 -6 -7 -8 -9 -10 -11 -12 -13 -15 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.1.2 : 
;;; the next message is sent to i=i!1`1+1

[-1]  mid < i!3
[-2]  i!3 = i!1`1
[-3]  i!1`1 < p - 1
  |-------
[1]   mid < 1 + i!1`1 AND 1 + i!1`1 <= p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.3.1.2.1.2.1.2.


This completes the proof of restrictpremid_middle.3.1.2.1.2.1.

restrictpremid_middle.3.1.2.1.2.2 : 
;;; consider the three cases which could make -1 true

{-1}  i!3 = i!1`1
{-2}  P!1 = p
[-3]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-4]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-5]  u!1 = hu(rem(p)(i!3))
[-6]  length(i!2`1) = i!1`1
[-7]  length(i!2`3) = i!1`1
[-8]  length(i!2`4) = P!1 - 1 - i!1`1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] i!1`1 < P!1 - 1
[-12] 2 <= P!1
  |-------
{1}   rem(p)(i!1`1) = i!1`1
[2]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (delete -1 -3 -4 -5 -6 -7 -8 -9 -10 -12 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.2 : 
;;; consider the three cases which could make -1 true

[-1]  P!1 = p
[-2]  i!1`1 < P!1 - 1
  |-------
[1]   rem(p)(i!1`1) = i!1`1

Rerunning step: (rewrite "rem_def" 1)
Found matching substitution:
r: mod(b) gets i!1`1,
x: int gets i!1`1,
b: posnat gets p,
Rewriting using rem_def, matching in 1,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.2 : 
;;; consider the three cases which could make -1 true

[-1]  P!1 = p
[-2]  i!1`1 < P!1 - 1
  |-------
{1}   EXISTS q: 0 = p * q

Rerunning step: (inst 1 "0")
Instantiating the top quantifier in 1 with the terms: 
 0,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.2 : 
;;; consider the three cases which could make -1 true

[-1]  P!1 = p
[-2]  i!1`1 < P!1 - 1
  |-------
{1}   0 = p * 0

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.3.1.2.1.2.2.

restrictpremid_middle.3.1.2.1.2.3 : 
;;; consider the three cases which could make -1 true

{-1}  P!1 = p
[-2]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-3]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-4]  u!1 = hu(rem(p)(i!3))
[-5]  length(i!2`1) = i!1`1
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = P!1 - 1 - i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1`1 < P!1 - 1
[-11] 2 <= P!1
  |-------
{1}   i!3 = i!1`1
[2]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (replace -3 -5)
Replacing using formula -3,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.3 : 
;;; consider the three cases which could make -1 true

[-1]  P!1 = p
[-2]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-3]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-4]  u!1 = hu(rem(p)(i!3))
{-5}  length(append(nl1!1, cons(n_mid, nl2!1))) = i!1`1
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = P!1 - 1 - i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1`1 < P!1 - 1
[-11] 2 <= P!1
  |-------
[1]   i!3 = i!1`1
[2]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (rewrite "length_append" -5)
Found matching substitution:
l2: list[T] gets cons(n_mid, nl2!1),
l1: list[T] gets nl1!1,
Rewriting using length_append, matching in -5,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.3 : 
;;; consider the three cases which could make -1 true

[-1]  P!1 = p
[-2]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-3]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-4]  u!1 = hu(rem(p)(i!3))
{-5}  length(cons(n_mid, nl2!1)) + length(nl1!1) = i!1`1
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = P!1 - 1 - i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1`1 < P!1 - 1
[-11] 2 <= P!1
  |-------
[1]   i!3 = i!1`1
[2]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (expand "length" -5 1)
Expanding the definition of length,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.3 : 
;;; consider the three cases which could make -1 true

[-1]  P!1 = p
[-2]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-3]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-4]  u!1 = hu(rem(p)(i!3))
{-5}  1 + length(nl1!1) + length[Nonce](nl2!1) = i!1`1
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = P!1 - 1 - i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1`1 < P!1 - 1
[-11] 2 <= P!1
  |-------
[1]   i!3 = i!1`1
[2]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (typepred "nl1!1" "nl2!1")
Adding type constraints for  nl1!1, nl2!1,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.3 : 
;;; consider the three cases which could make -1 true

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl1!1)
{-2}  length(nl1!1) = mid
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
{-4}  length(nl2!1) = -1 - mid + i!3
[-5]  P!1 = p
[-6]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-7]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-8]  u!1 = hu(rem(p)(i!3))
[-9]  1 + length(nl1!1) + length[Nonce](nl2!1) = i!1`1
[-10] length(i!2`3) = i!1`1
[-11] length(i!2`4) = P!1 - 1 - i!1`1
[-12] (length(hu_list) = p)
[-13] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-14] i!1`1 < P!1 - 1
[-15] 2 <= P!1
  |-------
[1]   i!3 = i!1`1
[2]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (delete -1 -3 -5 -6 -7 -8 -10 -11 -12 -13 -14 -15 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.3 : 
;;; consider the three cases which could make -1 true

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  1 + length(nl1!1) + length[Nonce](nl2!1) = i!1`1
  |-------
[1]   i!3 = i!1`1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.3.1.2.1.2.3.

restrictpremid_middle.3.1.2.1.2.4 : 
;;; consider the three cases which could make -1 true

[-1]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-2]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-3]  u!1 = hu(rem(p)(i!3))
[-4]  length(i!2`1) = i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1`1 < P!1 - 1
[-10] 2 <= P!1
  |-------
{1}   P!1 = p
[2]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (lemma "listprops[Identity].equality_length"
                 ("l1" "append(i!2`3,i!2`4)" "l2"
                  "remove(hu_list,rem(p)(i!3))"))
Applying listprops[Identity].equality_length where 
  l1 gets append(i!2`3, i!2`4),
  l2 gets remove(hu_list, rem(p)(i!3)),
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.4 : 
;;; consider the three cases which could make -1 true

{-1}  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3)) IMPLIES
       length[Identity](append(i!2`3, i!2`4)) =
        length[Identity](remove(hu_list, rem(p)(i!3)))
[-2]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-3]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-4]  u!1 = hu(rem(p)(i!3))
[-5]  length(i!2`1) = i!1`1
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = P!1 - 1 - i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1`1 < P!1 - 1
[-11] 2 <= P!1
  |-------
[1]   P!1 = p
[2]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (delete -3 -4 -5 -9 -10 -11 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.4 : 
;;; consider the three cases which could make -1 true

[-1]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3)) IMPLIES
       length[Identity](append(i!2`3, i!2`4)) =
        length[Identity](remove(hu_list, rem(p)(i!3)))
[-2]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  (length(hu_list) = p)
  |-------
[1]   P!1 = p

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.4 : 
;;; consider the three cases which could make -1 true

{-1}  length[Identity](append(i!2`3, i!2`4)) =
       length[Identity](remove(hu_list, rem(p)(i!3)))
[-2]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  (length(hu_list) = p)
  |-------
[1]   P!1 = p

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets i!2`4,
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.4 : 
;;; consider the three cases which could make -1 true

{-1}  length(i!2`3) + length(i!2`4) =
       length[Identity](remove(hu_list, rem(p)(i!3)))
[-2]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  (length(hu_list) = p)
  |-------
[1]   P!1 = p

Rerunning step: (rewrite "length_remove" -1 :dir rl)
Found matching substitution:
i: below[length(c)] gets rem(p)(i!3),
c: (cons?[T]) gets hu_list,
Rewriting using length_remove, matching in -1,
this yields  2 subgoals: 
restrictpremid_middle.3.1.2.1.2.4.1 : 
;;; consider the three cases which could make -1 true

{-1}  length(i!2`3) + length(i!2`4) = length[Identity](hu_list) - 1
[-2]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  (length(hu_list) = p)
  |-------
[1]   P!1 = p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.3.1.2.1.2.4.1.

restrictpremid_middle.3.1.2.1.2.4.2 : 
;;; consider the three cases which could make -1 true

[-1]  length(i!2`3) + length(i!2`4) =
       length[Identity](remove(hu_list, rem(p)(i!3)))
[-2]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  (length(hu_list) = p)
  |-------
{1}   cons?[Identity](hu_list)
[2]   P!1 = p

Rerunning step: (typepred "p")
Adding type constraints for  p,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.4.2 : 
;;; consider the three cases which could make -1 true

{-1}  3 <= p
[-2]  length(i!2`3) + length(i!2`4) =
       length[Identity](remove(hu_list, rem(p)(i!3)))
[-3]  append(i!2`3, i!2`4) = remove(hu_list, rem(p)(i!3))
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  (length(hu_list) = p)
  |-------
[1]   cons?[Identity](hu_list)
[2]   P!1 = p

Rerunning step: (delete -2 -3 -4 -5 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1.2.4.2 : 
;;; consider the three cases which could make -1 true

[-1]  3 <= p
[-2]  (length(hu_list) = p)
  |-------
[1]   cons?[Identity](hu_list)

Rerunning step: (nonemptylist "hu_list")
Relating existence of a tail to a list's length,

This completes the proof of restrictpremid_middle.3.1.2.1.2.4.2.


This completes the proof of restrictpremid_middle.3.1.2.1.2.4.


This completes the proof of restrictpremid_middle.3.1.2.1.2.

restrictpremid_middle.3.1.2.1.3 : 
;;; consider the three cases which could make -1 true

{-1}  EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(u!1) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`4)),
                      conc(nlist(append(i!2`1, (: i!1`2 :))),
                           ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictpremid_middle.3.1.2.1.3 : 
;;; consider the three cases which could make -1 true

{-1}  public(u!1) = public(hu(i!3))
{-2}  conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
       conc(ilist(remove(hu_list, i!3)),
            nlist(append(nl1!1, cons(n_mid, nl2!1))))
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`4)),
                      conc(nlist(append(i!2`1, (: i!1`2 :))),
                           ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (delete -1 -3 -4 -5 -6 -7 +)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.1.3 : 
;;; consider the three cases which could make -1 true

[-1]  conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
       conc(ilist(remove(hu_list, i!3)),
            nlist(append(nl1!1, cons(n_mid, nl2!1))))
  |-------

Rerunning step: (comment "contradiction in -1")
Adding comment: contradiction in -1
this simplifies to: 
restrictpremid_middle.3.1.2.1.3 : 
;;; contradiction in -1

[-1]  conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
       conc(ilist(remove(hu_list, i!3)),
            nlist(append(nl1!1, cons(n_mid, nl2!1))))
  |-------

Rerunning step: (assert :flush? t)
Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
restrictpremid_middle.3.1.2.1.3 : 
;;; contradiction in -1

[-1]  conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
       conc(ilist(remove(hu_list, i!3)),
            nlist(append(nl1!1, cons(n_mid, nl2!1))))
  |-------

Rerunning step: (decompose-equality -1)
Applying decompose-equality,

This completes the proof of restrictpremid_middle.3.1.2.1.3.


This completes the proof of restrictpremid_middle.3.1.2.1.

restrictpremid_middle.3.1.2.2 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   ((rec(u!1, nth(i!2`3, i!1`1 - 1),
            E(public(u!1),
              conc(ilist(append(i!2`3, i!2`4)),
                   nlist(cons(i!1`2, i!2`2)))))
         >>
         ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
           Stop[event]))
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
{2}   R_premid(v!1)
              (trans(u!1, car(i!2`4),
                     E(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))))
{3}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(nlist(append(i!2`1, (: i!1`2 :))),
                   ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
       >>
       ((rec(u!1, nth(i!2`3, i!1`1 - 1),
             E(public(u!1),
               conc(ilist(append(i!2`3, i!2`4)),
                    nlist(cons(i!1`2, i!2`2)))))
          >>
          ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
            Stop[event]))
         # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[5]   i!1`2 = n_mid
[6]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.2 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   ((rec(u!1, nth(i!2`3, i!1`1 - 1),
            E(public(u!1),
              conc(ilist(append(i!2`3, i!2`4)),
                   nlist(cons(i!1`2, i!2`2)))))
         >>
         ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
           Stop[event]))
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictpremid_middle.3.1.2.2 :  

{-1}  rho_premid(v!1)
                (E(public(u!1),
                   conc(ilist(append(i!2`3, i!2`4)),
                        nlist(cons(i!1`2, i!2`2)))))
[-2]  rho_premid(v!1)
                (E(public(u!1),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
{1}   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
{2}   R_premid(v!1)
              (rec(u!1, nth(i!2`3, i!1`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(i!2`3, i!2`4)),
                          nlist(cons(i!1`2, i!2`2))))))
{3}   rec(u!1, nth(i!2`3, i!1`1 - 1),
          E(public(u!1),
            conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2)))))
       >>
       (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
          Stop[event])
         # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[5]   i!1`2 = n_mid
[6]   P!1 = 2

Rerunning step: (delete -2 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.2 :  

[-1]  rho_premid(v!1)
                (E(public(u!1),
                   conc(ilist(append(i!2`3, i!2`4)),
                        nlist(cons(i!1`2, i!2`2)))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (expand "E")
Expanding the definition of E,
this simplifies to: 
restrictpremid_middle.3.1.2.2 :  

{-1}  rho_premid(v!1)
                (code(public(u!1),
                      conc(ilist(append(i!2`3, i!2`4)),
                           nlist(cons(i!1`2, i!2`2)))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (expand "rho_premid" -1)
Expanding the definition of rho_premid,
this simplifies to: 
restrictpremid_middle.3.1.2.2 :  

{-1}  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
       OR
       (EXISTS (i: {x: nat | mid < x AND x <= p}):
          public(u!1) = public(hu(rem(p)(i))) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                   nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
             conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
              conc(nlist(append(nl1, cons(n_mid, nl2))),
                   ilist(remove(hu_list, rem(p)(i)))))
        OR
        EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
          public(u!1) = public(hu(i)) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                   nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
             conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
              conc(ilist(remove(hu_list, i)),
                   nlist(append(nl1, cons(n_mid, nl2))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (split)
Splitting conjunctions,
this yields  3 subgoals: 
restrictpremid_middle.3.1.2.2.1 :  

{-1}  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (delete -2 -3 -4 -5 -6 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.2.1 :  

[-1]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (expand "LastMessage")
Expanding the definition of LastMessage,
this simplifies to: 
restrictpremid_middle.3.1.2.2.1 :  

[-1]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   ((IF i!1`1 = P!1 - 2
          THEN trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2)))
        ELSE trans(u!1, car(i!2`4),
                   E(public(car(i!2`4)),
                     conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                          nlist(i!2`2))))
        ENDIF
         >> Stop[event])
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (lift-if)
Lifting IF-conditions to the top level,
this simplifies to: 
restrictpremid_middle.3.1.2.2.1 :  

[-1]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   IF i!1`1 = P!1 - 2
        THEN ((trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2)))
                >> Stop[event])
               # R_premid(v!1))
              |>
              LAMBDA (t: list[event]):
                every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))
                     (t)
                 =>
                 every(LAMBDA (e: event):
                         NOT rec?(e) => rho_premid(v!1)(msg(e)))
                      (t)
      ELSE ((trans(u!1, car(i!2`4),
                   E(public(car(i!2`4)),
                     conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                          nlist(i!2`2))))
              >> Stop[event])
             # R_premid(v!1))
            |>
            LAMBDA (t: list[event]):
              every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))
                   (t)
               =>
               every(LAMBDA (e: event):
                       NOT rec?(e) => rho_premid(v!1)(msg(e)))
                    (t)
      ENDIF

Rerunning step: (prop)
Applying propositional simplification,
this yields  2 subgoals: 
restrictpremid_middle.3.1.2.2.1.1 :  

{-1}  i!1`1 = P!1 - 2
[-2]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   ((trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))) >>
         Stop[event])
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictpremid_middle.3.1.2.2.1.1.1 :  

[-1]  i!1`1 = P!1 - 2
[-2]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   rho_premid(v!1)(E(public(car(i!2`4)), nlist(i!2`2)))
{2}   R_premid(v!1)
              (trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))))
{3}   trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))) >>
       (Stop[event] # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.2.1.1.1 :  

[-1]  i!1`1 = P!1 - 2
[-2]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
[1]   rho_premid(v!1)(E(public(car(i!2`4)), nlist(i!2`2)))

Rerunning step: (lemma "listprops[Nonce].elt_append2"
                 ("l1" "(:i!1`2:)" "l2" "i!2`2" "t" "n_mid"))
Applying listprops[Nonce].elt_append2 where 
  l1 gets (: i!1`2 :),
  l2 gets i!2`2,
  t gets n_mid,
this simplifies to: 
restrictpremid_middle.3.1.2.2.1.1.1 :  

{-1}  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  i!1`1 = P!1 - 2
[-3]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
[1]   rho_premid(v!1)(E(public(car(i!2`4)), nlist(i!2`2)))

Rerunning step: (grind :if-match nil :exclude "elt")
append rewrites append((: :), i!2`2)
  to i!2`2
append rewrites append((: i!1`2 :), i!2`2)
  to cons(i!1`2, i!2`2)
E rewrites E(public(car(i!2`4)), nlist(i!2`2))
  to code(public(car(i!2`4)), nlist(i!2`2))
rho_premid rewrites rho_premid(v!1)(nlist(i!2`2))
  to NOT elt(i!2`2, n_mid)
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_premid rewrites rho_premid(v!1)(code(public(car(i!2`4)), nlist(i!2`2)))
  to NOT elt(i!2`2, n_mid)
rho_premid rewrites rho_premid(v!1)(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_premid rewrites rho_premid(v!1)(nlist(cons(i!1`2, i!2`2)))
  to FALSE
rho_premid rewrites 
  rho_premid(v!1)
            (conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
  to FALSE
E rewrites E(public(car(i!2`4)), nlist(i!2`2))
  to code(public(car(i!2`4)), nlist(i!2`2))
rho_premid rewrites rho_premid(v!1)(nlist(i!2`2))
  to TRUE
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_premid rewrites rho_premid(v!1)(code(public(car(i!2`4)), nlist(i!2`2)))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpremid_middle.3.1.2.2.1.1.1.

restrictpremid_middle.3.1.2.2.1.1.2 :  

[-1]  i!1`1 = P!1 - 2
[-2]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   (Stop[event] # R_premid(v!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
{2}   R_premid(v!1)
              (trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))))
{3}   trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))) >>
       (Stop[event] # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.2.1.1.2 :  

  |-------
[1]   (Stop[event] # R_premid(v!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictpremid_middle.3.1.2.2.1.1.2.


This completes the proof of restrictpremid_middle.3.1.2.2.1.1.

restrictpremid_middle.3.1.2.2.1.2 :  

[-1]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   i!1`1 = P!1 - 2
{2}   ((trans(u!1, car(i!2`4),
              E(public(car(i!2`4)),
                conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                     nlist(i!2`2))))
         >> Stop[event])
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictpremid_middle.3.1.2.2.1.2.1 :  

[-1]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   rho_premid(v!1)
                (E(public(car(i!2`4)),
                   conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                        nlist(i!2`2))))
{2}   R_premid(v!1)
              (trans(u!1, car(i!2`4),
                     E(public(car(i!2`4)),
                       conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                            nlist(i!2`2)))))
{3}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                   nlist(i!2`2))))
       >> (Stop[event] # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   i!1`1 = P!1 - 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.2.1.2.1 :  

[-1]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
[1]   rho_premid(v!1)
                (E(public(car(i!2`4)),
                   conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                        nlist(i!2`2))))
[2]   i!1`1 = P!1 - 2

Rerunning step: (lemma "listprops[Nonce].elt_append2"
                 ("l1" "(:i!1`2:)" "l2" "i!2`2" "t" "n_mid"))
Applying listprops[Nonce].elt_append2 where 
  l1 gets (: i!1`2 :),
  l2 gets i!2`2,
  t gets n_mid,
this simplifies to: 
restrictpremid_middle.3.1.2.2.1.2.1 :  

{-1}  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
[1]   rho_premid(v!1)
                (E(public(car(i!2`4)),
                   conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                        nlist(i!2`2))))
[2]   i!1`1 = P!1 - 2

Rerunning step: (expand "E")
Expanding the definition of E,
this simplifies to: 
restrictpremid_middle.3.1.2.2.1.2.1 :  

[-1]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   rho_premid(v!1)
                (code(public(car(i!2`4)),
                      conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                           nlist(i!2`2))))
[2]   i!1`1 = P!1 - 2

Rerunning step: (expand "rho_premid" 1)
Expanding the definition of rho_premid,
this simplifies to: 
restrictpremid_middle.3.1.2.2.1.2.1 :  

[-1]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   rho_premid(v!1)
                (conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                      nlist(i!2`2)))
       OR
       (EXISTS (i: {x: nat | mid < x AND x <= p}):
          public(car(i!2`4)) = public(hu(rem(p)(i))) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                   nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
             conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                  nlist(i!2`2))
              =
              conc(nlist(append(nl1, cons(n_mid, nl2))),
                   ilist(remove(hu_list, rem(p)(i)))))
        OR
        EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
          public(car(i!2`4)) = public(hu(i)) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                   nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
             conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                  nlist(i!2`2))
              =
              conc(ilist(remove(hu_list, i)),
                   nlist(append(nl1, cons(n_mid, nl2))))
[2]   i!1`1 = P!1 - 2

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictpremid_middle.3.1.2.2.1.2.1 :  

[-1]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   rho_premid(v!1)
                (conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                      nlist(i!2`2)))
{2}   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`4)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
{3}   EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(car(i!2`4)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2))
            =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))
[4]   i!1`1 = P!1 - 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.2.1.2.1 :  

[-1]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
[1]   rho_premid(v!1)
                (conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                      nlist(i!2`2)))
[2]   i!1`1 = P!1 - 2

Rerunning step: (grind :exclude "elt")
append rewrites append((: :), i!2`2)
  to i!2`2
append rewrites append((: i!1`2 :), i!2`2)
  to cons(i!1`2, i!2`2)
rho_premid rewrites 
  rho_premid(v!1)(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
  to TRUE
rho_premid rewrites rho_premid(v!1)(nlist(i!2`2))
  to NOT elt(i!2`2, n_mid)
rho_premid rewrites 
  rho_premid(v!1)
            (conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                  nlist(i!2`2)))
  to NOT elt(i!2`2, n_mid)
rho_premid rewrites rho_premid(v!1)(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_premid rewrites rho_premid(v!1)(nlist(cons(i!1`2, i!2`2)))
  to FALSE
rho_premid rewrites 
  rho_premid(v!1)
            (conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
  to FALSE
rho_premid rewrites 
  rho_premid(v!1)(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
  to TRUE
rho_premid rewrites rho_premid(v!1)(nlist(i!2`2))
  to TRUE
rho_premid rewrites 
  rho_premid(v!1)
            (conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                  nlist(i!2`2)))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpremid_middle.3.1.2.2.1.2.1.

restrictpremid_middle.3.1.2.2.1.2.2 :  

[-1]  rho_premid(v!1)
                (conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   (Stop[event] # R_premid(v!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
{2}   R_premid(v!1)
              (trans(u!1, car(i!2`4),
                     E(public(car(i!2`4)),
                       conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                            nlist(i!2`2)))))
{3}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                   nlist(i!2`2))))
       >> (Stop[event] # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   i!1`1 = P!1 - 2

Rerunning step: (delete - 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.2.1.2.2 :  

  |-------
[1]   (Stop[event] # R_premid(v!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictpremid_middle.3.1.2.2.1.2.2.


This completes the proof of restrictpremid_middle.3.1.2.2.1.2.


This completes the proof of restrictpremid_middle.3.1.2.2.1.

restrictpremid_middle.3.1.2.2.2 :  

{-1}  EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(u!1) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictpremid_middle.3.1.2.2.2 :  

{-1}  public(u!1) = public(hu(rem(p)(i!3)))
{-2}  conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, rem(p)(i!3))))
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (delete -1 -3 -4 -5 -6 -7 +)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.2.2 :  

[-1]  conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, rem(p)(i!3))))
  |-------

Rerunning step: (decompose-equality -1)
Applying decompose-equality,

This completes the proof of restrictpremid_middle.3.1.2.2.2.

restrictpremid_middle.3.1.2.2.3 :  

{-1}  EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(u!1) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (delete -2 -3 -4 1 3 4)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.2.3 :  

[-1]  EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(u!1) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))
[-2]  i!1`1 < P!1 - 1
[-3]  2 <= P!1
  |-------
[1]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictpremid_middle.3.1.2.2.3 :  

{-1}  public(u!1) = public(hu(i!3))
{-2}  conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
       conc(ilist(remove(hu_list, i!3)),
            nlist(append(nl1!1, cons(n_mid, nl2!1))))
[-3]  i!1`1 < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (assert :flush? t)
Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
restrictpremid_middle.3.1.2.2.3 :  

[-1]  public(u!1) = public(hu(i!3))
[-2]  conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
       conc(ilist(remove(hu_list, i!3)),
            nlist(append(nl1!1, cons(n_mid, nl2!1))))
[-3]  i!1`1 < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictpremid_middle.3.1.2.2.3 :  

{-1}  ilist(append(i!2`3, i!2`4)) = ilist(remove(hu_list, i!3))
{-2}  nlist(cons(i!1`2, i!2`2)) = nlist(append(nl1!1, cons(n_mid, nl2!1)))
[-3]  public(u!1) = public(hu(i!3))
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictpremid_middle.3.1.2.2.3 :  

{-1}  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-2]  nlist(cons(i!1`2, i!2`2)) = nlist(append(nl1!1, cons(n_mid, nl2!1)))
[-3]  public(u!1) = public(hu(i!3))
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictpremid_middle.3.1.2.2.3 :  

{-1}  cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-2]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-3]  public(u!1) = public(hu(i!3))
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (typepred "i!2`2" "i!2`3" "i!2`4" "nl1!1" "nl2!1"
                 "hu_list" "v!1" "i!3")
Adding type constraints for  i!2`2, i!2`3, i!2`4, nl1!1, nl2!1, hu_list, v!1, i!3,
this simplifies to: 
restrictpremid_middle.3.1.2.2.3 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`2)
{-2}  length(i!2`2) = P!1 - 1 - i!1`1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`3)
{-4}  length(i!2`3) = i!1`1
{-5}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`4)
{-6}  length(i!2`4) = P!1 - 1 - i!1`1
{-7}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl1!1)
{-8}  length(nl1!1) = mid - i!3
{-9}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
{-10} length(nl2!1) = -1 - mid + p
{-11} every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-12} (length(hu_list) = p)
{-13} FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
{-14} v!1 < mid
{-15} 0 < i!3
{-16} i!3 <= v!1
[-17] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-18] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-19] public(u!1) = public(hu(i!3))
[-20] i!1`1 < P!1 - 1
[-21] 2 <= P!1
  |-------
[1]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (delete -1 -3 -5 -7 -9 -11 -13 -15 -19)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.2.3 :  

[-1]  length(i!2`2) = P!1 - 1 - i!1`1
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  length(nl1!1) = mid - i!3
[-5]  length(nl2!1) = -1 - mid + p
[-6]  (length(hu_list) = p)
[-7]  v!1 < mid
[-8]  i!3 <= v!1
[-9]  cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-11] i!1`1 < P!1 - 1
[-12] 2 <= P!1
  |-------
[1]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (case "P!1=p" "i!3=i!1`1")
Case splitting on 
   P!1 = p, 
   i!3 = i!1`1, 
this yields  3 subgoals: 
restrictpremid_middle.3.1.2.2.3.1 :  

{-1}  i!3 = i!1`1
{-2}  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  v!1 < mid
[-10] i!3 <= v!1
[-11] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-12] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
[1]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (lemma "select_right_nonce2" ("P" "P!1"))
Applying select_right_nonce2 where 
  P gets P!1,
this simplifies to: 
restrictpremid_middle.3.1.2.2.3.1 :  

{-1}  (P!1 = p IMPLIES floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid)
       AND
       floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1 AND
        floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  length(nl1!1) = mid - i!3
[-8]  length(nl2!1) = -1 - mid + p
[-9]  (length(hu_list) = p)
[-10] v!1 < mid
[-11] i!3 <= v!1
[-12] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-13] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-14] i!1`1 < P!1 - 1
[-15] 2 <= P!1
  |-------
[1]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpremid_middle.3.1.2.2.3.1 :  

{-1}  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid
{-2}  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
{-3}  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`2) = P!1 - 1 - i!1`1
[-7]  length(i!2`3) = i!1`1
[-8]  length(i!2`4) = P!1 - 1 - i!1`1
[-9]  length(nl1!1) = mid - i!3
[-10] length(nl2!1) = -1 - mid + p
[-11] (length(hu_list) = p)
[-12] v!1 < mid
[-13] i!3 <= v!1
[-14] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-15] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-16] i!1`1 < P!1 - 1
[-17] 2 <= P!1
  |-------
[1]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictpremid_middle.3.1.2.2.3.1 :  

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`2) = P!1 - 1 - i!1`1
[-7]  length(i!2`3) = i!1`1
[-8]  length(i!2`4) = P!1 - 1 - i!1`1
[-9]  length(nl1!1) = mid - i!3
[-10] length(nl2!1) = -1 - mid + p
[-11] (length(hu_list) = p)
[-12] v!1 < mid
[-13] i!3 <= v!1
[-14] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-15] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-16] i!1`1 < P!1 - 1
[-17] 2 <= P!1
  |-------
{1}   i!1`1 <= mid

Rerunning step: (delete -1 -2 -3 -5 -6 -7 -8 -9 -10 -11 -14 -15 -16 -17)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.2.3.1 :  

[-1]  i!3 = i!1`1
[-2]  v!1 < mid
[-3]  i!3 <= v!1
  |-------
[1]   i!1`1 <= mid

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.3.1.2.2.3.1.

restrictpremid_middle.3.1.2.2.3.2 :  

{-1}  P!1 = p
[-2]  length(i!2`2) = P!1 - 1 - i!1`1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  length(nl1!1) = mid - i!3
[-6]  length(nl2!1) = -1 - mid + p
[-7]  (length(hu_list) = p)
[-8]  v!1 < mid
[-9]  i!3 <= v!1
[-10] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
{1}   i!3 = i!1`1
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (lemma "listprops[Identity].equality_length"
                 ("l1" "cons(i!1`2,i!2`2)" "l2"
                  "append(nl1!1,cons(n_mid,nl2!1))"))
Applying listprops[Identity].equality_length where 
  l1 gets cons(i!1`2, i!2`2),
  l2 gets append(nl1!1, cons(n_mid, nl2!1)),
this simplifies to: 
restrictpremid_middle.3.1.2.2.3.2 :  

{-1}  cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1)) IMPLIES
       length[Identity](cons(i!1`2, i!2`2)) =
        length[Identity](append(nl1!1, cons(n_mid, nl2!1)))
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  v!1 < mid
[-10] i!3 <= v!1
[-11] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-12] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
[1]   i!3 = i!1`1
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpremid_middle.3.1.2.2.3.2 :  

{-1}  length[Identity](cons(i!1`2, i!2`2)) =
       length[Identity](append(nl1!1, cons(n_mid, nl2!1)))
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  v!1 < mid
[-10] i!3 <= v!1
[-11] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-12] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
[1]   i!3 = i!1`1
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets cons(n_mid, nl2!1),
l1: list[T] gets nl1!1,
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictpremid_middle.3.1.2.2.3.2 :  

{-1}  length[Identity](cons(i!1`2, i!2`2)) =
       length(cons(n_mid, nl2!1)) + length(nl1!1)
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  v!1 < mid
[-10] i!3 <= v!1
[-11] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-12] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
[1]   i!3 = i!1`1
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (expand "length" -1 (1 2))
Expanding the definition of length,
this simplifies to: 
restrictpremid_middle.3.1.2.2.3.2 :  

{-1}  length[Identity](i!2`2) = length(nl1!1) + length[Nonce](nl2!1)
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  v!1 < mid
[-10] i!3 <= v!1
[-11] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-12] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
[1]   i!3 = i!1`1
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (delete -4 -5 -8 -9 -10 -11 -12 -13 -14 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.2.3.2 :  

[-1]  length[Identity](i!2`2) = length(nl1!1) + length[Nonce](nl2!1)
[-2]  P!1 = p
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(nl1!1) = mid - i!3
[-5]  length(nl2!1) = -1 - mid + p
  |-------
[1]   i!3 = i!1`1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.3.1.2.2.3.2.

restrictpremid_middle.3.1.2.2.3.3 :  

[-1]  length(i!2`2) = P!1 - 1 - i!1`1
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  length(nl1!1) = mid - i!3
[-5]  length(nl2!1) = -1 - mid + p
[-6]  (length(hu_list) = p)
[-7]  v!1 < mid
[-8]  i!3 <= v!1
[-9]  cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-11] i!1`1 < P!1 - 1
[-12] 2 <= P!1
  |-------
{1}   P!1 = p
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (lemma "listprops[Identity].equality_length"
                 ("l1" "append(i!2`3,i!2`4)" "l2"
                  "remove(hu_list,i!3)"))
Applying listprops[Identity].equality_length where 
  l1 gets append(i!2`3, i!2`4),
  l2 gets remove(hu_list, i!3),
this simplifies to: 
restrictpremid_middle.3.1.2.2.3.3 :  

{-1}  append(i!2`3, i!2`4) = remove(hu_list, i!3) IMPLIES
       length[Identity](append(i!2`3, i!2`4)) =
        length[Identity](remove(hu_list, i!3))
[-2]  length(i!2`2) = P!1 - 1 - i!1`1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  length(nl1!1) = mid - i!3
[-6]  length(nl2!1) = -1 - mid + p
[-7]  (length(hu_list) = p)
[-8]  v!1 < mid
[-9]  i!3 <= v!1
[-10] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
[1]   P!1 = p
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpremid_middle.3.1.2.2.3.3 :  

{-1}  length[Identity](append(i!2`3, i!2`4)) =
       length[Identity](remove(hu_list, i!3))
[-2]  length(i!2`2) = P!1 - 1 - i!1`1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  length(nl1!1) = mid - i!3
[-6]  length(nl2!1) = -1 - mid + p
[-7]  (length(hu_list) = p)
[-8]  v!1 < mid
[-9]  i!3 <= v!1
[-10] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
[1]   P!1 = p
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets i!2`4,
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictpremid_middle.3.1.2.2.3.3 :  

{-1}  length(i!2`3) + length(i!2`4) = length[Identity](remove(hu_list, i!3))
[-2]  length(i!2`2) = P!1 - 1 - i!1`1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  length(nl1!1) = mid - i!3
[-6]  length(nl2!1) = -1 - mid + p
[-7]  (length(hu_list) = p)
[-8]  v!1 < mid
[-9]  i!3 <= v!1
[-10] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
[1]   P!1 = p
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (rewrite "length_remove" -1 :dir rl)
Found matching substitution:
i: below[length(c)] gets i!3,
c: (cons?[T]) gets hu_list,
Rewriting using length_remove, matching in -1,
this yields  2 subgoals: 
restrictpremid_middle.3.1.2.2.3.3.1 :  

{-1}  length(i!2`3) + length(i!2`4) = length[Identity](hu_list) - 1
[-2]  length(i!2`2) = P!1 - 1 - i!1`1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  length(nl1!1) = mid - i!3
[-6]  length(nl2!1) = -1 - mid + p
[-7]  (length(hu_list) = p)
[-8]  v!1 < mid
[-9]  i!3 <= v!1
[-10] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
[1]   P!1 = p
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (delete -2 -5 -6 -8 -9 -10 -11 -12 -13 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.2.3.3.1 :  

[-1]  length(i!2`3) + length(i!2`4) = length[Identity](hu_list) - 1
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  (length(hu_list) = p)
  |-------
[1]   P!1 = p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.3.1.2.2.3.3.1.

restrictpremid_middle.3.1.2.2.3.3.2 :  

[-1]  length(i!2`3) + length(i!2`4) = length[Identity](remove(hu_list, i!3))
[-2]  length(i!2`2) = P!1 - 1 - i!1`1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  length(nl1!1) = mid - i!3
[-6]  length(nl2!1) = -1 - mid + p
[-7]  (length(hu_list) = p)
[-8]  v!1 < mid
[-9]  i!3 <= v!1
[-10] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
{1}   cons?[Identity](hu_list)
[2]   P!1 = p
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (typepred "p")
Adding type constraints for  p,
this simplifies to: 
restrictpremid_middle.3.1.2.2.3.3.2 :  

{-1}  3 <= p
[-2]  length(i!2`3) + length(i!2`4) = length[Identity](remove(hu_list, i!3))
[-3]  length(i!2`2) = P!1 - 1 - i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid - i!3
[-7]  length(nl2!1) = -1 - mid + p
[-8]  (length(hu_list) = p)
[-9]  v!1 < mid
[-10] i!3 <= v!1
[-11] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-12] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
[1]   cons?[Identity](hu_list)
[2]   P!1 = p
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (lemma "more_list_props[Identity].length_non_zero"
                 ("l" "hu_list"))
Applying more_list_props[Identity].length_non_zero where 
  l gets hu_list,
this simplifies to: 
restrictpremid_middle.3.1.2.2.3.3.2 :  

{-1}  length(hu_list) > 0 IFF cons?(hu_list)
[-2]  3 <= p
[-3]  length(i!2`3) + length(i!2`4) = length[Identity](remove(hu_list, i!3))
[-4]  length(i!2`2) = P!1 - 1 - i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  length(nl1!1) = mid - i!3
[-8]  length(nl2!1) = -1 - mid + p
[-9]  (length(hu_list) = p)
[-10] v!1 < mid
[-11] i!3 <= v!1
[-12] cons(i!1`2, i!2`2) = append(nl1!1, cons(n_mid, nl2!1))
[-13] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-14] i!1`1 < P!1 - 1
[-15] 2 <= P!1
  |-------
[1]   cons?[Identity](hu_list)
[2]   P!1 = p
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (delete -3 -4 -5 -6 -7 -8 -10 -11 -12 -13 -14 -15 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.1.2.2.3.3.2 :  

[-1]  length(hu_list) > 0 IFF cons?(hu_list)
[-2]  3 <= p
[-3]  (length(hu_list) = p)
  |-------
[1]   cons?[Identity](hu_list)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.3.1.2.2.3.3.2.


This completes the proof of restrictpremid_middle.3.1.2.2.3.3.


This completes the proof of restrictpremid_middle.3.1.2.2.3.


This completes the proof of restrictpremid_middle.3.1.2.2.


This completes the proof of restrictpremid_middle.3.1.2.


This completes the proof of restrictpremid_middle.3.1.

restrictpremid_middle.3.2 :  

{-1}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-2}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
{1}   cons?[Identity](i!2`4)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (signal(running(i!1`1, append(i`3, cons(u!1, i`4)),
                          nth(i`1,
                              floor(1 - 2 * ((mid - 1) / (p - 2))
                                    +
                                    ((mid - 1) / (p - 2)) * P!1))))
            >>
            (trans(u!1, car(i`4),
                   E(public(car(i`4)),
                     conc(nlist(append(i`1, (: i!1`2 :))),
                          ilist(append(i`3, cons(u!1, cdr(i`4)))))))
              >>
              (rec(u!1, nth(i`3, i!1`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(i`3, i`4)),
                          nlist(cons(i!1`2, i`2)))))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete -1 -2 -3 -5 2 3 4 5)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.2 :  

[-1]  i!1`1 < P!1 - 1
  |-------
[1]   cons?[Identity](i!2`4)

Rerunning step: (nonemptylist "i!2`4")
Relating existence of a tail to a list's length,

This completes the proof of restrictpremid_middle.3.2.

restrictpremid_middle.3.3 :  

{-1}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-2}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
{1}   floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       length[Nonce](i!2`1)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (signal(running(i!1`1, append(i`3, cons(u!1, i`4)),
                          nth(i`1,
                              floor(1 - 2 * ((mid - 1) / (p - 2))
                                    +
                                    ((mid - 1) / (p - 2)) * P!1))))
            >>
            (trans(u!1, car(i`4),
                   E(public(car(i`4)),
                     conc(nlist(append(i`1, (: i!1`2 :))),
                          ilist(append(i`3, cons(u!1, cdr(i`4)))))))
              >>
              (rec(u!1, nth(i`3, i!1`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(i`3, i`4)),
                          nlist(cons(i!1`2, i`2)))))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (typepred "i!2`1")
Adding type constraints for  i!2`1,
this simplifies to: 
restrictpremid_middle.3.3 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`1)
{-2}  length(i!2`1) = i!1`1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       length[Nonce](i!2`1)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (signal(running(i!1`1, append(i`3, cons(u!1, i`4)),
                          nth(i`1,
                              floor(1 - 2 * ((mid - 1) / (p - 2))
                                    +
                                    ((mid - 1) / (p - 2)) * P!1))))
            >>
            (trans(u!1, car(i`4),
                   E(public(car(i`4)),
                     conc(nlist(append(i`1, (: i!1`2 :))),
                          ilist(append(i`3, cons(u!1, cdr(i`4)))))))
              >>
              (rec(u!1, nth(i`3, i!1`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(i`3, i`4)),
                          nlist(cons(i!1`2, i`2)))))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete -1 -3 -4 -5 -6 -7 3 4 5)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.3 :  

[-1]  length(i!2`1) = i!1`1
  |-------
[1]   floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       length[Nonce](i!2`1)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.3.3.

restrictpremid_middle.3.4 :  

{-1}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-2}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
{1}   i!1`1 - 1 < length[Identity](i!2`3)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (signal(running(i!1`1, append(i`3, cons(u!1, i`4)),
                          nth(i`1,
                              floor(1 - 2 * ((mid - 1) / (p - 2))
                                    +
                                    ((mid - 1) / (p - 2)) * P!1))))
            >>
            (trans(u!1, car(i`4),
                   E(public(car(i`4)),
                     conc(nlist(append(i`1, (: i!1`2 :))),
                          ilist(append(i`3, cons(u!1, cdr(i`4)))))))
              >>
              (rec(u!1, nth(i`3, i!1`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(i`3, i`4)),
                          nlist(cons(i!1`2, i`2)))))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (typepred "i!2`3")
Adding type constraints for  i!2`3,
this simplifies to: 
restrictpremid_middle.3.4 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`3)
{-2}  length(i!2`3) = i!1`1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   i!1`1 - 1 < length[Identity](i!2`3)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (signal(running(i!1`1, append(i`3, cons(u!1, i`4)),
                          nth(i`1,
                              floor(1 - 2 * ((mid - 1) / (p - 2))
                                    +
                                    ((mid - 1) / (p - 2)) * P!1))))
            >>
            (trans(u!1, car(i`4),
                   E(public(car(i`4)),
                     conc(nlist(append(i`1, (: i!1`2 :))),
                          ilist(append(i`3, cons(u!1, cdr(i`4)))))))
              >>
              (rec(u!1, nth(i`3, i!1`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(i`3, i`4)),
                          nlist(cons(i!1`2, i`2)))))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete -1 -3 -4 -5 -6 -7 2 3 4 5)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.4 :  

[-1]  length(i!2`3) = i!1`1
  |-------
[1]   i!1`1 - 1 < length[Identity](i!2`3)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_middle.3.4.

restrictpremid_middle.3.5 :  

{-1}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-2}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
{1}   FORALL (nl1: {x: list[Nonce] | length[Nonce](x) = i!1`1},
              nl2: {x: list[Nonce] | length[Nonce](x) = P!1 - 1 - i!1`1},
              il1: {x: list[Identity] | length[Identity](x) = i!1`1},
              il2:
                {x: list[Identity] |
                   length[Identity](x) = P!1 - 1 - i!1`1}):
        cons?[Identity](il2)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1: {x: list[Identity] | length(x) = i!1`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (signal(running(i!1`1, append(il1, cons(u!1, il2)),
                          nth(nl1,
                              floor(1 - 2 * ((mid - 1) / (p - 2))
                                    +
                                    ((mid - 1) / (p - 2)) * P!1))))
            >>
            (trans(u!1, car(il2),
                   E(public(car(il2)),
                     conc(nlist(append(nl1, (: i!1`2 :))),
                          ilist(append(il1, cons(u!1, cdr(il2)))))))
              >>
              (rec(u!1, nth(il1, i!1`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(il1, il2)),
                          nlist(cons(i!1`2, nl2)))))
                >>
                ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictpremid_middle.3.5 :  

[-1]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
{1}   cons?[Identity](il2!1)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1: {x: list[Identity] | length(x) = i!1`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (signal(running(i!1`1, append(il1, cons(u!1, il2)),
                          nth(nl1,
                              floor(1 - 2 * ((mid - 1) / (p - 2))
                                    +
                                    ((mid - 1) / (p - 2)) * P!1))))
            >>
            (trans(u!1, car(il2),
                   E(public(car(il2)),
                     conc(nlist(append(nl1, (: i!1`2 :))),
                          ilist(append(il1, cons(u!1, cdr(il2)))))))
              >>
              (rec(u!1, nth(il1, i!1`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(il1, il2)),
                          nlist(cons(i!1`2, nl2)))))
                >>
                ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete -1 -2 -3 -5 2 3 4 5)
Deleting some formulas,
this simplifies to: 
restrictpremid_middle.3.5 :  

[-1]  i!1`1 < P!1 - 1
  |-------
[1]   cons?[Identity](il2!1)

Rerunning step: (nonemptylist "il2!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictpremid_middle.3.5.


This completes the proof of restrictpremid_middle.3.

Q.E.D.


Run time  = 61.21 secs.
Real time = 69.20 secs.
nil
pvs(62): 
Installing rewrite rule sets.singleton_rew (all instances)
restrictpremid_last :  

  |-------
{1}   FORALL (P: nat_from_2, u: Identity, v: below[mid]):
        ((Interleave! (nnP: Nonces(P, u, P - 1)): UROLE_LAST(P, u, nnP)) #
          R_premid(v))
         |> RankUser(rho_premid(v))

Rerunning step: (auto-rewrite-theory "sets")
Rewriting relative to the theory: sets,
this simplifies to: 
restrictpremid_last :  

  |-------
[1]   FORALL (P: nat_from_2, u: Identity, v: below[mid]):
        ((Interleave! (nnP: Nonces(P, u, P - 1)): UROLE_LAST(P, u, nnP)) #
          R_premid(v))
         |> RankUser(rho_premid(v))

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictpremid_last :  

  |-------
{1}   ((Interleave! (nnP: Nonces(P!1, u!1, P!1 - 1)):
          UROLE_LAST(P!1, u!1, nnP))
        # R_premid(v!1))
       |> RankUser(rho_premid(v!1))

Rerunning step: (expand "RankUser")
Expanding the definition of RankUser,
this simplifies to: 
restrictpremid_last :  

  |-------
{1}   ((Interleave! (nnP: Nonces(P!1, u!1, P!1 - 1)):
          UROLE_LAST(P!1, u!1, nnP))
        # R_premid(v!1))
       |>
       LAMBDA (tr: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(tr)
          =>
          every(LAMBDA (e: event):
                  complement(rec?)(e) => rho_premid(v!1)(msg(e)))
               (tr)

Rerunning step: (interleaving2)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
Applying interleaving rule,
this simplifies to: 
restrictpremid_last :  

  |-------
{1}   UROLE_LAST(P!1, u!1, i!1) # R_premid(v!1) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (expand "UROLE_LAST")
Expanding the definition of UROLE_LAST,
this simplifies to: 
restrictpremid_last :  

  |-------
{1}   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (signal(running(P!1 - 1, append(il, (: u!1 :)),
                          nth(nl,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(nlist(append(nl, (: i!1 :))),
                          ilist(append(cdr(il), (: u!1 :))))))
              >>
              (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (typepred "P!1")
Adding type constraints for  P!1,
this simplifies to: 
restrictpremid_last :  

{-1}  2 <= P!1
  |-------
[1]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (signal(running(P!1 - 1, append(il, (: u!1 :)),
                          nth(nl,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(nlist(append(nl, (: i!1 :))),
                          ilist(append(cdr(il), (: u!1 :))))))
              >>
              (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (lemma "select_right_nonce3" ("P" "P!1"))
Applying select_right_nonce3 where 
  P gets P!1,
this simplifies to: 
restrictpremid_last :  

{-1}  (P!1 = p IMPLIES floor((mid / (p - 1)) * (P!1 - 1)) = mid) AND
       floor((mid / (p - 1)) * (P!1 - 1)) >= 0 AND
        floor((mid / (p - 1)) * (P!1 - 1)) < P!1 - 1
[-2]  2 <= P!1
  |-------
[1]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (signal(running(P!1 - 1, append(il, (: u!1 :)),
                          nth(nl,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(nlist(append(nl, (: i!1 :))),
                          ilist(append(cdr(il), (: u!1 :))))))
              >>
              (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictpremid_last :  

{-1}  (P!1 = p IMPLIES floor((mid / (p - 1)) * (P!1 - 1)) = mid)
{-2}  floor((mid / (p - 1)) * (P!1 - 1)) >= 0
{-3}  floor((mid / (p - 1)) * (P!1 - 1)) < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (signal(running(P!1 - 1, append(il, (: u!1 :)),
                          nth(nl,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(nlist(append(nl, (: i!1 :))),
                          ilist(append(cdr(il), (: u!1 :))))))
              >>
              (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictpremid_last :  

[-1]  floor((mid / (p - 1)) * (P!1 - 1)) >= 0
[-2]  floor((mid / (p - 1)) * (P!1 - 1)) < P!1 - 1
[-3]  2 <= P!1
  |-------
[1]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (signal(running(P!1 - 1, append(il, (: u!1 :)),
                          nth(nl,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(nlist(append(nl, (: i!1 :))),
                          ilist(append(cdr(il), (: u!1 :))))))
              >>
              (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (choice3)
Applying choice rule,
this yields  7 subgoals: 
restrictpremid_last.1 :  

[-1]  floor((mid / (p - 1)) * (P!1 - 1)) >= 0
[-2]  floor((mid / (p - 1)) * (P!1 - 1)) < P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   (rec(u!1, nth(i!2`2, P!1 - 2),
           E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
        >>
        (signal(running(P!1 - 1, append(i!2`2, (: u!1 :)),
                        nth(i!2`1,
                            floor((mid / (p - 1)) * P!1 -
                                   (mid / (p - 1))))))
          >>
          (trans(u!1, car(i!2`2),
                 E(public(car(i!2`2)),
                   conc(nlist(append(i!2`1, (: i!1 :))),
                        ilist(append(cdr(i!2`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i!2`2, P!1 - 2),
                 E(public(u!1), nlist((: i!1 :))))
              >> Stop[event]))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictpremid_last.1 :  

{-1}  rho_premid(v!1)(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
{-2}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
{-3}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  2 <= P!1
  |-------
{1}   ((signal(running(P!1 - 1, append(i!2`2, (: u!1 :)),
                       nth(i!2`1,
                           floor((mid / (p - 1)) * P!1 -
                                  (mid / (p - 1))))))
         >>
         (trans(u!1, car(i!2`2),
                E(public(car(i!2`2)),
                  conc(nlist(append(i!2`1, (: i!1 :))),
                       ilist(append(cdr(i!2`2), (: u!1 :))))))
           >>
           (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
             >> Stop[event])))
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
{2}   R_premid(v!1)
              (rec(u!1, nth(i!2`2, P!1 - 2),
                   E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2)))))
{3}   rec(u!1, nth(i!2`2, P!1 - 2),
          E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
       >>
       ((signal(running(P!1 - 1, append(i!2`2, (: u!1 :)),
                        nth(i!2`1,
                            floor((mid / (p - 1)) * P!1 -
                                   (mid / (p - 1))))))
          >>
          (trans(u!1, car(i!2`2),
                 E(public(car(i!2`2)),
                   conc(nlist(append(i!2`1, (: i!1 :))),
                        ilist(append(cdr(i!2`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i!2`2, P!1 - 2),
                 E(public(u!1), nlist((: i!1 :))))
              >> Stop[event])))
         # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.1 :  

[-1]  rho_premid(v!1)(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   ((signal(running(P!1 - 1, append(i!2`2, (: u!1 :)),
                       nth(i!2`1,
                           floor((mid / (p - 1)) * P!1 -
                                  (mid / (p - 1))))))
         >>
         (trans(u!1, car(i!2`2),
                E(public(car(i!2`2)),
                  conc(nlist(append(i!2`1, (: i!1 :))),
                       ilist(append(cdr(i!2`2), (: u!1 :))))))
           >>
           (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
             >> Stop[event])))
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictpremid_last.1.1 :  

[-1]  rho_premid(v!1)(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  2 <= P!1
  |-------
{1}   rho_premid(v!1)
                (running(P!1 - 1, append(i!2`2, (: u!1 :)),
                         nth(i!2`1,
                             floor((mid / (p - 1)) * P!1 -
                                    (mid / (p - 1))))))
{2}   R_premid(v!1)
              (signal(running(P!1 - 1, append(i!2`2, (: u!1 :)),
                              nth(i!2`1,
                                  floor((mid / (p - 1)) * P!1
                                        -
                                        (mid / (p - 1)))))))
{3}   signal(running(P!1 - 1, append(i!2`2, (: u!1 :)),
                     nth(i!2`1,
                         floor((mid / (p - 1)) * P!1 - (mid / (p - 1))))))
       >>
       ((trans(u!1, car(i!2`2),
               E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :))))))
          >>
          (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
            >> Stop[event]))
         # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.1.1 :  

  |-------
[1]   rho_premid(v!1)
                (running(P!1 - 1, append(i!2`2, (: u!1 :)),
                         nth(i!2`1,
                             floor((mid / (p - 1)) * P!1 -
                                    (mid / (p - 1))))))

Rerunning step: (expand "rho_premid")
Expanding the definition of rho_premid,
this simplifies to: 
restrictpremid_last.1.1 :  

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictpremid_last.1.1.

restrictpremid_last.1.2 :  

[-1]  rho_premid(v!1)(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  2 <= P!1
  |-------
{1}   ((trans(u!1, car(i!2`2),
              E(public(car(i!2`2)),
                conc(nlist(append(i!2`1, (: i!1 :))),
                     ilist(append(cdr(i!2`2), (: u!1 :))))))
         >>
         (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
           >> Stop[event]))
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
{2}   R_premid(v!1)
              (signal(running(P!1 - 1, append(i!2`2, (: u!1 :)),
                              nth(i!2`1,
                                  floor((mid / (p - 1)) * P!1
                                        -
                                        (mid / (p - 1)))))))
{3}   signal(running(P!1 - 1, append(i!2`2, (: u!1 :)),
                     nth(i!2`1,
                         floor((mid / (p - 1)) * P!1 - (mid / (p - 1))))))
       >>
       ((trans(u!1, car(i!2`2),
               E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :))))))
          >>
          (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
            >> Stop[event]))
         # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.1.2 :  

[-1]  rho_premid(v!1)(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   ((trans(u!1, car(i!2`2),
              E(public(car(i!2`2)),
                conc(nlist(append(i!2`1, (: i!1 :))),
                     ilist(append(cdr(i!2`2), (: u!1 :))))))
         >>
         (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
           >> Stop[event]))
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictpremid_last.1.2.1 :  

[-1]  rho_premid(v!1)(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  2 <= P!1
  |-------
{1}   rho_premid(v!1)
                (E(public(car(i!2`2)),
                   conc(nlist(append(i!2`1, (: i!1 :))),
                        ilist(append(cdr(i!2`2), (: u!1 :))))))
{2}   R_premid(v!1)
              (trans(u!1, car(i!2`2),
                     E(public(car(i!2`2)),
                       conc(nlist(append(i!2`1, (: i!1 :))),
                            ilist(append(cdr(i!2`2), (: u!1 :)))))))
{3}   trans(u!1, car(i!2`2),
            E(public(car(i!2`2)),
              conc(nlist(append(i!2`1, (: i!1 :))),
                   ilist(append(cdr(i!2`2), (: u!1 :))))))
       >>
       ((rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :)))) >>
          Stop[event])
         # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.1.2.1 :  

[-1]  rho_premid(v!1)(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (E(public(car(i!2`2)),
                   conc(nlist(append(i!2`1, (: i!1 :))),
                        ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (expand "E")
Expanding the definition of E,
this simplifies to: 
restrictpremid_last.1.2.1 :  

{-1}  rho_premid(v!1)(code(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  2 <= P!1
  |-------
{1}   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(nlist(append(i!2`1, (: i!1 :))),
                           ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (comment "explore the 3 options that could make -1 true")
Adding comment: explore the 3 options that could make -1 true
this simplifies to: 
restrictpremid_last.1.2.1 : 
;;; explore the 3 options that could make -1 true

[-1]  rho_premid(v!1)(code(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(nlist(append(i!2`1, (: i!1 :))),
                           ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (expand "rho_premid" -1)
Expanding the definition of rho_premid,
this simplifies to: 
restrictpremid_last.1.2.1 : 
;;; explore the 3 options that could make -1 true

{-1}  rho_premid(v!1)(conc(nlist(i!2`1), ilist(i!2`2))) OR
       (EXISTS (i: {x: nat | mid < x AND x <= p}):
          public(u!1) = public(hu(rem(p)(i))) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                   nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
             conc(nlist(i!2`1), ilist(i!2`2)) =
              conc(nlist(append(nl1, cons(n_mid, nl2))),
                   ilist(remove(hu_list, rem(p)(i)))))
        OR
        EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
          public(u!1) = public(hu(i)) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                   nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
             conc(nlist(i!2`1), ilist(i!2`2)) =
              conc(ilist(remove(hu_list, i)),
                   nlist(append(nl1, cons(n_mid, nl2))))
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(nlist(append(i!2`1, (: i!1 :))),
                           ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (split)
Splitting conjunctions,
this yields  3 subgoals: 
restrictpremid_last.1.2.1.1 : 
;;; explore the 3 options that could make -1 true

{-1}  rho_premid(v!1)(conc(nlist(i!2`1), ilist(i!2`2)))
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(nlist(append(i!2`1, (: i!1 :))),
                           ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (expand "rho_premid" -1)
Expanding the definition of rho_premid,
this simplifies to: 
restrictpremid_last.1.2.1.1 : 
;;; explore the 3 options that could make -1 true

{-1}  rho_premid(v!1)(nlist(i!2`1)) AND rho_premid(v!1)(ilist(i!2`2))
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(nlist(append(i!2`1, (: i!1 :))),
                           ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (typepred "i!1" "mid")
Adding type constraints for  i!1, mid,
this simplifies to: 
restrictpremid_last.1.2.1.1 : 
;;; explore the 3 options that could make -1 true

{-1}  IRpart(P!1, u!1, P!1 - 1)(i!1)
{-2}  0 < mid
{-3}  mid < p - 1
[-4]  rho_premid(v!1)(nlist(i!2`1)) AND rho_premid(v!1)(ilist(i!2`2))
[-5]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-6]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(nlist(append(i!2`1, (: i!1 :))),
                           ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (expand "rho_premid" 1)
Expanding the definition of rho_premid,
this simplifies to: 
restrictpremid_last.1.2.1.1 : 
;;; explore the 3 options that could make -1 true

[-1]  IRpart(P!1, u!1, P!1 - 1)(i!1)
[-2]  0 < mid
[-3]  mid < p - 1
[-4]  rho_premid(v!1)(nlist(i!2`1)) AND rho_premid(v!1)(ilist(i!2`2))
[-5]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-6]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-7]  2 <= P!1
  |-------
{1}   rho_premid(v!1)
                (conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :)))))
       OR
       (EXISTS (i: {x: nat | mid < x AND x <= p}):
          public(car(i!2`2)) = public(hu(rem(p)(i))) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                   nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
             conc(nlist(append(i!2`1, (: i!1 :))),
                  ilist(append(cdr(i!2`2), (: u!1 :))))
              =
              conc(nlist(append(nl1, cons(n_mid, nl2))),
                   ilist(remove(hu_list, rem(p)(i)))))
        OR
        EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
          public(car(i!2`2)) = public(hu(i)) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                   nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
             conc(nlist(append(i!2`1, (: i!1 :))),
                  ilist(append(cdr(i!2`2), (: u!1 :))))
              =
              conc(ilist(remove(hu_list, i)),
                   nlist(append(nl1, cons(n_mid, nl2))))

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictpremid_last.1.2.1.1 : 
;;; explore the 3 options that could make -1 true

[-1]  IRpart(P!1, u!1, P!1 - 1)(i!1)
[-2]  0 < mid
[-3]  mid < p - 1
{-4}  rho_premid(v!1)(nlist(i!2`1))
{-5}  rho_premid(v!1)(ilist(i!2`2))
[-6]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-7]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-8]  2 <= P!1
  |-------
{1}   rho_premid(v!1)
                (conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :)))))
{2}   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`2)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
{3}   EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(car(i!2`2)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :))))
            =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))

Rerunning step: (delete -2 -6 -7 -8 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.1.2.1.1 : 
;;; explore the 3 options that could make -1 true

[-1]  IRpart(P!1, u!1, P!1 - 1)(i!1)
[-2]  mid < p - 1
[-3]  rho_premid(v!1)(nlist(i!2`1))
[-4]  rho_premid(v!1)(ilist(i!2`2))
  |-------
[1]   rho_premid(v!1)
                (conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :)))))

Rerunning step: (lemma "n_prop" ("P" "P!1" "u" "u!1" "r" "P!1-1"))
Applying n_prop where 
  P gets P!1,
  u gets u!1,
  r gets P!1 - 1,
this simplifies to: 
restrictpremid_last.1.2.1.1 : 
;;; explore the 3 options that could make -1 true

{-1}  (P!1 /= p OR P!1 - 1 /= mid) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, P!1 - 1)(n_mid)
[-2]  IRpart(P!1, u!1, P!1 - 1)(i!1)
[-3]  mid < p - 1
[-4]  rho_premid(v!1)(nlist(i!2`1))
[-5]  rho_premid(v!1)(ilist(i!2`2))
  |-------
[1]   rho_premid(v!1)
                (conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :)))))

Rerunning step: (lemma "listprops[Nonce].elt_append3"
                 ("l1" "i!2`1" "l2" "(:i!1:)" "t" "n_mid"))
Applying listprops[Nonce].elt_append3 where 
  l1 gets i!2`1,
  l2 gets (: i!1 :),
  t gets n_mid,
this simplifies to: 
restrictpremid_last.1.2.1.1 : 
;;; explore the 3 options that could make -1 true

{-1}  elt(append(i!2`1, (: i!1 :)), n_mid) IMPLIES
       elt(i!2`1, n_mid) OR elt((: i!1 :), n_mid)
[-2]  (P!1 /= p OR P!1 - 1 /= mid) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, P!1 - 1)(n_mid)
[-3]  IRpart(P!1, u!1, P!1 - 1)(i!1)
[-4]  mid < p - 1
[-5]  rho_premid(v!1)(nlist(i!2`1))
[-6]  rho_premid(v!1)(ilist(i!2`2))
  |-------
[1]   rho_premid(v!1)
                (conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :)))))

Rerunning step: (lemma "listprops[Nonce].elt_singleton"
                 ("t1" "i!1" "t2" "n_mid"))
Applying listprops[Nonce].elt_singleton where 
  t1 gets i!1,
  t2 gets n_mid,
this simplifies to: 
restrictpremid_last.1.2.1.1 : 
;;; explore the 3 options that could make -1 true

{-1}  elt((: i!1 :), n_mid) IFF i!1 = n_mid
[-2]  elt(append(i!2`1, (: i!1 :)), n_mid) IMPLIES
       elt(i!2`1, n_mid) OR elt((: i!1 :), n_mid)
[-3]  (P!1 /= p OR P!1 - 1 /= mid) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, P!1 - 1)(n_mid)
[-4]  IRpart(P!1, u!1, P!1 - 1)(i!1)
[-5]  mid < p - 1
[-6]  rho_premid(v!1)(nlist(i!2`1))
[-7]  rho_premid(v!1)(ilist(i!2`2))
  |-------
[1]   rho_premid(v!1)
                (conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :)))))

Rerunning step: (grind :exclude "elt")
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
/= rewrites P!1 /= p
  to NOT (P!1 = p)
/= rewrites P!1 - 1 /= mid
  to TRUE
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
rho_premid rewrites rho_premid(v!1)(nlist(i!2`1))
  to FALSE
/= rewrites P!1 /= p
  to NOT (P!1 = p)
/= rewrites P!1 - 1 /= mid
  to TRUE
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
rho_premid rewrites rho_premid(v!1)(nlist(i!2`1))
  to NOT elt(i!2`1, n_mid)
rho_premid rewrites rho_premid(v!1)(ilist(i!2`2))
  to TRUE
rho_premid rewrites rho_premid(v!1)(nlist(append(i!2`1, (: i!1 :))))
  to TRUE
rho_premid rewrites rho_premid(v!1)(ilist(append(cdr(i!2`2), (: u!1 :))))
  to TRUE
rho_premid rewrites 
  rho_premid(v!1)
            (conc(nlist(append(i!2`1, (: i!1 :))),
                  ilist(append(cdr(i!2`2), (: u!1 :)))))
  to TRUE
/= rewrites P!1 /= p
  to NOT (P!1 = p)
/= rewrites P!1 - 1 /= mid
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpremid_last.1.2.1.1.

restrictpremid_last.1.2.1.2 : 
;;; explore the 3 options that could make -1 true

{-1}  EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(u!1) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(i!2`1), ilist(i!2`2)) =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(nlist(append(i!2`1, (: i!1 :))),
                           ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictpremid_last.1.2.1.2 : 
;;; explore the 3 options that could make -1 true

{-1}  public(u!1) = public(hu(rem(p)(i!3)))
{-2}  conc(nlist(i!2`1), ilist(i!2`2)) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, rem(p)(i!3))))
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-4]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(nlist(append(i!2`1, (: i!1 :))),
                           ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictpremid_last.1.2.1.2 : 
;;; explore the 3 options that could make -1 true

{-1}  u!1 = hu(rem(p)(i!3))
[-2]  conc(nlist(i!2`1), ilist(i!2`2)) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, rem(p)(i!3))))
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-4]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(nlist(append(i!2`1, (: i!1 :))),
                           ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictpremid_last.1.2.1.2 : 
;;; explore the 3 options that could make -1 true

{-1}  nlist(i!2`1) = nlist(append(nl1!1, cons(n_mid, nl2!1)))
{-2}  ilist(i!2`2) = ilist(remove(hu_list, rem(p)(i!3)))
[-3]  u!1 = hu(rem(p)(i!3))
[-4]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-5]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(nlist(append(i!2`1, (: i!1 :))),
                           ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictpremid_last.1.2.1.2 : 
;;; explore the 3 options that could make -1 true

{-1}  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-2]  ilist(i!2`2) = ilist(remove(hu_list, rem(p)(i!3)))
[-3]  u!1 = hu(rem(p)(i!3))
[-4]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-5]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(nlist(append(i!2`1, (: i!1 :))),
                           ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictpremid_last.1.2.1.2 : 
;;; explore the 3 options that could make -1 true

{-1}  i!2`2 = remove(hu_list, rem(p)(i!3))
[-2]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-3]  u!1 = hu(rem(p)(i!3))
[-4]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-5]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(nlist(append(i!2`1, (: i!1 :))),
                           ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (expand "rho_premid" 1)
Expanding the definition of rho_premid,
this simplifies to: 
restrictpremid_last.1.2.1.2 : 
;;; explore the 3 options that could make -1 true

[-1]  i!2`2 = remove(hu_list, rem(p)(i!3))
[-2]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-3]  u!1 = hu(rem(p)(i!3))
[-4]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-5]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   rho_premid(v!1)
                (conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :)))))
       OR
       (EXISTS (i: {x: nat | mid < x AND x <= p}):
          public(car(i!2`2)) = public(hu(rem(p)(i))) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                   nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
             conc(nlist(append(i!2`1, (: i!1 :))),
                  ilist(append(cdr(i!2`2), (: u!1 :))))
              =
              conc(nlist(append(nl1, cons(n_mid, nl2))),
                   ilist(remove(hu_list, rem(p)(i)))))
        OR
        EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
          public(car(i!2`2)) = public(hu(i)) AND
           EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                   nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
             conc(nlist(append(i!2`1, (: i!1 :))),
                  ilist(append(cdr(i!2`2), (: u!1 :))))
              =
              conc(ilist(remove(hu_list, i)),
                   nlist(append(nl1, cons(n_mid, nl2))))

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictpremid_last.1.2.1.2 : 
;;; explore the 3 options that could make -1 true

[-1]  i!2`2 = remove(hu_list, rem(p)(i!3))
[-2]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-3]  u!1 = hu(rem(p)(i!3))
[-4]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-5]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   rho_premid(v!1)
                (conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :)))))
{2}   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`2)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
{3}   EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(car(i!2`2)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :))))
            =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))

Rerunning step: (typepred "i!2`1" "i!2`2" "nl1!1" "nl2!1" "mid"
                 "hu_list" "p")
Adding type constraints for  i!2`1, i!2`2, nl1!1, nl2!1, mid, hu_list, p,
this simplifies to: 
restrictpremid_last.1.2.1.2 : 
;;; explore the 3 options that could make -1 true

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`1)
{-2}  length(i!2`1) = P!1 - 1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`2)
{-4}  length(i!2`2) = P!1 - 1
{-5}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl1!1)
{-6}  length(nl1!1) = mid
{-7}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
{-8}  length(nl2!1) = -1 - mid + i!3
{-9}  0 < mid
{-10} mid < p - 1
{-11} every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-12} (length(hu_list) = p)
{-13} FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
{-14} 3 <= p
[-15] i!2`2 = remove(hu_list, rem(p)(i!3))
[-16] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-17] u!1 = hu(rem(p)(i!3))
[-18] floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-19] floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-20] 2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :)))))
[2]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`2)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))
[3]   EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(car(i!2`2)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :))))
            =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))

Rerunning step: (delete -1 -3 -5 -7 -9 -11 -18 -19 1 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.1.2.1.2 : 
;;; explore the 3 options that could make -1 true

[-1]  length(i!2`1) = P!1 - 1
[-2]  length(i!2`2) = P!1 - 1
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + i!3
[-5]  mid < p - 1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  3 <= p
[-9]  i!2`2 = remove(hu_list, rem(p)(i!3))
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(rem(p)(i!3))
[-12] 2 <= P!1
  |-------
[1]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`2)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))

Rerunning step: (comment "the outgoing message is sent to 0 = p mod p, establish some equalities first")
Adding comment: the outgoing message is sent to 0 = p mod p, establish some equalities first
this simplifies to: 
restrictpremid_last.1.2.1.2 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  length(i!2`1) = P!1 - 1
[-2]  length(i!2`2) = P!1 - 1
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + i!3
[-5]  mid < p - 1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  3 <= p
[-9]  i!2`2 = remove(hu_list, rem(p)(i!3))
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(rem(p)(i!3))
[-12] 2 <= P!1
  |-------
[1]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`2)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))

Rerunning step: (case "P!1=p" "i!3=p-1" "rem(p)(i!3)=p-1" "rem(p)(p)=0")
Case splitting on 
   P!1 = p, 
   i!3 = p - 1, 
   rem(p)(i!3) = p - 1, 
   rem(p)(p) = 0, 
this yields  5 subgoals: 
restrictpremid_last.1.2.1.2.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

{-1}  rem(p)(p) = 0
{-2}  rem(p)(i!3) = p - 1
{-3}  i!3 = p - 1
{-4}  P!1 = p
[-5]  length(i!2`1) = P!1 - 1
[-6]  length(i!2`2) = P!1 - 1
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -1 - mid + i!3
[-9]  mid < p - 1
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] 3 <= p
[-13] i!2`2 = remove(hu_list, rem(p)(i!3))
[-14] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-15] u!1 = hu(rem(p)(i!3))
[-16] 2 <= P!1
  |-------
[1]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`2)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))

Rerunning step: (inst 1 "p")
Instantiating the top quantifier in 1 with the terms: 
 p,
this simplifies to: 
restrictpremid_last.1.2.1.2.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  rem(p)(p) = 0
[-2]  rem(p)(i!3) = p - 1
[-3]  i!3 = p - 1
[-4]  P!1 = p
[-5]  length(i!2`1) = P!1 - 1
[-6]  length(i!2`2) = P!1 - 1
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -1 - mid + i!3
[-9]  mid < p - 1
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] 3 <= p
[-13] i!2`2 = remove(hu_list, rem(p)(i!3))
[-14] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-15] u!1 = hu(rem(p)(i!3))
[-16] 2 <= P!1
  |-------
{1}   public(car(i!2`2)) = public(hu(rem(p)(p))) AND
       EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
               nl2: {x: list[Nonce] | length(x) = -1 - mid + p}):
         conc(nlist(append(i!2`1, (: i!1 :))),
              ilist(append(cdr(i!2`2), (: u!1 :))))
          =
          conc(nlist(append(nl1, cons(n_mid, nl2))),
               ilist(remove(hu_list, rem(p)(p))))

Rerunning step: (replace* -1 -2 -3 -4 -15)
Repeatedly applying the replace rule,
this simplifies to: 
restrictpremid_last.1.2.1.2.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  rem(p)(p) = 0
{-2}  rem(p)(p - 1) = p - 1
[-3]  i!3 = p - 1
[-4]  P!1 = p
{-5}  length(i!2`1) = p - 1
{-6}  length(i!2`2) = p - 1
[-7]  length(nl1!1) = mid
{-8}  length(nl2!1) = -1 - mid + (p - 1)
[-9]  mid < p - 1
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] 3 <= p
{-13} i!2`2 = remove(hu_list, p - 1)
[-14] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
{-15} u!1 = hu(p - 1)
{-16} 2 <= p
  |-------
{1}   public(car(i!2`2)) = public(hu(0)) AND
       EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
               nl2: {x: list[Nonce] | length(x) = -1 - mid + p}):
         conc(nlist(append(i!2`1, (: i!1 :))),
              ilist(append(cdr(i!2`2), (: hu(p - 1) :))))
          =
          conc(nlist(append(nl1, cons(n_mid, nl2))),
               ilist(remove(hu_list, 0)))

Rerunning step: (delete -1 -2 -3)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.1.2.1.2.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  P!1 = p
[-2]  length(i!2`1) = p - 1
[-3]  length(i!2`2) = p - 1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + (p - 1)
[-6]  mid < p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  3 <= p
[-10] i!2`2 = remove(hu_list, p - 1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(p - 1)
[-13] 2 <= p
  |-------
[1]   public(car(i!2`2)) = public(hu(0)) AND
       EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
               nl2: {x: list[Nonce] | length(x) = -1 - mid + p}):
         conc(nlist(append(i!2`1, (: i!1 :))),
              ilist(append(cdr(i!2`2), (: hu(p - 1) :))))
          =
          conc(nlist(append(nl1, cons(n_mid, nl2))),
               ilist(remove(hu_list, 0)))

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
restrictpremid_last.1.2.1.2.1.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  P!1 = p
[-2]  length(i!2`1) = p - 1
[-3]  length(i!2`2) = p - 1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + (p - 1)
[-6]  mid < p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  3 <= p
[-10] i!2`2 = remove(hu_list, p - 1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(p - 1)
[-13] 2 <= p
  |-------
{1}   public(car(i!2`2)) = public(hu(0))

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  P!1 = p
[-2]  length(i!2`1) = p - 1
[-3]  length(i!2`2) = p - 1
[-4]  length(nl1!1) = mid
{-5}  length(nl2!1) = -2 - mid + p
[-6]  mid < p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  3 <= p
[-10] i!2`2 = remove(hu_list, p - 1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(p - 1)
[-13] 2 <= p
  |-------
{1}   car(i!2`2) = hu(0)

Rerunning step: (inst -8 "0")
Instantiating the top quantifier in -8 with the terms: 
 0,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  P!1 = p
[-2]  length(i!2`1) = p - 1
[-3]  length(i!2`2) = p - 1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -2 - mid + p
[-6]  mid < p - 1
[-7]  (length(hu_list) = p)
{-8}  nth(hu_list, 0) = hu(0)
[-9]  3 <= p
[-10] i!2`2 = remove(hu_list, p - 1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(p - 1)
[-13] 2 <= p
  |-------
[1]   car(i!2`2) = hu(0)

Rerunning step: (replace -10 1)
Replacing using formula -10,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  P!1 = p
[-2]  length(i!2`1) = p - 1
[-3]  length(i!2`2) = p - 1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -2 - mid + p
[-6]  mid < p - 1
[-7]  (length(hu_list) = p)
[-8]  nth(hu_list, 0) = hu(0)
[-9]  3 <= p
[-10] i!2`2 = remove(hu_list, p - 1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(p - 1)
[-13] 2 <= p
  |-------
{1}   car(remove(hu_list, p - 1)) = hu(0)

Rerunning step: (replace -8 1 rl)
Replacing using formula -8,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  P!1 = p
[-2]  length(i!2`1) = p - 1
[-3]  length(i!2`2) = p - 1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -2 - mid + p
[-6]  mid < p - 1
[-7]  (length(hu_list) = p)
[-8]  nth(hu_list, 0) = hu(0)
[-9]  3 <= p
[-10] i!2`2 = remove(hu_list, p - 1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(p - 1)
[-13] 2 <= p
  |-------
{1}   car(remove(hu_list, p - 1)) = nth(hu_list, 0)

Rerunning step: (delete -)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

  |-------
[1]   car(remove(hu_list, p - 1)) = nth(hu_list, 0)

Rerunning step: (grind)
remove rewrites remove(cdr(hu_list), p - 2)
  to cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), p - 3))
remove rewrites remove(hu_list, p - 1)
  to cons(car(hu_list),
           cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), p - 3)))
nth rewrites nth(hu_list, 0)
  to car(hu_list)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpremid_last.1.2.1.2.1.1.

restrictpremid_last.1.2.1.2.1.2 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  P!1 = p
[-2]  length(i!2`1) = p - 1
[-3]  length(i!2`2) = p - 1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + (p - 1)
[-6]  mid < p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  3 <= p
[-10] i!2`2 = remove(hu_list, p - 1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(p - 1)
[-13] 2 <= p
  |-------
{1}   EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
              nl2: {x: list[Nonce] | length(x) = -1 - mid + p}):
        conc(nlist(append(i!2`1, (: i!1 :))),
             ilist(append(cdr(i!2`2), (: hu(p - 1) :))))
         =
         conc(nlist(append(nl1, cons(n_mid, nl2))),
              ilist(remove(hu_list, 0)))

Rerunning step: (inst 1 "nl1!1" "append(nl2!1,(:i!1:))")
Instantiating the top quantifier in 1 with the terms: 
 nl1!1, append(nl2!1,(:i!1:)),
this yields  2 subgoals: 
restrictpremid_last.1.2.1.2.1.2.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  P!1 = p
[-2]  length(i!2`1) = p - 1
[-3]  length(i!2`2) = p - 1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + (p - 1)
[-6]  mid < p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  3 <= p
[-10] i!2`2 = remove(hu_list, p - 1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(p - 1)
[-13] 2 <= p
  |-------
{1}   conc(nlist(append(i!2`1, (: i!1 :))),
           ilist(append(cdr(i!2`2), (: hu(p - 1) :))))
       =
       conc(nlist(append(nl1!1, cons(n_mid, append(nl2!1, (: i!1 :))))),
            ilist(remove(hu_list, 0)))

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this yields  2 subgoals: 
restrictpremid_last.1.2.1.2.1.2.1.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  P!1 = p
[-2]  length(i!2`1) = p - 1
[-3]  length(i!2`2) = p - 1
[-4]  length(nl1!1) = mid
{-5}  length(nl2!1) = -2 - mid + p
[-6]  mid < p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  3 <= p
[-10] i!2`2 = remove(hu_list, p - 1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(p - 1)
[-13] 2 <= p
  |-------
{1}   nlist(append(i!2`1, (: i!1 :))) =
       nlist(append(nl1!1, cons(n_mid, append(nl2!1, (: i!1 :)))))

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  P!1 = p
[-2]  length(i!2`1) = p - 1
[-3]  length(i!2`2) = p - 1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -2 - mid + p
[-6]  mid < p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  3 <= p
[-10] i!2`2 = remove(hu_list, p - 1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(p - 1)
[-13] 2 <= p
  |-------
{1}   append(i!2`1, (: i!1 :)) =
       append(nl1!1, cons(n_mid, append(nl2!1, (: i!1 :))))

Rerunning step: (replace -11 1)
Replacing using formula -11,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  P!1 = p
[-2]  length(i!2`1) = p - 1
[-3]  length(i!2`2) = p - 1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -2 - mid + p
[-6]  mid < p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  3 <= p
[-10] i!2`2 = remove(hu_list, p - 1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(p - 1)
[-13] 2 <= p
  |-------
{1}   append(append(nl1!1, cons(n_mid, nl2!1)), (: i!1 :)) =
       append(nl1!1, cons(n_mid, append(nl2!1, (: i!1 :))))

Rerunning step: (rewrite "append_assoc" 1)
Found matching substitution:
l3: list[T] gets (: i!1 :),
l2: list[T] gets cons(n_mid, nl2!1),
l1: list[T] gets nl1!1,
Rewriting using append_assoc, matching in 1,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  P!1 = p
[-2]  length(i!2`1) = p - 1
[-3]  length(i!2`2) = p - 1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -2 - mid + p
[-6]  mid < p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  3 <= p
[-10] i!2`2 = remove(hu_list, p - 1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(p - 1)
[-13] 2 <= p
  |-------
{1}   append(nl1!1, append(cons(n_mid, nl2!1), (: i!1 :))) =
       append(nl1!1, cons(n_mid, append(nl2!1, (: i!1 :))))

Rerunning step: (expand "append" 1 2)
Expanding the definition of append,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  P!1 = p
[-2]  length(i!2`1) = p - 1
[-3]  length(i!2`2) = p - 1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -2 - mid + p
[-6]  mid < p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  3 <= p
[-10] i!2`2 = remove(hu_list, p - 1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(p - 1)
[-13] 2 <= p
  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictpremid_last.1.2.1.2.1.2.1.1.

restrictpremid_last.1.2.1.2.1.2.1.2 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  P!1 = p
[-2]  length(i!2`1) = p - 1
[-3]  length(i!2`2) = p - 1
[-4]  length(nl1!1) = mid
{-5}  length(nl2!1) = -2 - mid + p
[-6]  mid < p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  3 <= p
[-10] i!2`2 = remove(hu_list, p - 1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(p - 1)
[-13] 2 <= p
  |-------
{1}   ilist(append(cdr(i!2`2), (: hu(p - 1) :))) = ilist(remove(hu_list, 0))

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.2 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  P!1 = p
[-2]  length(i!2`1) = p - 1
[-3]  length(i!2`2) = p - 1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -2 - mid + p
[-6]  mid < p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  3 <= p
[-10] i!2`2 = remove(hu_list, p - 1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(p - 1)
[-13] 2 <= p
  |-------
{1}   append(cdr(i!2`2), (: hu(p - 1) :)) = remove(hu_list, 0)

Rerunning step: (expand "remove" 1)
Expanding the definition of remove,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.2 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  P!1 = p
[-2]  length(i!2`1) = p - 1
[-3]  length(i!2`2) = p - 1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -2 - mid + p
[-6]  mid < p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  3 <= p
[-10] i!2`2 = remove(hu_list, p - 1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(p - 1)
[-13] 2 <= p
  |-------
{1}   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (rewrite "length_nth_equality[Identity]" 1)
Found matching substitution:
l2: list[Identity] gets cdr(hu_list),
l1: list[Identity] gets append(cdr(i!2`2), (: hu(p - 1) :)),
Rewriting using length_nth_equality[Identity], matching in 1,
this yields  2 subgoals: 
restrictpremid_last.1.2.1.2.1.2.1.2.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  P!1 = p
[-2]  length(i!2`1) = p - 1
[-3]  length(i!2`2) = p - 1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -2 - mid + p
[-6]  mid < p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  3 <= p
[-10] i!2`2 = remove(hu_list, p - 1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(p - 1)
[-13] 2 <= p
  |-------
{1}   length[Identity](append(cdr(i!2`2), (: hu(p - 1) :))) =
       length[Identity](cdr(hu_list))
[2]   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets (: hu(p - 1) :),
l1: list[T] gets cdr(i!2`2),
Rewriting using length_append, matching in 1,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.2.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  P!1 = p
[-2]  length(i!2`1) = p - 1
[-3]  length(i!2`2) = p - 1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -2 - mid + p
[-6]  mid < p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  3 <= p
[-10] i!2`2 = remove(hu_list, p - 1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(p - 1)
[-13] 2 <= p
  |-------
{1}   length(cdr(i!2`2)) + length((: hu(p - 1) :)) =
       length[Identity](cdr(hu_list))
[2]   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (rewrite "length_cdr" 1)
Found matching substitution:
cons_l: (cons?[T]) gets i!2`2,
Rewriting using length_cdr, matching in 1,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.2.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  P!1 = p
[-2]  length(i!2`1) = p - 1
[-3]  length(i!2`2) = p - 1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -2 - mid + p
[-6]  mid < p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  3 <= p
[-10] i!2`2 = remove(hu_list, p - 1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(p - 1)
[-13] 2 <= p
  |-------
{1}   length(i!2`2) - 1 + length((: hu(p - 1) :)) =
       length[Identity](cdr(hu_list))
[2]   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (rewrite "length_cdr" 1)
Found matching substitution:
cons_l: (cons?[T]) gets hu_list,
Rewriting using length_cdr, matching in 1,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.2.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  P!1 = p
[-2]  length(i!2`1) = p - 1
[-3]  length(i!2`2) = p - 1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -2 - mid + p
[-6]  mid < p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  3 <= p
[-10] i!2`2 = remove(hu_list, p - 1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(p - 1)
[-13] 2 <= p
  |-------
{1}   length(i!2`2) - 1 + length((: hu(p - 1) :)) = length(hu_list) - 1
[2]   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (delete -1 -2 -4 -5 -6 -8 -9 -10 -11 -12 -13 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.2.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  length(i!2`2) = p - 1
[-2]  (length(hu_list) = p)
  |-------
[1]   length(i!2`2) - 1 + length((: hu(p - 1) :)) = length(hu_list) - 1

Rerunning step: (grind)
length rewrites length[Identity]((: :))
  to 0
length rewrites length((: hu(p - 1) :))
  to 1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpremid_last.1.2.1.2.1.2.1.2.1.

restrictpremid_last.1.2.1.2.1.2.1.2.2 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  P!1 = p
[-2]  length(i!2`1) = p - 1
[-3]  length(i!2`2) = p - 1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -2 - mid + p
[-6]  mid < p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  3 <= p
[-10] i!2`2 = remove(hu_list, p - 1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(p - 1)
[-13] 2 <= p
  |-------
{1}   FORALL (i:
                below[length[Identity]
                          (append(cdr(i!2`2), (: hu(p - 1) :)))]):
        nth(append(cdr(i!2`2), (: hu(p - 1) :)), i) = nth(cdr(hu_list), i)
[2]   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.2.2 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

{-1}  i!4 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-2]  P!1 = p
[-3]  length(i!2`1) = p - 1
[-4]  length(i!2`2) = p - 1
[-5]  length(nl1!1) = mid
[-6]  length(nl2!1) = -2 - mid + p
[-7]  mid < p - 1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] 3 <= p
[-11] i!2`2 = remove(hu_list, p - 1)
[-12] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-13] u!1 = hu(p - 1)
[-14] 2 <= p
  |-------
{1}   nth(append(cdr(i!2`2), (: hu(p - 1) :)), i!4) = nth(cdr(hu_list), i!4)
[2]   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (lemma "listprops[Identity].nth_append"
                 ("l1" "cdr(i!2`2)" "l2" "(:hu(p-1):)" "i" "i!4"))
Applying listprops[Identity].nth_append where 
  l1 gets cdr(i!2`2),
  l2 gets (: hu(p - 1) :),
  i gets i!4,
this yields  2 subgoals: 
restrictpremid_last.1.2.1.2.1.2.1.2.2.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

{-1}  nth(append(cdr(i!2`2), (: hu(p - 1) :)), i!4) =
       IF i!4 < length[Identity](cdr(i!2`2)) THEN nth(cdr(i!2`2), i!4)
       ELSE nth((: hu(p - 1) :), i!4 - length[Identity](cdr(i!2`2)))
       ENDIF
[-2]  i!4 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-3]  P!1 = p
[-4]  length(i!2`1) = p - 1
[-5]  length(i!2`2) = p - 1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -2 - mid + p
[-8]  mid < p - 1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] 3 <= p
[-12] i!2`2 = remove(hu_list, p - 1)
[-13] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-14] u!1 = hu(p - 1)
[-15] 2 <= p
  |-------
[1]   nth(append(cdr(i!2`2), (: hu(p - 1) :)), i!4) = nth(cdr(hu_list), i!4)
[2]   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.2.2.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  nth(append(cdr(i!2`2), (: hu(p - 1) :)), i!4) =
       IF i!4 < length[Identity](cdr(i!2`2)) THEN nth(cdr(i!2`2), i!4)
       ELSE nth((: hu(p - 1) :), i!4 - length[Identity](cdr(i!2`2)))
       ENDIF
[-2]  i!4 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-3]  P!1 = p
[-4]  length(i!2`1) = p - 1
[-5]  length(i!2`2) = p - 1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -2 - mid + p
[-8]  mid < p - 1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] 3 <= p
[-12] i!2`2 = remove(hu_list, p - 1)
[-13] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-14] u!1 = hu(p - 1)
[-15] 2 <= p
  |-------
{1}   IF i!4 < length[Identity](cdr(i!2`2)) THEN nth(cdr(i!2`2), i!4)
      ELSE nth((: hu(p - 1) :), i!4 - length[Identity](cdr(i!2`2)))
      ENDIF
       = nth(cdr(hu_list), i!4)
[2]   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.2.2.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  i!4 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-2]  P!1 = p
[-3]  length(i!2`1) = p - 1
[-4]  length(i!2`2) = p - 1
[-5]  length(nl1!1) = mid
[-6]  length(nl2!1) = -2 - mid + p
[-7]  mid < p - 1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] 3 <= p
[-11] i!2`2 = remove(hu_list, p - 1)
[-12] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-13] u!1 = hu(p - 1)
[-14] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](cdr(i!2`2)) THEN nth(cdr(i!2`2), i!4)
      ELSE nth((: hu(p - 1) :), i!4 - length[Identity](cdr(i!2`2)))
      ENDIF
       = nth(cdr(hu_list), i!4)
[2]   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (rewrite "length_cdr" 1)
Found matching substitution:
cons_l: (cons?[T]) gets i!2`2,
Rewriting using length_cdr, matching in 1,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.2.2.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  i!4 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-2]  P!1 = p
[-3]  length(i!2`1) = p - 1
[-4]  length(i!2`2) = p - 1
[-5]  length(nl1!1) = mid
[-6]  length(nl2!1) = -2 - mid + p
[-7]  mid < p - 1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] 3 <= p
[-11] i!2`2 = remove(hu_list, p - 1)
[-12] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-13] u!1 = hu(p - 1)
[-14] 2 <= p
  |-------
{1}   IF i!4 < length(i!2`2) - 1 THEN nth(cdr(i!2`2), i!4)
      ELSE nth((: hu(p - 1) :), i!4 - (length(i!2`2) - 1))
      ENDIF
       = nth(cdr(hu_list), i!4)
[2]   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (case "i!4<p-2 OR i!4=p-2")
Case splitting on 
   i!4 < p - 2 OR i!4 = p - 2, 
this yields  2 subgoals: 
restrictpremid_last.1.2.1.2.1.2.1.2.2.1.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

{-1}  i!4 < p - 2 OR i!4 = p - 2
[-2]  i!4 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-3]  P!1 = p
[-4]  length(i!2`1) = p - 1
[-5]  length(i!2`2) = p - 1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -2 - mid + p
[-8]  mid < p - 1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] 3 <= p
[-12] i!2`2 = remove(hu_list, p - 1)
[-13] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-14] u!1 = hu(p - 1)
[-15] 2 <= p
  |-------
[1]   IF i!4 < length(i!2`2) - 1 THEN nth(cdr(i!2`2), i!4)
      ELSE nth((: hu(p - 1) :), i!4 - (length(i!2`2) - 1))
      ENDIF
       = nth(cdr(hu_list), i!4)
[2]   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.2.2.1.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  i!4 < p - 2 OR i!4 = p - 2
[-2]  i!4 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-3]  P!1 = p
[-4]  length(i!2`1) = p - 1
[-5]  length(i!2`2) = p - 1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -2 - mid + p
[-8]  mid < p - 1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] 3 <= p
[-12] i!2`2 = remove(hu_list, p - 1)
[-13] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-14] u!1 = hu(p - 1)
[-15] 2 <= p
  |-------
[1]   IF i!4 < length(i!2`2) - 1 THEN nth(cdr(i!2`2), i!4)
      ELSE nth((: hu(p - 1) :), i!4 - (length(i!2`2) - 1))
      ENDIF
       = nth(cdr(hu_list), i!4)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,
this yields  2 subgoals: 
restrictpremid_last.1.2.1.2.1.2.1.2.2.1.1.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

{-1}  i!4 < p - 2
[-2]  i!4 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-3]  P!1 = p
[-4]  length(i!2`1) = p - 1
[-5]  length(i!2`2) = p - 1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -2 - mid + p
[-8]  mid < p - 1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] 3 <= p
[-12] i!2`2 = remove(hu_list, p - 1)
[-13] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-14] u!1 = hu(p - 1)
[-15] 2 <= p
  |-------
{1}   nth(cdr(i!2`2), i!4) = nth(cdr(hu_list), i!4)

Rerunning step: (replace -12 1)
Replacing using formula -12,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.2.2.1.1.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  i!4 < p - 2
[-2]  i!4 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-3]  P!1 = p
[-4]  length(i!2`1) = p - 1
[-5]  length(i!2`2) = p - 1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -2 - mid + p
[-8]  mid < p - 1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] 3 <= p
[-12] i!2`2 = remove(hu_list, p - 1)
[-13] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-14] u!1 = hu(p - 1)
[-15] 2 <= p
  |-------
{1}   nth(cdr(remove(hu_list, p - 1)), i!4) = nth(cdr(hu_list), i!4)

Rerunning step: (lemma "listprops[Identity].nth_remove"
                 ("l" "hu_list" "i" "p-1" "j" "i!4+1"))
Applying listprops[Identity].nth_remove where 
  l gets hu_list,
  i gets p - 1,
  j gets i!4 + 1,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.2.2.1.1.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

{-1}  nth(remove(hu_list, p - 1), i!4 + 1) =
       IF i!4 + 1 < p - 1 THEN nth(hu_list, i!4 + 1)
       ELSE nth(hu_list, i!4 + 1 + 1)
       ENDIF
[-2]  i!4 < p - 2
[-3]  i!4 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-4]  P!1 = p
[-5]  length(i!2`1) = p - 1
[-6]  length(i!2`2) = p - 1
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -2 - mid + p
[-9]  mid < p - 1
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] 3 <= p
[-13] i!2`2 = remove(hu_list, p - 1)
[-14] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-15] u!1 = hu(p - 1)
[-16] 2 <= p
  |-------
[1]   nth(cdr(remove(hu_list, p - 1)), i!4) = nth(cdr(hu_list), i!4)

Rerunning step: (expand "nth" -1 1)
Expanding the definition of nth,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.2.2.1.1.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

{-1}  nth(cdr(remove(hu_list, p - 1)), i!4) = nth(hu_list, 1 + i!4)
[-2]  i!4 < p - 2
[-3]  i!4 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-4]  P!1 = p
[-5]  length(i!2`1) = p - 1
[-6]  length(i!2`2) = p - 1
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -2 - mid + p
[-9]  mid < p - 1
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] 3 <= p
[-13] i!2`2 = remove(hu_list, p - 1)
[-14] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-15] u!1 = hu(p - 1)
[-16] 2 <= p
  |-------
[1]   nth(cdr(remove(hu_list, p - 1)), i!4) = nth(cdr(hu_list), i!4)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.2.2.1.1.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  nth(cdr(remove(hu_list, p - 1)), i!4) = nth(hu_list, 1 + i!4)
[-2]  i!4 < p - 2
[-3]  i!4 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-4]  P!1 = p
[-5]  length(i!2`1) = p - 1
[-6]  length(i!2`2) = p - 1
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -2 - mid + p
[-9]  mid < p - 1
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] 3 <= p
[-13] i!2`2 = remove(hu_list, p - 1)
[-14] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-15] u!1 = hu(p - 1)
[-16] 2 <= p
  |-------
{1}   nth(hu_list, 1 + i!4) = nth(cdr(hu_list), i!4)

Rerunning step: (delete -)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.2.2.1.1.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

  |-------
[1]   nth(hu_list, 1 + i!4) = nth(cdr(hu_list), i!4)

Rerunning step: (expand "nth" 1 1)
Expanding the definition of nth,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.2.2.1.1.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictpremid_last.1.2.1.2.1.2.1.2.2.1.1.1.

restrictpremid_last.1.2.1.2.1.2.1.2.2.1.1.2 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

{-1}  i!4 = p - 2
[-2]  i!4 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-3]  P!1 = p
[-4]  length(i!2`1) = p - 1
[-5]  length(i!2`2) = p - 1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -2 - mid + p
[-8]  mid < p - 1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] 3 <= p
[-12] i!2`2 = remove(hu_list, p - 1)
[-13] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-14] u!1 = hu(p - 1)
[-15] 2 <= p
  |-------
{1}   nth((: hu(p - 1) :), 1 - length(i!2`2) + i!4) = nth(cdr(hu_list), i!4)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.2.2.1.1.2 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  i!4 = p - 2
[-2]  i!4 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-3]  P!1 = p
[-4]  length(i!2`1) = p - 1
[-5]  length(i!2`2) = p - 1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -2 - mid + p
[-8]  mid < p - 1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] 3 <= p
[-12] i!2`2 = remove(hu_list, p - 1)
[-13] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-14] u!1 = hu(p - 1)
[-15] 2 <= p
  |-------
{1}   nth((: hu(p - 1) :), 1 - length(i!2`2) + (p - 2)) =
       nth(cdr(hu_list), p - 2)

Rerunning step: (replace -5 1)
Replacing using formula -5,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.2.2.1.1.2 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  i!4 = p - 2
[-2]  i!4 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-3]  P!1 = p
[-4]  length(i!2`1) = p - 1
[-5]  length(i!2`2) = p - 1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -2 - mid + p
[-8]  mid < p - 1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] 3 <= p
[-12] i!2`2 = remove(hu_list, p - 1)
[-13] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-14] u!1 = hu(p - 1)
[-15] 2 <= p
  |-------
{1}   nth((: hu(p - 1) :), 1 - (p - 1) + (p - 2)) = nth(cdr(hu_list), p - 2)

Rerunning step: (expand "nth" 1 1)
Expanding the definition of nth,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.2.2.1.1.2 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  i!4 = p - 2
[-2]  i!4 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-3]  P!1 = p
[-4]  length(i!2`1) = p - 1
[-5]  length(i!2`2) = p - 1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -2 - mid + p
[-8]  mid < p - 1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] 3 <= p
[-12] i!2`2 = remove(hu_list, p - 1)
[-13] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-14] u!1 = hu(p - 1)
[-15] 2 <= p
  |-------
{1}   hu(p - 1) = nth(cdr(hu_list), p - 2)

Rerunning step: (rewrite "nth_cdr" 1)
Found matching substitution:
i: below[length(c) - 1] gets p - 2,
c: (cons?[T]) gets hu_list,
Rewriting using nth_cdr, matching in 1,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.2.2.1.1.2 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  i!4 = p - 2
[-2]  i!4 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-3]  P!1 = p
[-4]  length(i!2`1) = p - 1
[-5]  length(i!2`2) = p - 1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -2 - mid + p
[-8]  mid < p - 1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] 3 <= p
[-12] i!2`2 = remove(hu_list, p - 1)
[-13] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-14] u!1 = hu(p - 1)
[-15] 2 <= p
  |-------
{1}   hu(p - 1) = nth(hu_list, p - 1)

Rerunning step: (inst -10 "p-1")
Instantiating the top quantifier in -10 with the terms: 
 p-1,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.2.2.1.1.2 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  i!4 = p - 2
[-2]  i!4 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-3]  P!1 = p
[-4]  length(i!2`1) = p - 1
[-5]  length(i!2`2) = p - 1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -2 - mid + p
[-8]  mid < p - 1
[-9]  (length(hu_list) = p)
{-10} nth(hu_list, p - 1) = hu(p - 1)
[-11] 3 <= p
[-12] i!2`2 = remove(hu_list, p - 1)
[-13] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-14] u!1 = hu(p - 1)
[-15] 2 <= p
  |-------
[1]   hu(p - 1) = nth(hu_list, p - 1)

Rerunning step: (replace -10 1)
Replacing using formula -10,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.2.2.1.1.2 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  i!4 = p - 2
[-2]  i!4 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-3]  P!1 = p
[-4]  length(i!2`1) = p - 1
[-5]  length(i!2`2) = p - 1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -2 - mid + p
[-8]  mid < p - 1
[-9]  (length(hu_list) = p)
[-10] nth(hu_list, p - 1) = hu(p - 1)
[-11] 3 <= p
[-12] i!2`2 = remove(hu_list, p - 1)
[-13] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-14] u!1 = hu(p - 1)
[-15] 2 <= p
  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictpremid_last.1.2.1.2.1.2.1.2.2.1.1.2.


This completes the proof of restrictpremid_last.1.2.1.2.1.2.1.2.2.1.1.

restrictpremid_last.1.2.1.2.1.2.1.2.2.1.2 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  i!4 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-2]  P!1 = p
[-3]  length(i!2`1) = p - 1
[-4]  length(i!2`2) = p - 1
[-5]  length(nl1!1) = mid
[-6]  length(nl2!1) = -2 - mid + p
[-7]  mid < p - 1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] 3 <= p
[-11] i!2`2 = remove(hu_list, p - 1)
[-12] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-13] u!1 = hu(p - 1)
[-14] 2 <= p
  |-------
{1}   i!4 < p - 2 OR i!4 = p - 2
[2]   IF i!4 < length(i!2`2) - 1 THEN nth(cdr(i!2`2), i!4)
      ELSE nth((: hu(p - 1) :), i!4 - (length(i!2`2) - 1))
      ENDIF
       = nth(cdr(hu_list), i!4)
[3]   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets (: hu(p - 1) :),
l1: list[T] gets cdr(i!2`2),
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.2.2.1.2 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

{-1}  i!4 < length(cdr(i!2`2)) + length((: hu(p - 1) :))
[-2]  P!1 = p
[-3]  length(i!2`1) = p - 1
[-4]  length(i!2`2) = p - 1
[-5]  length(nl1!1) = mid
[-6]  length(nl2!1) = -2 - mid + p
[-7]  mid < p - 1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] 3 <= p
[-11] i!2`2 = remove(hu_list, p - 1)
[-12] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-13] u!1 = hu(p - 1)
[-14] 2 <= p
  |-------
[1]   i!4 < p - 2 OR i!4 = p - 2
[2]   IF i!4 < length(i!2`2) - 1 THEN nth(cdr(i!2`2), i!4)
      ELSE nth((: hu(p - 1) :), i!4 - (length(i!2`2) - 1))
      ENDIF
       = nth(cdr(hu_list), i!4)
[3]   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (rewrite "length_cdr" -1)
Found matching substitution:
cons_l: (cons?[T]) gets i!2`2,
Rewriting using length_cdr, matching in -1,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.2.2.1.2 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

{-1}  i!4 < length(i!2`2) - 1 + length((: hu(p - 1) :))
[-2]  P!1 = p
[-3]  length(i!2`1) = p - 1
[-4]  length(i!2`2) = p - 1
[-5]  length(nl1!1) = mid
[-6]  length(nl2!1) = -2 - mid + p
[-7]  mid < p - 1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] 3 <= p
[-11] i!2`2 = remove(hu_list, p - 1)
[-12] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-13] u!1 = hu(p - 1)
[-14] 2 <= p
  |-------
[1]   i!4 < p - 2 OR i!4 = p - 2
[2]   IF i!4 < length(i!2`2) - 1 THEN nth(cdr(i!2`2), i!4)
      ELSE nth((: hu(p - 1) :), i!4 - (length(i!2`2) - 1))
      ENDIF
       = nth(cdr(hu_list), i!4)
[3]   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (delete -2 -3 -4 -5 -6 -7 -8 -9 -10 -12 -13 -14 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.2.2.1.2 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  i!4 < length(i!2`2) - 1 + length((: hu(p - 1) :))
[-2]  i!2`2 = remove(hu_list, p - 1)
  |-------
[1]   i!4 < p - 2 OR i!4 = p - 2

Rerunning step: (grind)
length rewrites length[Identity]((: :))
  to 0
length rewrites length((: hu(p - 1) :))
  to 1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpremid_last.1.2.1.2.1.2.1.2.2.1.2.


This completes the proof of restrictpremid_last.1.2.1.2.1.2.1.2.2.1.

restrictpremid_last.1.2.1.2.1.2.1.2.2.2T (TCC):   

[-1]  i!4 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-2]  P!1 = p
[-3]  length(i!2`1) = p - 1
[-4]  length(i!2`2) = p - 1
[-5]  length(nl1!1) = mid
[-6]  length(nl2!1) = -2 - mid + p
[-7]  mid < p - 1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] 3 <= p
[-11] i!2`2 = remove(hu_list, p - 1)
[-12] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-13] u!1 = hu(p - 1)
[-14] 2 <= p
  |-------
{1}   i!4 <
       length[Identity](cdr[Identity](i!2`2)) +
        length[Identity]((: hu(p - 1) :))
[2]   nth(append(cdr(i!2`2), (: hu(p - 1) :)), i!4) = nth(cdr(hu_list), i!4)
[3]   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (delete -2 -3 -4 -5 -6 -7 -8 -9 -10 -11 -12 -13 -14 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.1.2.2.2T : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  i!4 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
  |-------
[1]   i!4 <
       length[Identity](cdr[Identity](i!2`2)) +
        length[Identity]((: hu(p - 1) :))

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets (: hu(p - 1) :),
l1: list[T] gets cdr(i!2`2),
Rewriting using length_append, matching in -1,

This completes the proof of restrictpremid_last.1.2.1.2.1.2.1.2.2.2T.


This completes the proof of restrictpremid_last.1.2.1.2.1.2.1.2.2.


This completes the proof of restrictpremid_last.1.2.1.2.1.2.1.2.


This completes the proof of restrictpremid_last.1.2.1.2.1.2.1.

restrictpremid_last.1.2.1.2.1.2.2 (TCC):   

[-1]  P!1 = p
[-2]  length(i!2`1) = p - 1
[-3]  length(i!2`2) = p - 1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + (p - 1)
[-6]  mid < p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  3 <= p
[-10] i!2`2 = remove(hu_list, p - 1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(p - 1)
[-13] 2 <= p
  |-------
{1}   length[Nonce](append[Nonce](nl2!1, (: i!1 :))) = -1 - mid + p

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets (: i!1 :),
l1: list[T] gets nl2!1,
Rewriting using length_append, matching in 1,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.2 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  P!1 = p
[-2]  length(i!2`1) = p - 1
[-3]  length(i!2`2) = p - 1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + (p - 1)
[-6]  mid < p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  3 <= p
[-10] i!2`2 = remove(hu_list, p - 1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(p - 1)
[-13] 2 <= p
  |-------
{1}   length((: i!1 :)) + length(nl2!1) = -1 - mid + p

Rerunning step: (delete -1 -2 -3 -4 -6 -7 -8 -9 -10 -11 -12 -13)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.1.2.1.2.1.2.2 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  length(nl2!1) = -1 - mid + (p - 1)
  |-------
[1]   length((: i!1 :)) + length(nl2!1) = -1 - mid + p

Rerunning step: (grind)
length rewrites length[Identity]((: :))
  to 0
length rewrites length((: i!1 :))
  to 1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpremid_last.1.2.1.2.1.2.2.


This completes the proof of restrictpremid_last.1.2.1.2.1.2.


This completes the proof of restrictpremid_last.1.2.1.2.1.

restrictpremid_last.1.2.1.2.2 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

{-1}  rem(p)(i!3) = p - 1
{-2}  i!3 = p - 1
{-3}  P!1 = p
[-4]  length(i!2`1) = P!1 - 1
[-5]  length(i!2`2) = P!1 - 1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!3
[-8]  mid < p - 1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] 3 <= p
[-12] i!2`2 = remove(hu_list, rem(p)(i!3))
[-13] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-14] u!1 = hu(rem(p)(i!3))
[-15] 2 <= P!1
  |-------
{1}   rem(p)(p) = 0
[2]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`2)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.1.2.1.2.2 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

  |-------
[1]   rem(p)(p) = 0

Rerunning step: (rewrite "rem_def")
Found matching substitution:
r: mod(b) gets 0,
x: int gets p,
b: posnat gets p,
Rewriting using rem_def, matching in *,
this simplifies to: 
restrictpremid_last.1.2.1.2.2 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

  |-------
{1}   EXISTS q: p = p * q

Rerunning step: (inst 1 "1")
Instantiating the top quantifier in 1 with the terms: 
 1,
this simplifies to: 
restrictpremid_last.1.2.1.2.2 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

  |-------
{1}   p = p * 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_last.1.2.1.2.2.

restrictpremid_last.1.2.1.2.3 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

{-1}  i!3 = p - 1
{-2}  P!1 = p
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  length(nl1!1) = mid
[-6]  length(nl2!1) = -1 - mid + i!3
[-7]  mid < p - 1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] 3 <= p
[-11] i!2`2 = remove(hu_list, rem(p)(i!3))
[-12] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-13] u!1 = hu(rem(p)(i!3))
[-14] 2 <= P!1
  |-------
{1}   rem(p)(i!3) = p - 1
[2]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`2)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictpremid_last.1.2.1.2.3 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  i!3 = p - 1
[-2]  P!1 = p
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  length(nl1!1) = mid
[-6]  length(nl2!1) = -1 - mid + i!3
[-7]  mid < p - 1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] 3 <= p
[-11] i!2`2 = remove(hu_list, rem(p)(i!3))
[-12] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-13] u!1 = hu(rem(p)(i!3))
[-14] 2 <= P!1
  |-------
{1}   rem(p)(p - 1) = p - 1
[2]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`2)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.1.2.1.2.3 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

  |-------
[1]   rem(p)(p - 1) = p - 1

Rerunning step: (rewrite "rem_def")
Found matching substitution:
r: mod(b) gets p - 1,
x: int gets p - 1,
b: posnat gets p,
Rewriting using rem_def, matching in *,
this simplifies to: 
restrictpremid_last.1.2.1.2.3 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

  |-------
{1}   EXISTS q: 0 = p * q

Rerunning step: (inst 1 "0")
Instantiating the top quantifier in 1 with the terms: 
 0,
this simplifies to: 
restrictpremid_last.1.2.1.2.3 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

  |-------
{1}   0 = p * 0

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_last.1.2.1.2.3.

restrictpremid_last.1.2.1.2.4 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

{-1}  P!1 = p
[-2]  length(i!2`1) = P!1 - 1
[-3]  length(i!2`2) = P!1 - 1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  mid < p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  3 <= p
[-10] i!2`2 = remove(hu_list, rem(p)(i!3))
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(rem(p)(i!3))
[-13] 2 <= P!1
  |-------
{1}   i!3 = p - 1
[2]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`2)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))

Rerunning step: (replace -11 -2)
Replacing using formula -11,
this simplifies to: 
restrictpremid_last.1.2.1.2.4 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  P!1 = p
{-2}  length(append(nl1!1, cons(n_mid, nl2!1))) = P!1 - 1
[-3]  length(i!2`2) = P!1 - 1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  mid < p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  3 <= p
[-10] i!2`2 = remove(hu_list, rem(p)(i!3))
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(rem(p)(i!3))
[-13] 2 <= P!1
  |-------
[1]   i!3 = p - 1
[2]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`2)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))

Rerunning step: (rewrite "length_append" -2)
Found matching substitution:
l2: list[T] gets cons(n_mid, nl2!1),
l1: list[T] gets nl1!1,
Rewriting using length_append, matching in -2,
this simplifies to: 
restrictpremid_last.1.2.1.2.4 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  P!1 = p
{-2}  length(cons(n_mid, nl2!1)) + length(nl1!1) = P!1 - 1
[-3]  length(i!2`2) = P!1 - 1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  mid < p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  3 <= p
[-10] i!2`2 = remove(hu_list, rem(p)(i!3))
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(rem(p)(i!3))
[-13] 2 <= P!1
  |-------
[1]   i!3 = p - 1
[2]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`2)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))

Rerunning step: (expand "length" -2 1)
Expanding the definition of length,
this simplifies to: 
restrictpremid_last.1.2.1.2.4 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  P!1 = p
{-2}  1 + length(nl1!1) + length[Identity](nl2!1) = P!1 - 1
[-3]  length(i!2`2) = P!1 - 1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  mid < p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  3 <= p
[-10] i!2`2 = remove(hu_list, rem(p)(i!3))
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(rem(p)(i!3))
[-13] 2 <= P!1
  |-------
[1]   i!3 = p - 1
[2]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`2)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))

Rerunning step: (delete -3 -6 -7 -8 -9 -10 -11 -12 -13 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.1.2.1.2.4 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  P!1 = p
[-2]  1 + length(nl1!1) + length[Identity](nl2!1) = P!1 - 1
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + i!3
  |-------
[1]   i!3 = p - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_last.1.2.1.2.4.

restrictpremid_last.1.2.1.2.5 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  length(i!2`1) = P!1 - 1
[-2]  length(i!2`2) = P!1 - 1
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + i!3
[-5]  mid < p - 1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  3 <= p
[-9]  i!2`2 = remove(hu_list, rem(p)(i!3))
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(rem(p)(i!3))
[-12] 2 <= P!1
  |-------
{1}   P!1 = p
[2]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`2)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))

Rerunning step: (replace -9 -2)
Replacing using formula -9,
this simplifies to: 
restrictpremid_last.1.2.1.2.5 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  length(i!2`1) = P!1 - 1
{-2}  length(remove(hu_list, rem(p)(i!3))) = P!1 - 1
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + i!3
[-5]  mid < p - 1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  3 <= p
[-9]  i!2`2 = remove(hu_list, rem(p)(i!3))
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(rem(p)(i!3))
[-12] 2 <= P!1
  |-------
[1]   P!1 = p
[2]   EXISTS (i: {x: nat | mid < x AND x <= p}):
        public(car(i!2`2)) = public(hu(rem(p)(i))) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, rem(p)(i))))

Rerunning step: (delete -1 -3 -4 -5 -7 -9 -10 -11 -12 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.1.2.1.2.5 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  length(remove(hu_list, rem(p)(i!3))) = P!1 - 1
[-2]  (length(hu_list) = p)
[-3]  3 <= p
  |-------
[1]   P!1 = p

Rerunning step: (rewrite "length_remove" -1 :dir rl)
Found matching substitution:
i: below[length(c)] gets rem(p)(i!3),
c: (cons?[T]) gets hu_list,
Rewriting using length_remove, matching in -1,
this yields  2 subgoals: 
restrictpremid_last.1.2.1.2.5.1 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

{-1}  length[Identity](hu_list) - 1 = P!1 - 1
[-2]  (length(hu_list) = p)
[-3]  3 <= p
  |-------
[1]   P!1 = p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_last.1.2.1.2.5.1.

restrictpremid_last.1.2.1.2.5.2 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  length(remove(hu_list, rem(p)(i!3))) = P!1 - 1
[-2]  (length(hu_list) = p)
[-3]  3 <= p
  |-------
{1}   cons?[Identity](hu_list)
[2]   P!1 = p

Rerunning step: (delete -1 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.1.2.1.2.5.2 : 
;;; the outgoing message is sent to 0 = p mod p, establish some equalities first

[-1]  (length(hu_list) = p)
[-2]  3 <= p
  |-------
[1]   cons?[Identity](hu_list)

Rerunning step: (nonemptylist "hu_list")
Relating existence of a tail to a list's length,

This completes the proof of restrictpremid_last.1.2.1.2.5.2.


This completes the proof of restrictpremid_last.1.2.1.2.5.


This completes the proof of restrictpremid_last.1.2.1.2.

restrictpremid_last.1.2.1.3 : 
;;; explore the 3 options that could make -1 true

{-1}  EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
        public(u!1) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                 nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
           conc(nlist(i!2`1), ilist(i!2`2)) =
            conc(ilist(remove(hu_list, i)),
                 nlist(append(nl1, cons(n_mid, nl2))))
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(nlist(append(i!2`1, (: i!1 :))),
                           ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictpremid_last.1.2.1.3 : 
;;; explore the 3 options that could make -1 true

{-1}  public(u!1) = public(hu(i!3))
{-2}  conc(nlist(i!2`1), ilist(i!2`2)) =
       conc(ilist(remove(hu_list, i!3)),
            nlist(append(nl1!1, cons(n_mid, nl2!1))))
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-4]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   rho_premid(v!1)
                (code(public(car(i!2`2)),
                      conc(nlist(append(i!2`1, (: i!1 :))),
                           ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (delete -1 -3 -4 -5 1)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.1.2.1.3 : 
;;; explore the 3 options that could make -1 true

[-1]  conc(nlist(i!2`1), ilist(i!2`2)) =
       conc(ilist(remove(hu_list, i!3)),
            nlist(append(nl1!1, cons(n_mid, nl2!1))))
  |-------

Rerunning step: (decompose-equality -1)
Applying decompose-equality,

This completes the proof of restrictpremid_last.1.2.1.3.


This completes the proof of restrictpremid_last.1.2.1.

restrictpremid_last.1.2.2 :  

[-1]  rho_premid(v!1)(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  2 <= P!1
  |-------
{1}   ((rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :)))) >>
         Stop[event])
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
{2}   R_premid(v!1)
              (trans(u!1, car(i!2`2),
                     E(public(car(i!2`2)),
                       conc(nlist(append(i!2`1, (: i!1 :))),
                            ilist(append(cdr(i!2`2), (: u!1 :)))))))
{3}   trans(u!1, car(i!2`2),
            E(public(car(i!2`2)),
              conc(nlist(append(i!2`1, (: i!1 :))),
                   ilist(append(cdr(i!2`2), (: u!1 :))))))
       >>
       ((rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :)))) >>
          Stop[event])
         # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.1.2.2 :  

[-1]  rho_premid(v!1)(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   ((rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :)))) >>
         Stop[event])
        # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictpremid_last.1.2.2 :  

{-1}  rho_premid(v!1)(E(public(u!1), nlist((: i!1 :))))
[-2]  rho_premid(v!1)(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-4]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-5]  2 <= P!1
  |-------
{1}   (Stop[event] # R_premid(v!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)
{2}   R_premid(v!1)
              (rec(u!1, nth(i!2`2, P!1 - 2),
                   E(public(u!1), nlist((: i!1 :)))))
{3}   rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :)))) >>
       (Stop[event] # R_premid(v!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.1.2.2 :  

  |-------
[1]   (Stop[event] # R_premid(v!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictpremid_last.1.2.2.


This completes the proof of restrictpremid_last.1.2.


This completes the proof of restrictpremid_last.1.

restrictpremid_last.2 :  

{-1}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
{-2}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!1 :))
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (signal(running(P!1 - 1, append(i`2, (: u!1 :)),
                          nth(i`1,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(nlist(append(i`1, (: i!1 :))),
                          ilist(append(cdr(i`2), (: u!1 :))))))
              >>
              (rec(u!1, nth(i`2, P!1 - 2),
                   E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
         # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.2 :  

  |-------
[1]   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!1 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!1 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpremid_last.2.

restrictpremid_last.3 :  

{-1}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
{-2}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   cons?[Identity](i!2`2)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (signal(running(P!1 - 1, append(i`2, (: u!1 :)),
                          nth(i`1,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(nlist(append(i`1, (: i!1 :))),
                          ilist(append(cdr(i`2), (: u!1 :))))))
              >>
              (rec(u!1, nth(i`2, P!1 - 2),
                   E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
         # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -2 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.3 :  

[-1]  2 <= P!1
  |-------
[1]   cons?[Identity](i!2`2)

Rerunning step: (nonemptylist "i!2`2")
Relating existence of a tail to a list's length,

This completes the proof of restrictpremid_last.3.

restrictpremid_last.4 :  

{-1}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
{-2}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < length[Nonce](i!2`1)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (signal(running(P!1 - 1, append(i`2, (: u!1 :)),
                          nth(i`1,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(nlist(append(i`1, (: i!1 :))),
                          ilist(append(cdr(i`2), (: u!1 :))))))
              >>
              (rec(u!1, nth(i`2, P!1 - 2),
                   E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
         # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (typepred "i!2`1")
Adding type constraints for  i!2`1,
this simplifies to: 
restrictpremid_last.4 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`1)
{-2}  length(i!2`1) = P!1 - 1
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-4]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < length[Nonce](i!2`1)
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (signal(running(P!1 - 1, append(i`2, (: u!1 :)),
                          nth(i`1,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(nlist(append(i`1, (: i!1 :))),
                          ilist(append(cdr(i`2), (: u!1 :))))))
              >>
              (rec(u!1, nth(i`2, P!1 - 2),
                   E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
         # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -3 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.4 :  

[-1]  length(i!2`1) = P!1 - 1
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-3]  2 <= P!1
  |-------
[1]   floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < length[Nonce](i!2`1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_last.4.

restrictpremid_last.5 :  

{-1}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
{-2}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   P!1 - 2 < length[Identity](i!2`2)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (signal(running(P!1 - 1, append(i`2, (: u!1 :)),
                          nth(i`1,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(nlist(append(i`1, (: i!1 :))),
                          ilist(append(cdr(i`2), (: u!1 :))))))
              >>
              (rec(u!1, nth(i`2, P!1 - 2),
                   E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
         # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (typepred "i!2`2")
Adding type constraints for  i!2`2,
this simplifies to: 
restrictpremid_last.5 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`2)
{-2}  length(i!2`2) = P!1 - 1
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-4]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   P!1 - 2 < length[Identity](i!2`2)
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (signal(running(P!1 - 1, append(i`2, (: u!1 :)),
                          nth(i`1,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(nlist(append(i`1, (: i!1 :))),
                          ilist(append(cdr(i`2), (: u!1 :))))))
              >>
              (rec(u!1, nth(i`2, P!1 - 2),
                   E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
         # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -3 -4 -5 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.5 :  

[-1]  length(i!2`2) = P!1 - 1
  |-------
[1]   P!1 - 2 < length[Identity](i!2`2)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpremid_last.5.

restrictpremid_last.6 :  

{-1}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
{-2}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!1 :))
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (signal(running(P!1 - 1, append(il, (: u!1 :)),
                          nth(nl,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(nlist(append(nl, (: i!1 :))),
                          ilist(append(cdr(il), (: u!1 :))))))
              >>
              (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.6 :  

  |-------
[1]   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!1 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!1 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpremid_last.6.

restrictpremid_last.7 :  

{-1}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
{-2}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        cons?[Identity](il)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (signal(running(P!1 - 1, append(il, (: u!1 :)),
                          nth(nl,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(nlist(append(nl, (: i!1 :))),
                          ilist(append(cdr(il), (: u!1 :))))))
              >>
              (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictpremid_last.7 :  

[-1]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   cons?[Identity](il!1)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (signal(running(P!1 - 1, append(il, (: u!1 :)),
                          nth(nl,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(nlist(append(nl, (: i!1 :))),
                          ilist(append(cdr(il), (: u!1 :))))))
              >>
              (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_premid(v!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -2 2)
Deleting some formulas,
this simplifies to: 
restrictpremid_last.7 :  

[-1]  2 <= P!1
  |-------
[1]   cons?[Identity](il!1)

Rerunning step: (nonemptylist "il!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictpremid_last.7.

Q.E.D.


Run time  = 5.03 secs.
Real time = 6.99 secs.
nil
pvs(67): 
Installing rewrite rule sets.singleton_rew (all instances)
authentication_premid :  

  |-------
{1}   FORALL (v: below[mid]): network(USER) |> auth(T, R_premid(v))

Rerunning step: (auto-rewrite-theory "sets")
Rewriting relative to the theory: sets,
this simplifies to: 
authentication_premid :  

  |-------
[1]   FORALL (v: below[mid]): network(USER) |> auth(T, R_premid(v))

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_premid :  

  |-------
{1}   network(USER) |> auth(T, R_premid(v!1))

Rerunning step: (rewrite "authentication_by_rank" +
                 ("rho" "rho_premid(v!1)"))
Found matching substitution:
R: setof[event] gets R_premid(v!1),
T: setof[event] gets T,
users: [Identity -> process[event]] gets USER,
rho: setof[Message] gets rho_premid(v!1),
member rewrites member(x, INIT)
  to INIT(x)
member rewrites member(x, rho_premid(v!1))
  to rho_premid(v!1)(x)
subset? rewrites subset?(INIT, rho_premid(v!1))
  to FORALL (x: Message): INIT(x) => rho_premid(v!1)(x)
member rewrites member(x, S)
  to S(x)
member rewrites member(x, rho_premid(v!1))
  to rho_premid(v!1)(x)
subset? rewrites subset?(S, rho_premid(v!1))
  to FORALL (x: Message): S(x) => rho_premid(v!1)(x)
Rewriting using authentication_by_rank, matching in + where
  rho gets rho_premid(v!1),
this yields  4 subgoals: 
authentication_premid.1 :  

  |-------
{1}   FORALL (x: Message): INIT(x) => rho_premid(v!1)(x)
[2]   network(USER) |> auth(T, R_premid(v!1))

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_premid.1 :  

  |-------
[1]   FORALL (x: Message): INIT(x) => rho_premid(v!1)(x)

Rerunning step: (comment "intruder's initial knowledge is in rho")
Adding comment: intruder's initial knowledge is in rho
this simplifies to: 
authentication_premid.1 : 
;;; intruder's initial knowledge is in rho

  |-------
[1]   FORALL (x: Message): INIT(x) => rho_premid(v!1)(x)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_premid.1 : 
;;; intruder's initial knowledge is in rho

  |-------
{1}   INIT(x!1) => rho_premid(v!1)(x!1)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_premid.1 : 
;;; intruder's initial knowledge is in rho

{-1}  INIT(x!1)
  |-------
{1}   rho_premid(v!1)(x!1)

Rerunning step: (expand "INIT")
Expanding the definition of INIT,
this simplifies to: 
authentication_premid.1 : 
;;; intruder's initial knowledge is in rho

{-1}  CASES x!1
        OF user(z): TRUE,
           nonce(z): z /= n_mid,
           public(z): TRUE,
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i))
        ELSE FALSE
        ENDCASES
  |-------
[1]   rho_premid(v!1)(x!1)

Rerunning step: (expand "rho_premid")
Expanding the definition of rho_premid,
this simplifies to: 
authentication_premid.1 : 
;;; intruder's initial knowledge is in rho

[-1]  CASES x!1
        OF user(z): TRUE,
           nonce(z): z /= n_mid,
           public(z): TRUE,
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i))
        ELSE FALSE
        ENDCASES
  |-------
{1}   CASES x!1
        OF nonce(z): z /= n_mid,
           nlist(z): NOT elt(z, n_mid),
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i)),
           conc(z1, z2): rho_premid(v!1)(z1) AND rho_premid(v!1)(z2),
           commit(z1, z2, z3): z1 /= mid OR z2 /= hu_list OR z3 /= n_mid,
           code(z1, z2):
             rho_premid(v!1)(z2) OR
              (EXISTS (i: {x: nat | mid < x AND x <= p}):
                 z1 = public(hu(rem(p)(i))) AND
                  (EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                           nl2:
                             {x: list[Nonce] | length(x) = i - 1 - mid}):
                     z2 =
                      conc(nlist(append(nl1, cons(n_mid, nl2))),
                           ilist(remove(hu_list, rem(p)(i))))))
               OR
               EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
                 z1 = public(hu(i)) AND
                  EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                          nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
                    z2 =
                     conc(ilist(remove(hu_list, i)),
                          nlist(append(nl1, cons(n_mid, nl2))))
        ELSE TRUE
        ENDCASES

Rerunning step: (smash)
Repeatedly simplifying with BDDs, decision procedures, rewriting,
and if-lifting,

This completes the proof of authentication_premid.1.

authentication_premid.2 :  

  |-------
{1}   FORALL (S: setof[Message]), (m: Message):
        (FORALL (x: Message): S(x) => rho_premid(v!1)(x)) AND (S |- m)
         IMPLIES rho_premid(v!1)(m)
[2]   network(USER) |> auth(T, R_premid(v!1))

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_premid.2 :  

  |-------
[1]   FORALL (S: setof[Message]), (m: Message):
        (FORALL (x: Message): S(x) => rho_premid(v!1)(x)) AND (S |- m)
         IMPLIES rho_premid(v!1)(m)

Rerunning step: (comment "from of a set of messages in rho, no message not in rho can be generated")
Adding comment: from of a set of messages in rho, no message not in rho can be generated
this simplifies to: 
authentication_premid.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   FORALL (S: setof[Message]), (m: Message):
        (FORALL (x: Message): S(x) => rho_premid(v!1)(x)) AND (S |- m)
         IMPLIES rho_premid(v!1)(m)

Rerunning step: (expand "|-")
Expanding the definition of |-,
this simplifies to: 
authentication_premid.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   FORALL (S: setof[Message]), (m: Message):
        (FORALL (x: Message): S(x) => rho_premid(v!1)(x)) AND Gen(S, m)
         IMPLIES rho_premid(v!1)(m)

Rerunning step: (rule-induct "Gen")
Applying rule (co)induction over Gen,
this simplifies to: 
authentication_premid.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  FORALL (x: Message): S!1(x) => rho_premid(v!1)(x)
  |-------
{1}   FORALL (m: Message):
        (     S!1(m)
          OR (EXISTS m1, m2:
                rho_premid(v!1)(m1) AND
                 rho_premid(v!1)(m2) AND m = conc(m1, m2))
          OR (EXISTS m1: rho_premid(v!1)(conc(m1, m)))
          OR (EXISTS m2: rho_premid(v!1)(conc(m, m2)))
          OR (EXISTS (n: Nonce):
                rho_premid(v!1)(nonce(n)) AND m = nlist((: n :)))
          OR (EXISTS (n: Nonce):
                rho_premid(v!1)(nlist((: n :))) AND m = nonce(n))
          OR (EXISTS (nl1, nl2: list[Nonce]):
                rho_premid(v!1)(nlist(nl1)) AND
                 rho_premid(v!1)(nlist(nl2)) AND
                  m = nlist(append(nl1, nl2)))
          OR (EXISTS (nl, nl1, nl2: list[Nonce]):
                rho_premid(v!1)(nlist(nl)) AND
                 nl = append(nl1, nl2) AND m = nlist(nl1))
          OR (EXISTS (nl, nl1, nl2: list[Nonce]):
                rho_premid(v!1)(nlist(nl)) AND
                 nl = append(nl1, nl2) AND m = nlist(nl2))
          OR (EXISTS (i: Identity):
                rho_premid(v!1)(user(i)) AND m = ilist((: i :)))
          OR (EXISTS (i: Identity):
                rho_premid(v!1)(ilist((: i :))) AND m = user(i))
          OR (EXISTS (il1, il2: list[Identity]):
                rho_premid(v!1)(ilist(il1)) AND
                 rho_premid(v!1)(ilist(il2)) AND
                  m = ilist(append(il1, il2)))
          OR (EXISTS (il, il1, il2: list[Identity]):
                rho_premid(v!1)(ilist(il)) AND
                 il = append(il1, il2) AND m = ilist(il1))
          OR (EXISTS (il, il1, il2: list[Identity]):
                rho_premid(v!1)(ilist(il)) AND
                 il = append(il1, il2) AND m = ilist(il2))
          OR EXISTS m1, k:
               rho_premid(v!1)(m1) AND rho_premid(v!1)(k) AND m = E(k, m1))
         IMPLIES rho_premid(v!1)(m)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_premid.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  FORALL (x: Message): S!1(x) => rho_premid(v!1)(x)
  |-------
{1}   (     S!1(m!2)
        OR (EXISTS m1, m2:
              rho_premid(v!1)(m1) AND
               rho_premid(v!1)(m2) AND m!2 = conc(m1, m2))
        OR (EXISTS m1: rho_premid(v!1)(conc(m1, m!2)))
        OR (EXISTS m2: rho_premid(v!1)(conc(m!2, m2)))
        OR (EXISTS (n: Nonce):
              rho_premid(v!1)(nonce(n)) AND m!2 = nlist((: n :)))
        OR (EXISTS (n: Nonce):
              rho_premid(v!1)(nlist((: n :))) AND m!2 = nonce(n))
        OR (EXISTS (nl1, nl2: list[Nonce]):
              rho_premid(v!1)(nlist(nl1)) AND
               rho_premid(v!1)(nlist(nl2)) AND
                m!2 = nlist(append(nl1, nl2)))
        OR (EXISTS (nl, nl1, nl2: list[Nonce]):
              rho_premid(v!1)(nlist(nl)) AND
               nl = append(nl1, nl2) AND m!2 = nlist(nl1))
        OR (EXISTS (nl, nl1, nl2: list[Nonce]):
              rho_premid(v!1)(nlist(nl)) AND
               nl = append(nl1, nl2) AND m!2 = nlist(nl2))
        OR (EXISTS (i: Identity):
              rho_premid(v!1)(user(i)) AND m!2 = ilist((: i :)))
        OR (EXISTS (i: Identity):
              rho_premid(v!1)(ilist((: i :))) AND m!2 = user(i))
        OR (EXISTS (il1, il2: list[Identity]):
              rho_premid(v!1)(ilist(il1)) AND
               rho_premid(v!1)(ilist(il2)) AND
                m!2 = ilist(append(il1, il2)))
        OR (EXISTS (il, il1, il2: list[Identity]):
              rho_premid(v!1)(ilist(il)) AND
               il = append(il1, il2) AND m!2 = ilist(il1))
        OR (EXISTS (il, il1, il2: list[Identity]):
              rho_premid(v!1)(ilist(il)) AND
               il = append(il1, il2) AND m!2 = ilist(il2))
        OR EXISTS m1, k:
             rho_premid(v!1)(m1) AND rho_premid(v!1)(k) AND m!2 = E(k, m1))
       IMPLIES rho_premid(v!1)(m!2)

Rerunning step: (smash)
Repeatedly simplifying with BDDs, decision procedures, rewriting,
and if-lifting,
this yields  15 subgoals: 
authentication_premid.2.1 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  S!1(m!2)
[-2]  FORALL (x: Message): S!1(x) => rho_premid(v!1)(x)
  |-------
{1}   rho_premid(v!1)(m!2)

Rerunning step: (inst -2 "m!2")
Instantiating the top quantifier in -2 with the terms: 
 m!2,
this simplifies to: 
authentication_premid.2.1 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  S!1(m!2)
{-2}  S!1(m!2) => rho_premid(v!1)(m!2)
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_premid.2.1.

authentication_premid.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS m1, m2:
        rho_premid(v!1)(m1) AND rho_premid(v!1)(m2) AND m!2 = conc(m1, m2)
[-2]  FORALL (x: Message): S!1(x) => rho_premid(v!1)(x)
  |-------
{1}   rho_premid(v!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS m1, m2:
        rho_premid(v!1)(m1) AND rho_premid(v!1)(m2) AND m!2 = conc(m1, m2)
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_premid.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(m1!1) AND
       rho_premid(v!1)(m2!1) AND m!2 = conc(m1!1, m2!1)
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_premid.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(m1!1)
{-2}  rho_premid(v!1)(m2!1)
{-3}  m!2 = conc(m1!1, m2!1)
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_premid.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_premid(v!1)(m1!1)
[-2]  rho_premid(v!1)(m2!1)
[-3]  m!2 = conc(m1!1, m2!1)
  |-------
{1}   rho_premid(v!1)(conc(m1!1, m2!1))

Rerunning step: (expand "rho_premid" 1)
Expanding the definition of rho_premid,
this simplifies to: 
authentication_premid.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_premid(v!1)(m1!1)
[-2]  rho_premid(v!1)(m2!1)
[-3]  m!2 = conc(m1!1, m2!1)
  |-------
{1}   rho_premid(v!1)(m1!1) AND rho_premid(v!1)(m2!1)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_premid.2.2.

authentication_premid.2.3 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS m1: rho_premid(v!1)(conc(m1, m!2))
[-2]  FORALL (x: Message): S!1(x) => rho_premid(v!1)(x)
  |-------
{1}   rho_premid(v!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.3 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS m1: rho_premid(v!1)(conc(m1, m!2))
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_premid.2.3 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(conc(m1!1, m!2))
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (expand "rho_premid" -1)
Expanding the definition of rho_premid,
this simplifies to: 
authentication_premid.2.3 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  FALSE
  |-------
[1]   rho_premid(v!1)(m!2)

which is trivially true.

This completes the proof of authentication_premid.2.3.

authentication_premid.2.4 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS m2: rho_premid(v!1)(conc(m!2, m2))
[-2]  FORALL (x: Message): S!1(x) => rho_premid(v!1)(x)
  |-------
{1}   rho_premid(v!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.4 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS m2: rho_premid(v!1)(conc(m!2, m2))
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_premid.2.4 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(conc(m!2, m2!1))
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (expand "rho_premid" -1)
Expanding the definition of rho_premid,
this simplifies to: 
authentication_premid.2.4 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  FALSE
  |-------
[1]   rho_premid(v!1)(m!2)

which is trivially true.

This completes the proof of authentication_premid.2.4.

authentication_premid.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (n: Nonce): rho_premid(v!1)(nonce(n)) AND m!2 = nlist((: n :))
[-2]  FORALL (x: Message): S!1(x) => rho_premid(v!1)(x)
  |-------
{1}   rho_premid(v!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (n: Nonce): rho_premid(v!1)(nonce(n)) AND m!2 = nlist((: n :))
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_premid.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(nonce(n!1)) AND m!2 = nlist((: n!1 :))
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_premid.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(nonce(n!1))
{-2}  m!2 = nlist((: n!1 :))
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (expand "rho_premid" -1)
Expanding the definition of rho_premid,
this simplifies to: 
authentication_premid.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  n!1 /= n_mid
[-2]  m!2 = nlist((: n!1 :))
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
authentication_premid.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  n!1 /= n_mid
[-2]  m!2 = nlist((: n!1 :))
  |-------
{1}   rho_premid(v!1)(nlist((: n!1 :)))

Rerunning step: (expand "rho_premid")
Expanding the definition of rho_premid,
this simplifies to: 
authentication_premid.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  n!1 /= n_mid
[-2]  m!2 = nlist((: n!1 :))
{-3}  elt((: n!1 :), n_mid)
  |-------

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  n!1 /= n_mid
[-2]  elt((: n!1 :), n_mid)
  |-------

Rerunning step: (grind)
/= rewrites n!1 /= n_mid
  to NOT (n!1 = n_mid)
elt rewrites elt((: n!1 :), n_mid)
  to EXISTS (i: below[length((: n!1 :))]): nth((: n!1 :), i) = n_mid
length rewrites length[Nonce]((: :))
  to 0
length rewrites length((: n!1 :))
  to 1
nth rewrites nth((: n!1 :), i!1)
  to n!1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_premid.2.5.

authentication_premid.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (n: Nonce): rho_premid(v!1)(nlist((: n :))) AND m!2 = nonce(n)
[-2]  FORALL (x: Message): S!1(x) => rho_premid(v!1)(x)
  |-------
{1}   rho_premid(v!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (n: Nonce): rho_premid(v!1)(nlist((: n :))) AND m!2 = nonce(n)
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_premid.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(nlist((: n!1 :))) AND m!2 = nonce(n!1)
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_premid.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(nlist((: n!1 :)))
{-2}  m!2 = nonce(n!1)
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
authentication_premid.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_premid(v!1)(nlist((: n!1 :)))
[-2]  m!2 = nonce(n!1)
  |-------
{1}   rho_premid(v!1)(nonce(n!1))

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_premid(v!1)(nlist((: n!1 :)))
  |-------
[1]   rho_premid(v!1)(nonce(n!1))

Rerunning step: (expand "rho_premid")
Expanding the definition of rho_premid,
this simplifies to: 
authentication_premid.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   elt((: n!1 :), n_mid)
{2}   n!1 /= n_mid

Rerunning step: (expand "elt")
Expanding the definition of elt,
this simplifies to: 
authentication_premid.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   EXISTS (i: below[length((: n!1 :))]): nth((: n!1 :), i) = n_mid
[2]   n!1 /= n_mid

Rerunning step: (inst 1 "0")
Instantiating the top quantifier in 1 with the terms: 
 0,
this yields  2 subgoals: 
authentication_premid.2.6.1 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   nth((: n!1 :), 0) = n_mid
[2]   n!1 /= n_mid

Rerunning step: (grind)
nth rewrites nth((: n!1 :), 0)
  to n!1
/= rewrites n!1 /= n_mid
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_premid.2.6.1.

authentication_premid.2.6.2 (TCC):   

  |-------
{1}   0 < length[Nonce]((: n!1 :))
[2]   n!1 /= n_mid

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.6.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   0 < length[Nonce]((: n!1 :))

Rerunning step: (grind)
length rewrites length[Nonce]((: :))
  to 0
length rewrites length[Nonce]((: n!1 :))
  to 1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_premid.2.6.2.


This completes the proof of authentication_premid.2.6.

authentication_premid.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (nl1, nl2: list[Nonce]):
        rho_premid(v!1)(nlist(nl1)) AND
         rho_premid(v!1)(nlist(nl2)) AND m!2 = nlist(append(nl1, nl2))
[-2]  FORALL (x: Message): S!1(x) => rho_premid(v!1)(x)
  |-------
{1}   rho_premid(v!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (nl1, nl2: list[Nonce]):
        rho_premid(v!1)(nlist(nl1)) AND
         rho_premid(v!1)(nlist(nl2)) AND m!2 = nlist(append(nl1, nl2))
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_premid.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(nlist(nl1!1)) AND
       rho_premid(v!1)(nlist(nl2!1)) AND m!2 = nlist(append(nl1!1, nl2!1))
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_premid.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(nlist(nl1!1))
{-2}  rho_premid(v!1)(nlist(nl2!1))
{-3}  m!2 = nlist(append(nl1!1, nl2!1))
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_premid.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_premid(v!1)(nlist(nl1!1))
[-2]  rho_premid(v!1)(nlist(nl2!1))
[-3]  m!2 = nlist(append(nl1!1, nl2!1))
  |-------
{1}   rho_premid(v!1)(nlist(append(nl1!1, nl2!1)))

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_premid(v!1)(nlist(nl1!1))
[-2]  rho_premid(v!1)(nlist(nl2!1))
  |-------
[1]   rho_premid(v!1)(nlist(append(nl1!1, nl2!1)))

Rerunning step: (expand "rho_premid")
Expanding the definition of rho_premid,
this simplifies to: 
authentication_premid.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(append(nl1!1, nl2!1), n_mid)
  |-------
{1}   elt(nl1!1, n_mid)
{2}   elt(nl2!1, n_mid)

Rerunning step: (lemma "listprops[Nonce].elt_append3"
                 ("l1" "nl1!1" "l2" "nl2!1" "t" "n_mid"))
Applying listprops[Nonce].elt_append3 where 
  l1 gets nl1!1,
  l2 gets nl2!1,
  t gets n_mid,
this simplifies to: 
authentication_premid.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(append(nl1!1, nl2!1), n_mid) IMPLIES
       elt(nl1!1, n_mid) OR elt(nl2!1, n_mid)
[-2]  elt(append(nl1!1, nl2!1), n_mid)
  |-------
[1]   elt(nl1!1, n_mid)
[2]   elt(nl2!1, n_mid)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_premid.2.7.

authentication_premid.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (nl, nl1, nl2: list[Nonce]):
        rho_premid(v!1)(nlist(nl)) AND
         nl = append(nl1, nl2) AND m!2 = nlist(nl1)
[-2]  FORALL (x: Message): S!1(x) => rho_premid(v!1)(x)
  |-------
{1}   rho_premid(v!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (nl, nl1, nl2: list[Nonce]):
        rho_premid(v!1)(nlist(nl)) AND
         nl = append(nl1, nl2) AND m!2 = nlist(nl1)
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_premid.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(nlist(nl!1)) AND
       nl!1 = append(nl1!1, nl2!1) AND m!2 = nlist(nl1!1)
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_premid.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(nlist(nl!1))
{-2}  nl!1 = append(nl1!1, nl2!1)
{-3}  m!2 = nlist(nl1!1)
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_premid.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_premid(v!1)(nlist(nl!1))
[-2]  nl!1 = append(nl1!1, nl2!1)
[-3]  m!2 = nlist(nl1!1)
  |-------
{1}   rho_premid(v!1)(nlist(nl1!1))

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_premid(v!1)(nlist(nl!1))
[-2]  nl!1 = append(nl1!1, nl2!1)
  |-------
[1]   rho_premid(v!1)(nlist(nl1!1))

Rerunning step: (replace -2 -1)
Replacing using formula -2,
this simplifies to: 
authentication_premid.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(nlist(append(nl1!1, nl2!1)))
[-2]  nl!1 = append(nl1!1, nl2!1)
  |-------
[1]   rho_premid(v!1)(nlist(nl1!1))

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_premid(v!1)(nlist(append(nl1!1, nl2!1)))
  |-------
[1]   rho_premid(v!1)(nlist(nl1!1))

Rerunning step: (expand "rho_premid")
Expanding the definition of rho_premid,
this simplifies to: 
authentication_premid.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(nl1!1, n_mid)
  |-------
{1}   elt(append(nl1!1, nl2!1), n_mid)

Rerunning step: (lemma "listprops[Nonce].elt_append1"
                 ("l1" "nl1!1" "l2" "nl2!1" "t" "n_mid"))
Applying listprops[Nonce].elt_append1 where 
  l1 gets nl1!1,
  l2 gets nl2!1,
  t gets n_mid,
this simplifies to: 
authentication_premid.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(nl1!1, n_mid) IMPLIES elt(append(nl1!1, nl2!1), n_mid)
[-2]  elt(nl1!1, n_mid)
  |-------
[1]   elt(append(nl1!1, nl2!1), n_mid)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_premid.2.8.

authentication_premid.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (nl, nl1, nl2: list[Nonce]):
        rho_premid(v!1)(nlist(nl)) AND
         nl = append(nl1, nl2) AND m!2 = nlist(nl2)
[-2]  FORALL (x: Message): S!1(x) => rho_premid(v!1)(x)
  |-------
{1}   rho_premid(v!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (nl, nl1, nl2: list[Nonce]):
        rho_premid(v!1)(nlist(nl)) AND
         nl = append(nl1, nl2) AND m!2 = nlist(nl2)
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_premid.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(nlist(nl!1)) AND
       nl!1 = append(nl1!1, nl2!1) AND m!2 = nlist(nl2!1)
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_premid.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(nlist(nl!1))
{-2}  nl!1 = append(nl1!1, nl2!1)
{-3}  m!2 = nlist(nl2!1)
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_premid.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_premid(v!1)(nlist(nl!1))
[-2]  nl!1 = append(nl1!1, nl2!1)
[-3]  m!2 = nlist(nl2!1)
  |-------
{1}   rho_premid(v!1)(nlist(nl2!1))

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_premid(v!1)(nlist(nl!1))
[-2]  nl!1 = append(nl1!1, nl2!1)
  |-------
[1]   rho_premid(v!1)(nlist(nl2!1))

Rerunning step: (replace -2 -1)
Replacing using formula -2,
this simplifies to: 
authentication_premid.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(nlist(append(nl1!1, nl2!1)))
[-2]  nl!1 = append(nl1!1, nl2!1)
  |-------
[1]   rho_premid(v!1)(nlist(nl2!1))

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_premid(v!1)(nlist(append(nl1!1, nl2!1)))
  |-------
[1]   rho_premid(v!1)(nlist(nl2!1))

Rerunning step: (expand "rho_premid")
Expanding the definition of rho_premid,
this simplifies to: 
authentication_premid.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(nl2!1, n_mid)
  |-------
{1}   elt(append(nl1!1, nl2!1), n_mid)

Rerunning step: (lemma "listprops[Nonce].elt_append2"
                 ("l1" "nl1!1" "l2" "nl2!1" "t" "n_mid"))
Applying listprops[Nonce].elt_append2 where 
  l1 gets nl1!1,
  l2 gets nl2!1,
  t gets n_mid,
this simplifies to: 
authentication_premid.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(nl2!1, n_mid) IMPLIES elt(append(nl1!1, nl2!1), n_mid)
[-2]  elt(nl2!1, n_mid)
  |-------
[1]   elt(append(nl1!1, nl2!1), n_mid)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_premid.2.9.

authentication_premid.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (i: Identity):
        rho_premid(v!1)(user(i)) AND m!2 = ilist((: i :))
[-2]  FORALL (x: Message): S!1(x) => rho_premid(v!1)(x)
  |-------
{1}   rho_premid(v!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (i: Identity):
        rho_premid(v!1)(user(i)) AND m!2 = ilist((: i :))
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_premid.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(user(i!1)) AND m!2 = ilist((: i!1 :))
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_premid.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(user(i!1))
{-2}  m!2 = ilist((: i!1 :))
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
authentication_premid.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_premid(v!1)(user(i!1))
[-2]  m!2 = ilist((: i!1 :))
  |-------
{1}   rho_premid(v!1)(ilist((: i!1 :)))

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_premid(v!1)(user(i!1))
  |-------
[1]   rho_premid(v!1)(ilist((: i!1 :)))

Rerunning step: (expand "rho_premid" 1)
Expanding the definition of rho_premid,
this simplifies to: 
authentication_premid.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_premid(v!1)(user(i!1))
  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_premid.2.10.

authentication_premid.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (i: Identity):
        rho_premid(v!1)(ilist((: i :))) AND m!2 = user(i)
[-2]  FORALL (x: Message): S!1(x) => rho_premid(v!1)(x)
  |-------
{1}   rho_premid(v!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (i: Identity):
        rho_premid(v!1)(ilist((: i :))) AND m!2 = user(i)
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_premid.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(ilist((: i!1 :))) AND m!2 = user(i!1)
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_premid.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(ilist((: i!1 :)))
{-2}  m!2 = user(i!1)
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
authentication_premid.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_premid(v!1)(ilist((: i!1 :)))
[-2]  m!2 = user(i!1)
  |-------
{1}   rho_premid(v!1)(user(i!1))

Rerunning step: (delete -)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   rho_premid(v!1)(user(i!1))

Rerunning step: (expand "rho_premid")
Expanding the definition of rho_premid,
this simplifies to: 
authentication_premid.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_premid.2.11.

authentication_premid.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (il1, il2: list[Identity]):
        rho_premid(v!1)(ilist(il1)) AND
         rho_premid(v!1)(ilist(il2)) AND m!2 = ilist(append(il1, il2))
[-2]  FORALL (x: Message): S!1(x) => rho_premid(v!1)(x)
  |-------
{1}   rho_premid(v!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (il1, il2: list[Identity]):
        rho_premid(v!1)(ilist(il1)) AND
         rho_premid(v!1)(ilist(il2)) AND m!2 = ilist(append(il1, il2))
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_premid.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(ilist(il1!1)) AND
       rho_premid(v!1)(ilist(il2!1)) AND m!2 = ilist(append(il1!1, il2!1))
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_premid.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(ilist(il1!1))
{-2}  rho_premid(v!1)(ilist(il2!1))
{-3}  m!2 = ilist(append(il1!1, il2!1))
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_premid.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_premid(v!1)(ilist(il1!1))
[-2]  rho_premid(v!1)(ilist(il2!1))
[-3]  m!2 = ilist(append(il1!1, il2!1))
  |-------
{1}   rho_premid(v!1)(ilist(append(il1!1, il2!1)))

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_premid(v!1)(ilist(il1!1))
[-2]  rho_premid(v!1)(ilist(il2!1))
  |-------
[1]   rho_premid(v!1)(ilist(append(il1!1, il2!1)))

Rerunning step: (expand "rho_premid" 1)
Expanding the definition of rho_premid,
this simplifies to: 
authentication_premid.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_premid(v!1)(ilist(il1!1))
[-2]  rho_premid(v!1)(ilist(il2!1))
  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_premid.2.12.

authentication_premid.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (il, il1, il2: list[Identity]):
        rho_premid(v!1)(ilist(il)) AND
         il = append(il1, il2) AND m!2 = ilist(il1)
[-2]  FORALL (x: Message): S!1(x) => rho_premid(v!1)(x)
  |-------
{1}   rho_premid(v!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (il, il1, il2: list[Identity]):
        rho_premid(v!1)(ilist(il)) AND
         il = append(il1, il2) AND m!2 = ilist(il1)
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_premid.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(ilist(il!1)) AND
       il!1 = append(il1!1, il2!1) AND m!2 = ilist(il1!1)
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_premid.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(ilist(il!1))
{-2}  il!1 = append(il1!1, il2!1)
{-3}  m!2 = ilist(il1!1)
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_premid.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_premid(v!1)(ilist(il!1))
[-2]  il!1 = append(il1!1, il2!1)
[-3]  m!2 = ilist(il1!1)
  |-------
{1}   rho_premid(v!1)(ilist(il1!1))

Rerunning step: (delete -)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   rho_premid(v!1)(ilist(il1!1))

Rerunning step: (expand "rho_premid")
Expanding the definition of rho_premid,
this simplifies to: 
authentication_premid.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_premid.2.13.

authentication_premid.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (il, il1, il2: list[Identity]):
        rho_premid(v!1)(ilist(il)) AND
         il = append(il1, il2) AND m!2 = ilist(il2)
[-2]  FORALL (x: Message): S!1(x) => rho_premid(v!1)(x)
  |-------
{1}   rho_premid(v!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (il, il1, il2: list[Identity]):
        rho_premid(v!1)(ilist(il)) AND
         il = append(il1, il2) AND m!2 = ilist(il2)
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_premid.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(ilist(il!1)) AND
       il!1 = append(il1!1, il2!1) AND m!2 = ilist(il2!1)
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_premid.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(ilist(il!1))
{-2}  il!1 = append(il1!1, il2!1)
{-3}  m!2 = ilist(il2!1)
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_premid.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_premid(v!1)(ilist(il!1))
[-2]  il!1 = append(il1!1, il2!1)
[-3]  m!2 = ilist(il2!1)
  |-------
{1}   rho_premid(v!1)(ilist(il2!1))

Rerunning step: (delete -)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   rho_premid(v!1)(ilist(il2!1))

Rerunning step: (expand "rho_premid")
Expanding the definition of rho_premid,
this simplifies to: 
authentication_premid.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_premid.2.14.

authentication_premid.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS m1, k:
        rho_premid(v!1)(m1) AND rho_premid(v!1)(k) AND m!2 = E(k, m1)
[-2]  FORALL (x: Message): S!1(x) => rho_premid(v!1)(x)
  |-------
{1}   rho_premid(v!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS m1, k:
        rho_premid(v!1)(m1) AND rho_premid(v!1)(k) AND m!2 = E(k, m1)
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_premid.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(m1!1) AND rho_premid(v!1)(k!1) AND m!2 = E(k!1, m1!1)
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_premid.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_premid(v!1)(m1!1)
{-2}  rho_premid(v!1)(k!1)
{-3}  m!2 = E(k!1, m1!1)
  |-------
[1]   rho_premid(v!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_premid.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_premid(v!1)(m1!1)
[-2]  rho_premid(v!1)(k!1)
[-3]  m!2 = E(k!1, m1!1)
  |-------
{1}   rho_premid(v!1)(E(k!1, m1!1))

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
authentication_premid.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_premid(v!1)(m1!1)
[-2]  rho_premid(v!1)(k!1)
  |-------
[1]   rho_premid(v!1)(E(k!1, m1!1))

Rerunning step: (typepred "k!1")
Adding type constraints for  k!1,
this simplifies to: 
authentication_premid.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  public?(k!1) OR secret?(k!1)
[-2]  rho_premid(v!1)(m1!1)
[-3]  rho_premid(v!1)(k!1)
  |-------
[1]   rho_premid(v!1)(E(k!1, m1!1))

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
authentication_premid.2.15.1 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  public?(k!1)
[-2]  rho_premid(v!1)(m1!1)
[-3]  rho_premid(v!1)(k!1)
  |-------
[1]   rho_premid(v!1)(E(k!1, m1!1))

Rerunning step: (grind)
rho_premid rewrites rho_premid(v!1)(k!1)
  to TRUE
E rewrites E(k!1, m1!1)
  to CASES m1!1
        OF code(k1, m1):
             CASES k1
               OF public(u):
                    IF k!1 = secret(u) THEN m1 ELSE code(k!1, m1!1) ENDIF,
                  secret(u):
                    IF k!1 = public(u) THEN m1 ELSE code(k!1, m1!1) ENDIF
               ENDCASES
        ELSE code(k!1, m1!1)
        ENDCASES
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_premid rewrites rho_premid(v!1)(code(k!1, m1!1))
  to TRUE
rho_premid rewrites rho_premid(v!1)(public(x_secret(x_code(m1!1))))
  to TRUE
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_premid rewrites rho_premid(v!1)(m1!1)
  to FALSE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_premid.2.15.1.

authentication_premid.2.15.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  secret?(k!1)
[-2]  rho_premid(v!1)(m1!1)
[-3]  rho_premid(v!1)(k!1)
  |-------
[1]   rho_premid(v!1)(E(k!1, m1!1))

Rerunning step: (expand "rho_premid" -3)
Expanding the definition of rho_premid,
this simplifies to: 
authentication_premid.2.15.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  secret?(k!1)
[-2]  rho_premid(v!1)(m1!1)
{-3}  CASES k!1
        OF nonce(z): z /= n_mid,
           nlist(z): NOT elt(z, n_mid),
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i)),
           conc(z1, z2): rho_premid(v!1)(z1) AND rho_premid(v!1)(z2),
           commit(z1, z2, z3): z1 /= mid OR z2 /= hu_list OR z3 /= n_mid,
           code(z1, z2):
             rho_premid(v!1)(z2) OR
              (EXISTS (i: {x: nat | mid < x AND x <= p}):
                 z1 = public(hu(rem(p)(i))) AND
                  (EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                           nl2:
                             {x: list[Nonce] | length(x) = i - 1 - mid}):
                     z2 =
                      conc(nlist(append(nl1, cons(n_mid, nl2))),
                           ilist(remove(hu_list, rem(p)(i))))))
               OR
               EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
                 z1 = public(hu(i)) AND
                  EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                          nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
                    z2 =
                     conc(ilist(remove(hu_list, i)),
                          nlist(append(nl1, cons(n_mid, nl2))))
        ELSE TRUE
        ENDCASES
  |-------
[1]   rho_premid(v!1)(E(k!1, m1!1))

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
authentication_premid.2.15.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  secret?(k!1)
[-2]  rho_premid(v!1)(m1!1)
  |-------
{1}   EXISTS (i: nat_to_p): x_secret(k!1) = hu(i)
[2]   rho_premid(v!1)(E(k!1, m1!1))

Rerunning step: (lazy-grind)
E rewrites E(k!1, m1!1)
  to CASES m1!1
        OF code(k1, m1):
             CASES k1
               OF public(u):
                    IF k!1 = secret(u) THEN m1 ELSE code(k!1, m1!1) ENDIF,
                  secret(u):
                    IF k!1 = public(u) THEN m1 ELSE code(k!1, m1!1) ENDIF
               ENDCASES
        ELSE code(k!1, m1!1)
        ENDCASES
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_premid rewrites rho_premid(v!1)(code(k!1, m1!1))
  to TRUE
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_premid rewrites rho_premid(v!1)(m1!1)
  to (EXISTS (i: {x: nat | mid < x AND x <= p}):
         x_code(m1!1) = public(hu(rem(p)(i))) AND
          EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                  nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
            y_code(m1!1) =
             conc(nlist(append(nl1, cons(n_mid, nl2))),
                  ilist(remove(hu_list, rem(p)(i)))))
       OR
       EXISTS (i: {x: nat | 0 < x AND x <= v!1}):
         x_code(m1!1) = public(hu(i)) AND
          EXISTS (nl1: {x: list[Nonce] | length(x) = mid - i},
                  nl2: {x: list[Nonce] | length(x) = p - 1 - mid}):
            y_code(m1!1) =
             conc(ilist(cons(car(hu_list), remove(cdr(hu_list), i - 1))),
                  nlist(append(nl1, cons(n_mid, nl2))))
elt rewrites elt(append(nl1!1, cons(n_mid, nl2!1)), n_mid)
  to EXISTS (i: below[length(append(nl1!1, cons(n_mid, nl2!1)))]):
        nth(append(nl1!1, cons(n_mid, nl2!1)), i) = n_mid
rho_premid rewrites rho_premid(v!1)(nlist(append(nl1!1, cons(n_mid, nl2!1))))
  to NOT EXISTS (i: below[length(append(nl1!1, cons(n_mid, nl2!1)))]):
            nth(append(nl1!1, cons(n_mid, nl2!1)), i) = n_mid
rho_premid rewrites rho_premid(v!1)(ilist(remove(hu_list, rem(p)(i!1))))
  to TRUE
rho_premid rewrites 
  rho_premid(v!1)
            (conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
                  ilist(remove(hu_list, rem(p)(i!1)))))
  to NOT EXISTS (i: below[length(append(nl1!1, cons(n_mid, nl2!1)))]):
            nth(append(nl1!1, cons(n_mid, nl2!1)), i) = n_mid
rho_premid rewrites 
  rho_premid(v!1)(ilist(cons(car(hu_list), remove(cdr(hu_list), i!1 - 1))))
  to TRUE
elt rewrites elt(append(nl1!1, cons(n_mid, nl2!1)), n_mid)
  to EXISTS (i: below[length(append(nl1!1, cons(n_mid, nl2!1)))]):
        nth(append(nl1!1, cons(n_mid, nl2!1)), i) = n_mid
rho_premid rewrites rho_premid(v!1)(nlist(append(nl1!1, cons(n_mid, nl2!1))))
  to NOT EXISTS (i: below[length(append(nl1!1, cons(n_mid, nl2!1)))]):
            nth(append(nl1!1, cons(n_mid, nl2!1)), i) = n_mid
rho_premid rewrites 
  rho_premid(v!1)
            (conc(ilist(cons(car(hu_list), remove(cdr(hu_list), i!1 - 1))),
                  nlist(append(nl1!1, cons(n_mid, nl2!1)))))
  to NOT EXISTS (i: below[length(append(nl1!1, cons(n_mid, nl2!1)))]):
            nth(append(nl1!1, cons(n_mid, nl2!1)), i) = n_mid
By skolemization, if-lifting, simplification and instantiation,

This completes the proof of authentication_premid.2.15.2.


This completes the proof of authentication_premid.2.15.


This completes the proof of authentication_premid.2.

authentication_premid.3 :  

  |-------
{1}   FORALL (i: Identity):
        USER(i) # R_premid(v!1) |> RankUser(rho_premid(v!1))
[2]   network(USER) |> auth(T, R_premid(v!1))

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_premid.3 :  

  |-------
[1]   FORALL (i: Identity):
        USER(i) # R_premid(v!1) |> RankUser(rho_premid(v!1))

Rerunning step: (comment "users maintain the rank function")
Adding comment: users maintain the rank function
this simplifies to: 
authentication_premid.3 : 
;;; users maintain the rank function

  |-------
[1]   FORALL (i: Identity):
        USER(i) # R_premid(v!1) |> RankUser(rho_premid(v!1))

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_premid.3 : 
;;; users maintain the rank function

  |-------
{1}   USER(i!1) # R_premid(v!1) |> RankUser(rho_premid(v!1))

Rerunning step: (expand "USER")
Expanding the definition of USER,
this simplifies to: 
authentication_premid.3 : 
;;; users maintain the rank function

  |-------
{1}   (Interleave! (P: nat_from_2):
         (Interleave! (nn0: Nonces(P, i!1, 0)): UROLE_INIT(P, i!1, nn0)) //
          (Interleave! (nnP: Nonces(P, i!1, P - 1)):
             UROLE_LAST(P, i!1, nnP))
          //
          IF P = 2 THEN Stop[event]
          ELSE (Interleave! (j: nat_1_to(P), nnJ: Nonces(P, i!1, j)):
                  UROLE_MIDDLE(P, j, i!1, nnJ))
          ENDIF)
       # R_premid(v!1)
       |> RankUser(rho_premid(v!1))

Rerunning step: (expand "RankUser")
Expanding the definition of RankUser,
this simplifies to: 
authentication_premid.3 : 
;;; users maintain the rank function

  |-------
{1}   (Interleave! (P: nat_from_2):
         (Interleave! (nn0: Nonces(P, i!1, 0)): UROLE_INIT(P, i!1, nn0)) //
          (Interleave! (nnP: Nonces(P, i!1, P - 1)):
             UROLE_LAST(P, i!1, nnP))
          //
          IF P = 2 THEN Stop[event]
          ELSE (Interleave! (j: nat_1_to(P), nnJ: Nonces(P, i!1, j)):
                  UROLE_MIDDLE(P, j, i!1, nnJ))
          ENDIF)
       # R_premid(v!1)
       |>
       LAMBDA (tr: list[event]):
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
              (tr)
          IMPLIES
          every(LAMBDA (e: event):
                  complement(rec?)(e) IMPLIES rho_premid(v!1)(msg(e)))
               (tr)

Rerunning step: (interleaving2)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
Applying interleaving rule,
this simplifies to: 
authentication_premid.3 : 
;;; users maintain the rank function

  |-------
{1}   (Interleave! (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
       //
       (Interleave! (nnP: Nonces(i!2, i!1, i!2 - 1)):
          UROLE_LAST(i!2, i!1, nnP))
       //
       IF i!2 = 2 THEN Stop[event]
       ELSE (Interleave! (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
               UROLE_MIDDLE(i!2, j, i!1, nnJ))
       ENDIF
       # R_premid(v!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
              (t)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
               (t)

Rerunning step: (interleaving)
Applying interleaving rule,
this yields  2 subgoals: 
authentication_premid.3.1 : 
;;; users maintain the rank function

  |-------
{1}   (((Interleave! (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
         //
         (Interleave! (nnP: Nonces(i!2, i!1, i!2 - 1)):
            UROLE_LAST(i!2, i!1, nnP))
         # R_premid(v!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
                (t))

Rerunning step: (interleaving)
Applying interleaving rule,
this yields  2 subgoals: 
authentication_premid.3.1.1 : 
;;; users maintain the rank function

  |-------
{1}   (((Interleave! (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
         # R_premid(v!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
                (t))

Rerunning step: (lemma "restrictpremid_init" ("P" "i!2" "u" "i!1"))
Applying restrictpremid_init where 
  P gets i!2,
  u gets i!1,
this simplifies to: 
authentication_premid.3.1.1 : 
;;; users maintain the rank function

{-1}  FORALL (v: below[mid]):
        ((Interleave! (nn0: Nonces(i!2, i!1, 0)):
            UROLE_INIT(i!2, i!1, nn0))
          # R_premid(v))
         |> RankUser(rho_premid(v))
  |-------
[1]   (((Interleave! (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
         # R_premid(v!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
                (t))

Rerunning step: (grind :exclude ("rho_premid" "UROLE_INIT"))
Interleave rewrites 
  (Interleave! (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
  to Par(emptyset)
         (LAMBDA (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
# rewrites 
  (Par(emptyset)
      (LAMBDA (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
    # R_premid(v!1))
  to Par(R_premid(v!1))
         (Par(emptyset)
             (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                UROLE_INIT(i!2, i!1, nn0)),
          Stop)
Par rewrites 
  Par(R_premid(v!1))
     (Par(emptyset)
         (LAMBDA (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                       UROLE_INIT(i!2, i!1, nn0)))),
             (t2: (Stop)):
        prod(R_premid(v!1))(t1, t2, x)
member rewrites 
  member(x,
         Par(R_premid(v!1))
            (Par(emptyset)
                (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                   UROLE_INIT(i!2, i!1, nn0)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                       UROLE_INIT(i!2, i!1, nn0)))),
             (t2: (Stop)):
        prod(R_premid(v!1))(t1, t2, x)
member rewrites 
  member(x,
         LAMBDA (t: list[event]):
           every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
                (t)
            =>
            every(LAMBDA (e: event):
                    NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
                 (t))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v!1)(msg(e)))(x)
       =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
            (x)
subset? rewrites 
  subset?(Par(R_premid(v!1))
             (Par(emptyset)
                 (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                    UROLE_INIT(i!2, i!1, nn0)),
              Stop),
          LAMBDA (t: list[event]):
            every(LAMBDA (e: event):
                    rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
                 (t)
             =>
             every(LAMBDA (e: event):
                     NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
                  (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                          UROLE_INIT(i!2, i!1, nn0)))),
                (t2: (Stop)):
           prod(R_premid(v!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
              (x)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
               (x)
|> rewrites 
  (Par(R_premid(v!1))
      (Par(emptyset)
          (LAMBDA (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0)),
       Stop)
    |>
    LAMBDA (t: list[event]):
      every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v!1)(msg(e)))(t)
       =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
            (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                          UROLE_INIT(i!2, i!1, nn0)))),
                (t2: (Stop)):
           prod(R_premid(v!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
              (x)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
               (x)
# rewrites 
  (Par(emptyset)
      (LAMBDA (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
    # R_premid(v))
  to Par(R_premid(v))
         (Par(emptyset)
             (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                UROLE_INIT(i!2, i!1, nn0)),
          Stop)
Par rewrites 
  Par(R_premid(v))
     (Par(emptyset)
         (LAMBDA (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                       UROLE_INIT(i!2, i!1, nn0)))),
             (t2: (Stop)):
        prod(R_premid(v))(t1, t2, x)
member rewrites 
  member(x,
         Par(R_premid(v))
            (Par(emptyset)
                (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                   UROLE_INIT(i!2, i!1, nn0)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                       UROLE_INIT(i!2, i!1, nn0)))),
             (t2: (Stop)):
        prod(R_premid(v))(t1, t2, x)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
RankUser rewrites RankUser(rho_premid(v))(x)
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v)(msg(e)))(x)
       IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_premid(v)(msg(e)))
            (x)
member rewrites member(x, RankUser(rho_premid(v)))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v)(msg(e)))(x)
       IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_premid(v)(msg(e)))
            (x)
subset? rewrites 
  subset?(Par(R_premid(v))
             (Par(emptyset)
                 (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                    UROLE_INIT(i!2, i!1, nn0)),
              Stop),
          RankUser(rho_premid(v)))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                          UROLE_INIT(i!2, i!1, nn0)))),
                (t2: (Stop)):
           prod(R_premid(v))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v)(msg(e)))(x)
          IMPLIES
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_premid(v)(msg(e)))
               (x)
|> rewrites 
  Par(R_premid(v))
     (Par(emptyset)
         (LAMBDA (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0)),
      Stop)
   |> RankUser(rho_premid(v))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                          UROLE_INIT(i!2, i!1, nn0)))),
                (t2: (Stop)):
           prod(R_premid(v))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v)(msg(e)))(x)
          IMPLIES
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_premid(v)(msg(e)))
               (x)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_premid.3.1.1.

authentication_premid.3.1.2 : 
;;; users maintain the rank function

  |-------
{1}   (((Interleave! (nnP: Nonces(i!2, i!1, i!2 - 1)):
           UROLE_LAST(i!2, i!1, nnP))
         # R_premid(v!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
                (t))

Rerunning step: (lemma "restrictpremid_last" ("P" "i!2" "u" "i!1"))
Applying restrictpremid_last where 
  P gets i!2,
  u gets i!1,
this simplifies to: 
authentication_premid.3.1.2 : 
;;; users maintain the rank function

{-1}  FORALL (v: below[mid]):
        ((Interleave! (nnP: Nonces(i!2, i!1, i!2 - 1)):
            UROLE_LAST(i!2, i!1, nnP))
          # R_premid(v))
         |> RankUser(rho_premid(v))
  |-------
[1]   (((Interleave! (nnP: Nonces(i!2, i!1, i!2 - 1)):
           UROLE_LAST(i!2, i!1, nnP))
         # R_premid(v!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
                (t))

Rerunning step: (grind :exclude ("rho_premid" "UROLE_LAST"))
Interleave rewrites 
  (Interleave! (nnP: Nonces(i!2, i!1, i!2 - 1)): UROLE_LAST(i!2, i!1, nnP))
  to Par(emptyset)
         (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
            UROLE_LAST(i!2, i!1, nnP))
# rewrites 
  (Par(emptyset)
      (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)): UROLE_LAST(i!2, i!1, nnP))
    # R_premid(v!1))
  to Par(R_premid(v!1))
         (Par(emptyset)
             (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                UROLE_LAST(i!2, i!1, nnP)),
          Stop)
Par rewrites 
  Par(R_premid(v!1))
     (Par(emptyset)
         (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
            UROLE_LAST(i!2, i!1, nnP)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                       UROLE_LAST(i!2, i!1, nnP)))),
             (t2: (Stop)):
        prod(R_premid(v!1))(t1, t2, x)
member rewrites 
  member(x,
         Par(R_premid(v!1))
            (Par(emptyset)
                (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                   UROLE_LAST(i!2, i!1, nnP)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                       UROLE_LAST(i!2, i!1, nnP)))),
             (t2: (Stop)):
        prod(R_premid(v!1))(t1, t2, x)
member rewrites 
  member(x,
         LAMBDA (t: list[event]):
           every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
                (t)
            =>
            every(LAMBDA (e: event):
                    NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
                 (t))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v!1)(msg(e)))(x)
       =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
            (x)
subset? rewrites 
  subset?(Par(R_premid(v!1))
             (Par(emptyset)
                 (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                    UROLE_LAST(i!2, i!1, nnP)),
              Stop),
          LAMBDA (t: list[event]):
            every(LAMBDA (e: event):
                    rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
                 (t)
             =>
             every(LAMBDA (e: event):
                     NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
                  (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                          UROLE_LAST(i!2, i!1, nnP)))),
                (t2: (Stop)):
           prod(R_premid(v!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
              (x)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
               (x)
|> rewrites 
  (Par(R_premid(v!1))
      (Par(emptyset)
          (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
             UROLE_LAST(i!2, i!1, nnP)),
       Stop)
    |>
    LAMBDA (t: list[event]):
      every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v!1)(msg(e)))(t)
       =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
            (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                          UROLE_LAST(i!2, i!1, nnP)))),
                (t2: (Stop)):
           prod(R_premid(v!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
              (x)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
               (x)
# rewrites 
  (Par(emptyset)
      (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)): UROLE_LAST(i!2, i!1, nnP))
    # R_premid(v))
  to Par(R_premid(v))
         (Par(emptyset)
             (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                UROLE_LAST(i!2, i!1, nnP)),
          Stop)
Par rewrites 
  Par(R_premid(v))
     (Par(emptyset)
         (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
            UROLE_LAST(i!2, i!1, nnP)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                       UROLE_LAST(i!2, i!1, nnP)))),
             (t2: (Stop)):
        prod(R_premid(v))(t1, t2, x)
member rewrites 
  member(x,
         Par(R_premid(v))
            (Par(emptyset)
                (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                   UROLE_LAST(i!2, i!1, nnP)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                       UROLE_LAST(i!2, i!1, nnP)))),
             (t2: (Stop)):
        prod(R_premid(v))(t1, t2, x)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
RankUser rewrites RankUser(rho_premid(v))(x)
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v)(msg(e)))(x)
       IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_premid(v)(msg(e)))
            (x)
member rewrites member(x, RankUser(rho_premid(v)))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v)(msg(e)))(x)
       IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_premid(v)(msg(e)))
            (x)
subset? rewrites 
  subset?(Par(R_premid(v))
             (Par(emptyset)
                 (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                    UROLE_LAST(i!2, i!1, nnP)),
              Stop),
          RankUser(rho_premid(v)))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                          UROLE_LAST(i!2, i!1, nnP)))),
                (t2: (Stop)):
           prod(R_premid(v))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v)(msg(e)))(x)
          IMPLIES
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_premid(v)(msg(e)))
               (x)
|> rewrites 
  Par(R_premid(v))
     (Par(emptyset)
         (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
            UROLE_LAST(i!2, i!1, nnP)),
      Stop)
   |> RankUser(rho_premid(v))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                          UROLE_LAST(i!2, i!1, nnP)))),
                (t2: (Stop)):
           prod(R_premid(v))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v)(msg(e)))(x)
          IMPLIES
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_premid(v)(msg(e)))
               (x)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_premid.3.1.2.


This completes the proof of authentication_premid.3.1.

authentication_premid.3.2 : 
;;; users maintain the rank function

  |-------
{1}   ((IF i!2 = 2 THEN Stop[event]
        ELSE (Interleave! (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                UROLE_MIDDLE(i!2, j, i!1, nnJ))
        ENDIF
         # R_premid(v!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
                (t))

Rerunning step: (lift-if)
Lifting IF-conditions to the top level,
this simplifies to: 
authentication_premid.3.2 : 
;;; users maintain the rank function

  |-------
{1}   IF i!2 = 2
        THEN ((Stop[event] # R_premid(v!1)) |>
               LAMBDA (t: list[event]):
                 every(LAMBDA (e: event):
                         rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
                      (t)
                  =>
                  every(LAMBDA (e: event):
                          NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
                       (t))
      ELSE (((Interleave! (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                UROLE_MIDDLE(i!2, j, i!1, nnJ))
              # R_premid(v!1))
             |>
             LAMBDA (t: list[event]):
               every(LAMBDA (e: event):
                       rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
                    (t)
                =>
                every(LAMBDA (e: event):
                        NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
                     (t))
      ENDIF

Rerunning step: (prop)
Applying propositional simplification,
this yields  2 subgoals: 
authentication_premid.3.2.1 : 
;;; users maintain the rank function

{-1}  i!2 = 2
  |-------
{1}   ((Stop[event] # R_premid(v!1)) |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
                (t))

Rerunning step: (stop)
Applying stop rule,

This completes the proof of authentication_premid.3.2.1.

authentication_premid.3.2.2 : 
;;; users maintain the rank function

  |-------
{1}   i!2 = 2
{2}   (((Interleave! (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
           UROLE_MIDDLE(i!2, j, i!1, nnJ))
         # R_premid(v!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
                (t))

Rerunning step: (lemma "restrictpremid_middle" ("P" "i!2" "u" "i!1"))
Applying restrictpremid_middle where 
  P gets i!2,
  u gets i!1,
this simplifies to: 
authentication_premid.3.2.2 : 
;;; users maintain the rank function

{-1}  FORALL (v: below[mid]):
        i!2 /= 2 =>
         (((Interleave! (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
              UROLE_MIDDLE(i!2, k, i!1, nnK))
            # R_premid(v))
           |> RankUser(rho_premid(v)))
  |-------
[1]   i!2 = 2
[2]   (((Interleave! (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
           UROLE_MIDDLE(i!2, j, i!1, nnJ))
         # R_premid(v!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
                (t))

Rerunning step: (grind :exclude ("rho_premid" "UROLE_MIDDLE"))
Interleave rewrites 
  (Interleave! (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
     UROLE_MIDDLE(i!2, j, i!1, nnJ))
  to Par(emptyset)
         (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
            UROLE_MIDDLE(i!2, j, i!1, nnJ))
# rewrites 
  (Par(emptyset)
      (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
         UROLE_MIDDLE(i!2, j, i!1, nnJ))
    # R_premid(v!1))
  to Par(R_premid(v!1))
         (Par(emptyset)
             (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                UROLE_MIDDLE(i!2, j, i!1, nnJ)),
          Stop)
Par rewrites 
  Par(R_premid(v!1))
     (Par(emptyset)
         (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
            UROLE_MIDDLE(i!2, j, i!1, nnJ)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                       UROLE_MIDDLE(i!2, j, i!1, nnJ)))),
             (t2: (Stop)):
        prod(R_premid(v!1))(t1, t2, x)
member rewrites 
  member(x,
         Par(R_premid(v!1))
            (Par(emptyset)
                (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                   UROLE_MIDDLE(i!2, j, i!1, nnJ)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                       UROLE_MIDDLE(i!2, j, i!1, nnJ)))),
             (t2: (Stop)):
        prod(R_premid(v!1))(t1, t2, x)
member rewrites 
  member(x,
         LAMBDA (t: list[event]):
           every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
                (t)
            =>
            every(LAMBDA (e: event):
                    NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
                 (t))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v!1)(msg(e)))(x)
       =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
            (x)
subset? rewrites 
  subset?(Par(R_premid(v!1))
             (Par(emptyset)
                 (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                    UROLE_MIDDLE(i!2, j, i!1, nnJ)),
              Stop),
          LAMBDA (t: list[event]):
            every(LAMBDA (e: event):
                    rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
                 (t)
             =>
             every(LAMBDA (e: event):
                     NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
                  (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (j: nat_1_to(i!2),
                                nnJ: Nonces(i!2, i!1, j)):
                          UROLE_MIDDLE(i!2, j, i!1, nnJ)))),
                (t2: (Stop)):
           prod(R_premid(v!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
              (x)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
               (x)
|> rewrites 
  (Par(R_premid(v!1))
      (Par(emptyset)
          (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
             UROLE_MIDDLE(i!2, j, i!1, nnJ)),
       Stop)
    |>
    LAMBDA (t: list[event]):
      every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v!1)(msg(e)))(t)
       =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
            (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (j: nat_1_to(i!2),
                                nnJ: Nonces(i!2, i!1, j)):
                          UROLE_MIDDLE(i!2, j, i!1, nnJ)))),
                (t2: (Stop)):
           prod(R_premid(v!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
              (x)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_premid(v!1)(msg(e)))
               (x)
# rewrites 
  (Par(emptyset)
      (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
         UROLE_MIDDLE(i!2, j, i!1, nnJ))
    # R_premid(v))
  to Par(R_premid(v))
         (Par(emptyset)
             (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                UROLE_MIDDLE(i!2, j, i!1, nnJ)),
          Stop)
Par rewrites 
  Par(R_premid(v))
     (Par(emptyset)
         (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
            UROLE_MIDDLE(i!2, j, i!1, nnJ)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                       UROLE_MIDDLE(i!2, j, i!1, nnJ)))),
             (t2: (Stop)):
        prod(R_premid(v))(t1, t2, x)
member rewrites 
  member(x,
         Par(R_premid(v))
            (Par(emptyset)
                (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                   UROLE_MIDDLE(i!2, j, i!1, nnJ)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                       UROLE_MIDDLE(i!2, j, i!1, nnJ)))),
             (t2: (Stop)):
        prod(R_premid(v))(t1, t2, x)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
RankUser rewrites RankUser(rho_premid(v))(x)
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v)(msg(e)))(x)
       IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_premid(v)(msg(e)))
            (x)
member rewrites member(x, RankUser(rho_premid(v)))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v)(msg(e)))(x)
       IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_premid(v)(msg(e)))
            (x)
subset? rewrites 
  subset?(Par(R_premid(v))
             (Par(emptyset)
                 (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                    UROLE_MIDDLE(i!2, j, i!1, nnJ)),
              Stop),
          RankUser(rho_premid(v)))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (j: nat_1_to(i!2),
                                nnJ: Nonces(i!2, i!1, j)):
                          UROLE_MIDDLE(i!2, j, i!1, nnJ)))),
                (t2: (Stop)):
           prod(R_premid(v))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v)(msg(e)))(x)
          IMPLIES
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_premid(v)(msg(e)))
               (x)
|> rewrites 
  (Par(R_premid(v))
      (Par(emptyset)
          (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
             UROLE_MIDDLE(i!2, j, i!1, nnJ)),
       Stop)
    |> RankUser(rho_premid(v)))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (j: nat_1_to(i!2),
                                nnJ: Nonces(i!2, i!1, j)):
                          UROLE_MIDDLE(i!2, j, i!1, nnJ)))),
                (t2: (Stop)):
           prod(R_premid(v))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_premid(v)(msg(e)))(x)
          IMPLIES
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_premid(v)(msg(e)))
               (x)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_premid.3.2.2.


This completes the proof of authentication_premid.3.2.


This completes the proof of authentication_premid.3.

authentication_premid.4 :  

  |-------
{1}   FORALL (e: (T)): NOT rho_premid(v!1)(msg(e))
[2]   network(USER) |> auth(T, R_premid(v!1))

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_premid.4 :  

  |-------
[1]   FORALL (e: (T)): NOT rho_premid(v!1)(msg(e))

Rerunning step: (comment "T is not in rho")
Adding comment: T is not in rho
this simplifies to: 
authentication_premid.4 : 
;;; T is not in rho

  |-------
[1]   FORALL (e: (T)): NOT rho_premid(v!1)(msg(e))

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
authentication_premid.4 : 
;;; T is not in rho

{-1}  T(e!1)
{-2}  rho_premid(v!1)(msg(e!1))
  |-------

Rerunning step: (expand "T")
Expanding the definition of T,
this simplifies to: 
authentication_premid.4 : 
;;; T is not in rho

{-1}  e!1 = signal(commit(mid, hu_list, n_mid))
[-2]  rho_premid(v!1)(msg(e!1))
  |-------

Rerunning step: (replace -1 -2)
Replacing using formula -1,
this simplifies to: 
authentication_premid.4 : 
;;; T is not in rho

[-1]  e!1 = signal(commit(mid, hu_list, n_mid))
{-2}  rho_premid(v!1)(msg(signal(commit(mid, hu_list, n_mid))))
  |-------

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
authentication_premid.4 : 
;;; T is not in rho

[-1]  rho_premid(v!1)(msg(signal(commit(mid, hu_list, n_mid))))
  |-------

Rerunning step: (grind)
rho_premid rewrites rho_premid(v!1)(commit(mid, hu_list, n_mid))
  to FALSE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_premid.4.

Q.E.D.


Run time  = 4.32 secs.
Real time = 5.53 secs.
nil
pvs(72): 
Installing rewrite rule sets.singleton_rew (all instances)
restrictpostmid_init :  

  |-------
{1}   FORALL (P: nat_from_2, u: Identity, w: {x: nat | mid < x AND x < p}):
        ((Interleave! (nn0: Nonces(P, u, 0)): UROLE_INIT(P, u, nn0)) #
          R_postmid(w))
         |> RankUser(rho_postmid(w))

Rerunning step: (auto-rewrite-theory "sets")
Rewriting relative to the theory: sets,
this simplifies to: 
restrictpostmid_init :  

  |-------
[1]   FORALL (P: nat_from_2, u: Identity, w: {x: nat | mid < x AND x < p}):
        ((Interleave! (nn0: Nonces(P, u, 0)): UROLE_INIT(P, u, nn0)) #
          R_postmid(w))
         |> RankUser(rho_postmid(w))

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictpostmid_init :  

  |-------
{1}   ((Interleave! (nn0: Nonces(P!1, u!1, 0)): UROLE_INIT(P!1, u!1, nn0))
        # R_postmid(w!1))
       |> RankUser(rho_postmid(w!1))

Rerunning step: (expand "RankUser")
Expanding the definition of RankUser,
this simplifies to: 
restrictpostmid_init :  

  |-------
{1}   ((Interleave! (nn0: Nonces(P!1, u!1, 0)): UROLE_INIT(P!1, u!1, nn0))
        # R_postmid(w!1))
       |>
       LAMBDA (tr: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(tr)
          =>
          every(LAMBDA (e: event):
                  complement(rec?)(e) => rho_postmid(w!1)(msg(e)))
               (tr)

Rerunning step: (interleaving2)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
Applying interleaving rule,
this simplifies to: 
restrictpostmid_init :  

  |-------
{1}   UROLE_INIT(P!1, u!1, i!1) # R_postmid(w!1) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (expand "UROLE_INIT")
Expanding the definition of UROLE_INIT,
this simplifies to: 
restrictpostmid_init :  

  |-------
{1}   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (signal(running(0, cons(u!1, il),
                            nth(nl,
                                floor(((mid - 1) / (p - 2)) * P!1
                                      -
                                      2 * ((mid - 1) / (p - 2))))))
              >>
              (trans(u!1, car(il),
                     E(public(car(il)),
                       conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                >> Stop[event]))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (typepred "P!1")
Adding type constraints for  P!1,
this simplifies to: 
restrictpostmid_init :  

{-1}  2 <= P!1
  |-------
[1]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (signal(running(0, cons(u!1, il),
                            nth(nl,
                                floor(((mid - 1) / (p - 2)) * P!1
                                      -
                                      2 * ((mid - 1) / (p - 2))))))
              >>
              (trans(u!1, car(il),
                     E(public(car(il)),
                       conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                >> Stop[event]))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (lemma "select_right_nonce1" ("P" "P!1"))
Applying select_right_nonce1 where 
  P gets P!1,
this simplifies to: 
restrictpostmid_init :  

{-1}  (P!1 = p IMPLIES floor(((mid - 1) / (p - 2)) * (P!1 - 2)) = mid - 1)
       AND
       floor(((mid - 1) / (p - 2)) * (P!1 - 2)) >= 0 AND
        floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1
[-2]  2 <= P!1
  |-------
[1]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (signal(running(0, cons(u!1, il),
                            nth(nl,
                                floor(((mid - 1) / (p - 2)) * P!1
                                      -
                                      2 * ((mid - 1) / (p - 2))))))
              >>
              (trans(u!1, car(il),
                     E(public(car(il)),
                       conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                >> Stop[event]))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictpostmid_init :  

{-1}  (P!1 = p IMPLIES floor(((mid - 1) / (p - 2)) * (P!1 - 2)) = mid - 1)
{-2}  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) >= 0
{-3}  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (signal(running(0, cons(u!1, il),
                            nth(nl,
                                floor(((mid - 1) / (p - 2)) * P!1
                                      -
                                      2 * ((mid - 1) / (p - 2))))))
              >>
              (trans(u!1, car(il),
                     E(public(car(il)),
                       conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                >> Stop[event]))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictpostmid_init :  

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) >= 0
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1
[-3]  2 <= P!1
  |-------
[1]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (signal(running(0, cons(u!1, il),
                            nth(nl,
                                floor(((mid - 1) / (p - 2)) * P!1
                                      -
                                      2 * ((mid - 1) / (p - 2))))))
              >>
              (trans(u!1, car(il),
                     E(public(car(il)),
                       conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                >> Stop[event]))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (choice3)
Applying choice rule,
this yields  7 subgoals: 
restrictpostmid_init.1 :  

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) >= 0
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2)) < P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   (trans(u!1, car(i!2`2),
             E(public(car(i!2`2)),
               conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))
        >>
        (rec(u!1, nth(i!2`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
          >>
          (signal(running(0, cons(u!1, i!2`2),
                          nth(i!2`1,
                              floor(((mid - 1) / (p - 2)) * P!1
                                    -
                                    2 * ((mid - 1) / (p - 2))))))
            >>
            (trans(u!1, car(i!2`2),
                   E(public(car(i!2`2)),
                     conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
              >> Stop[event]))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictpostmid_init.1.1 :  

{-1}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
{-2}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   rho_postmid(w!1)
                 (E(public(car(i!2`2)),
                    conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))
{2}   R_postmid(w!1)
               (trans(u!1, car(i!2`2),
                      E(public(car(i!2`2)),
                        conc(nlist((: i!1 :)),
                             ilist(cons(u!1, cdr(i!2`2)))))))
{3}   trans(u!1, car(i!2`2),
            E(public(car(i!2`2)),
              conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))
       >>
       ((rec(u!1, nth(i!2`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
          >>
          (signal(running(0, cons(u!1, i!2`2),
                          nth(i!2`1,
                              floor(((mid - 1) / (p - 2)) * P!1
                                    -
                                    2 * ((mid - 1) / (p - 2))))))
            >>
            (trans(u!1, car(i!2`2),
                   E(public(car(i!2`2)),
                     conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
              >> Stop[event])))
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -2 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_init.1.1 :  

[-1]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (E(public(car(i!2`2)),
                    conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))

Rerunning step: (expand "E")
Expanding the definition of E,
this simplifies to: 
restrictpostmid_init.1.1 :  

[-1]  2 <= P!1
  |-------
{1}   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(nlist((: i!1 :)),
                            ilist(cons(u!1, cdr(i!2`2))))))

Rerunning step: (expand "rho_postmid")
Expanding the definition of rho_postmid,
this simplifies to: 
restrictpostmid_init.1.1 :  

[-1]  2 <= P!1
  |-------
{1}   rho_postmid(w!1)
                 (conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2)))))
       OR
       EXISTS (i: {x: nat | mid < x AND x <= w!1}):
         public(car(i!2`2)) = public(hu(i)) AND
          EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                  nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
            conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2)))) =
             conc(nlist(append(nl1, cons(n_mid, nl2))),
                  ilist(remove(hu_list, i)))

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictpostmid_init.1.1 :  

[-1]  2 <= P!1
  |-------
{1}   rho_postmid(w!1)(conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2)))))
{2}   EXISTS (i: {x: nat | mid < x AND x <= w!1}):
        public(car(i!2`2)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2)))) =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, i)))

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_init.1.1 :  

[-1]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)(conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2)))))

Rerunning step: (typepred "i!1")
Adding type constraints for  i!1,
this simplifies to: 
restrictpostmid_init.1.1 :  

{-1}  IRpart(P!1, u!1, 0)(i!1)
[-2]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)(conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2)))))

Rerunning step: (lemma "n_prop" ("P" "P!1" "u" "u!1" "r" "0"))
Applying n_prop where 
  P gets P!1,
  u gets u!1,
  r gets 0,
this simplifies to: 
restrictpostmid_init.1.1 :  

{-1}  (P!1 /= p OR 0 /= mid) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, 0)(n_mid)
[-2]  IRpart(P!1, u!1, 0)(i!1)
[-3]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)(conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2)))))

Rerunning step: (typepred "mid")
Adding type constraints for  mid,
this simplifies to: 
restrictpostmid_init.1.1 :  

{-1}  0 < mid
{-2}  mid < p - 1
[-3]  (P!1 /= p OR 0 /= mid) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, 0)(n_mid)
[-4]  IRpart(P!1, u!1, 0)(i!1)
[-5]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)(conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2)))))

Rerunning step: (lemma "listprops[Nonce].elt_singleton"
                 ("t1" "i!1" "t2" "n_mid"))
Applying listprops[Nonce].elt_singleton where 
  t1 gets i!1,
  t2 gets n_mid,
this simplifies to: 
restrictpostmid_init.1.1 :  

{-1}  elt((: i!1 :), n_mid) IFF i!1 = n_mid
[-2]  0 < mid
[-3]  mid < p - 1
[-4]  (P!1 /= p OR 0 /= mid) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, 0)(n_mid)
[-5]  IRpart(P!1, u!1, 0)(i!1)
[-6]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)(conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2)))))

Rerunning step: (grind :exclude "elt")
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
/= rewrites P!1 /= p
  to NOT (P!1 = p)
/= rewrites 0 /= mid
  to TRUE
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
rho_postmid rewrites rho_postmid(w!1)(nlist((: i!1 :)))
  to TRUE
rho_postmid rewrites rho_postmid(w!1)(ilist(cons(u!1, cdr(i!2`2))))
  to TRUE
rho_postmid rewrites 
  rho_postmid(w!1)(conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2)))))
  to TRUE
/= rewrites P!1 /= p
  to NOT (P!1 = p)
/= rewrites 0 /= mid
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpostmid_init.1.1.

restrictpostmid_init.1.2 :  

{-1}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
{-2}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   ((rec(u!1, nth(i!2`2, P!1 - 2),
            E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
         >>
         (signal(running(0, cons(u!1, i!2`2),
                         nth(i!2`1,
                             floor(((mid - 1) / (p - 2)) * P!1 -
                                    2 * ((mid - 1) / (p - 2))))))
           >>
           (trans(u!1, car(i!2`2),
                  E(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
             >> Stop[event])))
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
{2}   R_postmid(w!1)
               (trans(u!1, car(i!2`2),
                      E(public(car(i!2`2)),
                        conc(nlist((: i!1 :)),
                             ilist(cons(u!1, cdr(i!2`2)))))))
{3}   trans(u!1, car(i!2`2),
            E(public(car(i!2`2)),
              conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))
       >>
       ((rec(u!1, nth(i!2`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
          >>
          (signal(running(0, cons(u!1, i!2`2),
                          nth(i!2`1,
                              floor(((mid - 1) / (p - 2)) * P!1
                                    -
                                    2 * ((mid - 1) / (p - 2))))))
            >>
            (trans(u!1, car(i!2`2),
                   E(public(car(i!2`2)),
                     conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
              >> Stop[event])))
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_init.1.2 :  

[-1]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
[-2]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-3]  2 <= P!1
  |-------
[1]   ((rec(u!1, nth(i!2`2, P!1 - 2),
            E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
         >>
         (signal(running(0, cons(u!1, i!2`2),
                         nth(i!2`1,
                             floor(((mid - 1) / (p - 2)) * P!1 -
                                    2 * ((mid - 1) / (p - 2))))))
           >>
           (trans(u!1, car(i!2`2),
                  E(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
             >> Stop[event])))
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictpostmid_init.1.2 :  

{-1}  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
[-3]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-4]  2 <= P!1
  |-------
{1}   ((signal(running(0, cons(u!1, i!2`2),
                       nth(i!2`1,
                           floor(((mid - 1) / (p - 2)) * P!1 -
                                  2 * ((mid - 1) / (p - 2))))))
         >>
         (trans(u!1, car(i!2`2),
                E(public(car(i!2`2)),
                  conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
           >> Stop[event]))
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
{2}   R_postmid(w!1)
               (rec(u!1, nth(i!2`2, P!1 - 2),
                    E(public(u!1),
                      conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)))))
{3}   rec(u!1, nth(i!2`2, P!1 - 2),
          E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
       >>
       ((signal(running(0, cons(u!1, i!2`2),
                        nth(i!2`1,
                            floor(((mid - 1) / (p - 2)) * P!1 -
                                   2 * ((mid - 1) / (p - 2))))))
          >>
          (trans(u!1, car(i!2`2),
                 E(public(car(i!2`2)),
                   conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
            >> Stop[event]))
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_init.1.2 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
[-3]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   ((signal(running(0, cons(u!1, i!2`2),
                       nth(i!2`1,
                           floor(((mid - 1) / (p - 2)) * P!1 -
                                  2 * ((mid - 1) / (p - 2))))))
         >>
         (trans(u!1, car(i!2`2),
                E(public(car(i!2`2)),
                  conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
           >> Stop[event]))
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictpostmid_init.1.2.1 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
[-3]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-4]  2 <= P!1
  |-------
{1}   rho_postmid(w!1)
                 (running(0, cons(u!1, i!2`2),
                          nth(i!2`1,
                              floor(((mid - 1) / (p - 2)) * P!1
                                    -
                                    2 * ((mid - 1) / (p - 2))))))
{2}   R_postmid(w!1)
               (signal(running(0, cons(u!1, i!2`2),
                               nth(i!2`1,
                                   floor(((mid - 1) / (p - 2)) * P!1
                                         -
                                         2 * ((mid - 1) / (p - 2)))))))
{3}   signal(running(0, cons(u!1, i!2`2),
                     nth(i!2`1,
                         floor(((mid - 1) / (p - 2)) * P!1 -
                                2 * ((mid - 1) / (p - 2))))))
       >>
       ((trans(u!1, car(i!2`2),
               E(public(car(i!2`2)),
                 conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
          >> Stop[event])
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_init.1.2.1 :  

  |-------
[1]   rho_postmid(w!1)
                 (running(0, cons(u!1, i!2`2),
                          nth(i!2`1,
                              floor(((mid - 1) / (p - 2)) * P!1
                                    -
                                    2 * ((mid - 1) / (p - 2))))))

Rerunning step: (expand "rho_postmid")
Expanding the definition of rho_postmid,
this simplifies to: 
restrictpostmid_init.1.2.1 :  

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictpostmid_init.1.2.1.

restrictpostmid_init.1.2.2 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
[-3]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-4]  2 <= P!1
  |-------
{1}   ((trans(u!1, car(i!2`2),
              E(public(car(i!2`2)),
                conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
         >> Stop[event])
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
{2}   R_postmid(w!1)
               (signal(running(0, cons(u!1, i!2`2),
                               nth(i!2`1,
                                   floor(((mid - 1) / (p - 2)) * P!1
                                         -
                                         2 * ((mid - 1) / (p - 2)))))))
{3}   signal(running(0, cons(u!1, i!2`2),
                     nth(i!2`1,
                         floor(((mid - 1) / (p - 2)) * P!1 -
                                2 * ((mid - 1) / (p - 2))))))
       >>
       ((trans(u!1, car(i!2`2),
               E(public(car(i!2`2)),
                 conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
          >> Stop[event])
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_init.1.2.2 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
[-3]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   ((trans(u!1, car(i!2`2),
              E(public(car(i!2`2)),
                conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
         >> Stop[event])
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictpostmid_init.1.2.2.1 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
[-3]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-4]  2 <= P!1
  |-------
{1}   rho_postmid(w!1)
                 (E(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
{2}   R_postmid(w!1)
               (trans(u!1, car(i!2`2),
                      E(public(car(i!2`2)),
                        conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1)))))
{3}   trans(u!1, car(i!2`2),
            E(public(car(i!2`2)),
              conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
       >> (Stop[event] # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete -2 -3 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_init.1.2.2.1 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (E(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (expand "E")
Expanding the definition of E,
this simplifies to: 
restrictpostmid_init.1.2.2.1 :  

{-1}  rho_postmid(w!1)
                 (code(public(u!1),
                       conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
{1}   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (expand "rho_postmid" -1)
Expanding the definition of rho_postmid,
this simplifies to: 
restrictpostmid_init.1.2.2.1 :  

{-1}  rho_postmid(w!1)(conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))) OR
       EXISTS (i: {x: nat | mid < x AND x <= w!1}):
         public(u!1) = public(hu(i)) AND
          EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                  nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
            conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)) =
             conc(nlist(append(nl1, cons(n_mid, nl2))),
                  ilist(remove(hu_list, i)))
[-2]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
restrictpostmid_init.1.2.2.1.1 :  

{-1}  rho_postmid(w!1)(conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)))
[-2]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (lemma "listprops[Nonce].elt_append2"
                 ("l1" "(:i!1:)" "l2" "i!2`1" "t" "n_mid"))
Applying listprops[Nonce].elt_append2 where 
  l1 gets (: i!1 :),
  l2 gets i!2`1,
  t gets n_mid,
this simplifies to: 
restrictpostmid_init.1.2.2.1.1 :  

{-1}  elt(i!2`1, n_mid) IMPLIES elt(append((: i!1 :), i!2`1), n_mid)
[-2]  rho_postmid(w!1)(conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)))
[-3]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (grind :exclude "elt")
append rewrites append((: :), i!2`1)
  to i!2`1
append rewrites append((: i!1 :), i!2`1)
  to cons(i!1, i!2`1)
rho_postmid rewrites rho_postmid(w!1)(nlist(cons(i!1, i!2`1)))
  to FALSE
rho_postmid rewrites rho_postmid(w!1)(ilist(i!2`2))
  to TRUE
rho_postmid rewrites 
  rho_postmid(w!1)(conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)))
  to FALSE
rho_postmid rewrites rho_postmid(w!1)(nlist(cons(i!1, i!2`1)))
  to NOT elt(cons(i!1, i!2`1), n_mid)
rho_postmid rewrites rho_postmid(w!1)(ilist(i!2`2))
  to TRUE
rho_postmid rewrites 
  rho_postmid(w!1)(conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)))
  to NOT elt(cons(i!1, i!2`1), n_mid)
rho_postmid rewrites rho_postmid(w!1)(ilist(cons(u!1, cdr(i!2`2))))
  to TRUE
rho_postmid rewrites rho_postmid(w!1)(nlist(i!2`1))
  to TRUE
rho_postmid rewrites 
  rho_postmid(w!1)(conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1)))
  to TRUE
remove rewrites remove(cdr(hu_list), i - 1)
  to cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2))
remove rewrites remove(hu_list, i)
  to cons(car(hu_list),
           cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2)))
rho_postmid rewrites 
  rho_postmid(w!1)
             (code(public(car(i!2`2)),
                   conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpostmid_init.1.2.2.1.1.

restrictpostmid_init.1.2.2.1.2 :  

{-1}  EXISTS (i: {x: nat | mid < x AND x <= w!1}):
        public(u!1) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)) =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, i)))
[-2]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictpostmid_init.1.2.2.1.2 :  

{-1}  public(u!1) = public(hu(i!3))
{-2}  conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, i!3)))
[-3]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (comment "contradiction in -2 and i!3<p")
Adding comment: contradiction in -2 and i!3<p
this simplifies to: 
restrictpostmid_init.1.2.2.1.2 : 
;;; contradiction in -2 and i!3<p

[-1]  public(u!1) = public(hu(i!3))
[-2]  conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, i!3)))
[-3]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictpostmid_init.1.2.2.1.2 : 
;;; contradiction in -2 and i!3<p

{-1}  nlist(cons(i!1, i!2`1)) = nlist(append(nl1!1, cons(n_mid, nl2!1)))
{-2}  ilist(i!2`2) = ilist(remove(hu_list, i!3))
[-3]  public(u!1) = public(hu(i!3))
[-4]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictpostmid_init.1.2.2.1.2 : 
;;; contradiction in -2 and i!3<p

{-1}  cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-2]  ilist(i!2`2) = ilist(remove(hu_list, i!3))
[-3]  public(u!1) = public(hu(i!3))
[-4]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictpostmid_init.1.2.2.1.2 : 
;;; contradiction in -2 and i!3<p

{-1}  i!2`2 = remove(hu_list, i!3)
[-2]  cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-3]  public(u!1) = public(hu(i!3))
[-4]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (typepred "i!3" "nl1!1" "nl2!1" "i!2`1" "i!2`2"
                 "hu_list")
Adding type constraints for  i!3, nl1!1, nl2!1, i!2`1, i!2`2, hu_list,
this simplifies to: 
restrictpostmid_init.1.2.2.1.2 : 
;;; contradiction in -2 and i!3<p

{-1}  mid < i!3
{-2}  i!3 <= w!1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl1!1)
{-4}  length(nl1!1) = mid
{-5}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
{-6}  length(nl2!1) = -1 - mid + i!3
{-7}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`1)
{-8}  length(i!2`1) = P!1 - 1
{-9}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`2)
{-10} length(i!2`2) = P!1 - 1
{-11} every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-12} (length(hu_list) = p)
{-13} FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-14] i!2`2 = remove(hu_list, i!3)
[-15] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
[-16] public(u!1) = public(hu(i!3))
[-17] 2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (delete -1 -3 -5 -7 -9 -11 -13 -16 -17 +)
Deleting some formulas,
this simplifies to: 
restrictpostmid_init.1.2.2.1.2 : 
;;; contradiction in -2 and i!3<p

[-1]  i!3 <= w!1
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  length(i!2`1) = P!1 - 1
[-5]  length(i!2`2) = P!1 - 1
[-6]  (length(hu_list) = p)
[-7]  i!2`2 = remove(hu_list, i!3)
[-8]  cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
  |-------

Rerunning step: (case "P!1=p")
Case splitting on 
   P!1 = p, 
this yields  2 subgoals: 
restrictpostmid_init.1.2.2.1.2.1 : 
;;; contradiction in -2 and i!3<p

{-1}  P!1 = p
[-2]  i!3 <= w!1
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + i!3
[-5]  length(i!2`1) = P!1 - 1
[-6]  length(i!2`2) = P!1 - 1
[-7]  (length(hu_list) = p)
[-8]  i!2`2 = remove(hu_list, i!3)
[-9]  cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
  |-------

Rerunning step: (lemma "listprops[Identity].equality_length"
                 ("l1" "cons(i!1,i!2`1)" "l2"
                  "append(nl1!1,cons(n_mid,nl2!1))"))
Applying listprops[Identity].equality_length where 
  l1 gets cons(i!1, i!2`1),
  l2 gets append(nl1!1, cons(n_mid, nl2!1)),
this simplifies to: 
restrictpostmid_init.1.2.2.1.2.1 : 
;;; contradiction in -2 and i!3<p

{-1}  cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1)) IMPLIES
       length[Identity](cons(i!1, i!2`1)) =
        length[Identity](append(nl1!1, cons(n_mid, nl2!1)))
[-2]  P!1 = p
[-3]  i!3 <= w!1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  length(i!2`1) = P!1 - 1
[-7]  length(i!2`2) = P!1 - 1
[-8]  (length(hu_list) = p)
[-9]  i!2`2 = remove(hu_list, i!3)
[-10] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
  |-------

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpostmid_init.1.2.2.1.2.1 : 
;;; contradiction in -2 and i!3<p

{-1}  length[Identity](cons(i!1, i!2`1)) =
       length[Identity](append(nl1!1, cons(n_mid, nl2!1)))
[-2]  P!1 = p
[-3]  i!3 <= w!1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  length(i!2`1) = P!1 - 1
[-7]  length(i!2`2) = P!1 - 1
[-8]  (length(hu_list) = p)
[-9]  i!2`2 = remove(hu_list, i!3)
[-10] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
  |-------

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets cons(n_mid, nl2!1),
l1: list[T] gets nl1!1,
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictpostmid_init.1.2.2.1.2.1 : 
;;; contradiction in -2 and i!3<p

{-1}  length[Identity](cons(i!1, i!2`1)) =
       length(cons(n_mid, nl2!1)) + length(nl1!1)
[-2]  P!1 = p
[-3]  i!3 <= w!1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  length(i!2`1) = P!1 - 1
[-7]  length(i!2`2) = P!1 - 1
[-8]  (length(hu_list) = p)
[-9]  i!2`2 = remove(hu_list, i!3)
[-10] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
  |-------

Rerunning step: (expand "length" -1 (1 2))
Expanding the definition of length,
this simplifies to: 
restrictpostmid_init.1.2.2.1.2.1 : 
;;; contradiction in -2 and i!3<p

{-1}  length[Identity](i!2`1) = length(nl1!1) + length[Identity](nl2!1)
[-2]  P!1 = p
[-3]  i!3 <= w!1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  length(i!2`1) = P!1 - 1
[-7]  length(i!2`2) = P!1 - 1
[-8]  (length(hu_list) = p)
[-9]  i!2`2 = remove(hu_list, i!3)
[-10] cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
  |-------

Rerunning step: (delete -7 -8 -9 -10)
Deleting some formulas,
this simplifies to: 
restrictpostmid_init.1.2.2.1.2.1 : 
;;; contradiction in -2 and i!3<p

[-1]  length[Identity](i!2`1) = length(nl1!1) + length[Identity](nl2!1)
[-2]  P!1 = p
[-3]  i!3 <= w!1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  length(i!2`1) = P!1 - 1
  |-------

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_init.1.2.2.1.2.1.

restrictpostmid_init.1.2.2.1.2.2 : 
;;; contradiction in -2 and i!3<p

[-1]  i!3 <= w!1
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  length(i!2`1) = P!1 - 1
[-5]  length(i!2`2) = P!1 - 1
[-6]  (length(hu_list) = p)
[-7]  i!2`2 = remove(hu_list, i!3)
[-8]  cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
  |-------
{1}   P!1 = p

Rerunning step: (replace -7 -5)
Replacing using formula -7,
this simplifies to: 
restrictpostmid_init.1.2.2.1.2.2 : 
;;; contradiction in -2 and i!3<p

[-1]  i!3 <= w!1
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  length(i!2`1) = P!1 - 1
{-5}  length(remove(hu_list, i!3)) = P!1 - 1
[-6]  (length(hu_list) = p)
[-7]  i!2`2 = remove(hu_list, i!3)
[-8]  cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
  |-------
[1]   P!1 = p

Rerunning step: (rewrite "length_remove" -5 :dir rl)
Found matching substitution:
i: below[length(c)] gets i!3,
c: (cons?[T]) gets hu_list,
Rewriting using length_remove, matching in -5,
this yields  2 subgoals: 
restrictpostmid_init.1.2.2.1.2.2.1 : 
;;; contradiction in -2 and i!3<p

[-1]  i!3 <= w!1
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  length(i!2`1) = P!1 - 1
{-5}  length[Identity](hu_list) - 1 = P!1 - 1
[-6]  (length(hu_list) = p)
[-7]  i!2`2 = remove(hu_list, i!3)
[-8]  cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
  |-------
[1]   P!1 = p

Rerunning step: (delete -1 -2 -3 -4 -7 -8)
Deleting some formulas,
this simplifies to: 
restrictpostmid_init.1.2.2.1.2.2.1 : 
;;; contradiction in -2 and i!3<p

[-1]  length[Identity](hu_list) - 1 = P!1 - 1
[-2]  (length(hu_list) = p)
  |-------
[1]   P!1 = p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_init.1.2.2.1.2.2.1.

restrictpostmid_init.1.2.2.1.2.2.2 : 
;;; contradiction in -2 and i!3<p

[-1]  i!3 <= w!1
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  length(i!2`1) = P!1 - 1
[-5]  length(remove(hu_list, i!3)) = P!1 - 1
[-6]  (length(hu_list) = p)
[-7]  i!2`2 = remove(hu_list, i!3)
[-8]  cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
  |-------
{1}   cons?[Identity](hu_list)
[2]   P!1 = p

Rerunning step: (typepred "p")
Adding type constraints for  p,
this simplifies to: 
restrictpostmid_init.1.2.2.1.2.2.2 : 
;;; contradiction in -2 and i!3<p

{-1}  3 <= p
[-2]  i!3 <= w!1
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + i!3
[-5]  length(i!2`1) = P!1 - 1
[-6]  length(remove(hu_list, i!3)) = P!1 - 1
[-7]  (length(hu_list) = p)
[-8]  i!2`2 = remove(hu_list, i!3)
[-9]  cons(i!1, i!2`1) = append(nl1!1, cons(n_mid, nl2!1))
  |-------
[1]   cons?[Identity](hu_list)
[2]   P!1 = p

Rerunning step: (delete -2 -3 -4 -5 -6 -8 -9 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_init.1.2.2.1.2.2.2 : 
;;; contradiction in -2 and i!3<p

[-1]  3 <= p
[-2]  (length(hu_list) = p)
  |-------
[1]   cons?[Identity](hu_list)

Rerunning step: (nonemptylist "hu_list")
Relating existence of a tail to a list's length,

This completes the proof of restrictpostmid_init.1.2.2.1.2.2.2.


This completes the proof of restrictpostmid_init.1.2.2.1.2.2.


This completes the proof of restrictpostmid_init.1.2.2.1.2.


This completes the proof of restrictpostmid_init.1.2.2.1.

restrictpostmid_init.1.2.2.2 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
[-3]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-4]  2 <= P!1
  |-------
{1}   (Stop[event] # R_postmid(w!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
{2}   R_postmid(w!1)
               (trans(u!1, car(i!2`2),
                      E(public(car(i!2`2)),
                        conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1)))))
{3}   trans(u!1, car(i!2`2),
            E(public(car(i!2`2)),
              conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
       >> (Stop[event] # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_init.1.2.2.2 :  

  |-------
[1]   (Stop[event] # R_postmid(w!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictpostmid_init.1.2.2.2.


This completes the proof of restrictpostmid_init.1.2.2.


This completes the proof of restrictpostmid_init.1.2.


This completes the proof of restrictpostmid_init.1.

restrictpostmid_init.2 :  

{-1}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
{-2}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       length[Nonce](i!2`1)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, i`1)), ilist(i`2))))
            >>
            (signal(running(0, cons(u!1, i`2),
                            nth(i`1,
                                floor(((mid - 1) / (p - 2)) * P!1
                                      -
                                      2 * ((mid - 1) / (p - 2))))))
              >>
              (trans(u!1, car(i`2),
                     E(public(car(i`2)),
                       conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
                >> Stop[event]))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (typepred "i!2`1")
Adding type constraints for  i!2`1,
this simplifies to: 
restrictpostmid_init.2 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`1)
{-2}  length(i!2`1) = P!1 - 1
[-3]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
[-4]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       length[Nonce](i!2`1)
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, i`1)), ilist(i`2))))
            >>
            (signal(running(0, cons(u!1, i`2),
                            nth(i`1,
                                floor(((mid - 1) / (p - 2)) * P!1
                                      -
                                      2 * ((mid - 1) / (p - 2))))))
              >>
              (trans(u!1, car(i`2),
                     E(public(car(i`2)),
                       conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
                >> Stop[event]))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -3 -5 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_init.2 :  

[-1]  length(i!2`1) = P!1 - 1
[-2]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
  |-------
[1]   floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       length[Nonce](i!2`1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_init.2.

restrictpostmid_init.3 :  

{-1}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
{-2}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   P!1 - 2 < length[Identity](i!2`2)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, i`1)), ilist(i`2))))
            >>
            (signal(running(0, cons(u!1, i`2),
                            nth(i`1,
                                floor(((mid - 1) / (p - 2)) * P!1
                                      -
                                      2 * ((mid - 1) / (p - 2))))))
              >>
              (trans(u!1, car(i`2),
                     E(public(car(i`2)),
                       conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
                >> Stop[event]))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (typepred "i!2`2")
Adding type constraints for  i!2`2,
this simplifies to: 
restrictpostmid_init.3 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`2)
{-2}  length(i!2`2) = P!1 - 1
[-3]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
[-4]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   P!1 - 2 < length[Identity](i!2`2)
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, i`1)), ilist(i`2))))
            >>
            (signal(running(0, cons(u!1, i`2),
                            nth(i`1,
                                floor(((mid - 1) / (p - 2)) * P!1
                                      -
                                      2 * ((mid - 1) / (p - 2))))))
              >>
              (trans(u!1, car(i`2),
                     E(public(car(i`2)),
                       conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
                >> Stop[event]))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -3 -4 -5 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_init.3 :  

[-1]  length(i!2`2) = P!1 - 1
  |-------
[1]   P!1 - 2 < length[Identity](i!2`2)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_init.3.

restrictpostmid_init.4 :  

{-1}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
{-2}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!1 :))
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, i`1)), ilist(i`2))))
            >>
            (signal(running(0, cons(u!1, i`2),
                            nth(i`1,
                                floor(((mid - 1) / (p - 2)) * P!1
                                      -
                                      2 * ((mid - 1) / (p - 2))))))
              >>
              (trans(u!1, car(i`2),
                     E(public(car(i`2)),
                       conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
                >> Stop[event]))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_init.4 :  

  |-------
[1]   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!1 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!1 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpostmid_init.4.

restrictpostmid_init.5 :  

{-1}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
{-2}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   cons?[Identity](i!2`2)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, i`1)), ilist(i`2))))
            >>
            (signal(running(0, cons(u!1, i`2),
                            nth(i`1,
                                floor(((mid - 1) / (p - 2)) * P!1
                                      -
                                      2 * ((mid - 1) / (p - 2))))))
              >>
              (trans(u!1, car(i`2),
                     E(public(car(i`2)),
                       conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
                >> Stop[event]))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -2 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_init.5 :  

[-1]  2 <= P!1
  |-------
[1]   cons?[Identity](i!2`2)

Rerunning step: (nonemptylist "i!2`2")
Relating existence of a tail to a list's length,

This completes the proof of restrictpostmid_init.5.

restrictpostmid_init.6 :  

{-1}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
{-2}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!1 :))
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (signal(running(0, cons(u!1, il),
                            nth(nl,
                                floor(((mid - 1) / (p - 2)) * P!1
                                      -
                                      2 * ((mid - 1) / (p - 2))))))
              >>
              (trans(u!1, car(il),
                     E(public(car(il)),
                       conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                >> Stop[event]))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_init.6 :  

  |-------
[1]   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!1 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!1 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpostmid_init.6.

restrictpostmid_init.7 :  

{-1}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
{-2}  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        cons?[Identity](il)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (signal(running(0, cons(u!1, il),
                            nth(nl,
                                floor(((mid - 1) / (p - 2)) * P!1
                                      -
                                      2 * ((mid - 1) / (p - 2))))))
              >>
              (trans(u!1, car(il),
                     E(public(car(il)),
                       conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                >> Stop[event]))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictpostmid_init.7 :  

[-1]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) >= 0
[-2]  floor(((mid - 1) / (p - 2)) * P!1 - 2 * ((mid - 1) / (p - 2))) <
       P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   cons?[Identity](il!1)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (signal(running(0, cons(u!1, il),
                            nth(nl,
                                floor(((mid - 1) / (p - 2)) * P!1
                                      -
                                      2 * ((mid - 1) / (p - 2))))))
              >>
              (trans(u!1, car(il),
                     E(public(car(il)),
                       conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                >> Stop[event]))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -2 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_init.7 :  

[-1]  2 <= P!1
  |-------
[1]   cons?[Identity](il!1)

Rerunning step: (nonemptylist "il!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictpostmid_init.7.

Q.E.D.


Run time  = 3.25 secs.
Real time = 4.30 secs.
nil
pvs(77): 
Installing rewrite rule sets.singleton_rew (all instances)
restrictpostmid_middle :  

  |-------
{1}   FORALL (P: nat_from_2, u: Identity, w: {x: nat | mid < x AND x < p}):
        P /= 2 =>
         (((Interleave! (k: nat_1_to(P), nnK: Nonces(P, u, k)):
              UROLE_MIDDLE(P, k, u, nnK))
            # R_postmid(w))
           |> RankUser(rho_postmid(w)))

Rerunning step: (auto-rewrite-theory "sets")
Rewriting relative to the theory: sets,
this simplifies to: 
restrictpostmid_middle :  

  |-------
[1]   FORALL (P: nat_from_2, u: Identity, w: {x: nat | mid < x AND x < p}):
        P /= 2 =>
         (((Interleave! (k: nat_1_to(P), nnK: Nonces(P, u, k)):
              UROLE_MIDDLE(P, k, u, nnK))
            # R_postmid(w))
           |> RankUser(rho_postmid(w)))

Rerunning step: (auto-rewrite "USER_TCC2")
Installing rewrite rule gnsl_middle.USER_TCC2
Installing automatic rewrites from: 
  USER_TCC2
this simplifies to: 
restrictpostmid_middle :  

  |-------
[1]   FORALL (P: nat_from_2, u: Identity, w: {x: nat | mid < x AND x < p}):
        P /= 2 =>
         (((Interleave! (k: nat_1_to(P), nnK: Nonces(P, u, k)):
              UROLE_MIDDLE(P, k, u, nnK))
            # R_postmid(w))
           |> RankUser(rho_postmid(w)))

Rerunning step: (skosimp)
Skolemizing and flattening,
this simplifies to: 
restrictpostmid_middle :  

  |-------
{1}   P!1 = 2
{2}   (((Interleave! (k: nat_1_to(P!1), nnK: Nonces(P!1, u!1, k)):
           UROLE_MIDDLE(P!1, k, u!1, nnK))
         # R_postmid(w!1))
        |> RankUser(rho_postmid(w!1)))

Rerunning step: (expand "RankUser")
Expanding the definition of RankUser,
this simplifies to: 
restrictpostmid_middle :  

  |-------
[1]   P!1 = 2
{2}   (((Interleave! (k: nat_1_to(P!1), nnK: Nonces(P!1, u!1, k)):
           UROLE_MIDDLE(P!1, k, u!1, nnK))
         # R_postmid(w!1))
        |>
        LAMBDA (tr: list[event]):
          every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(tr)
           =>
           every(LAMBDA (e: event):
                   complement(rec?)(e) => rho_postmid(w!1)(msg(e)))
                (tr))

Rerunning step: (interleaving2)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
USER_TCC2 rewrites EXISTS (x: [k: nat_1_to(P!1), Nonces(P!1, u!1, k)]): TRUE
  to TRUE
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
USER_TCC2 rewrites EXISTS (x: [k: nat_1_to(P!1), Nonces(P!1, u!1, k)]): TRUE
  to TRUE
Applying interleaving rule,
this simplifies to: 
restrictpostmid_middle :  

  |-------
[1]   P!1 = 2
{2}   UROLE_MIDDLE(P!1, i!1`1, u!1, i!1`2) # R_postmid(w!1) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (typepred "i!1`1" "P!1")
Adding type constraints for  i!1`1, P!1,
this simplifies to: 
restrictpostmid_middle :  

{-1}  0 < i!1`1
{-2}  i!1`1 < P!1 - 1
{-3}  2 <= P!1
  |-------
[1]   P!1 = 2
[2]   UROLE_MIDDLE(P!1, i!1`1, u!1, i!1`2) # R_postmid(w!1) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (lemma "select_right_nonce2" ("P" "P!1"))
Applying select_right_nonce2 where 
  P gets P!1,
this simplifies to: 
restrictpostmid_middle :  

{-1}  (P!1 = p IMPLIES floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid)
       AND
       floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1 AND
        floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-2]  0 < i!1`1
[-3]  i!1`1 < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   P!1 = 2
[2]   UROLE_MIDDLE(P!1, i!1`1, u!1, i!1`2) # R_postmid(w!1) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictpostmid_middle :  

{-1}  (P!1 = p IMPLIES floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid)
{-2}  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
{-3}  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   P!1 = 2
[2]   UROLE_MIDDLE(P!1, i!1`1, u!1, i!1`2) # R_postmid(w!1) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle :  

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   P!1 = 2
[2]   UROLE_MIDDLE(P!1, i!1`1, u!1, i!1`2) # R_postmid(w!1) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (expand "UROLE_MIDDLE")
Expanding the definition of UROLE_MIDDLE,
this simplifies to: 
restrictpostmid_middle :  

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   P!1 = 2
{2}   IF i!1`2 = n_mid
        THEN Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
                      nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                      il1:
                        {x: list[Identity] |
                           (length(x) = i!1`1) AND
                            FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
                      il2:
                        {x: list[Identity] |
                           (length(x) = P!1 - 1 - i!1`1) AND
                            FORALL (k: below[P!1 - 1 - i!1`1]):
                              nth(x, k) = hu(1 + k + i!1`1)}):
               (rec(u!1, nth(il1, i!1`1 - 1),
                    E(public(u!1),
                      conc(nlist(nl1), ilist(append(il1, il2)))))
                 >>
                 (trans(u!1, car(il2),
                        E(public(car(il2)),
                          conc(nlist(append(nl1, (: i!1`2 :))),
                               ilist(append(il1, cons(u!1, cdr(il2)))))))
                   >>
                   (rec(u!1, nth(il1, i!1`1 - 1),
                        E(public(u!1),
                          conc(ilist(append(il1, il2)),
                               nlist(cons(i!1`2, nl2)))))
                     >>
                     ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                       (signal(commit(mid,
                                      append(il1, cons(u!1, il2)),
                                      i!1`2))
                         >> Stop[event])))))
      ELSE IF i!1`1 <=
               floor(1 - 2 * ((mid - 1) / (p - 2)) +
                      ((mid - 1) / (p - 2)) * P!1)
             THEN Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
                           nl2:
                             {x: list[Nonce] |
                                length(x) = P!1 - 1 - i!1`1},
                           il1: {x: list[Identity] | length(x) = i!1`1},
                           il2:
                             {x: list[Identity] |
                                length(x) = P!1 - 1 - i!1`1}):
                    (rec(u!1, nth(il1, i!1`1 - 1),
                         E(public(u!1),
                           conc(nlist(nl1), ilist(append(il1, il2)))))
                      >>
                      (trans(u!1, car(il2),
                             E(public(car(il2)),
                               conc(nlist(append(nl1, (: i!1`2 :))),
                                    ilist
                                    (append(il1, cons(u!1, cdr(il2)))))))
                        >>
                        (rec(u!1, nth(il1, i!1`1 - 1),
                             E(public(u!1),
                               conc(ilist(append(il1, il2)),
                                    nlist(cons(i!1`2, nl2)))))
                          >>
                          (signal(running(i!1`1,
                                          append(il1, cons(u!1, il2)),
                                          nth
                                          (cons(i!1`2, nl2),
                                           floor
                                           (1 - 2 * ((mid - 1) / (p - 2))
                                            +
                                            ((mid - 1) / (p - 2)) * P!1)
                                           -
                                           i!1`1)))
                            >>
                            ((LastMessage(P!1,
                                          i!1`1,
                                          u!1,
                                          nl1,
                                          nl2,
                                          il1,
                                          il2))
                              >> Stop[event])))))
           ELSE Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
                         nl2:
                           {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                         il1: {x: list[Identity] | length(x) = i!1`1},
                         il2:
                           {x: list[Identity] |
                              length(x) = P!1 - 1 - i!1`1}):
                  (rec(u!1, nth(il1, i!1`1 - 1),
                       E(public(u!1),
                         conc(nlist(nl1), ilist(append(il1, il2)))))
                    >>
                    (signal(running(i!1`1,
                                    append(il1, cons(u!1, il2)),
                                    nth
                                    (nl1,
                                     floor
                                     (1 - 2 * ((mid - 1) / (p - 2))
                                      +
                                      ((mid - 1) / (p - 2)) * P!1))))
                      >>
                      (trans(u!1, car(il2),
                             E(public(car(il2)),
                               conc(nlist(append(nl1, (: i!1`2 :))),
                                    ilist
                                    (append(il1, cons(u!1, cdr(il2)))))))
                        >>
                        (rec(u!1, nth(il1, i!1`1 - 1),
                             E(public(u!1),
                               conc(ilist(append(il1, il2)),
                                    nlist(cons(i!1`2, nl2)))))
                          >>
                          ((LastMessage(P!1,
                                        i!1`1,
                                        u!1,
                                        nl1,
                                        nl2,
                                        il1,
                                        il2))
                            >> Stop[event])))))
           ENDIF
      ENDIF
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (lift-if)
Lifting IF-conditions to the top level,
this simplifies to: 
restrictpostmid_middle :  

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   P!1 = 2
{2}   IF i!1`2 = n_mid
        THEN Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
                      nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                      il1:
                        {x: list[Identity] |
                           (length(x) = i!1`1) AND
                            FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
                      il2:
                        {x: list[Identity] |
                           (length(x) = P!1 - 1 - i!1`1) AND
                            FORALL (k: below[P!1 - 1 - i!1`1]):
                              nth(x, k) = hu(1 + k + i!1`1)}):
               (rec(u!1, nth(il1, i!1`1 - 1),
                    E(public(u!1),
                      conc(nlist(nl1), ilist(append(il1, il2)))))
                 >>
                 (trans(u!1, car(il2),
                        E(public(car(il2)),
                          conc(nlist(append(nl1, (: i!1`2 :))),
                               ilist(append(il1, cons(u!1, cdr(il2)))))))
                   >>
                   (rec(u!1, nth(il1, i!1`1 - 1),
                        E(public(u!1),
                          conc(ilist(append(il1, il2)),
                               nlist(cons(i!1`2, nl2)))))
                     >>
                     ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                       (signal(commit(mid,
                                      append(il1, cons(u!1, il2)),
                                      i!1`2))
                         >> Stop[event])))))
              # R_postmid(w!1)
              |>
              LAMBDA (t: list[event]):
                every(LAMBDA (e: event):
                        rec?(e) => rho_postmid(w!1)(msg(e)))
                     (t)
                 =>
                 every(LAMBDA (e: event):
                         NOT rec?(e) => rho_postmid(w!1)(msg(e)))
                      (t)
      ELSE IF i!1`1 <=
               floor(1 - 2 * ((mid - 1) / (p - 2)) +
                      ((mid - 1) / (p - 2)) * P!1)
             THEN Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
                           nl2:
                             {x: list[Nonce] |
                                length(x) = P!1 - 1 - i!1`1},
                           il1: {x: list[Identity] | length(x) = i!1`1},
                           il2:
                             {x: list[Identity] |
                                length(x) = P!1 - 1 - i!1`1}):
                    (rec(u!1, nth(il1, i!1`1 - 1),
                         E(public(u!1),
                           conc(nlist(nl1), ilist(append(il1, il2)))))
                      >>
                      (trans(u!1, car(il2),
                             E(public(car(il2)),
                               conc(nlist(append(nl1, (: i!1`2 :))),
                                    ilist
                                    (append(il1, cons(u!1, cdr(il2)))))))
                        >>
                        (rec(u!1, nth(il1, i!1`1 - 1),
                             E(public(u!1),
                               conc(ilist(append(il1, il2)),
                                    nlist(cons(i!1`2, nl2)))))
                          >>
                          (signal(running(i!1`1,
                                          append(il1, cons(u!1, il2)),
                                          nth
                                          (cons(i!1`2, nl2),
                                           floor
                                           (1 - 2 * ((mid - 1) / (p - 2))
                                            +
                                            ((mid - 1) / (p - 2)) * P!1)
                                           -
                                           i!1`1)))
                            >>
                            ((LastMessage(P!1,
                                          i!1`1,
                                          u!1,
                                          nl1,
                                          nl2,
                                          il1,
                                          il2))
                              >> Stop[event])))))
                   # R_postmid(w!1)
                   |>
                   LAMBDA (t: list[event]):
                     every(LAMBDA (e: event):
                             rec?(e) => rho_postmid(w!1)(msg(e)))
                          (t)
                      =>
                      every(LAMBDA (e: event):
                              NOT rec?(e) => rho_postmid(w!1)(msg(e)))
                           (t)
           ELSE Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
                         nl2:
                           {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                         il1: {x: list[Identity] | length(x) = i!1`1},
                         il2:
                           {x: list[Identity] |
                              length(x) = P!1 - 1 - i!1`1}):
                  (rec(u!1, nth(il1, i!1`1 - 1),
                       E(public(u!1),
                         conc(nlist(nl1), ilist(append(il1, il2)))))
                    >>
                    (signal(running(i!1`1,
                                    append(il1, cons(u!1, il2)),
                                    nth
                                    (nl1,
                                     floor
                                     (1 - 2 * ((mid - 1) / (p - 2))
                                      +
                                      ((mid - 1) / (p - 2)) * P!1))))
                      >>
                      (trans(u!1, car(il2),
                             E(public(car(il2)),
                               conc(nlist(append(nl1, (: i!1`2 :))),
                                    ilist
                                    (append(il1, cons(u!1, cdr(il2)))))))
                        >>
                        (rec(u!1, nth(il1, i!1`1 - 1),
                             E(public(u!1),
                               conc(ilist(append(il1, il2)),
                                    nlist(cons(i!1`2, nl2)))))
                          >>
                          ((LastMessage(P!1,
                                        i!1`1,
                                        u!1,
                                        nl1,
                                        nl2,
                                        il1,
                                        il2))
                            >> Stop[event])))))
                 # R_postmid(w!1)
                 |>
                 LAMBDA (t: list[event]):
                   every(LAMBDA (e: event):
                           rec?(e) => rho_postmid(w!1)(msg(e)))
                        (t)
                    =>
                    every(LAMBDA (e: event):
                            NOT rec?(e) => rho_postmid(w!1)(msg(e)))
                         (t)
           ENDIF
      ENDIF

Rerunning step: (prop)
Applying propositional simplification,
this yields  3 subgoals: 
restrictpostmid_middle.1 :  

{-1}  i!1`2 = n_mid
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1:
                 {x: list[Identity] |
                    (length(x) = i!1`1) AND
                     FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
               il2:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1 - i!1`1) AND
                     FORALL (k: below[P!1 - 1 - i!1`1]):
                       nth(x, k) = hu(1 + k + i!1`1)}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                (signal(commit(mid, append(il1, cons(u!1, il2)), i!1`2)) >>
                  Stop[event])))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   P!1 = 2

Rerunning step: (case "P!1=p AND u!1=hu(mid) AND i!1`1=mid")
Case splitting on 
   P!1 = p AND u!1 = hu(mid) AND i!1`1 = mid, 
this yields  2 subgoals: 
restrictpostmid_middle.1.1 :  

{-1}  P!1 = p AND u!1 = hu(mid) AND i!1`1 = mid
[-2]  i!1`2 = n_mid
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-4]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1:
                 {x: list[Identity] |
                    (length(x) = i!1`1) AND
                     FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
               il2:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1 - i!1`1) AND
                     FORALL (k: below[P!1 - 1 - i!1`1]):
                       nth(x, k) = hu(1 + k + i!1`1)}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                (signal(commit(mid, append(il1, cons(u!1, il2)), i!1`2)) >>
                  Stop[event])))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   P!1 = 2

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictpostmid_middle.1.1 :  

{-1}  P!1 = p
{-2}  u!1 = hu(mid)
{-3}  i!1`1 = mid
[-4]  i!1`2 = n_mid
[-5]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-6]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-7]  0 < i!1`1
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
[1]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1:
                 {x: list[Identity] |
                    (length(x) = i!1`1) AND
                     FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
               il2:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1 - i!1`1) AND
                     FORALL (k: below[P!1 - 1 - i!1`1]):
                       nth(x, k) = hu(1 + k + i!1`1)}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                (signal(commit(mid, append(il1, cons(u!1, il2)), i!1`2)) >>
                  Stop[event])))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   P!1 = 2

Rerunning step: (choice3)
Applying choice rule,
this yields  10 subgoals: 
restrictpostmid_middle.1.1.1 :  

[-1]  P!1 = p
[-2]  u!1 = hu(mid)
[-3]  i!1`1 = mid
[-4]  i!1`2 = n_mid
[-5]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-6]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-7]  0 < i!1`1
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
{1}   (rec(u!1, nth(i!2`3, i!1`1 - 1),
           E(public(u!1), conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
        >>
        (trans(u!1, car(i!2`4),
               E(public(car(i!2`4)),
                 conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
          >>
          (rec(u!1, nth(i!2`3, i!1`1 - 1),
               E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
            >>
            ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
              (signal(commit(mid, append(i!2`3, cons(u!1, i!2`4)), i!1`2))
                >> Stop[event])))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictpostmid_middle.1.1.1 :  

{-1}  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  P!1 = p
[-3]  u!1 = hu(mid)
[-4]  i!1`1 = mid
[-5]  i!1`2 = n_mid
{-6}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-7}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-8]  0 < i!1`1
[-9]  i!1`1 < P!1 - 1
[-10] 2 <= P!1
  |-------
{1}   ((trans(u!1, car(i!2`4),
              E(public(car(i!2`4)),
                conc(nlist(append(i!2`1, (: i!1`2 :))),
                     ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
         >>
         (rec(u!1, nth(i!2`3, i!1`1 - 1),
              E(public(u!1),
                conc(ilist(append(i!2`3, i!2`4)),
                     nlist(cons(i!1`2, i!2`2)))))
           >>
           ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
             (signal(commit(mid, append(i!2`3, cons(u!1, i!2`4)), i!1`2))
               >> Stop[event]))))
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
{2}   R_postmid(w!1)
               (rec(u!1, nth(i!2`3, i!1`1 - 1),
                    E(public(u!1),
                      conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))))
{3}   rec(u!1, nth(i!2`3, i!1`1 - 1),
          E(public(u!1), conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
       >>
       ((trans(u!1, car(i!2`4),
               E(public(car(i!2`4)),
                 conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
          >>
          (rec(u!1, nth(i!2`3, i!1`1 - 1),
               E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
            >>
            ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
              (signal(commit(mid, append(i!2`3, cons(u!1, i!2`4)), i!1`2))
                >> Stop[event]))))
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.1.1.1 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  P!1 = p
[-3]  u!1 = hu(mid)
[-4]  i!1`1 = mid
[-5]  i!1`2 = n_mid
[-6]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-7]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-8]  0 < i!1`1
[-9]  i!1`1 < P!1 - 1
[-10] 2 <= P!1
  |-------
[1]   ((trans(u!1, car(i!2`4),
              E(public(car(i!2`4)),
                conc(nlist(append(i!2`1, (: i!1`2 :))),
                     ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
         >>
         (rec(u!1, nth(i!2`3, i!1`1 - 1),
              E(public(u!1),
                conc(ilist(append(i!2`3, i!2`4)),
                     nlist(cons(i!1`2, i!2`2)))))
           >>
           ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
             (signal(commit(mid, append(i!2`3, cons(u!1, i!2`4)), i!1`2))
               >> Stop[event]))))
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictpostmid_middle.1.1.1.1 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  P!1 = p
[-3]  u!1 = hu(mid)
[-4]  i!1`1 = mid
[-5]  i!1`2 = n_mid
[-6]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-7]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-8]  0 < i!1`1
[-9]  i!1`1 < P!1 - 1
[-10] 2 <= P!1
  |-------
{1}   rho_postmid(w!1)
                 (E(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
{2}   R_postmid(w!1)
               (trans(u!1, car(i!2`4),
                      E(public(car(i!2`4)),
                        conc(nlist(append(i!2`1, (: i!1`2 :))),
                             ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))))
{3}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(nlist(append(i!2`1, (: i!1`2 :))),
                   ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
       >>
       ((rec(u!1, nth(i!2`3, i!1`1 - 1),
             E(public(u!1),
               conc(ilist(append(i!2`3, i!2`4)),
                    nlist(cons(i!1`2, i!2`2)))))
          >>
          ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
            (signal(commit(mid, append(i!2`3, cons(u!1, i!2`4)), i!1`2)) >>
              Stop[event])))
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   P!1 = 2

Rerunning step: (comment "prove the outgoing message, containing n_mid, is in rho")
Adding comment: prove the outgoing message, containing n_mid, is in rho
this simplifies to: 
restrictpostmid_middle.1.1.1.1 : 
;;; prove the outgoing message, containing n_mid, is in rho

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  P!1 = p
[-3]  u!1 = hu(mid)
[-4]  i!1`1 = mid
[-5]  i!1`2 = n_mid
[-6]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-7]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-8]  0 < i!1`1
[-9]  i!1`1 < P!1 - 1
[-10] 2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (E(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   R_postmid(w!1)
               (trans(u!1, car(i!2`4),
                      E(public(car(i!2`4)),
                        conc(nlist(append(i!2`1, (: i!1`2 :))),
                             ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))))
[3]   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(nlist(append(i!2`1, (: i!1`2 :))),
                   ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
       >>
       ((rec(u!1, nth(i!2`3, i!1`1 - 1),
             E(public(u!1),
               conc(ilist(append(i!2`3, i!2`4)),
                    nlist(cons(i!1`2, i!2`2)))))
          >>
          ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
            (signal(commit(mid, append(i!2`3, cons(u!1, i!2`4)), i!1`2)) >>
              Stop[event])))
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   P!1 = 2

Rerunning step: (typepred "i!2`1" "i!2`3" "i!2`4" "hu_list")
Adding type constraints for  i!2`1, i!2`3, i!2`4, hu_list,
this simplifies to: 
restrictpostmid_middle.1.1.1.1 : 
;;; prove the outgoing message, containing n_mid, is in rho

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`1)
{-2}  length(i!2`1) = i!1`1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`3)
{-4}  (length(i!2`3) = i!1`1)
{-5}  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
{-6}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`4)
{-7}  (length(i!2`4) = P!1 - 1 - i!1`1)
{-8}  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
{-9}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-10} (length(hu_list) = p)
{-11} FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-13] P!1 = p
[-14] u!1 = hu(mid)
[-15] i!1`1 = mid
[-16] i!1`2 = n_mid
[-17] floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-18] floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-19] 0 < i!1`1
[-20] i!1`1 < P!1 - 1
[-21] 2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (E(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   R_postmid(w!1)
               (trans(u!1, car(i!2`4),
                      E(public(car(i!2`4)),
                        conc(nlist(append(i!2`1, (: i!1`2 :))),
                             ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))))
[3]   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(nlist(append(i!2`1, (: i!1`2 :))),
                   ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
       >>
       ((rec(u!1, nth(i!2`3, i!1`1 - 1),
             E(public(u!1),
               conc(ilist(append(i!2`3, i!2`4)),
                    nlist(cons(i!1`2, i!2`2)))))
          >>
          ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
            (signal(commit(mid, append(i!2`3, cons(u!1, i!2`4)), i!1`2)) >>
              Stop[event])))
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   P!1 = 2

Rerunning step: (delete -1 -3 -6 -9 -12 -17 -18 -19 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.1.1.1.1 : 
;;; prove the outgoing message, containing n_mid, is in rho

[-1]  length(i!2`1) = i!1`1
[-2]  (length(i!2`3) = i!1`1)
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-5]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  u!1 = hu(mid)
[-10] i!1`1 = mid
[-11] i!1`2 = n_mid
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (E(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))

Rerunning step: (expand "E")
Expanding the definition of E,
this simplifies to: 
restrictpostmid_middle.1.1.1.1 : 
;;; prove the outgoing message, containing n_mid, is in rho

[-1]  length(i!2`1) = i!1`1
[-2]  (length(i!2`3) = i!1`1)
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-5]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  u!1 = hu(mid)
[-10] i!1`1 = mid
[-11] i!1`2 = n_mid
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
{1}   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))

Rerunning step: (expand "rho_postmid")
Expanding the definition of rho_postmid,
this simplifies to: 
restrictpostmid_middle.1.1.1.1 : 
;;; prove the outgoing message, containing n_mid, is in rho

[-1]  length(i!2`1) = i!1`1
[-2]  (length(i!2`3) = i!1`1)
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-5]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  u!1 = hu(mid)
[-10] i!1`1 = mid
[-11] i!1`2 = n_mid
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
{1}   rho_postmid(w!1)
                 (conc(nlist(append(i!2`1, (: i!1`2 :))),
                       ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))
       OR
       EXISTS (i: {x: nat | mid < x AND x <= w!1}):
         public(car(i!2`4)) = public(hu(i)) AND
          EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                  nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
            conc(nlist(append(i!2`1, (: i!1`2 :))),
                 ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
             =
             conc(nlist(append(nl1, cons(n_mid, nl2))),
                  ilist(remove(hu_list, i)))

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictpostmid_middle.1.1.1.1 : 
;;; prove the outgoing message, containing n_mid, is in rho

[-1]  length(i!2`1) = i!1`1
[-2]  (length(i!2`3) = i!1`1)
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-5]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  u!1 = hu(mid)
[-10] i!1`1 = mid
[-11] i!1`2 = n_mid
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
{1}   rho_postmid(w!1)
                 (conc(nlist(append(i!2`1, (: i!1`2 :))),
                       ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))
{2}   EXISTS (i: {x: nat | mid < x AND x <= w!1}):
        public(car(i!2`4)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, i)))

Rerunning step: (delete 1)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.1.1.1.1 : 
;;; prove the outgoing message, containing n_mid, is in rho

[-1]  length(i!2`1) = i!1`1
[-2]  (length(i!2`3) = i!1`1)
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-5]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  u!1 = hu(mid)
[-10] i!1`1 = mid
[-11] i!1`2 = n_mid
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
[1]   EXISTS (i: {x: nat | mid < x AND x <= w!1}):
        public(car(i!2`4)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, i)))

Rerunning step: (comment "the outgoing message is sent to mid+1")
Adding comment: the outgoing message is sent to mid+1
this simplifies to: 
restrictpostmid_middle.1.1.1.1 : 
;;; the outgoing message is sent to mid+1

[-1]  length(i!2`1) = i!1`1
[-2]  (length(i!2`3) = i!1`1)
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-5]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  u!1 = hu(mid)
[-10] i!1`1 = mid
[-11] i!1`2 = n_mid
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
[1]   EXISTS (i: {x: nat | mid < x AND x <= w!1}):
        public(car(i!2`4)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, i)))

Rerunning step: (inst 1 "mid+1")
Instantiating the top quantifier in 1 with the terms: 
 mid+1,
this simplifies to: 
restrictpostmid_middle.1.1.1.1 : 
;;; the outgoing message is sent to mid+1

[-1]  length(i!2`1) = i!1`1
[-2]  (length(i!2`3) = i!1`1)
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-5]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  u!1 = hu(mid)
[-10] i!1`1 = mid
[-11] i!1`2 = n_mid
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
{1}   public(car(i!2`4)) = public(hu(mid + 1)) AND
       EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
               nl2: {x: list[Nonce] | length(x) = 0}):
         conc(nlist(append(i!2`1, (: i!1`2 :))),
              ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
          =
          conc(nlist(append(nl1, cons(n_mid, nl2))),
               ilist(remove(hu_list, mid + 1)))

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
restrictpostmid_middle.1.1.1.1.1 : 
;;; the outgoing message is sent to mid+1

[-1]  length(i!2`1) = i!1`1
[-2]  (length(i!2`3) = i!1`1)
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-5]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  u!1 = hu(mid)
[-10] i!1`1 = mid
[-11] i!1`2 = n_mid
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
{1}   public(car(i!2`4)) = public(hu(mid + 1))

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictpostmid_middle.1.1.1.1.1 : 
;;; the outgoing message is sent to mid+1

[-1]  length(i!2`1) = i!1`1
[-2]  (length(i!2`3) = i!1`1)
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-5]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  u!1 = hu(mid)
[-10] i!1`1 = mid
[-11] i!1`2 = n_mid
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
{1}   car(i!2`4) = hu(1 + mid)

Rerunning step: (inst -5 "0")
Instantiating the top quantifier in -5 with the terms: 
 0,
this simplifies to: 
restrictpostmid_middle.1.1.1.1.1 : 
;;; the outgoing message is sent to mid+1

[-1]  length(i!2`1) = i!1`1
[-2]  (length(i!2`3) = i!1`1)
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  (length(i!2`4) = P!1 - 1 - i!1`1)
{-5}  nth(i!2`4, 0) = hu(1 + 0 + i!1`1)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  u!1 = hu(mid)
[-10] i!1`1 = mid
[-11] i!1`2 = n_mid
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
[1]   car(i!2`4) = hu(1 + mid)

Rerunning step: (delete -1 -2 -3 -4 -6 -7 -8 -9 -11 -12 -13)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.1.1.1.1.1 : 
;;; the outgoing message is sent to mid+1

[-1]  nth(i!2`4, 0) = hu(1 + 0 + i!1`1)
[-2]  i!1`1 = mid
  |-------
[1]   car(i!2`4) = hu(1 + mid)

Rerunning step: (grind)
nth rewrites nth(i!2`4, 0)
  to car(i!2`4)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpostmid_middle.1.1.1.1.1.

restrictpostmid_middle.1.1.1.1.2 : 
;;; the outgoing message is sent to mid+1

[-1]  length(i!2`1) = i!1`1
[-2]  (length(i!2`3) = i!1`1)
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-5]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  u!1 = hu(mid)
[-10] i!1`1 = mid
[-11] i!1`2 = n_mid
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
{1}   EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
              nl2: {x: list[Nonce] | length(x) = 0}):
        conc(nlist(append(i!2`1, (: i!1`2 :))),
             ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
         =
         conc(nlist(append(nl1, cons(n_mid, nl2))),
              ilist(remove(hu_list, mid + 1)))

Rerunning step: (inst 1 "i!2`1" "null")
Instantiating the top quantifier in 1 with the terms: 
 i!2`1, null,
this yields  2 subgoals: 
restrictpostmid_middle.1.1.1.1.2.1 : 
;;; the outgoing message is sent to mid+1

[-1]  length(i!2`1) = i!1`1
[-2]  (length(i!2`3) = i!1`1)
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-5]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  u!1 = hu(mid)
[-10] i!1`1 = mid
[-11] i!1`2 = n_mid
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
{1}   conc(nlist(append(i!2`1, (: i!1`2 :))),
           ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
       =
       conc(nlist(append(i!2`1, cons(n_mid, null))),
            ilist(remove(hu_list, mid + 1)))

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictpostmid_middle.1.1.1.1.2.1 : 
;;; the outgoing message is sent to mid+1

[-1]  length(i!2`1) = i!1`1
[-2]  (length(i!2`3) = i!1`1)
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-5]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  u!1 = hu(mid)
[-10] i!1`1 = mid
[-11] i!1`2 = n_mid
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
{1}   ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))) =
       ilist(remove(hu_list, 1 + mid))

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictpostmid_middle.1.1.1.1.2.1 : 
;;; the outgoing message is sent to mid+1

[-1]  length(i!2`1) = i!1`1
[-2]  (length(i!2`3) = i!1`1)
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-5]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  u!1 = hu(mid)
[-10] i!1`1 = mid
[-11] i!1`2 = n_mid
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
{1}   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + mid)

Rerunning step: (rewrite "length_nth_equality[Identity]" 1)
Found matching substitution:
l2: list[Identity] gets remove(hu_list, 1 + mid),
l1: list[Identity] gets append(i!2`3, cons(u!1, cdr(i!2`4))),
Rewriting using length_nth_equality[Identity], matching in 1,
this yields  2 subgoals: 
restrictpostmid_middle.1.1.1.1.2.1.1 : 
;;; the outgoing message is sent to mid+1

[-1]  length(i!2`1) = i!1`1
[-2]  (length(i!2`3) = i!1`1)
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-5]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  u!1 = hu(mid)
[-10] i!1`1 = mid
[-11] i!1`2 = n_mid
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
{1}   length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4)))) =
       length[Identity](remove(hu_list, 1 + mid))
[2]   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + mid)

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets cons(u!1, cdr(i!2`4)),
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in 1,
this simplifies to: 
restrictpostmid_middle.1.1.1.1.2.1.1 : 
;;; the outgoing message is sent to mid+1

[-1]  length(i!2`1) = i!1`1
[-2]  (length(i!2`3) = i!1`1)
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-5]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  u!1 = hu(mid)
[-10] i!1`1 = mid
[-11] i!1`2 = n_mid
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
{1}   length(cons(u!1, cdr(i!2`4))) + length(i!2`3) =
       length[Identity](remove(hu_list, 1 + mid))
[2]   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + mid)

Rerunning step: (rewrite "length_remove" 1 :dir rl)
Found matching substitution:
i: below[length(c)] gets 1 + mid,
c: (cons?[T]) gets hu_list,
Rewriting using length_remove, matching in 1,
this yields  2 subgoals: 
restrictpostmid_middle.1.1.1.1.2.1.1.1 : 
;;; the outgoing message is sent to mid+1

[-1]  length(i!2`1) = i!1`1
[-2]  (length(i!2`3) = i!1`1)
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-5]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  u!1 = hu(mid)
[-10] i!1`1 = mid
[-11] i!1`2 = n_mid
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
{1}   length(cons(u!1, cdr(i!2`4))) + length(i!2`3) =
       length[Identity](hu_list) - 1
[2]   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + mid)

Rerunning step: (expand "length" 1 1)
Expanding the definition of length,
this simplifies to: 
restrictpostmid_middle.1.1.1.1.2.1.1.1 : 
;;; the outgoing message is sent to mid+1

[-1]  length(i!2`1) = i!1`1
[-2]  (length(i!2`3) = i!1`1)
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-5]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  u!1 = hu(mid)
[-10] i!1`1 = mid
[-11] i!1`2 = n_mid
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
{1}   1 + length[Identity](cdr(i!2`4)) + length(i!2`3) =
       length[Identity](hu_list) - 1
[2]   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + mid)

Rerunning step: (rewrite "length_cdr" 1)
Found matching substitution:
cons_l: (cons?[T]) gets i!2`4,
Rewriting using length_cdr, matching in 1,
this simplifies to: 
restrictpostmid_middle.1.1.1.1.2.1.1.1 : 
;;; the outgoing message is sent to mid+1

[-1]  length(i!2`1) = i!1`1
[-2]  (length(i!2`3) = i!1`1)
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-5]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  u!1 = hu(mid)
[-10] i!1`1 = mid
[-11] i!1`2 = n_mid
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
{1}   1 + (length(i!2`4) - 1) + length(i!2`3) =
       length[Identity](hu_list) - 1
[2]   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + mid)

Rerunning step: (delete -1 -3 -5 -7 -9 -10 -11 -12 -13 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.1.1.1.1.2.1.1.1 : 
;;; the outgoing message is sent to mid+1

[-1]  (length(i!2`3) = i!1`1)
[-2]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-3]  (length(hu_list) = p)
[-4]  P!1 = p
  |-------
[1]   1 + (length(i!2`4) - 1) + length(i!2`3) =
       length[Identity](hu_list) - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.1.1.1.1.2.1.1.1.

restrictpostmid_middle.1.1.1.1.2.1.1.2 : 
;;; the outgoing message is sent to mid+1

[-1]  length(i!2`1) = i!1`1
[-2]  (length(i!2`3) = i!1`1)
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-5]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  u!1 = hu(mid)
[-10] i!1`1 = mid
[-11] i!1`2 = n_mid
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
{1}   cons?[Identity](hu_list)
[2]   length(cons(u!1, cdr(i!2`4))) + length(i!2`3) =
       length[Identity](remove(hu_list, 1 + mid))
[3]   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + mid)

Rerunning step: (lemma "more_list_props[Identity].length_non_zero"
                 ("l" "hu_list"))
Applying more_list_props[Identity].length_non_zero where 
  l gets hu_list,
this simplifies to: 
restrictpostmid_middle.1.1.1.1.2.1.1.2 : 
;;; the outgoing message is sent to mid+1

{-1}  length(hu_list) > 0 IFF cons?(hu_list)
[-2]  length(i!2`1) = i!1`1
[-3]  (length(i!2`3) = i!1`1)
[-4]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-5]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-6]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  P!1 = p
[-10] u!1 = hu(mid)
[-11] i!1`1 = mid
[-12] i!1`2 = n_mid
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
[1]   cons?[Identity](hu_list)
[2]   length(cons(u!1, cdr(i!2`4))) + length(i!2`3) =
       length[Identity](remove(hu_list, 1 + mid))
[3]   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + mid)

Rerunning step: (delete -2 -3 -4 -5 -6 -8 -10 -11 -12 -13 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.1.1.1.1.2.1.1.2 : 
;;; the outgoing message is sent to mid+1

[-1]  length(hu_list) > 0 IFF cons?(hu_list)
[-2]  (length(hu_list) = p)
[-3]  P!1 = p
[-4]  2 <= P!1
  |-------
[1]   cons?[Identity](hu_list)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.1.1.1.1.2.1.1.2.


This completes the proof of restrictpostmid_middle.1.1.1.1.2.1.1.

restrictpostmid_middle.1.1.1.1.2.1.2 : 
;;; the outgoing message is sent to mid+1

[-1]  length(i!2`1) = i!1`1
[-2]  (length(i!2`3) = i!1`1)
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-5]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  u!1 = hu(mid)
[-10] i!1`1 = mid
[-11] i!1`2 = n_mid
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
{1}   FORALL (i:
                below[length[Identity]
                          (append(i!2`3, cons(u!1, cdr(i!2`4))))]):
        nth(append(i!2`3, cons(u!1, cdr(i!2`4))), i) =
         nth(remove(hu_list, 1 + mid), i)
[2]   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + mid)

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictpostmid_middle.1.1.1.1.2.1.2 : 
;;; the outgoing message is sent to mid+1

{-1}  i!3 < length[Identity](append(i!2`3, cons(u!1, cdr(i!2`4))))
[-2]  length(i!2`1) = i!1`1
[-3]  (length(i!2`3) = i!1`1)
[-4]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-5]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-6]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  P!1 = p
[-10] u!1 = hu(mid)
[-11] i!1`1 = mid
[-12] i!1`2 = n_mid
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
{1}   nth(append(i!2`3, cons(u!1, cdr(i!2`4))), i!3) =
       nth(remove(hu_list, 1 + mid), i!3)
[2]   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + mid)

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets cons(u!1, cdr(i!2`4)),
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictpostmid_middle.1.1.1.1.2.1.2 : 
;;; the outgoing message is sent to mid+1

{-1}  i!3 < length(cons(u!1, cdr(i!2`4))) + length(i!2`3)
[-2]  length(i!2`1) = i!1`1
[-3]  (length(i!2`3) = i!1`1)
[-4]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-5]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-6]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  P!1 = p
[-10] u!1 = hu(mid)
[-11] i!1`1 = mid
[-12] i!1`2 = n_mid
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
[1]   nth(append(i!2`3, cons(u!1, cdr(i!2`4))), i!3) =
       nth(remove(hu_list, 1 + mid), i!3)
[2]   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + mid)

Rerunning step: (lemma "listprops[Identity].nth_append"
                 ("l1" "i!2`3" "l2" "cons(u!1,cdr(i!2`4))" "i" "i!3"))
Applying listprops[Identity].nth_append where 
  l1 gets i!2`3,
  l2 gets cons(u!1, cdr(i!2`4)),
  i gets i!3,
this yields  2 subgoals: 
restrictpostmid_middle.1.1.1.1.2.1.2.1 : 
;;; the outgoing message is sent to mid+1

{-1}  nth(append(i!2`3, cons(u!1, cdr(i!2`4))), i!3) =
       IF i!3 < length[Identity](i!2`3) THEN nth(i!2`3, i!3)
       ELSE nth(cons(u!1, cdr(i!2`4)), i!3 - length[Identity](i!2`3))
       ENDIF
[-2]  i!3 < length(cons(u!1, cdr(i!2`4))) + length(i!2`3)
[-3]  length(i!2`1) = i!1`1
[-4]  (length(i!2`3) = i!1`1)
[-5]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-6]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-7]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] P!1 = p
[-11] u!1 = hu(mid)
[-12] i!1`1 = mid
[-13] i!1`2 = n_mid
[-14] i!1`1 < P!1 - 1
[-15] 2 <= P!1
  |-------
[1]   nth(append(i!2`3, cons(u!1, cdr(i!2`4))), i!3) =
       nth(remove(hu_list, 1 + mid), i!3)
[2]   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + mid)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictpostmid_middle.1.1.1.1.2.1.2.1 : 
;;; the outgoing message is sent to mid+1

[-1]  nth(append(i!2`3, cons(u!1, cdr(i!2`4))), i!3) =
       IF i!3 < length[Identity](i!2`3) THEN nth(i!2`3, i!3)
       ELSE nth(cons(u!1, cdr(i!2`4)), i!3 - length[Identity](i!2`3))
       ENDIF
[-2]  i!3 < length(cons(u!1, cdr(i!2`4))) + length(i!2`3)
[-3]  length(i!2`1) = i!1`1
[-4]  (length(i!2`3) = i!1`1)
[-5]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-6]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-7]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] P!1 = p
[-11] u!1 = hu(mid)
[-12] i!1`1 = mid
[-13] i!1`2 = n_mid
[-14] i!1`1 < P!1 - 1
[-15] 2 <= P!1
  |-------
{1}   IF i!3 < length[Identity](i!2`3) THEN nth(i!2`3, i!3)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!3 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, 1 + mid), i!3)
[2]   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + mid)

Rerunning step: (delete -1 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.1.1.1.1.2.1.2.1 : 
;;; the outgoing message is sent to mid+1

[-1]  i!3 < length(cons(u!1, cdr(i!2`4))) + length(i!2`3)
[-2]  length(i!2`1) = i!1`1
[-3]  (length(i!2`3) = i!1`1)
[-4]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-5]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-6]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  P!1 = p
[-10] u!1 = hu(mid)
[-11] i!1`1 = mid
[-12] i!1`2 = n_mid
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
[1]   IF i!3 < length[Identity](i!2`3) THEN nth(i!2`3, i!3)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!3 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, 1 + mid), i!3)

Rerunning step: (expand "length" -1 1)
Expanding the definition of length,
this simplifies to: 
restrictpostmid_middle.1.1.1.1.2.1.2.1 : 
;;; the outgoing message is sent to mid+1

{-1}  i!3 < 1 + length[Identity](cdr(i!2`4)) + length(i!2`3)
[-2]  length(i!2`1) = i!1`1
[-3]  (length(i!2`3) = i!1`1)
[-4]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-5]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-6]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  P!1 = p
[-10] u!1 = hu(mid)
[-11] i!1`1 = mid
[-12] i!1`2 = n_mid
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
[1]   IF i!3 < length[Identity](i!2`3) THEN nth(i!2`3, i!3)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!3 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, 1 + mid), i!3)

Rerunning step: (rewrite "length_cdr" -1)
Found matching substitution:
cons_l: (cons?[T]) gets i!2`4,
Rewriting using length_cdr, matching in -1,
this simplifies to: 
restrictpostmid_middle.1.1.1.1.2.1.2.1 : 
;;; the outgoing message is sent to mid+1

{-1}  i!3 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-2]  length(i!2`1) = i!1`1
[-3]  (length(i!2`3) = i!1`1)
[-4]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-5]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-6]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  P!1 = p
[-10] u!1 = hu(mid)
[-11] i!1`1 = mid
[-12] i!1`2 = n_mid
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
[1]   IF i!3 < length[Identity](i!2`3) THEN nth(i!2`3, i!3)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!3 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, 1 + mid), i!3)

Rerunning step: (lemma "listprops[Identity].nth_remove"
                 ("l" "hu_list" "i" "1+mid" "j" "i!3"))
Applying listprops[Identity].nth_remove where 
  l gets hu_list,
  i gets 1 + mid,
  j gets i!3,
this yields  2 subgoals: 
restrictpostmid_middle.1.1.1.1.2.1.2.1.1 : 
;;; the outgoing message is sent to mid+1

{-1}  nth(remove(hu_list, 1 + mid), i!3) =
       IF i!3 < 1 + mid THEN nth(hu_list, i!3)
       ELSE nth(hu_list, i!3 + 1)
       ENDIF
[-2]  i!3 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-3]  length(i!2`1) = i!1`1
[-4]  (length(i!2`3) = i!1`1)
[-5]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-6]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-7]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] P!1 = p
[-11] u!1 = hu(mid)
[-12] i!1`1 = mid
[-13] i!1`2 = n_mid
[-14] i!1`1 < P!1 - 1
[-15] 2 <= P!1
  |-------
[1]   IF i!3 < length[Identity](i!2`3) THEN nth(i!2`3, i!3)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!3 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, 1 + mid), i!3)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictpostmid_middle.1.1.1.1.2.1.2.1.1 : 
;;; the outgoing message is sent to mid+1

[-1]  nth(remove(hu_list, 1 + mid), i!3) =
       IF i!3 < 1 + mid THEN nth(hu_list, i!3)
       ELSE nth(hu_list, i!3 + 1)
       ENDIF
[-2]  i!3 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-3]  length(i!2`1) = i!1`1
[-4]  (length(i!2`3) = i!1`1)
[-5]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-6]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-7]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] P!1 = p
[-11] u!1 = hu(mid)
[-12] i!1`1 = mid
[-13] i!1`2 = n_mid
[-14] i!1`1 < P!1 - 1
[-15] 2 <= P!1
  |-------
{1}   IF i!3 < length[Identity](i!2`3) THEN nth(i!2`3, i!3)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!3 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!3 < 1 + mid THEN nth(hu_list, i!3)
       ELSE nth(hu_list, i!3 + 1)
       ENDIF

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.1.1.1.1.2.1.2.1.1 : 
;;; the outgoing message is sent to mid+1

[-1]  i!3 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-2]  length(i!2`1) = i!1`1
[-3]  (length(i!2`3) = i!1`1)
[-4]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-5]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-6]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  P!1 = p
[-10] u!1 = hu(mid)
[-11] i!1`1 = mid
[-12] i!1`2 = n_mid
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
[1]   IF i!3 < length[Identity](i!2`3) THEN nth(i!2`3, i!3)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!3 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!3 < 1 + mid THEN nth(hu_list, i!3)
       ELSE nth(hu_list, i!3 + 1)
       ENDIF

Rerunning step: (expand "nth" 1 2)
Expanding the definition of nth,
this simplifies to: 
restrictpostmid_middle.1.1.1.1.2.1.2.1.1 : 
;;; the outgoing message is sent to mid+1

[-1]  i!3 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-2]  length(i!2`1) = i!1`1
[-3]  (length(i!2`3) = i!1`1)
[-4]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-5]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-6]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  P!1 = p
[-10] u!1 = hu(mid)
[-11] i!1`1 = mid
[-12] i!1`2 = n_mid
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
{1}   IF i!3 < length[Identity](i!2`3) THEN nth(i!2`3, i!3)
      ELSE IF i!3 - length[Identity](i!2`3) = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!3)
           ENDIF
      ENDIF
       =
       IF i!3 < 1 + mid THEN nth(hu_list, i!3)
       ELSE nth(hu_list, 1 + i!3)
       ENDIF

Rerunning step: (case "i!3<mid OR i!3=mid OR i!3>mid")
Case splitting on 
   i!3 < mid OR i!3 = mid OR i!3 > mid, 
this yields  2 subgoals: 
restrictpostmid_middle.1.1.1.1.2.1.2.1.1.1 : 
;;; the outgoing message is sent to mid+1

{-1}  i!3 < mid OR i!3 = mid OR i!3 > mid
[-2]  i!3 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-3]  length(i!2`1) = i!1`1
[-4]  (length(i!2`3) = i!1`1)
[-5]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-6]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-7]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] P!1 = p
[-11] u!1 = hu(mid)
[-12] i!1`1 = mid
[-13] i!1`2 = n_mid
[-14] i!1`1 < P!1 - 1
[-15] 2 <= P!1
  |-------
[1]   IF i!3 < length[Identity](i!2`3) THEN nth(i!2`3, i!3)
      ELSE IF i!3 - length[Identity](i!2`3) = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!3)
           ENDIF
      ENDIF
       =
       IF i!3 < 1 + mid THEN nth(hu_list, i!3)
       ELSE nth(hu_list, 1 + i!3)
       ENDIF

Rerunning step: (expand "nth" -7)
Expanding the definition of nth,
this simplifies to: 
restrictpostmid_middle.1.1.1.1.2.1.2.1.1.1 : 
;;; the outgoing message is sent to mid+1

[-1]  i!3 < mid OR i!3 = mid OR i!3 > mid
[-2]  i!3 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-3]  length(i!2`1) = i!1`1
[-4]  (length(i!2`3) = i!1`1)
[-5]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-6]  (length(i!2`4) = P!1 - 1 - i!1`1)
{-7}  FORALL (k: below[P!1 - 1 - i!1`1]):
        IF k = 0 THEN car(i!2`4) ELSE nth(cdr(i!2`4), k - 1) ENDIF =
         hu(1 + k + i!1`1)
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] P!1 = p
[-11] u!1 = hu(mid)
[-12] i!1`1 = mid
[-13] i!1`2 = n_mid
[-14] i!1`1 < P!1 - 1
[-15] 2 <= P!1
  |-------
[1]   IF i!3 < length[Identity](i!2`3) THEN nth(i!2`3, i!3)
      ELSE IF i!3 - length[Identity](i!2`3) = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!3)
           ENDIF
      ENDIF
       =
       IF i!3 < 1 + mid THEN nth(hu_list, i!3)
       ELSE nth(hu_list, 1 + i!3)
       ENDIF

Rerunning step: (delete -3 -13)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.1.1.1.1.2.1.2.1.1.1 : 
;;; the outgoing message is sent to mid+1

[-1]  i!3 < mid OR i!3 = mid OR i!3 > mid
[-2]  i!3 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-3]  (length(i!2`3) = i!1`1)
[-4]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-5]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-6]  FORALL (k: below[P!1 - 1 - i!1`1]):
        IF k = 0 THEN car(i!2`4) ELSE nth(cdr(i!2`4), k - 1) ENDIF =
         hu(1 + k + i!1`1)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  P!1 = p
[-10] u!1 = hu(mid)
[-11] i!1`1 = mid
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
[1]   IF i!3 < length[Identity](i!2`3) THEN nth(i!2`3, i!3)
      ELSE IF i!3 - length[Identity](i!2`3) = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!3)
           ENDIF
      ENDIF
       =
       IF i!3 < 1 + mid THEN nth(hu_list, i!3)
       ELSE nth(hu_list, 1 + i!3)
       ENDIF

Rerunning step: (lazy-grind :exclude ("nth" "append" "remove"))
By skolemization, if-lifting, simplification and instantiation,

This completes the proof of restrictpostmid_middle.1.1.1.1.2.1.2.1.1.1.

restrictpostmid_middle.1.1.1.1.2.1.2.1.1.2 : 
;;; the outgoing message is sent to mid+1

[-1]  i!3 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-2]  length(i!2`1) = i!1`1
[-3]  (length(i!2`3) = i!1`1)
[-4]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-5]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-6]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  P!1 = p
[-10] u!1 = hu(mid)
[-11] i!1`1 = mid
[-12] i!1`2 = n_mid
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
{1}   i!3 < mid OR i!3 = mid OR i!3 > mid
[2]   IF i!3 < length[Identity](i!2`3) THEN nth(i!2`3, i!3)
      ELSE IF i!3 - length[Identity](i!2`3) = 0 THEN u!1
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!3)
           ENDIF
      ENDIF
       =
       IF i!3 < 1 + mid THEN nth(hu_list, i!3)
       ELSE nth(hu_list, 1 + i!3)
       ENDIF

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.1.1.1.1.2.1.2.1.1.2 : 
;;; the outgoing message is sent to mid+1

  |-------
[1]   i!3 < mid OR i!3 = mid OR i!3 > mid

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.1.1.1.1.2.1.2.1.1.2.


This completes the proof of restrictpostmid_middle.1.1.1.1.2.1.2.1.1.

restrictpostmid_middle.1.1.1.1.2.1.2.1.2T (TCC):   

[-1]  i!3 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-2]  length(i!2`1) = i!1`1
[-3]  (length(i!2`3) = i!1`1)
[-4]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-5]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-6]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  P!1 = p
[-10] u!1 = hu(mid)
[-11] i!1`1 = mid
[-12] i!1`2 = n_mid
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
{1}   i!3 < length[Identity](hu_list) - 1
[2]   IF i!3 < length[Identity](i!2`3) THEN nth(i!2`3, i!3)
      ELSE nth(cons(u!1, cdr(i!2`4)), i!3 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, 1 + mid), i!3)

Rerunning step: (delete -2 -4 -6 -8 -10 -11 -12 -13 -14 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.1.1.1.1.2.1.2.1.2T : 
;;; the outgoing message is sent to mid+1

[-1]  i!3 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-2]  (length(i!2`3) = i!1`1)
[-3]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-4]  (length(hu_list) = p)
[-5]  P!1 = p
  |-------
[1]   i!3 < length[Identity](hu_list) - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.1.1.1.1.2.1.2.1.2T.


This completes the proof of restrictpostmid_middle.1.1.1.1.2.1.2.1.

restrictpostmid_middle.1.1.1.1.2.1.2.2T (TCC):   

[-1]  i!3 < length(cons(u!1, cdr(i!2`4))) + length(i!2`3)
[-2]  length(i!2`1) = i!1`1
[-3]  (length(i!2`3) = i!1`1)
[-4]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-5]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-6]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  P!1 = p
[-10] u!1 = hu(mid)
[-11] i!1`1 = mid
[-12] i!1`2 = n_mid
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
{1}   i!3 <
       length[Identity](cons[Identity](u!1, cdr[Identity](i!2`4))) +
        length[Identity](i!2`3)
[2]   nth(append(i!2`3, cons(u!1, cdr(i!2`4))), i!3) =
       nth(remove(hu_list, 1 + mid), i!3)
[3]   append(i!2`3, cons(u!1, cdr(i!2`4))) = remove(hu_list, 1 + mid)

which is trivially true.

This completes the proof of restrictpostmid_middle.1.1.1.1.2.1.2.2T.


This completes the proof of restrictpostmid_middle.1.1.1.1.2.1.2.


This completes the proof of restrictpostmid_middle.1.1.1.1.2.1.

restrictpostmid_middle.1.1.1.1.2.2 (TCC):   

[-1]  length(i!2`1) = i!1`1
[-2]  (length(i!2`3) = i!1`1)
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-5]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  u!1 = hu(mid)
[-10] i!1`1 = mid
[-11] i!1`2 = n_mid
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
{1}   length[Nonce](null[Nonce]) = 0

Rerunning step: (expand "length" 1)
Expanding the definition of length,
this simplifies to: 
restrictpostmid_middle.1.1.1.1.2.2 : 
;;; the outgoing message is sent to mid+1

[-1]  length(i!2`1) = i!1`1
[-2]  (length(i!2`3) = i!1`1)
[-3]  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  (length(i!2`4) = P!1 - 1 - i!1`1)
[-5]  FORALL (k: below[P!1 - 1 - i!1`1]): nth(i!2`4, k) = hu(1 + k + i!1`1)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  u!1 = hu(mid)
[-10] i!1`1 = mid
[-11] i!1`2 = n_mid
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictpostmid_middle.1.1.1.1.2.2.


This completes the proof of restrictpostmid_middle.1.1.1.1.2.


This completes the proof of restrictpostmid_middle.1.1.1.1.

restrictpostmid_middle.1.1.1.2 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  P!1 = p
[-3]  u!1 = hu(mid)
[-4]  i!1`1 = mid
[-5]  i!1`2 = n_mid
[-6]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-7]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-8]  0 < i!1`1
[-9]  i!1`1 < P!1 - 1
[-10] 2 <= P!1
  |-------
{1}   ((rec(u!1, nth(i!2`3, i!1`1 - 1),
            E(public(u!1),
              conc(ilist(append(i!2`3, i!2`4)),
                   nlist(cons(i!1`2, i!2`2)))))
         >>
         ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
           (signal(commit(mid, append(i!2`3, cons(u!1, i!2`4)), i!1`2)) >>
             Stop[event])))
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
{2}   R_postmid(w!1)
               (trans(u!1, car(i!2`4),
                      E(public(car(i!2`4)),
                        conc(nlist(append(i!2`1, (: i!1`2 :))),
                             ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))))
{3}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(nlist(append(i!2`1, (: i!1`2 :))),
                   ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
       >>
       ((rec(u!1, nth(i!2`3, i!1`1 - 1),
             E(public(u!1),
               conc(ilist(append(i!2`3, i!2`4)),
                    nlist(cons(i!1`2, i!2`2)))))
          >>
          ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
            (signal(commit(mid, append(i!2`3, cons(u!1, i!2`4)), i!1`2)) >>
              Stop[event])))
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.1.1.1.2 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  P!1 = p
[-3]  u!1 = hu(mid)
[-4]  i!1`1 = mid
[-5]  i!1`2 = n_mid
[-6]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-7]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-8]  0 < i!1`1
[-9]  i!1`1 < P!1 - 1
[-10] 2 <= P!1
  |-------
[1]   ((rec(u!1, nth(i!2`3, i!1`1 - 1),
            E(public(u!1),
              conc(ilist(append(i!2`3, i!2`4)),
                   nlist(cons(i!1`2, i!2`2)))))
         >>
         ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
           (signal(commit(mid, append(i!2`3, cons(u!1, i!2`4)), i!1`2)) >>
             Stop[event])))
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictpostmid_middle.1.1.1.2 :  

{-1}  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(ilist(append(i!2`3, i!2`4)),
                         nlist(cons(i!1`2, i!2`2)))))
[-2]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-3]  P!1 = p
[-4]  u!1 = hu(mid)
[-5]  i!1`1 = mid
[-6]  i!1`2 = n_mid
[-7]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-8]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-9]  0 < i!1`1
[-10] i!1`1 < P!1 - 1
[-11] 2 <= P!1
  |-------
{1}   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         (signal(commit(mid, append(i!2`3, cons(u!1, i!2`4)), i!1`2)) >>
           Stop[event]))
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
{2}   R_postmid(w!1)
               (rec(u!1, nth(i!2`3, i!1`1 - 1),
                    E(public(u!1),
                      conc(ilist(append(i!2`3, i!2`4)),
                           nlist(cons(i!1`2, i!2`2))))))
{3}   rec(u!1, nth(i!2`3, i!1`1 - 1),
          E(public(u!1),
            conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2)))))
       >>
       (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
          (signal(commit(mid, append(i!2`3, cons(u!1, i!2`4)), i!1`2)) >>
            Stop[event]))
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   P!1 = 2

Rerunning step: (delete -2 -3 -4 -5 -7 -8 -9 -10 -11 +)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.1.1.1.2 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(ilist(append(i!2`3, i!2`4)),
                         nlist(cons(i!1`2, i!2`2)))))
[-2]  i!1`2 = n_mid
  |-------

Rerunning step: (comment "the message in -1 contains n_mid but is not escaped in the rank function, hence it will evaluate to false")
Adding comment: the message in -1 contains n_mid but is not escaped in the rank function, hence it will evaluate to false
this simplifies to: 
restrictpostmid_middle.1.1.1.2 : 
;;; the message in -1 contains n_mid but is not escaped in the rank function, hence it will evaluate to false

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(ilist(append(i!2`3, i!2`4)),
                         nlist(cons(i!1`2, i!2`2)))))
[-2]  i!1`2 = n_mid
  |-------

Rerunning step: (grind :if-match nil)
E rewrites 
  E(public(u!1),
    conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
  to code(public(u!1),
           conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
rho_postmid rewrites rho_postmid(w!1)(ilist(append(i!2`3, i!2`4)))
  to TRUE
elt rewrites elt(cons(i!1`2, i!2`2), n_mid)
  to EXISTS (i: below[length(cons(i!1`2, i!2`2))]):
        nth(cons(i!1`2, i!2`2), i) = n_mid
rho_postmid rewrites rho_postmid(w!1)(nlist(cons(i!1`2, i!2`2)))
  to NOT EXISTS (i: below[length(cons(i!1`2, i!2`2))]):
            nth(cons(i!1`2, i!2`2), i) = n_mid
rho_postmid rewrites 
  rho_postmid(w!1)
             (conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
  to NOT EXISTS (i: below[length(cons(i!1`2, i!2`2))]):
            nth(cons(i!1`2, i!2`2), i) = n_mid
remove rewrites remove(cdr(hu_list), i - 1)
  to cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2))
remove rewrites remove(hu_list, i)
  to cons(car(hu_list),
           cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2)))
rho_postmid rewrites 
  rho_postmid(w!1)
             (code(public(u!1),
                   conc(ilist(append(i!2`3, i!2`4)),
                        nlist(cons(i!1`2, i!2`2)))))
  to NOT EXISTS (i: below[length(cons(i!1`2, i!2`2))]):
            nth(cons(i!1`2, i!2`2), i) = n_mid
       OR
       EXISTS (i: {x: nat | mid < x AND x <= w!1}):
         public(u!1) = public(hu(i)) AND
          EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                  nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
            conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
             conc(nlist(append(nl1, cons(n_mid, nl2))),
                  ilist(cons(car(hu_list),
                             cons(car(cdr(hu_list)),
                                  remove(cdr(cdr(hu_list)), i - 2)))))
Trying repeated skolemization, instantiation, and if-lifting,
this yields  2 subgoals: 
restrictpostmid_middle.1.1.1.2.1 : 
;;; the message in -1 contains n_mid but is not escaped in the rank function, hence it will evaluate to false

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl1!1)
{-2}  length(nl1!1) = mid
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
{-4}  length(nl2!1) = -1 - mid + i!3
{-5}  mid < i!3
{-6}  i!3 <= w!1
{-7}  public(u!1) = public(hu(i!3))
{-8}  conc(ilist(append(i!2`3, i!2`4)), nlist(cons(n_mid, i!2`2))) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(cons(car(hu_list),
                       cons(car(cdr(hu_list)),
                            remove(cdr(cdr(hu_list)), i!3 - 2)))))
[-9]  i!1`2 = n_mid
  |-------

Rerunning step: (delete -1 -2 -3 -4 -5 -6 -7 -9)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.1.1.1.2.1 : 
;;; the message in -1 contains n_mid but is not escaped in the rank function, hence it will evaluate to false

[-1]  conc(ilist(append(i!2`3, i!2`4)), nlist(cons(n_mid, i!2`2))) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(cons(car(hu_list),
                       cons(car(cdr(hu_list)),
                            remove(cdr(cdr(hu_list)), i!3 - 2)))))
  |-------

Rerunning step: (decompose-equality -1)
Applying decompose-equality,

This completes the proof of restrictpostmid_middle.1.1.1.2.1.

restrictpostmid_middle.1.1.1.2.2 : 
;;; the message in -1 contains n_mid but is not escaped in the rank function, hence it will evaluate to false

[-1]  i!1`2 = n_mid
  |-------
{1}   EXISTS (i: below[length(cons(i!1`2, i!2`2))]):
        nth(cons(n_mid, i!2`2), i) = n_mid

Rerunning step: (inst 1 "0")
length rewrites length[Nonce](cons[Nonce](i!1`2, i!2`2))
  to 1 + length[Identity](i!2`2)
Instantiating the top quantifier in 1 with the terms: 
 0,
this simplifies to: 
restrictpostmid_middle.1.1.1.2.2 : 
;;; the message in -1 contains n_mid but is not escaped in the rank function, hence it will evaluate to false

[-1]  i!1`2 = n_mid
  |-------
{1}   nth(cons(n_mid, i!2`2), 0) = n_mid

Rerunning step: (expand "nth")
Expanding the definition of nth,
this simplifies to: 
restrictpostmid_middle.1.1.1.2.2 : 
;;; the message in -1 contains n_mid but is not escaped in the rank function, hence it will evaluate to false

[-1]  i!1`2 = n_mid
  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictpostmid_middle.1.1.1.2.2.


This completes the proof of restrictpostmid_middle.1.1.1.2.


This completes the proof of restrictpostmid_middle.1.1.1.

restrictpostmid_middle.1.1.2 :  

[-1]  P!1 = p
[-2]  u!1 = hu(mid)
[-3]  i!1`1 = mid
[-4]  i!1`2 = n_mid
{-5}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-6}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-7]  0 < i!1`1
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
{1}   cons?[Identity](i!2`4)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] |
                     (length(x) = i!1`1) AND
                      FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
                  {x: list[Identity] |
                     (length(x) = P!1 - 1 - i!1`1) AND
                      FORALL (k: below[P!1 - 1 - i!1`1]):
                        nth(x, k) = hu(1 + k + i!1`1)}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!1`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!1`2, i`2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                (signal(commit(mid, append(i`3, cons(u!1, i`4)), i!1`2)) >>
                  Stop[event])))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (delete -1 -2 -3 -4 -5 -6 -8 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.1.1.2 :  

[-1]  0 < i!1`1
[-2]  2 <= P!1
  |-------
[1]   cons?[Identity](i!2`4)

Rerunning step: (nonemptylist "i!2`4")
Relating existence of a tail to a list's length,

This completes the proof of restrictpostmid_middle.1.1.2.

restrictpostmid_middle.1.1.3 :  

[-1]  P!1 = p
[-2]  u!1 = hu(mid)
[-3]  i!1`1 = mid
[-4]  i!1`2 = n_mid
{-5}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-6}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-7]  0 < i!1`1
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
{1}   i!1`1 - 1 < length[Identity](i!2`3)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] |
                     (length(x) = i!1`1) AND
                      FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
                  {x: list[Identity] |
                     (length(x) = P!1 - 1 - i!1`1) AND
                      FORALL (k: below[P!1 - 1 - i!1`1]):
                        nth(x, k) = hu(1 + k + i!1`1)}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!1`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!1`2, i`2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                (signal(commit(mid, append(i`3, cons(u!1, i`4)), i!1`2)) >>
                  Stop[event])))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (typepred "i!2`3")
Adding type constraints for  i!2`3,
this simplifies to: 
restrictpostmid_middle.1.1.3 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`3)
{-2}  (length(i!2`3) = i!1`1)
{-3}  FORALL (k: below[i!1`1]): nth(i!2`3, k) = hu(k)
[-4]  P!1 = p
[-5]  u!1 = hu(mid)
[-6]  i!1`1 = mid
[-7]  i!1`2 = n_mid
[-8]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-9]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-10] 0 < i!1`1
[-11] i!1`1 < P!1 - 1
[-12] 2 <= P!1
  |-------
[1]   i!1`1 - 1 < length[Identity](i!2`3)
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] |
                     (length(x) = i!1`1) AND
                      FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
                  {x: list[Identity] |
                     (length(x) = P!1 - 1 - i!1`1) AND
                      FORALL (k: below[P!1 - 1 - i!1`1]):
                        nth(x, k) = hu(1 + k + i!1`1)}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!1`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!1`2, i`2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                (signal(commit(mid, append(i`3, cons(u!1, i`4)), i!1`2)) >>
                  Stop[event])))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (delete -1 -3 -4 -5 -6 -7 -8 -9 -10 -11 -12 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.1.1.3 :  

[-1]  (length(i!2`3) = i!1`1)
  |-------
[1]   i!1`1 - 1 < length[Identity](i!2`3)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.1.1.3.

restrictpostmid_middle.1.1.4 :  

[-1]  P!1 = p
[-2]  u!1 = hu(mid)
[-3]  i!1`1 = mid
[-4]  i!1`2 = n_mid
{-5}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-6}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-7]  0 < i!1`1
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
{1}   (length(x!1) = P!1 - 1 - i!1`1) IMPLIES
       FORALL (k: below[P!1 - 1 - i!1`1]): k < length[Identity](x!1)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] |
                     (length(x) = i!1`1) AND
                      FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
                  {x: list[Identity] |
                     (length(x) = P!1 - 1 - i!1`1) AND
                      FORALL (k: below[P!1 - 1 - i!1`1]):
                        nth(x, k) = hu(1 + k + i!1`1)}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!1`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!1`2, i`2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                (signal(commit(mid, append(i`3, cons(u!1, i`4)), i!1`2)) >>
                  Stop[event])))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (skosimp* 1)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictpostmid_middle.1.1.4 :  

{-1}  k!1 < P!1 - 1 - i!1`1
{-2}  (length(x!1) = P!1 - 1 - i!1`1)
[-3]  P!1 = p
[-4]  u!1 = hu(mid)
[-5]  i!1`1 = mid
[-6]  i!1`2 = n_mid
[-7]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-8]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-9]  0 < i!1`1
[-10] i!1`1 < P!1 - 1
[-11] 2 <= P!1
  |-------
{1}   k!1 < length[Identity](x!1)
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] |
                     (length(x) = i!1`1) AND
                      FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
                  {x: list[Identity] |
                     (length(x) = P!1 - 1 - i!1`1) AND
                      FORALL (k: below[P!1 - 1 - i!1`1]):
                        nth(x, k) = hu(1 + k + i!1`1)}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!1`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!1`2, i`2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                (signal(commit(mid, append(i`3, cons(u!1, i`4)), i!1`2)) >>
                  Stop[event])))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (delete -3 -4 -5 -6 -7 -8 -9 -10 -11 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.1.1.4 :  

[-1]  k!1 < P!1 - 1 - i!1`1
[-2]  (length(x!1) = P!1 - 1 - i!1`1)
  |-------
[1]   k!1 < length[Identity](x!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.1.1.4.

restrictpostmid_middle.1.1.5 :  

[-1]  P!1 = p
[-2]  u!1 = hu(mid)
[-3]  i!1`1 = mid
[-4]  i!1`2 = n_mid
{-5}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-6}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-7]  0 < i!1`1
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
{1}   (length(x!1) = i!1`1) IMPLIES
       FORALL (k: below[i!1`1]): k < length[Identity](x!1)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] |
                     (length(x) = i!1`1) AND
                      FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
                  {x: list[Identity] |
                     (length(x) = P!1 - 1 - i!1`1) AND
                      FORALL (k: below[P!1 - 1 - i!1`1]):
                        nth(x, k) = hu(1 + k + i!1`1)}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!1`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!1`2, i`2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                (signal(commit(mid, append(i`3, cons(u!1, i`4)), i!1`2)) >>
                  Stop[event])))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (skosimp* 1)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictpostmid_middle.1.1.5 :  

{-1}  k!1 < i!1`1
{-2}  (length(x!1) = i!1`1)
[-3]  P!1 = p
[-4]  u!1 = hu(mid)
[-5]  i!1`1 = mid
[-6]  i!1`2 = n_mid
[-7]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-8]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-9]  0 < i!1`1
[-10] i!1`1 < P!1 - 1
[-11] 2 <= P!1
  |-------
{1}   k!1 < length[Identity](x!1)
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] |
                     (length(x) = i!1`1) AND
                      FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
                  {x: list[Identity] |
                     (length(x) = P!1 - 1 - i!1`1) AND
                      FORALL (k: below[P!1 - 1 - i!1`1]):
                        nth(x, k) = hu(1 + k + i!1`1)}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!1`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!1`2, i`2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                (signal(commit(mid, append(i`3, cons(u!1, i`4)), i!1`2)) >>
                  Stop[event])))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (delete -3 -4 -5 -6 -7 -8 -9 -10 -11 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.1.1.5 :  

[-1]  k!1 < i!1`1
[-2]  (length(x!1) = i!1`1)
  |-------
[1]   k!1 < length[Identity](x!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.1.1.5.

restrictpostmid_middle.1.1.6 :  

[-1]  P!1 = p
[-2]  u!1 = hu(mid)
[-3]  i!1`1 = mid
[-4]  i!1`2 = n_mid
{-5}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-6}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-7]  0 < i!1`1
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
{1}   FORALL (nl1: {x: list[Nonce] | length[Nonce](x) = i!1`1},
              nl2: {x: list[Nonce] | length[Nonce](x) = P!1 - 1 - i!1`1},
              il1:
                {x: list[Identity] |
                   (length[Identity](x) = i!1`1) AND
                    FORALL (k: below[i!1`1]): nth[Identity](x, k) = hu(k)},
              il2:
                {x: list[Identity] |
                   (length[Identity](x) = P!1 - 1 - i!1`1) AND
                    FORALL (k: below[P!1 - 1 - i!1`1]):
                      nth[Identity](x, k) = hu(1 + k + i!1`1)}):
        cons?[Identity](il2)
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1:
                 {x: list[Identity] |
                    (length(x) = i!1`1) AND
                     FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
               il2:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1 - i!1`1) AND
                     FORALL (k: below[P!1 - 1 - i!1`1]):
                       nth(x, k) = hu(1 + k + i!1`1)}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                (signal(commit(mid, append(il1, cons(u!1, il2)), i!1`2)) >>
                  Stop[event])))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictpostmid_middle.1.1.6 :  

[-1]  P!1 = p
[-2]  u!1 = hu(mid)
[-3]  i!1`1 = mid
[-4]  i!1`2 = n_mid
[-5]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-6]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-7]  0 < i!1`1
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
{1}   cons?[Identity](il2!1)
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1:
                 {x: list[Identity] |
                    (length(x) = i!1`1) AND
                     FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
               il2:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1 - i!1`1) AND
                     FORALL (k: below[P!1 - 1 - i!1`1]):
                       nth(x, k) = hu(1 + k + i!1`1)}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                (signal(commit(mid, append(il1, cons(u!1, il2)), i!1`2)) >>
                  Stop[event])))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (delete -1 -2 -3 -4 -5 -6 -7 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.1.1.6 :  

[-1]  i!1`1 < P!1 - 1
[-2]  2 <= P!1
  |-------
[1]   cons?[Identity](il2!1)

Rerunning step: (nonemptylist "il2!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictpostmid_middle.1.1.6.

restrictpostmid_middle.1.1.7 :  

[-1]  P!1 = p
[-2]  u!1 = hu(mid)
[-3]  i!1`1 = mid
[-4]  i!1`2 = n_mid
{-5}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-6}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-7]  0 < i!1`1
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
{1}   FORALL (nl1: {x: list[Nonce] | length[Nonce](x) = i!1`1},
              nl2: {x: list[Nonce] | length[Nonce](x) = P!1 - 1 - i!1`1},
              il1:
                {x: list[Identity] |
                   (length[Identity](x) = i!1`1) AND
                    FORALL (k: below[i!1`1]): nth[Identity](x, k) = hu(k)},
              x: list[Identity]):
        (length(x) = P!1 - 1 - i!1`1) IMPLIES
         FORALL (k: below[P!1 - 1 - i!1`1]): k < length[Identity](x)
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1:
                 {x: list[Identity] |
                    (length(x) = i!1`1) AND
                     FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
               il2:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1 - i!1`1) AND
                     FORALL (k: below[P!1 - 1 - i!1`1]):
                       nth(x, k) = hu(1 + k + i!1`1)}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                (signal(commit(mid, append(il1, cons(u!1, il2)), i!1`2)) >>
                  Stop[event])))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (skosimp* 1)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictpostmid_middle.1.1.7 :  

{-1}  k!1 < P!1 - 1 - i!1`1
{-2}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl1!1)
{-3}  length(nl1!1) = i!1`1
{-4}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
{-5}  length(nl2!1) = P!1 - 1 - i!1`1
{-6}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (il1!1)
{-7}  (length(il1!1) = i!1`1)
{-8}  FORALL (k: below[i!1`1]): nth(il1!1, k) = hu(k)
{-9}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (x!1)
{-10} (length(x!1) = P!1 - 1 - i!1`1)
[-11] P!1 = p
[-12] u!1 = hu(mid)
[-13] i!1`1 = mid
[-14] i!1`2 = n_mid
[-15] floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-16] floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-17] 0 < i!1`1
[-18] i!1`1 < P!1 - 1
[-19] 2 <= P!1
  |-------
{1}   k!1 < length[Identity](x!1)
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1:
                 {x: list[Identity] |
                    (length(x) = i!1`1) AND
                     FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
               il2:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1 - i!1`1) AND
                     FORALL (k: below[P!1 - 1 - i!1`1]):
                       nth(x, k) = hu(1 + k + i!1`1)}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                (signal(commit(mid, append(il1, cons(u!1, il2)), i!1`2)) >>
                  Stop[event])))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (delete -2 -3
                  -4 -5
                  -6 -7
                  -8 -9
                  -11 -12
                  -13 -14
                  -15 -16
                  -17 -18
                  -19 2
                  3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.1.1.7 :  

[-1]  k!1 < P!1 - 1 - i!1`1
[-2]  (length(x!1) = P!1 - 1 - i!1`1)
  |-------
[1]   k!1 < length[Identity](x!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.1.1.7.

restrictpostmid_middle.1.1.8 :  

[-1]  P!1 = p
[-2]  u!1 = hu(mid)
[-3]  i!1`1 = mid
[-4]  i!1`2 = n_mid
{-5}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-6}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-7]  0 < i!1`1
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
{1}   FORALL (nl1: {x: list[Nonce] | length[Nonce](x) = i!1`1},
              nl2: {x: list[Nonce] | length[Nonce](x) = P!1 - 1 - i!1`1},
              x: list[Identity]):
        (length(x) = i!1`1) IMPLIES
         FORALL (k: below[i!1`1]): k < length[Identity](x)
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1:
                 {x: list[Identity] |
                    (length(x) = i!1`1) AND
                     FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
               il2:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1 - i!1`1) AND
                     FORALL (k: below[P!1 - 1 - i!1`1]):
                       nth(x, k) = hu(1 + k + i!1`1)}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                (signal(commit(mid, append(il1, cons(u!1, il2)), i!1`2)) >>
                  Stop[event])))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (skosimp* 1)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictpostmid_middle.1.1.8 :  

{-1}  k!1 < i!1`1
{-2}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl1!1)
{-3}  length(nl1!1) = i!1`1
{-4}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
{-5}  length(nl2!1) = P!1 - 1 - i!1`1
{-6}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (x!1)
{-7}  (length(x!1) = i!1`1)
[-8]  P!1 = p
[-9]  u!1 = hu(mid)
[-10] i!1`1 = mid
[-11] i!1`2 = n_mid
[-12] floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-13] floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-14] 0 < i!1`1
[-15] i!1`1 < P!1 - 1
[-16] 2 <= P!1
  |-------
{1}   k!1 < length[Identity](x!1)
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1:
                 {x: list[Identity] |
                    (length(x) = i!1`1) AND
                     FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
               il2:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1 - i!1`1) AND
                     FORALL (k: below[P!1 - 1 - i!1`1]):
                       nth(x, k) = hu(1 + k + i!1`1)}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                (signal(commit(mid, append(il1, cons(u!1, il2)), i!1`2)) >>
                  Stop[event])))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (delete -2 -3
                  -4 -5
                  -6 -8
                  -9 -10
                  -11 -12
                  -13 -14
                  -15 -16
                  2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.1.1.8 :  

[-1]  k!1 < i!1`1
[-2]  (length(x!1) = i!1`1)
  |-------
[1]   k!1 < length[Identity](x!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.1.1.8.

restrictpostmid_middle.1.1.9 :  

[-1]  P!1 = p
[-2]  u!1 = hu(mid)
[-3]  i!1`1 = mid
[-4]  i!1`2 = n_mid
{-5}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-6}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-7]  0 < i!1`1
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
{1}   FORALL (x: list[Identity]):
        (length(x) = P!1 - 1 - i!1`1) IMPLIES
         FORALL (k: below[P!1 - 1 - i!1`1]): k < length[Identity](x)
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1:
                 {x: list[Identity] |
                    (length(x) = i!1`1) AND
                     FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
               il2:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1 - i!1`1) AND
                     FORALL (k: below[P!1 - 1 - i!1`1]):
                       nth(x, k) = hu(1 + k + i!1`1)}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                (signal(commit(mid, append(il1, cons(u!1, il2)), i!1`2)) >>
                  Stop[event])))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.1.1.9 :  

  |-------
[1]   FORALL (x: list[Identity]):
        (length(x) = P!1 - 1 - i!1`1) IMPLIES
         FORALL (k: below[P!1 - 1 - i!1`1]): k < length[Identity](x)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictpostmid_middle.1.1.9 :  

  |-------
{1}   (length(x!1) = P!1 - 1 - i!1`1) IMPLIES
       FORALL (k: below[P!1 - 1 - i!1`1]): k < length[Identity](x!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.1.1.9.

restrictpostmid_middle.1.1.10 :  

[-1]  P!1 = p
[-2]  u!1 = hu(mid)
[-3]  i!1`1 = mid
[-4]  i!1`2 = n_mid
{-5}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-6}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-7]  0 < i!1`1
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
{1}   FORALL (x: list[Identity]):
        (length(x) = i!1`1) IMPLIES
         FORALL (k: below[i!1`1]): k < length[Identity](x)
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1:
                 {x: list[Identity] |
                    (length(x) = i!1`1) AND
                     FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
               il2:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1 - i!1`1) AND
                     FORALL (k: below[P!1 - 1 - i!1`1]):
                       nth(x, k) = hu(1 + k + i!1`1)}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                (signal(commit(mid, append(il1, cons(u!1, il2)), i!1`2)) >>
                  Stop[event])))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.1.1.10 :  

  |-------
[1]   FORALL (x: list[Identity]):
        (length(x) = i!1`1) IMPLIES
         FORALL (k: below[i!1`1]): k < length[Identity](x)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictpostmid_middle.1.1.10 :  

  |-------
{1}   (length(x!1) = i!1`1) IMPLIES
       FORALL (k: below[i!1`1]): k < length[Identity](x!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.1.1.10.


This completes the proof of restrictpostmid_middle.1.1.

restrictpostmid_middle.1.2 :  

[-1]  i!1`2 = n_mid
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   P!1 = p AND u!1 = hu(mid) AND i!1`1 = mid
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1:
                 {x: list[Identity] |
                    (length(x) = i!1`1) AND
                     FORALL (k: below[i!1`1]): nth(x, k) = hu(k)},
               il2:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1 - i!1`1) AND
                     FORALL (k: below[P!1 - 1 - i!1`1]):
                       nth(x, k) = hu(1 + k + i!1`1)}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                (signal(commit(mid, append(il1, cons(u!1, il2)), i!1`2)) >>
                  Stop[event])))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (delete -2 -3 -4 -5 -6 -7 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.1.2 :  

[-1]  i!1`2 = n_mid
  |-------
[1]   P!1 = p AND u!1 = hu(mid) AND i!1`1 = mid

Rerunning step: (typepred "i!1`2")
Adding type constraints for  i!1`2,
this simplifies to: 
restrictpostmid_middle.1.2 :  

{-1}  IRpart(P!1, u!1, i!1`1)(i!1`2)
[-2]  i!1`2 = n_mid
  |-------
[1]   P!1 = p AND u!1 = hu(mid) AND i!1`1 = mid

Rerunning step: (lemma "n_orig" ("P" "P!1" "u" "u!1" "r" "i!1`1"))
Applying n_orig where 
  P gets P!1,
  u gets u!1,
  r gets i!1`1,
this simplifies to: 
restrictpostmid_middle.1.2 :  

{-1}  IRpart(P!1, u!1, i!1`1)(n_mid) =>
       (P!1 = p AND u!1 = hu(mid) AND i!1`1 = mid)
[-2]  IRpart(P!1, u!1, i!1`1)(i!1`2)
[-3]  i!1`2 = n_mid
  |-------
[1]   P!1 = p AND u!1 = hu(mid) AND i!1`1 = mid

Rerunning step: (grind)
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpostmid_middle.1.2.


This completes the proof of restrictpostmid_middle.1.

restrictpostmid_middle.2 :  

{-1}  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1: {x: list[Identity] | length(x) = i!1`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              (signal(running(i!1`1, append(il1, cons(u!1, il2)),
                              nth(cons(i!1`2, nl2),
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)
                                   - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
{2}   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (choice3)
Applying choice rule,
this yields  6 subgoals: 
restrictpostmid_middle.2.1 :  

[-1]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   (rec(u!1, nth(i!2`3, i!1`1 - 1),
           E(public(u!1), conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
        >>
        (trans(u!1, car(i!2`4),
               E(public(car(i!2`4)),
                 conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
          >>
          (rec(u!1, nth(i!2`3, i!1`1 - 1),
               E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
            >>
            (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                            nth(cons(i!1`2, i!2`2),
                                floor(1 - 2 * ((mid - 1) / (p - 2))
                                      +
                                      ((mid - 1) / (p - 2)) * P!1)
                                 - i!1`1)))
              >>
              ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4))
                >> Stop[event])))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictpostmid_middle.2.1 :  

{-1}  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
{-3}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-4}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
{1}   ((trans(u!1, car(i!2`4),
              E(public(car(i!2`4)),
                conc(nlist(append(i!2`1, (: i!1`2 :))),
                     ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
         >>
         (rec(u!1, nth(i!2`3, i!1`1 - 1),
              E(public(u!1),
                conc(ilist(append(i!2`3, i!2`4)),
                     nlist(cons(i!1`2, i!2`2)))))
           >>
           (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                           nth(cons(i!1`2, i!2`2),
                               floor(1 - 2 * ((mid - 1) / (p - 2))
                                     +
                                     ((mid - 1) / (p - 2)) * P!1)
                                - i!1`1)))
             >>
             ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
               Stop[event]))))
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
{2}   R_postmid(w!1)
               (rec(u!1, nth(i!2`3, i!1`1 - 1),
                    E(public(u!1),
                      conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))))
{3}   rec(u!1, nth(i!2`3, i!1`1 - 1),
          E(public(u!1), conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
       >>
       ((trans(u!1, car(i!2`4),
               E(public(car(i!2`4)),
                 conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
          >>
          (rec(u!1, nth(i!2`3, i!1`1 - 1),
               E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
            >>
            (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                            nth(cons(i!1`2, i!2`2),
                                floor(1 - 2 * ((mid - 1) / (p - 2))
                                      +
                                      ((mid - 1) / (p - 2)) * P!1)
                                 - i!1`1)))
              >>
              ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4))
                >> Stop[event]))))
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.2.1 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   ((trans(u!1, car(i!2`4),
              E(public(car(i!2`4)),
                conc(nlist(append(i!2`1, (: i!1`2 :))),
                     ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
         >>
         (rec(u!1, nth(i!2`3, i!1`1 - 1),
              E(public(u!1),
                conc(ilist(append(i!2`3, i!2`4)),
                     nlist(cons(i!1`2, i!2`2)))))
           >>
           (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                           nth(cons(i!1`2, i!2`2),
                               floor(1 - 2 * ((mid - 1) / (p - 2))
                                     +
                                     ((mid - 1) / (p - 2)) * P!1)
                                - i!1`1)))
             >>
             ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
               Stop[event]))))
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictpostmid_middle.2.1.1 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
{1}   rho_postmid(w!1)
                 (E(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
{2}   R_postmid(w!1)
               (trans(u!1, car(i!2`4),
                      E(public(car(i!2`4)),
                        conc(nlist(append(i!2`1, (: i!1`2 :))),
                             ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))))
{3}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(nlist(append(i!2`1, (: i!1`2 :))),
                   ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
       >>
       ((rec(u!1, nth(i!2`3, i!1`1 - 1),
             E(public(u!1),
               conc(ilist(append(i!2`3, i!2`4)),
                    nlist(cons(i!1`2, i!2`2)))))
          >>
          (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                          nth(cons(i!1`2, i!2`2),
                              floor(1 - 2 * ((mid - 1) / (p - 2))
                                    +
                                    ((mid - 1) / (p - 2)) * P!1)
                               - i!1`1)))
            >>
            ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
              Stop[event])))
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete -3 -4 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.2.1.1 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (E(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (expand "E")
Expanding the definition of E,
this simplifies to: 
restrictpostmid_middle.2.1.1 :  

{-1}  rho_postmid(w!1)
                 (code(public(u!1),
                       conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
{1}   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (expand "rho_postmid" -1)
Expanding the definition of rho_postmid,
this simplifies to: 
restrictpostmid_middle.2.1.1 :  

{-1}  rho_postmid(w!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))) OR
       EXISTS (i: {x: nat | mid < x AND x <= w!1}):
         public(u!1) = public(hu(i)) AND
          EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                  nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
            conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
             conc(nlist(append(nl1, cons(n_mid, nl2))),
                  ilist(remove(hu_list, i)))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
restrictpostmid_middle.2.1.1.1 :  

{-1}  rho_postmid(w!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (typepred "i!1`2")
Adding type constraints for  i!1`2,
this simplifies to: 
restrictpostmid_middle.2.1.1.1 :  

{-1}  IRpart(P!1, u!1, i!1`1)(i!1`2)
[-2]  rho_postmid(w!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
[-3]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (lemma "n_prop" ("P" "P!1" "u" "u!1" "r" "i!1`1"))
Applying n_prop where 
  P gets P!1,
  u gets u!1,
  r gets i!1`1,
this simplifies to: 
restrictpostmid_middle.2.1.1.1 :  

{-1}  (P!1 /= p OR i!1`1 /= mid) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, i!1`1)(n_mid)
[-2]  IRpart(P!1, u!1, i!1`1)(i!1`2)
[-3]  rho_postmid(w!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
[-4]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (lemma "listprops[Nonce].elt_append3"
                 ("l1" "i!2`1" "l2" "(:i!1`2:)" "t" "n_mid"))
Applying listprops[Nonce].elt_append3 where 
  l1 gets i!2`1,
  l2 gets (: i!1`2 :),
  t gets n_mid,
this simplifies to: 
restrictpostmid_middle.2.1.1.1 :  

{-1}  elt(append(i!2`1, (: i!1`2 :)), n_mid) IMPLIES
       elt(i!2`1, n_mid) OR elt((: i!1`2 :), n_mid)
[-2]  (P!1 /= p OR i!1`1 /= mid) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, i!1`1)(n_mid)
[-3]  IRpart(P!1, u!1, i!1`1)(i!1`2)
[-4]  rho_postmid(w!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
[-5]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-6]  0 < i!1`1
[-7]  i!1`1 < P!1 - 1
[-8]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (lemma "listprops[Nonce].elt_singleton"
                 ("t1" "i!1`2" "t2" "n_mid"))
Applying listprops[Nonce].elt_singleton where 
  t1 gets i!1`2,
  t2 gets n_mid,
this simplifies to: 
restrictpostmid_middle.2.1.1.1 :  

{-1}  elt((: i!1`2 :), n_mid) IFF i!1`2 = n_mid
[-2]  elt(append(i!2`1, (: i!1`2 :)), n_mid) IMPLIES
       elt(i!2`1, n_mid) OR elt((: i!1`2 :), n_mid)
[-3]  (P!1 /= p OR i!1`1 /= mid) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, i!1`1)(n_mid)
[-4]  IRpart(P!1, u!1, i!1`1)(i!1`2)
[-5]  rho_postmid(w!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
[-6]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-7]  0 < i!1`1
[-8]  i!1`1 < P!1 - 1
[-9]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (grind :if-match nil :exclude "elt")
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
rho_postmid rewrites rho_postmid(w!1)(nlist(i!2`1))
  to FALSE
rho_postmid rewrites rho_postmid(w!1)(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_postmid rewrites 
  rho_postmid(w!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
  to FALSE
/= rewrites P!1 /= p
  to NOT (P!1 = p)
/= rewrites i!1`1 /= mid
  to NOT (i!1`1 = mid)
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
rho_postmid rewrites rho_postmid(w!1)(nlist(i!2`1))
  to FALSE
rho_postmid rewrites rho_postmid(w!1)(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_postmid rewrites 
  rho_postmid(w!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
  to FALSE
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
rho_postmid rewrites rho_postmid(w!1)(nlist(i!2`1))
  to NOT elt(i!2`1, n_mid)
rho_postmid rewrites rho_postmid(w!1)(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_postmid rewrites 
  rho_postmid(w!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
  to NOT elt(i!2`1, n_mid)
rho_postmid rewrites rho_postmid(w!1)(nlist(append(i!2`1, (: i!1`2 :))))
  to TRUE
rho_postmid rewrites 
  rho_postmid(w!1)(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
  to TRUE
rho_postmid rewrites 
  rho_postmid(w!1)
             (conc(nlist(append(i!2`1, (: i!1`2 :))),
                   ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))
  to TRUE
remove rewrites remove(cdr(hu_list), i - 1)
  to cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2))
remove rewrites remove(hu_list, i)
  to cons(car(hu_list),
           cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2)))
rho_postmid rewrites 
  rho_postmid(w!1)
             (code(public(car(i!2`4)),
                   conc(nlist(append(i!2`1, (: i!1`2 :))),
                        ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
  to TRUE
/= rewrites P!1 /= p
  to NOT (P!1 = p)
/= rewrites i!1`1 /= mid
  to NOT (i!1`1 = mid)
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
rho_postmid rewrites rho_postmid(w!1)(nlist(i!2`1))
  to NOT elt(i!2`1, n_mid)
rho_postmid rewrites rho_postmid(w!1)(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_postmid rewrites 
  rho_postmid(w!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
  to NOT elt(i!2`1, n_mid)
rho_postmid rewrites rho_postmid(w!1)(nlist(append(i!2`1, (: i!1`2 :))))
  to TRUE
rho_postmid rewrites 
  rho_postmid(w!1)(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
  to TRUE
rho_postmid rewrites 
  rho_postmid(w!1)
             (conc(nlist(append(i!2`1, (: i!1`2 :))),
                   ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))
  to TRUE
remove rewrites remove(cdr(hu_list), i - 1)
  to cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2))
remove rewrites remove(hu_list, i)
  to cons(car(hu_list),
           cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2)))
rho_postmid rewrites 
  rho_postmid(w!1)
             (code(public(car(i!2`4)),
                   conc(nlist(append(i!2`1, (: i!1`2 :))),
                        ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpostmid_middle.2.1.1.1.

restrictpostmid_middle.2.1.1.2 :  

{-1}  EXISTS (i: {x: nat | mid < x AND x <= w!1}):
        public(u!1) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, i)))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (comment "a contradiction is lurking in -2")
Adding comment: a contradiction is lurking in -2
this simplifies to: 
restrictpostmid_middle.2.1.1.2 : 
;;; a contradiction is lurking in -2

[-1]  EXISTS (i: {x: nat | mid < x AND x <= w!1}):
        public(u!1) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, i)))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictpostmid_middle.2.1.1.2 : 
;;; a contradiction is lurking in -2

{-1}  public(u!1) = public(hu(i!3))
{-2}  conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, i!3)))
[-3]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictpostmid_middle.2.1.1.2 : 
;;; a contradiction is lurking in -2

{-1}  nlist(i!2`1) = nlist(append(nl1!1, cons(n_mid, nl2!1)))
{-2}  ilist(append(i!2`3, i!2`4)) = ilist(remove(hu_list, i!3))
[-3]  public(u!1) = public(hu(i!3))
[-4]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictpostmid_middle.2.1.1.2 : 
;;; a contradiction is lurking in -2

{-1}  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-2]  ilist(append(i!2`3, i!2`4)) = ilist(remove(hu_list, i!3))
[-3]  public(u!1) = public(hu(i!3))
[-4]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictpostmid_middle.2.1.1.2 : 
;;; a contradiction is lurking in -2

{-1}  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-2]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-3]  public(u!1) = public(hu(i!3))
[-4]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (typepred "i!2`1" "i!2`3" "i!2`4" "nl1!1" "nl2!1"
                 "hu_list" "i!3")
Adding type constraints for  i!2`1, i!2`3, i!2`4, nl1!1, nl2!1, hu_list, i!3,
this simplifies to: 
restrictpostmid_middle.2.1.1.2 : 
;;; a contradiction is lurking in -2

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`1)
{-2}  length(i!2`1) = i!1`1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`3)
{-4}  length(i!2`3) = i!1`1
{-5}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`4)
{-6}  length(i!2`4) = P!1 - 1 - i!1`1
{-7}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl1!1)
{-8}  length(nl1!1) = mid
{-9}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
{-10} length(nl2!1) = -1 - mid + i!3
{-11} every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-12} (length(hu_list) = p)
{-13} FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
{-14} mid < i!3
{-15} i!3 <= w!1
[-16] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-17] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-18] public(u!1) = public(hu(i!3))
[-19] i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-20] 0 < i!1`1
[-21] i!1`1 < P!1 - 1
[-22] 2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (lemma "select_right_nonce2" ("P" "P!1"))
Applying select_right_nonce2 where 
  P gets P!1,
this simplifies to: 
restrictpostmid_middle.2.1.1.2 : 
;;; a contradiction is lurking in -2

{-1}  (P!1 = p IMPLIES floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid)
       AND
       floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1 AND
        floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-2]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`1)
[-3]  length(i!2`1) = i!1`1
[-4]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`3)
[-5]  length(i!2`3) = i!1`1
[-6]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`4)
[-7]  length(i!2`4) = P!1 - 1 - i!1`1
[-8]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl1!1)
[-9]  length(nl1!1) = mid
[-10] every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
[-11] length(nl2!1) = -1 - mid + i!3
[-12] every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] mid < i!3
[-16] i!3 <= w!1
[-17] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-18] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-19] public(u!1) = public(hu(i!3))
[-20] i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-21] 0 < i!1`1
[-22] i!1`1 < P!1 - 1
[-23] 2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (flatten -1)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictpostmid_middle.2.1.1.2 : 
;;; a contradiction is lurking in -2

{-1}  (P!1 = p IMPLIES floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid)
{-2}  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
{-3}  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-4]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`1)
[-5]  length(i!2`1) = i!1`1
[-6]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`3)
[-7]  length(i!2`3) = i!1`1
[-8]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`4)
[-9]  length(i!2`4) = P!1 - 1 - i!1`1
[-10] every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl1!1)
[-11] length(nl1!1) = mid
[-12] every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
[-13] length(nl2!1) = -1 - mid + i!3
[-14] every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
[-15] (length(hu_list) = p)
[-16] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-17] mid < i!3
[-18] i!3 <= w!1
[-19] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-20] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-21] public(u!1) = public(hu(i!3))
[-22] i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-23] 0 < i!1`1
[-24] i!1`1 < P!1 - 1
[-25] 2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (delete -2 -3 -4 -6 -8 -10 -12 -14 -21 +)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.2.1.1.2 : 
;;; a contradiction is lurking in -2

[-1]  (P!1 = p IMPLIES floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid)
[-2]  length(i!2`1) = i!1`1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  length(nl1!1) = mid
[-6]  length(nl2!1) = -1 - mid + i!3
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  mid < i!3
[-10] i!3 <= w!1
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-12] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-13] i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-14] 0 < i!1`1
[-15] i!1`1 < P!1 - 1
[-16] 2 <= P!1
  |-------

Rerunning step: (case "P!1=p" "i!3=i!1`1")
Case splitting on 
   P!1 = p, 
   i!3 = i!1`1, 
this yields  3 subgoals: 
restrictpostmid_middle.2.1.1.2.1 : 
;;; a contradiction is lurking in -2

{-1}  i!3 = i!1`1
{-2}  P!1 = p
[-3]  (P!1 = p IMPLIES floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid)
[-4]  length(i!2`1) = i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = P!1 - 1 - i!1`1
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -1 - mid + i!3
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] mid < i!3
[-12] i!3 <= w!1
[-13] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-14] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-15] i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
[-18] 2 <= P!1
  |-------

Rerunning step: (delete -4 -5 -6 -7 -8 -9 -10 -12 -13 -14 -16 -17 -18)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.2.1.1.2.1 : 
;;; a contradiction is lurking in -2

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  (P!1 = p IMPLIES floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid)
[-4]  mid < i!3
[-5]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
  |-------

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.2.1.1.2.1.

restrictpostmid_middle.2.1.1.2.2 : 
;;; a contradiction is lurking in -2

{-1}  P!1 = p
[-2]  (P!1 = p IMPLIES floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid)
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!3
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] mid < i!3
[-11] i!3 <= w!1
[-12] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-13] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-14] i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-15] 0 < i!1`1
[-16] i!1`1 < P!1 - 1
[-17] 2 <= P!1
  |-------
{1}   i!3 = i!1`1

Rerunning step: (delete -1 -2 -4 -5 -8 -9 -10 -11 -12 -14 -15 -16 -17)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.2.1.1.2.2 : 
;;; a contradiction is lurking in -2

[-1]  length(i!2`1) = i!1`1
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
  |-------
[1]   i!3 = i!1`1

Rerunning step: (replace -4 -1)
Replacing using formula -4,
this simplifies to: 
restrictpostmid_middle.2.1.1.2.2 : 
;;; a contradiction is lurking in -2

{-1}  length(append(nl1!1, cons(n_mid, nl2!1))) = i!1`1
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
  |-------
[1]   i!3 = i!1`1

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets cons(n_mid, nl2!1),
l1: list[T] gets nl1!1,
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictpostmid_middle.2.1.1.2.2 : 
;;; a contradiction is lurking in -2

{-1}  length(cons(n_mid, nl2!1)) + length(nl1!1) = i!1`1
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
  |-------
[1]   i!3 = i!1`1

Rerunning step: (expand "length" -1 1)
Expanding the definition of length,
this simplifies to: 
restrictpostmid_middle.2.1.1.2.2 : 
;;; a contradiction is lurking in -2

{-1}  1 + length(nl1!1) + length[Identity](nl2!1) = i!1`1
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
  |-------
[1]   i!3 = i!1`1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.2.1.1.2.2.

restrictpostmid_middle.2.1.1.2.3 : 
;;; a contradiction is lurking in -2

[-1]  (P!1 = p IMPLIES floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid)
[-2]  length(i!2`1) = i!1`1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  length(nl1!1) = mid
[-6]  length(nl2!1) = -1 - mid + i!3
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  mid < i!3
[-10] i!3 <= w!1
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-12] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-13] i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-14] 0 < i!1`1
[-15] i!1`1 < P!1 - 1
[-16] 2 <= P!1
  |-------
{1}   P!1 = p

Rerunning step: (lemma "listprops[Identity].equality_length"
                 ("l1" "append(i!2`3,i!2`4)" "l2"
                  "remove(hu_list,i!3)"))
Applying listprops[Identity].equality_length where 
  l1 gets append(i!2`3, i!2`4),
  l2 gets remove(hu_list, i!3),
this simplifies to: 
restrictpostmid_middle.2.1.1.2.3 : 
;;; a contradiction is lurking in -2

{-1}  append(i!2`3, i!2`4) = remove(hu_list, i!3) IMPLIES
       length[Identity](append(i!2`3, i!2`4)) =
        length[Identity](remove(hu_list, i!3))
[-2]  (P!1 = p IMPLIES floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid)
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!3
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] mid < i!3
[-11] i!3 <= w!1
[-12] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-13] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-14] i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-15] 0 < i!1`1
[-16] i!1`1 < P!1 - 1
[-17] 2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (delete -2 -3 -6 -7 -9 -10 -11 -13 -14 -15 -16)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.2.1.1.2.3 : 
;;; a contradiction is lurking in -2

[-1]  append(i!2`3, i!2`4) = remove(hu_list, i!3) IMPLIES
       length[Identity](append(i!2`3, i!2`4)) =
        length[Identity](remove(hu_list, i!3))
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  (length(hu_list) = p)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-6]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpostmid_middle.2.1.1.2.3 : 
;;; a contradiction is lurking in -2

{-1}  length[Identity](append(i!2`3, i!2`4)) =
       length[Identity](remove(hu_list, i!3))
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  (length(hu_list) = p)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-6]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets i!2`4,
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictpostmid_middle.2.1.1.2.3 : 
;;; a contradiction is lurking in -2

{-1}  length(i!2`3) + length(i!2`4) = length[Identity](remove(hu_list, i!3))
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  (length(hu_list) = p)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-6]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (rewrite "length_remove" -1 :dir rl)
Found matching substitution:
i: below[length(c)] gets i!3,
c: (cons?[T]) gets hu_list,
Rewriting using length_remove, matching in -1,
this yields  2 subgoals: 
restrictpostmid_middle.2.1.1.2.3.1 : 
;;; a contradiction is lurking in -2

{-1}  length(i!2`3) + length(i!2`4) = length[Identity](hu_list) - 1
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  (length(hu_list) = p)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-6]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.2.1.1.2.3.1.

restrictpostmid_middle.2.1.1.2.3.2 : 
;;; a contradiction is lurking in -2

[-1]  length(i!2`3) + length(i!2`4) = length[Identity](remove(hu_list, i!3))
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  (length(hu_list) = p)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-6]  2 <= P!1
  |-------
{1}   cons?[Identity](hu_list)
[2]   P!1 = p

Rerunning step: (lemma "more_list_props[Identity].length_non_zero"
                 ("l" "hu_list"))
Applying more_list_props[Identity].length_non_zero where 
  l gets hu_list,
this simplifies to: 
restrictpostmid_middle.2.1.1.2.3.2 : 
;;; a contradiction is lurking in -2

{-1}  length(hu_list) > 0 IFF cons?(hu_list)
[-2]  length(i!2`3) + length(i!2`4) = length[Identity](remove(hu_list, i!3))
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  (length(hu_list) = p)
[-6]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-7]  2 <= P!1
  |-------
[1]   cons?[Identity](hu_list)
[2]   P!1 = p

Rerunning step: (delete -2 -3 -4 -6 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.2.1.1.2.3.2 : 
;;; a contradiction is lurking in -2

[-1]  length(hu_list) > 0 IFF cons?(hu_list)
[-2]  (length(hu_list) = p)
[-3]  2 <= P!1
  |-------
[1]   cons?[Identity](hu_list)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.2.1.1.2.3.2.


This completes the proof of restrictpostmid_middle.2.1.1.2.3.


This completes the proof of restrictpostmid_middle.2.1.1.2.


This completes the proof of restrictpostmid_middle.2.1.1.

restrictpostmid_middle.2.1.2 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
{1}   ((rec(u!1, nth(i!2`3, i!1`1 - 1),
            E(public(u!1),
              conc(ilist(append(i!2`3, i!2`4)),
                   nlist(cons(i!1`2, i!2`2)))))
         >>
         (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                         nth(cons(i!1`2, i!2`2),
                             floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                    ((mid - 1) / (p - 2)) * P!1)
                              - i!1`1)))
           >>
           ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
             Stop[event])))
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
{2}   R_postmid(w!1)
               (trans(u!1, car(i!2`4),
                      E(public(car(i!2`4)),
                        conc(nlist(append(i!2`1, (: i!1`2 :))),
                             ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))))
{3}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(nlist(append(i!2`1, (: i!1`2 :))),
                   ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
       >>
       ((rec(u!1, nth(i!2`3, i!1`1 - 1),
             E(public(u!1),
               conc(ilist(append(i!2`3, i!2`4)),
                    nlist(cons(i!1`2, i!2`2)))))
          >>
          (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                          nth(cons(i!1`2, i!2`2),
                              floor(1 - 2 * ((mid - 1) / (p - 2))
                                    +
                                    ((mid - 1) / (p - 2)) * P!1)
                               - i!1`1)))
            >>
            ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
              Stop[event])))
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.2.1.2 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   ((rec(u!1, nth(i!2`3, i!1`1 - 1),
            E(public(u!1),
              conc(ilist(append(i!2`3, i!2`4)),
                   nlist(cons(i!1`2, i!2`2)))))
         >>
         (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                         nth(cons(i!1`2, i!2`2),
                             floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                    ((mid - 1) / (p - 2)) * P!1)
                              - i!1`1)))
           >>
           ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
             Stop[event])))
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictpostmid_middle.2.1.2 :  

{-1}  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(ilist(append(i!2`3, i!2`4)),
                         nlist(cons(i!1`2, i!2`2)))))
[-2]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-3]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-5]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-6]  0 < i!1`1
[-7]  i!1`1 < P!1 - 1
[-8]  2 <= P!1
  |-------
{1}   ((signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                       nth(cons(i!1`2, i!2`2),
                           floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                  ((mid - 1) / (p - 2)) * P!1)
                            - i!1`1)))
         >>
         ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
           Stop[event]))
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
{2}   R_postmid(w!1)
               (rec(u!1, nth(i!2`3, i!1`1 - 1),
                    E(public(u!1),
                      conc(ilist(append(i!2`3, i!2`4)),
                           nlist(cons(i!1`2, i!2`2))))))
{3}   rec(u!1, nth(i!2`3, i!1`1 - 1),
          E(public(u!1),
            conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2)))))
       >>
       ((signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                        nth(cons(i!1`2, i!2`2),
                            floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                   ((mid - 1) / (p - 2)) * P!1)
                             - i!1`1)))
          >>
          ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
            Stop[event]))
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.2.1.2 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(ilist(append(i!2`3, i!2`4)),
                         nlist(cons(i!1`2, i!2`2)))))
[-2]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-3]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-5]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-6]  0 < i!1`1
[-7]  i!1`1 < P!1 - 1
[-8]  2 <= P!1
  |-------
[1]   ((signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                       nth(cons(i!1`2, i!2`2),
                           floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                  ((mid - 1) / (p - 2)) * P!1)
                            - i!1`1)))
         >>
         ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
           Stop[event]))
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictpostmid_middle.2.1.2.1 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(ilist(append(i!2`3, i!2`4)),
                         nlist(cons(i!1`2, i!2`2)))))
[-2]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-3]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-5]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-6]  0 < i!1`1
[-7]  i!1`1 < P!1 - 1
[-8]  2 <= P!1
  |-------
{1}   rho_postmid(w!1)
                 (running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                          nth(cons(i!1`2, i!2`2),
                              floor(1 - 2 * ((mid - 1) / (p - 2))
                                    +
                                    ((mid - 1) / (p - 2)) * P!1)
                               - i!1`1)))
{2}   R_postmid(w!1)
               (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                               nth(cons(i!1`2, i!2`2),
                                   floor(1 - 2 * ((mid - 1) / (p - 2))
                                         +
                                         ((mid - 1) / (p - 2)) * P!1)
                                    - i!1`1))))
{3}   signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                     nth(cons(i!1`2, i!2`2),
                         floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                ((mid - 1) / (p - 2)) * P!1)
                          - i!1`1)))
       >>
       (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
          Stop[event])
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete - 2 3 4 5)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.2.1.2.1 :  

  |-------
[1]   rho_postmid(w!1)
                 (running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                          nth(cons(i!1`2, i!2`2),
                              floor(1 - 2 * ((mid - 1) / (p - 2))
                                    +
                                    ((mid - 1) / (p - 2)) * P!1)
                               - i!1`1)))

Rerunning step: (expand "rho_postmid")
Expanding the definition of rho_postmid,
this simplifies to: 
restrictpostmid_middle.2.1.2.1 :  

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictpostmid_middle.2.1.2.1.

restrictpostmid_middle.2.1.2.2 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(ilist(append(i!2`3, i!2`4)),
                         nlist(cons(i!1`2, i!2`2)))))
[-2]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-3]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-5]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-6]  0 < i!1`1
[-7]  i!1`1 < P!1 - 1
[-8]  2 <= P!1
  |-------
{1}   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
{2}   R_postmid(w!1)
               (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                               nth(cons(i!1`2, i!2`2),
                                   floor(1 - 2 * ((mid - 1) / (p - 2))
                                         +
                                         ((mid - 1) / (p - 2)) * P!1)
                                    - i!1`1))))
{3}   signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                     nth(cons(i!1`2, i!2`2),
                         floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                ((mid - 1) / (p - 2)) * P!1)
                          - i!1`1)))
       >>
       (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
          Stop[event])
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete -2 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.2.1.2.2 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(ilist(append(i!2`3, i!2`4)),
                         nlist(cons(i!1`2, i!2`2)))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (expand "E" -1)
Expanding the definition of E,
this simplifies to: 
restrictpostmid_middle.2.1.2.2 :  

{-1}  rho_postmid(w!1)
                 (code(public(u!1),
                       conc(ilist(append(i!2`3, i!2`4)),
                            nlist(cons(i!1`2, i!2`2)))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (expand "rho_postmid" -1)
Expanding the definition of rho_postmid,
this simplifies to: 
restrictpostmid_middle.2.1.2.2 :  

{-1}  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
       OR
       EXISTS (i: {x: nat | mid < x AND x <= w!1}):
         public(u!1) = public(hu(i)) AND
          EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                  nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
            conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
             conc(nlist(append(nl1, cons(n_mid, nl2))),
                  ilist(remove(hu_list, i)))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
restrictpostmid_middle.2.1.2.2.1 :  

{-1}  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (lemma "listprops[Nonce].elt_append2"
                 ("l1" "(:i!1`2:)" "l2" "i!2`2" "t" "n_mid"))
Applying listprops[Nonce].elt_append2 where 
  l1 gets (: i!1`2 :),
  l2 gets i!2`2,
  t gets n_mid,
this simplifies to: 
restrictpostmid_middle.2.1.2.2.1 :  

{-1}  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
[-3]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-5]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-6]  0 < i!1`1
[-7]  i!1`1 < P!1 - 1
[-8]  2 <= P!1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (delete -3 -4 -5)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.2.1.2.2.1 :  

[-1]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (expand "LastMessage")
Expanding the definition of LastMessage,
this simplifies to: 
restrictpostmid_middle.2.1.2.2.1 :  

[-1]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
{1}   ((IF i!1`1 = P!1 - 2
          THEN trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2)))
        ELSE trans(u!1, car(i!2`4),
                   E(public(car(i!2`4)),
                     conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                          nlist(i!2`2))))
        ENDIF
         >> Stop[event])
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (lift-if)
Lifting IF-conditions to the top level,
this simplifies to: 
restrictpostmid_middle.2.1.2.2.1 :  

[-1]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
{1}   IF i!1`1 = P!1 - 2
        THEN ((trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2)))
                >> Stop[event])
               # R_postmid(w!1))
              |>
              LAMBDA (t: list[event]):
                every(LAMBDA (e: event):
                        rec?(e) => rho_postmid(w!1)(msg(e)))
                     (t)
                 =>
                 every(LAMBDA (e: event):
                         NOT rec?(e) => rho_postmid(w!1)(msg(e)))
                      (t)
      ELSE ((trans(u!1, car(i!2`4),
                   E(public(car(i!2`4)),
                     conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                          nlist(i!2`2))))
              >> Stop[event])
             # R_postmid(w!1))
            |>
            LAMBDA (t: list[event]):
              every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))
                   (t)
               =>
               every(LAMBDA (e: event):
                       NOT rec?(e) => rho_postmid(w!1)(msg(e)))
                    (t)
      ENDIF
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (split 1)
Splitting conjunctions,
this yields  2 subgoals: 
restrictpostmid_middle.2.1.2.2.1.1 :  

[-1]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
{1}   i!1`1 = P!1 - 2 IMPLIES
       ((trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))) >>
          Stop[event])
         # R_postmid(w!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
           =>
           every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
                (t)
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (prefix2)
Applying prefix rule with adjusted if-lifting,
this yields  3 subgoals: 
restrictpostmid_middle.2.1.2.2.1.1.1 :  

{-1}  i!1`1 = P!1 - 2
[-2]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-3]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   rho_postmid(w!1)(E(public(car(i!2`4)), nlist(i!2`2)))
{2}   R_postmid(w!1)
               (trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))))
{3}   trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))) >>
       (Stop[event] # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.2.1.2.2.1.1.1 :  

[-1]  i!1`1 = P!1 - 2
[-2]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-3]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)(E(public(car(i!2`4)), nlist(i!2`2)))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (grind :if-match nil :exclude "elt")
E rewrites E(public(car(i!2`4)), nlist(i!2`2))
  to code(public(car(i!2`4)), nlist(i!2`2))
rho_postmid rewrites rho_postmid(w!1)(nlist(i!2`2))
  to NOT elt(i!2`2, n_mid)
remove rewrites remove(cdr(hu_list), i - 1)
  to cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2))
remove rewrites remove(hu_list, i)
  to cons(car(hu_list),
           cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2)))
rho_postmid rewrites rho_postmid(w!1)(code(public(car(i!2`4)), nlist(i!2`2)))
  to NOT elt(i!2`2, n_mid)
append rewrites append((: :), i!2`2)
  to i!2`2
append rewrites append((: i!1`2 :), i!2`2)
  to cons(i!1`2, i!2`2)
rho_postmid rewrites rho_postmid(w!1)(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_postmid rewrites rho_postmid(w!1)(nlist(cons(i!1`2, i!2`2)))
  to FALSE
rho_postmid rewrites 
  rho_postmid(w!1)
             (conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
  to FALSE
E rewrites E(public(car(i!2`4)), nlist(i!2`2))
  to code(public(car(i!2`4)), nlist(i!2`2))
rho_postmid rewrites rho_postmid(w!1)(nlist(i!2`2))
  to NOT elt(i!2`2, n_mid)
remove rewrites remove(cdr(hu_list), i - 1)
  to cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2))
remove rewrites remove(hu_list, i)
  to cons(car(hu_list),
           cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2)))
rho_postmid rewrites rho_postmid(w!1)(code(public(car(i!2`4)), nlist(i!2`2)))
  to NOT elt(i!2`2, n_mid)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpostmid_middle.2.1.2.2.1.1.1.

restrictpostmid_middle.2.1.2.2.1.1.2 :  

{-1}  i!1`1 = P!1 - 2
[-2]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-3]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   (Stop[event] # R_postmid(w!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
{2}   R_postmid(w!1)
               (trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))))
{3}   trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))) >>
       (Stop[event] # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete - 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.2.1.2.2.1.1.2 :  

  |-------
[1]   (Stop[event] # R_postmid(w!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   P!1 = 2

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictpostmid_middle.2.1.2.2.1.1.2.

restrictpostmid_middle.2.1.2.2.1.1.3 :  

[-1]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
{1}   cons?[Identity](i!2`4)
{2}   i!1`1 = P!1 - 2 IMPLIES
       IF R_postmid(w!1)
                   (trans(u!1, car(i!2`4),
                          E(public(car(i!2`4)), nlist(i!2`2))))
         THEN Stop
       ELSE trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))) >>
             (Stop[event] # R_postmid(w!1))
       ENDIF
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
           =>
           every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
                (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (delete -1 -2 -3 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.2.1.2.2.1.1.3 :  

[-1]  i!1`1 < P!1 - 1
[-2]  2 <= P!1
  |-------
[1]   cons?[Identity](i!2`4)

Rerunning step: (nonemptylist "i!2`4")
Relating existence of a tail to a list's length,

This completes the proof of restrictpostmid_middle.2.1.2.2.1.1.3.


This completes the proof of restrictpostmid_middle.2.1.2.2.1.1.

restrictpostmid_middle.2.1.2.2.1.2 :  

[-1]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
{1}   NOT i!1`1 = P!1 - 2 IMPLIES
       ((trans(u!1, car(i!2`4),
               E(public(car(i!2`4)),
                 conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                      nlist(i!2`2))))
          >> Stop[event])
         # R_postmid(w!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
           =>
           every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
                (t)
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (prefix2)
Applying prefix rule with adjusted if-lifting,
this yields  3 subgoals: 
restrictpostmid_middle.2.1.2.2.1.2.1 :  

[-1]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
{1}   rho_postmid(w!1)
                 (E(public(car(i!2`4)),
                    conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                         nlist(i!2`2))))
{2}   R_postmid(w!1)
               (trans(u!1, car(i!2`4),
                      E(public(car(i!2`4)),
                        conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                             nlist(i!2`2)))))
{3}   i!1`1 = P!1 - 2
{4}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                   nlist(i!2`2))))
       >> (Stop[event] # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[5]   i!1`2 = n_mid
[6]   P!1 = 2

Rerunning step: (delete 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.2.1.2.2.1.2.1 :  

[-1]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (E(public(car(i!2`4)),
                    conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                         nlist(i!2`2))))
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (grind :if-match nil :exclude "elt")
E rewrites 
  E(public(car(i!2`4)),
    conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)))
  to code(public(car(i!2`4)),
           conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)))
rho_postmid rewrites 
  rho_postmid(w!1)(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
  to TRUE
rho_postmid rewrites rho_postmid(w!1)(nlist(i!2`2))
  to NOT elt(i!2`2, n_mid)
rho_postmid rewrites 
  rho_postmid(w!1)
             (conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                   nlist(i!2`2)))
  to NOT elt(i!2`2, n_mid)
remove rewrites remove(cdr(hu_list), i - 1)
  to cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2))
remove rewrites remove(hu_list, i)
  to cons(car(hu_list),
           cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2)))
rho_postmid rewrites 
  rho_postmid(w!1)
             (code(public(car(i!2`4)),
                   conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                        nlist(i!2`2))))
  to NOT elt(i!2`2, n_mid) OR
       EXISTS (i: {x: nat | mid < x AND x <= w!1}):
         public(car(i!2`4)) = public(hu(i)) AND
          EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                  nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
            conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2))
             =
             conc(nlist(append(nl1, cons(n_mid, nl2))),
                  ilist(cons(car(hu_list),
                             cons(car(cdr(hu_list)),
                                  remove(cdr(cdr(hu_list)), i - 2)))))
append rewrites append((: :), i!2`2)
  to i!2`2
append rewrites append((: i!1`2 :), i!2`2)
  to cons(i!1`2, i!2`2)
rho_postmid rewrites rho_postmid(w!1)(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_postmid rewrites rho_postmid(w!1)(nlist(cons(i!1`2, i!2`2)))
  to FALSE
rho_postmid rewrites 
  rho_postmid(w!1)
             (conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
  to FALSE
E rewrites 
  E(public(car(i!2`4)),
    conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)))
  to code(public(car(i!2`4)),
           conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)))
rho_postmid rewrites 
  rho_postmid(w!1)(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
  to TRUE
rho_postmid rewrites rho_postmid(w!1)(nlist(i!2`2))
  to NOT elt(i!2`2, n_mid)
rho_postmid rewrites 
  rho_postmid(w!1)
             (conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                   nlist(i!2`2)))
  to NOT elt(i!2`2, n_mid)
remove rewrites remove(cdr(hu_list), i - 1)
  to cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2))
remove rewrites remove(hu_list, i)
  to cons(car(hu_list),
           cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2)))
rho_postmid rewrites 
  rho_postmid(w!1)
             (code(public(car(i!2`4)),
                   conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                        nlist(i!2`2))))
  to NOT elt(i!2`2, n_mid) OR
       EXISTS (i: {x: nat | mid < x AND x <= w!1}):
         public(car(i!2`4)) = public(hu(i)) AND
          EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                  nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
            conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2))
             =
             conc(nlist(append(nl1, cons(n_mid, nl2))),
                  ilist(cons(car(hu_list),
                             cons(car(cdr(hu_list)),
                                  remove(cdr(cdr(hu_list)), i - 2)))))
rho_postmid rewrites rho_postmid(w!1)(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_postmid rewrites rho_postmid(w!1)(nlist(cons(i!1`2, i!2`2)))
  to NOT elt(cons(i!1`2, i!2`2), n_mid)
rho_postmid rewrites 
  rho_postmid(w!1)
             (conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
  to NOT elt(cons(i!1`2, i!2`2), n_mid)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpostmid_middle.2.1.2.2.1.2.1.

restrictpostmid_middle.2.1.2.2.1.2.2 :  

[-1]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
{1}   (Stop[event] # R_postmid(w!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
{2}   R_postmid(w!1)
               (trans(u!1, car(i!2`4),
                      E(public(car(i!2`4)),
                        conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                             nlist(i!2`2)))))
{3}   i!1`1 = P!1 - 2
{4}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                   nlist(i!2`2))))
       >> (Stop[event] # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[5]   i!1`2 = n_mid
[6]   P!1 = 2

Rerunning step: (delete - 2 3 4 5 6)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.2.1.2.2.1.2.2 :  

  |-------
[1]   (Stop[event] # R_postmid(w!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictpostmid_middle.2.1.2.2.1.2.2.

restrictpostmid_middle.2.1.2.2.1.2.3 :  

[-1]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
{1}   cons?[Identity](i!2`4)
{2}   NOT i!1`1 = P!1 - 2 IMPLIES
       IF R_postmid(w!1)
                   (trans(u!1, car(i!2`4),
                          E(public(car(i!2`4)),
                            conc(ilist(append
                                       (i!2`3, cons(u!1, cdr(i!2`4)))),
                                 nlist(i!2`2)))))
         THEN Stop
       ELSE trans(u!1, car(i!2`4),
                  E(public(car(i!2`4)),
                    conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                         nlist(i!2`2))))
             >> (Stop[event] # R_postmid(w!1))
       ENDIF
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
           =>
           every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
                (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (delete -1 -2 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.2.1.2.2.1.2.3 :  

[-1]  0 < i!1`1
[-2]  i!1`1 < P!1 - 1
[-3]  2 <= P!1
  |-------
[1]   cons?[Identity](i!2`4)

Rerunning step: (nonemptylist "i!2`4")
Relating existence of a tail to a list's length,

This completes the proof of restrictpostmid_middle.2.1.2.2.1.2.3.


This completes the proof of restrictpostmid_middle.2.1.2.2.1.2.


This completes the proof of restrictpostmid_middle.2.1.2.2.1.

restrictpostmid_middle.2.1.2.2.2 :  

{-1}  EXISTS (i: {x: nat | mid < x AND x <= w!1}):
        public(u!1) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, i)))
[-2]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictpostmid_middle.2.1.2.2.2 :  

{-1}  public(u!1) = public(hu(i!3))
{-2}  conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, i!3)))
[-3]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-5]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-6]  0 < i!1`1
[-7]  i!1`1 < P!1 - 1
[-8]  2 <= P!1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   i!1`2 = n_mid
[3]   P!1 = 2

Rerunning step: (delete -1 -3 -4 -5 -6 -7 -8 +)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.2.1.2.2.2 :  

[-1]  conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, i!3)))
  |-------

Rerunning step: (decompose-equality -1)
Applying decompose-equality,

This completes the proof of restrictpostmid_middle.2.1.2.2.2.


This completes the proof of restrictpostmid_middle.2.1.2.2.


This completes the proof of restrictpostmid_middle.2.1.2.


This completes the proof of restrictpostmid_middle.2.1.

restrictpostmid_middle.2.2 :  

[-1]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
{-2}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-3}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) -
       i!1`1
       < length[Nonce](cons[Nonce](i!1`2, i!2`2))
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!1`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!1`2, i`2)))))
              >>
              (signal(running(i!1`1, append(i`3, cons(u!1, i`4)),
                              nth(cons(i!1`2, i`2),
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)
                                   - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (typepred "i!2`2")
Adding type constraints for  i!2`2,
this simplifies to: 
restrictpostmid_middle.2.2 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`2)
{-2}  length(i!2`2) = P!1 - 1 - i!1`1
[-3]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-5]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-6]  0 < i!1`1
[-7]  i!1`1 < P!1 - 1
[-8]  2 <= P!1
  |-------
[1]   floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) -
       i!1`1
       < length[Nonce](cons[Nonce](i!1`2, i!2`2))
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!1`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!1`2, i`2)))))
              >>
              (signal(running(i!1`1, append(i`3, cons(u!1, i`4)),
                              nth(cons(i!1`2, i`2),
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)
                                   - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (delete -1 -3 -4 -6 -7 -8 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.2.2 :  

[-1]  length(i!2`2) = P!1 - 1 - i!1`1
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
  |-------
[1]   floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) -
       i!1`1
       < length[Nonce](cons[Nonce](i!1`2, i!2`2))

Rerunning step: (expand "length" 1)
Expanding the definition of length,
this simplifies to: 
restrictpostmid_middle.2.2 :  

[-1]  length(i!2`2) = P!1 - 1 - i!1`1
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
  |-------
{1}   floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) -
       i!1`1
       < 1 + length[Nonce](i!2`2)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.2.2.

restrictpostmid_middle.2.3 :  

[-1]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
{-2}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-3}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   cons?[Identity](i!2`4)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!1`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!1`2, i`2)))))
              >>
              (signal(running(i!1`1, append(i`3, cons(u!1, i`4)),
                              nth(cons(i!1`2, i`2),
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)
                                   - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (delete -1 -2 -3 -4 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.2.3 :  

[-1]  i!1`1 < P!1 - 1
[-2]  2 <= P!1
  |-------
[1]   cons?[Identity](i!2`4)

Rerunning step: (nonemptylist "i!2`4")
Relating existence of a tail to a list's length,

This completes the proof of restrictpostmid_middle.2.3.

restrictpostmid_middle.2.4 :  

[-1]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
{-2}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-3}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   i!1`1 - 1 < length[Identity](i!2`3)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!1`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!1`2, i`2)))))
              >>
              (signal(running(i!1`1, append(i`3, cons(u!1, i`4)),
                              nth(cons(i!1`2, i`2),
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)
                                   - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (typepred "i!2`3")
Adding type constraints for  i!2`3,
this simplifies to: 
restrictpostmid_middle.2.4 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`3)
{-2}  length(i!2`3) = i!1`1
[-3]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-5]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-6]  0 < i!1`1
[-7]  i!1`1 < P!1 - 1
[-8]  2 <= P!1
  |-------
[1]   i!1`1 - 1 < length[Identity](i!2`3)
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!1`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!1`2, i`2)))))
              >>
              (signal(running(i!1`1, append(i`3, cons(u!1, i`4)),
                              nth(cons(i!1`2, i`2),
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)
                                   - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (delete -1 -3 -4 -5 -6 -7 -8 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.2.4 :  

[-1]  length(i!2`3) = i!1`1
  |-------
[1]   i!1`1 - 1 < length[Identity](i!2`3)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.2.4.

restrictpostmid_middle.2.5 :  

[-1]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
{-2}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-3}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   FORALL (nl1: {x: list[Nonce] | length[Nonce](x) = i!1`1},
              nl2: {x: list[Nonce] | length[Nonce](x) = P!1 - 1 - i!1`1},
              il1: {x: list[Identity] | length[Identity](x) = i!1`1},
              il2:
                {x: list[Identity] |
                   length[Identity](x) = P!1 - 1 - i!1`1}):
        floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
         - i!1`1
         < length[Nonce](cons[Nonce](i!1`2, nl2))
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1: {x: list[Identity] | length(x) = i!1`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              (signal(running(i!1`1, append(il1, cons(u!1, il2)),
                              nth(cons(i!1`2, nl2),
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)
                                   - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictpostmid_middle.2.5 :  

[-1]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) -
       i!1`1
       < length[Nonce](cons[Nonce](i!1`2, nl2!1))
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1: {x: list[Identity] | length(x) = i!1`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              (signal(running(i!1`1, append(il1, cons(u!1, il2)),
                              nth(cons(i!1`2, nl2),
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)
                                   - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (typepred "nl2!1")
Adding type constraints for  nl2!1,
this simplifies to: 
restrictpostmid_middle.2.5 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
{-2}  length(nl2!1) = P!1 - 1 - i!1`1
[-3]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-5]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-6]  0 < i!1`1
[-7]  i!1`1 < P!1 - 1
[-8]  2 <= P!1
  |-------
[1]   floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) -
       i!1`1
       < length[Nonce](cons[Nonce](i!1`2, nl2!1))
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1: {x: list[Identity] | length(x) = i!1`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              (signal(running(i!1`1, append(il1, cons(u!1, il2)),
                              nth(cons(i!1`2, nl2),
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)
                                   - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (delete -1 -3 -4 -6 -7 -8 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.2.5 :  

[-1]  length(nl2!1) = P!1 - 1 - i!1`1
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
  |-------
[1]   floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) -
       i!1`1
       < length[Nonce](cons[Nonce](i!1`2, nl2!1))

Rerunning step: (expand "length" 1)
Expanding the definition of length,
this simplifies to: 
restrictpostmid_middle.2.5 :  

[-1]  length(nl2!1) = P!1 - 1 - i!1`1
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
  |-------
{1}   floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) -
       i!1`1
       < 1 + length[Nonce](nl2!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.2.5.

restrictpostmid_middle.2.6 :  

[-1]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
{-2}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-3}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   FORALL (nl1: {x: list[Nonce] | length[Nonce](x) = i!1`1},
              nl2: {x: list[Nonce] | length[Nonce](x) = P!1 - 1 - i!1`1},
              il1: {x: list[Identity] | length[Identity](x) = i!1`1},
              il2:
                {x: list[Identity] |
                   length[Identity](x) = P!1 - 1 - i!1`1}):
        cons?[Identity](il2)
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1: {x: list[Identity] | length(x) = i!1`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              (signal(running(i!1`1, append(il1, cons(u!1, il2)),
                              nth(cons(i!1`2, nl2),
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)
                                   - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictpostmid_middle.2.6 :  

[-1]  i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   cons?[Identity](il2!1)
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1: {x: list[Identity] | length(x) = i!1`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              (signal(running(i!1`1, append(il1, cons(u!1, il2)),
                              nth(cons(i!1`2, nl2),
                                  floor(1 - 2 * ((mid - 1) / (p - 2))
                                        +
                                        ((mid - 1) / (p - 2)) * P!1)
                                   - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (delete -1 -2 -3 -4 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.2.6 :  

[-1]  i!1`1 < P!1 - 1
[-2]  2 <= P!1
  |-------
[1]   cons?[Identity](il2!1)

Rerunning step: (nonemptylist "il2!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictpostmid_middle.2.6.


This completes the proof of restrictpostmid_middle.2.

restrictpostmid_middle.3 :  

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
{1}   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
{2}   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1: {x: list[Identity] | length(x) = i!1`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (signal(running(i!1`1, append(il1, cons(u!1, il2)),
                          nth(nl1,
                              floor(1 - 2 * ((mid - 1) / (p - 2))
                                    +
                                    ((mid - 1) / (p - 2)) * P!1))))
            >>
            (trans(u!1, car(il2),
                   E(public(car(il2)),
                     conc(nlist(append(nl1, (: i!1`2 :))),
                          ilist(append(il1, cons(u!1, cdr(il2)))))))
              >>
              (rec(u!1, nth(il1, i!1`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(il1, il2)),
                          nlist(cons(i!1`2, nl2)))))
                >>
                ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
{3}   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (choice3)
Applying choice rule,
this yields  5 subgoals: 
restrictpostmid_middle.3.1 :  

[-1]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
{2}   (rec(u!1, nth(i!2`3, i!1`1 - 1),
           E(public(u!1), conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
        >>
        (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                        nth(i!2`1,
                            floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                   ((mid - 1) / (p - 2)) * P!1))))
          >>
          (trans(u!1, car(i!2`4),
                 E(public(car(i!2`4)),
                   conc(nlist(append(i!2`1, (: i!1`2 :))),
                        ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
            >>
            (rec(u!1, nth(i!2`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i!2`3, i!2`4)),
                        nlist(cons(i!1`2, i!2`2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4))
                >> Stop[event])))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictpostmid_middle.3.1 :  

{-1}  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
{-2}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-3}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   ((signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                       nth(i!2`1,
                           floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                  ((mid - 1) / (p - 2)) * P!1))))
         >>
         (trans(u!1, car(i!2`4),
                E(public(car(i!2`4)),
                  conc(nlist(append(i!2`1, (: i!1`2 :))),
                       ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
           >>
           (rec(u!1, nth(i!2`3, i!1`1 - 1),
                E(public(u!1),
                  conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2)))))
             >>
             ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
               Stop[event]))))
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
{2}   R_postmid(w!1)
               (rec(u!1, nth(i!2`3, i!1`1 - 1),
                    E(public(u!1),
                      conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))))
{3}   rec(u!1, nth(i!2`3, i!1`1 - 1),
          E(public(u!1), conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
       >>
       ((signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                        nth(i!2`1,
                            floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                   ((mid - 1) / (p - 2)) * P!1))))
          >>
          (trans(u!1, car(i!2`4),
                 E(public(car(i!2`4)),
                   conc(nlist(append(i!2`1, (: i!1`2 :))),
                        ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
            >>
            (rec(u!1, nth(i!2`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i!2`3, i!2`4)),
                        nlist(cons(i!1`2, i!2`2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4))
                >> Stop[event]))))
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[5]   i!1`2 = n_mid
[6]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   ((signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                       nth(i!2`1,
                           floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                  ((mid - 1) / (p - 2)) * P!1))))
         >>
         (trans(u!1, car(i!2`4),
                E(public(car(i!2`4)),
                  conc(nlist(append(i!2`1, (: i!1`2 :))),
                       ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
           >>
           (rec(u!1, nth(i!2`3, i!1`1 - 1),
                E(public(u!1),
                  conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2)))))
             >>
             ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
               Stop[event]))))
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictpostmid_middle.3.1.1 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   rho_postmid(w!1)
                 (running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                          nth(i!2`1,
                              floor(1 - 2 * ((mid - 1) / (p - 2))
                                    +
                                    ((mid - 1) / (p - 2)) * P!1))))
{2}   R_postmid(w!1)
               (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                               nth(i!2`1,
                                   floor(1 - 2 * ((mid - 1) / (p - 2))
                                         +
                                         ((mid - 1) / (p - 2)) * P!1)))))
{3}   signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                     nth(i!2`1,
                         floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                ((mid - 1) / (p - 2)) * P!1))))
       >>
       ((trans(u!1, car(i!2`4),
               E(public(car(i!2`4)),
                 conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
          >>
          (rec(u!1, nth(i!2`3, i!1`1 - 1),
               E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
            >>
            ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
              Stop[event])))
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[5]   i!1`2 = n_mid
[6]   P!1 = 2

Rerunning step: (delete - 2 3 4 5 6)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.1 :  

  |-------
[1]   rho_postmid(w!1)
                 (running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                          nth(i!2`1,
                              floor(1 - 2 * ((mid - 1) / (p - 2))
                                    +
                                    ((mid - 1) / (p - 2)) * P!1))))

Rerunning step: (expand "rho_postmid")
Expanding the definition of rho_postmid,
this simplifies to: 
restrictpostmid_middle.3.1.1 :  

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictpostmid_middle.3.1.1.

restrictpostmid_middle.3.1.2 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   ((trans(u!1, car(i!2`4),
              E(public(car(i!2`4)),
                conc(nlist(append(i!2`1, (: i!1`2 :))),
                     ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
         >>
         (rec(u!1, nth(i!2`3, i!1`1 - 1),
              E(public(u!1),
                conc(ilist(append(i!2`3, i!2`4)),
                     nlist(cons(i!1`2, i!2`2)))))
           >>
           ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
             Stop[event])))
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
{2}   R_postmid(w!1)
               (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                               nth(i!2`1,
                                   floor(1 - 2 * ((mid - 1) / (p - 2))
                                         +
                                         ((mid - 1) / (p - 2)) * P!1)))))
{3}   signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                     nth(i!2`1,
                         floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                ((mid - 1) / (p - 2)) * P!1))))
       >>
       ((trans(u!1, car(i!2`4),
               E(public(car(i!2`4)),
                 conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
          >>
          (rec(u!1, nth(i!2`3, i!1`1 - 1),
               E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
            >>
            ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
              Stop[event])))
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[5]   i!1`2 = n_mid
[6]   P!1 = 2

Rerunning step: (delete 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   ((trans(u!1, car(i!2`4),
              E(public(car(i!2`4)),
                conc(nlist(append(i!2`1, (: i!1`2 :))),
                     ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
         >>
         (rec(u!1, nth(i!2`3, i!1`1 - 1),
              E(public(u!1),
                conc(ilist(append(i!2`3, i!2`4)),
                     nlist(cons(i!1`2, i!2`2)))))
           >>
           ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
             Stop[event])))
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   R_postmid(w!1)
               (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                               nth(i!2`1,
                                   floor(1 - 2 * ((mid - 1) / (p - 2))
                                         +
                                         ((mid - 1) / (p - 2)) * P!1)))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictpostmid_middle.3.1.2.1 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   rho_postmid(w!1)
                 (E(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
{2}   R_postmid(w!1)
               (trans(u!1, car(i!2`4),
                      E(public(car(i!2`4)),
                        conc(nlist(append(i!2`1, (: i!1`2 :))),
                             ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))))
{3}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(nlist(append(i!2`1, (: i!1`2 :))),
                   ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
       >>
       ((rec(u!1, nth(i!2`3, i!1`1 - 1),
             E(public(u!1),
               conc(ilist(append(i!2`3, i!2`4)),
                    nlist(cons(i!1`2, i!2`2)))))
          >>
          ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
            Stop[event]))
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   R_postmid(w!1)
               (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                               nth(i!2`1,
                                   floor(1 - 2 * ((mid - 1) / (p - 2))
                                         +
                                         ((mid - 1) / (p - 2)) * P!1)))))
[5]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[6]   i!1`2 = n_mid
[7]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (E(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   R_postmid(w!1)
               (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                               nth(i!2`1,
                                   floor(1 - 2 * ((mid - 1) / (p - 2))
                                         +
                                         ((mid - 1) / (p - 2)) * P!1)))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (expand "R_postmid")
Expanding the definition of R_postmid,
this simplifies to: 
restrictpostmid_middle.3.1.2.1 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (E(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
{2}   signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                     nth(i!2`1,
                         floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                ((mid - 1) / (p - 2)) * P!1))))
       = signal(running(w!1, hu_list, n_mid))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (case "i!1`1=w!1 AND append(i!2`3,cons(u!1,i!2`4))=hu_list AND nth(i!2`1,floor(1+((mid-1)/(p-2))*(P!1-2)))=n_mid")
Case splitting on 
   i!1`1 = w!1 AND
    append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
     nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2))) = n_mid, 
this yields  2 subgoals: 
restrictpostmid_middle.3.1.2.1.1 :  

{-1}  i!1`1 = w!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2))) = n_mid
[-2]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (E(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                     nth(i!2`1,
                         floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                ((mid - 1) / (p - 2)) * P!1))))
       = signal(running(w!1, hu_list, n_mid))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete -2 -3 -4 -5 -6 -7 1 3 4 5)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.1 :  

[-1]  i!1`1 = w!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2))) = n_mid
  |-------
[1]   signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                     nth(i!2`1,
                         floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                ((mid - 1) / (p - 2)) * P!1))))
       = signal(running(w!1, hu_list, n_mid))

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.3.1.2.1.1.

restrictpostmid_middle.3.1.2.1.2 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   i!1`1 = w!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2))) = n_mid
[2]   rho_postmid(w!1)
                 (E(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                     nth(i!2`1,
                         floor(1 - 2 * ((mid - 1) / (p - 2)) +
                                ((mid - 1) / (p - 2)) * P!1))))
       = signal(running(w!1, hu_list, n_mid))
[4]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[5]   i!1`2 = n_mid
[6]   P!1 = 2

Rerunning step: (delete -2 -3 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  0 < i!1`1
[-3]  i!1`1 < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   i!1`1 = w!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2))) = n_mid
[2]   rho_postmid(w!1)
                 (E(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (comment "prove all the conjuncts of 1, except for the (by itself) unprovable first conjucts, which is used in the proof of 2")
Adding comment: prove all the conjuncts of 1, except for the (by itself) unprovable first conjucts, which is used in the proof of 2
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2 : 
;;; prove all the conjuncts of 1, except for the (by itself) unprovable first conjucts, which is used in the proof of 2

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  0 < i!1`1
[-3]  i!1`1 < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   i!1`1 = w!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2))) = n_mid
[2]   rho_postmid(w!1)
                 (E(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (comment "first, distinguish between the two separate cases that would make -1 true")
Adding comment: first, distinguish between the two separate cases that would make -1 true
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  0 < i!1`1
[-3]  i!1`1 < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   i!1`1 = w!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2))) = n_mid
[2]   rho_postmid(w!1)
                 (E(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (expand "E")
Expanding the definition of E,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  rho_postmid(w!1)
                 (code(public(u!1),
                       conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  0 < i!1`1
[-3]  i!1`1 < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   i!1`1 = w!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2))) = n_mid
{2}   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (expand "rho_postmid" -1)
Expanding the definition of rho_postmid,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  rho_postmid(w!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))) OR
       EXISTS (i: {x: nat | mid < x AND x <= w!1}):
         public(u!1) = public(hu(i)) AND
          EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                  nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
            conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
             conc(nlist(append(nl1, cons(n_mid, nl2))),
                  ilist(remove(hu_list, i)))
[-2]  0 < i!1`1
[-3]  i!1`1 < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   i!1`1 = w!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2))) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (split -1)
Splitting conjunctions,
this yields  2 subgoals: 
restrictpostmid_middle.3.1.2.1.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  rho_postmid(w!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
[-2]  0 < i!1`1
[-3]  i!1`1 < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   i!1`1 = w!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2))) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (lemma "listprops[Nonce].elt_append3"
                 ("l1" "i!2`1" "l2" "(:i!1`2:)" "t" "n_mid"))
Applying listprops[Nonce].elt_append3 where 
  l1 gets i!2`1,
  l2 gets (: i!1`2 :),
  t gets n_mid,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  elt(append(i!2`1, (: i!1`2 :)), n_mid) IMPLIES
       elt(i!2`1, n_mid) OR elt((: i!1`2 :), n_mid)
[-2]  rho_postmid(w!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   i!1`1 = w!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2))) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (lemma "listprops[Nonce].elt_singleton"
                 ("t1" "i!1`2" "t2" "n_mid"))
Applying listprops[Nonce].elt_singleton where 
  t1 gets i!1`2,
  t2 gets n_mid,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  elt((: i!1`2 :), n_mid) IFF i!1`2 = n_mid
[-2]  elt(append(i!2`1, (: i!1`2 :)), n_mid) IMPLIES
       elt(i!2`1, n_mid) OR elt((: i!1`2 :), n_mid)
[-3]  rho_postmid(w!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   i!1`1 = w!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2))) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete -4 -5 -6 1 3 4 5)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  elt((: i!1`2 :), n_mid) IFF i!1`2 = n_mid
[-2]  elt(append(i!2`1, (: i!1`2 :)), n_mid) IMPLIES
       elt(i!2`1, n_mid) OR elt((: i!1`2 :), n_mid)
[-3]  rho_postmid(w!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))

Rerunning step: (grind :if-match nil :exclude "elt")
rho_postmid rewrites rho_postmid(w!1)(nlist(i!2`1))
  to FALSE
rho_postmid rewrites rho_postmid(w!1)(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_postmid rewrites 
  rho_postmid(w!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
  to FALSE
rho_postmid rewrites rho_postmid(w!1)(nlist(i!2`1))
  to NOT elt(i!2`1, n_mid)
rho_postmid rewrites rho_postmid(w!1)(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_postmid rewrites 
  rho_postmid(w!1)(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
  to NOT elt(i!2`1, n_mid)
rho_postmid rewrites rho_postmid(w!1)(nlist(append(i!2`1, (: i!1`2 :))))
  to TRUE
rho_postmid rewrites 
  rho_postmid(w!1)(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
  to TRUE
rho_postmid rewrites 
  rho_postmid(w!1)
             (conc(nlist(append(i!2`1, (: i!1`2 :))),
                   ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))
  to TRUE
remove rewrites remove(cdr(hu_list), i - 1)
  to cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2))
remove rewrites remove(hu_list, i)
  to cons(car(hu_list),
           cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2)))
rho_postmid rewrites 
  rho_postmid(w!1)
             (code(public(car(i!2`4)),
                   conc(nlist(append(i!2`1, (: i!1`2 :))),
                        ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpostmid_middle.3.1.2.1.2.1.

restrictpostmid_middle.3.1.2.1.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  EXISTS (i: {x: nat | mid < x AND x <= w!1}):
        public(u!1) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, i)))
[-2]  0 < i!1`1
[-3]  i!1`1 < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   i!1`1 = w!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2))) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  public(u!1) = public(hu(i!3))
{-2}  conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, i!3)))
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   i!1`1 = w!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2))) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  u!1 = hu(i!3)
[-2]  conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, i!3)))
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   i!1`1 = w!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2))) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  nlist(i!2`1) = nlist(append(nl1!1, cons(n_mid, nl2!1)))
{-2}  ilist(append(i!2`3, i!2`4)) = ilist(remove(hu_list, i!3))
[-3]  u!1 = hu(i!3)
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   i!1`1 = w!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2))) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-2]  ilist(append(i!2`3, i!2`4)) = ilist(remove(hu_list, i!3))
[-3]  u!1 = hu(i!3)
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   i!1`1 = w!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2))) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-2]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-3]  u!1 = hu(i!3)
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   i!1`1 = w!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2))) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (typepred "i!2`1" "i!2`3" "i!2`4" "nl1!1" "nl2!1"
                 "hu_list")
Adding type constraints for  i!2`1, i!2`3, i!2`4, nl1!1, nl2!1, hu_list,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`1)
{-2}  length(i!2`1) = i!1`1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`3)
{-4}  length(i!2`3) = i!1`1
{-5}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`4)
{-6}  length(i!2`4) = P!1 - 1 - i!1`1
{-7}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl1!1)
{-8}  length(nl1!1) = mid
{-9}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
{-10} length(nl2!1) = -1 - mid + i!3
{-11} every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-12} (length(hu_list) = p)
{-13} FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-14] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-15] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-16] u!1 = hu(i!3)
[-17] 0 < i!1`1
[-18] i!1`1 < P!1 - 1
[-19] 2 <= P!1
  |-------
[1]   i!1`1 = w!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2))) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete -1 -3 -5 -7 -9 -11 4 5)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  length(i!2`1) = i!1`1
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-9]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-10] u!1 = hu(i!3)
[-11] 0 < i!1`1
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
[1]   i!1`1 = w!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2))) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (case "P!1=p" "i!3=i!1`1")
Case splitting on 
   P!1 = p, 
   i!3 = i!1`1, 
this yields  3 subgoals: 
restrictpostmid_middle.3.1.2.1.2.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  i!3 = i!1`1
{-2}  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!3
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!3)
[-13] 0 < i!1`1
[-14] i!1`1 < P!1 - 1
[-15] 2 <= P!1
  |-------
[1]   i!1`1 = w!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2))) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (replace* -1 -2 -12)
Repeatedly applying the replace rule,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
{-5}  length(i!2`4) = p - 1 - i!1`1
[-6]  length(nl1!1) = mid
{-7}  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
{-10} append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
{-12} u!1 = hu(i!1`1)
[-13] 0 < i!1`1
{-14} i!1`1 < p - 1
{-15} 2 <= p
  |-------
{1}   i!1`1 = w!1 AND
       append(i!2`3, cons(hu(i!1`1), i!2`4)) = hu_list AND
        nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (p - 2))) = n_mid
{2}   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3,
                                         cons(hu(i!1`1), cdr(i!2`4)))))))
{3}   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (split)
Splitting conjunctions,
this yields  3 subgoals: 
restrictpostmid_middle.3.1.2.1.2.2.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = p - 1 - i!1`1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] 0 < i!1`1
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
{1}   i!1`1 = w!1
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3,
                                         cons(hu(i!1`1), cdr(i!2`4)))))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (expand "rho_postmid" 2)
Expanding the definition of rho_postmid,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = p - 1 - i!1`1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] 0 < i!1`1
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
[1]   i!1`1 = w!1
{2}   rho_postmid(w!1)
                 (conc(nlist(append(i!2`1, (: i!1`2 :))),
                       ilist(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))))))
       OR
       EXISTS (i: {x: nat | mid < x AND x <= w!1}):
         public(car(i!2`4)) = public(hu(i)) AND
          EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                  nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
            conc(nlist(append(i!2`1, (: i!1`2 :))),
                 ilist(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4)))))
             =
             conc(nlist(append(nl1, cons(n_mid, nl2))),
                  ilist(remove(hu_list, i)))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = p - 1 - i!1`1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] 0 < i!1`1
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
[1]   i!1`1 = w!1
{2}   rho_postmid(w!1)
                 (conc(nlist(append(i!2`1, (: i!1`2 :))),
                       ilist(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))))))
{3}   EXISTS (i: {x: nat | mid < x AND x <= w!1}):
        public(car(i!2`4)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, i)))
[4]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (delete 2 4)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = p - 1 - i!1`1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] 0 < i!1`1
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
[1]   i!1`1 = w!1
[2]   EXISTS (i: {x: nat | mid < x AND x <= w!1}):
        public(car(i!2`4)) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4)))))
            =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, i)))

Rerunning step: (inst 2 "i!1`1+1")
Instantiating the top quantifier in 2 with the terms: 
 i!1`1+1,
this yields  2 subgoals: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = p - 1 - i!1`1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] 0 < i!1`1
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
[1]   i!1`1 = w!1
{2}   public(car(i!2`4)) = public(hu(i!1`1 + 1)) AND
       EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
               nl2: {x: list[Nonce] | length(x) = i!1`1 - mid}):
         conc(nlist(append(i!2`1, (: i!1`2 :))),
              ilist(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4)))))
          =
          conc(nlist(append(nl1, cons(n_mid, nl2))),
               ilist(remove(hu_list, i!1`1 + 1)))

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = p - 1 - i!1`1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] 0 < i!1`1
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
{1}   public(car(i!2`4)) = public(hu(i!1`1 + 1))
[2]   i!1`1 = w!1

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
{-5}  length(i!2`4) = -1 - i!1`1 + p
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] 0 < i!1`1
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
{1}   car(i!2`4) = hu(1 + i!1`1)
[2]   i!1`1 = w!1

Rerunning step: (lemma "listprops[Identity].equality_nth"
                 ("l1" "append(i!2`3,i!2`4)" "l2"
                  "remove(hu_list,i!1`1)"))
Applying listprops[Identity].equality_nth where 
  l1 gets append(i!2`3, i!2`4),
  l2 gets remove(hu_list, i!1`1),
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  append(i!2`3, i!2`4) = remove(hu_list, i!1`1) IMPLIES
       FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
         nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`1) = i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -1 - mid + i!1`1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-12] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-13] u!1 = hu(i!1`1)
[-14] 0 < i!1`1
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)
[2]   i!1`1 = w!1

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`1) = i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -1 - mid + i!1`1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-12] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-13] u!1 = hu(i!1`1)
[-14] 0 < i!1`1
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)
[2]   i!1`1 = w!1

Rerunning step: (inst -1 "i!1`1")
Instantiating the top quantifier in -1 with the terms: 
 i!1`1,
this yields  2 subgoals: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  nth(append(i!2`3, i!2`4), i!1`1) = nth(remove(hu_list, i!1`1), i!1`1)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`1) = i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -1 - mid + i!1`1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-12] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-13] u!1 = hu(i!1`1)
[-14] 0 < i!1`1
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)
[2]   i!1`1 = w!1

Rerunning step: (rewrite "nth_append" -1)
Found matching substitution:
i: below[length(l1) + length(l2)] gets i!1`1,
l2: list[T] gets i!2`4,
l1: list[T] gets i!2`3,
Rewriting using nth_append, matching in -1,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  nth(i!2`4, i!1`1 - length[Identity](i!2`3)) =
       nth(remove(hu_list, i!1`1), i!1`1)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`1) = i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -1 - mid + i!1`1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-12] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-13] u!1 = hu(i!1`1)
[-14] 0 < i!1`1
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)
[2]   i!1`1 = w!1

Rerunning step: (rewrite "nth_remove" -1)
Found matching substitution:
j: below[length(l) - 1] gets i!1`1,
i: below[length(l)] gets i!1`1,
l: list[T] gets hu_list,
Rewriting using nth_remove, matching in -1,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  nth(i!2`4, i!1`1 - length[Identity](i!2`3)) = nth(hu_list, 1 + i!1`1)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`1) = i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -1 - mid + i!1`1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-12] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-13] u!1 = hu(i!1`1)
[-14] 0 < i!1`1
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)
[2]   i!1`1 = w!1

Rerunning step: (expand "nth" -1 1)
Expanding the definition of nth,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  car(i!2`4) = nth(hu_list, 1 + i!1`1)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`1) = i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -1 - mid + i!1`1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-12] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-13] u!1 = hu(i!1`1)
[-14] 0 < i!1`1
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)
[2]   i!1`1 = w!1

Rerunning step: (inst -10 "1+i!1`1")
Instantiating the top quantifier in -10 with the terms: 
 1+i!1`1,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  car(i!2`4) = nth(hu_list, 1 + i!1`1)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`1) = i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -1 - mid + i!1`1
[-9]  (length(hu_list) = p)
{-10} nth(hu_list, 1 + i!1`1) = hu(1 + i!1`1)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-12] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-13] u!1 = hu(i!1`1)
[-14] 0 < i!1`1
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)
[2]   i!1`1 = w!1

Rerunning step: (delete -2 -3
                  -4 -5
                  -6 -7
                  -8 -9
                  -11 -12
                  -13 -14
                  -15 -16
                  2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  car(i!2`4) = nth(hu_list, 1 + i!1`1)
[-2]  nth(hu_list, 1 + i!1`1) = hu(1 + i!1`1)
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.1.1.1.1.

restrictpostmid_middle.3.1.2.1.2.2.1.1.1.1.2 (TCC):   

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = -1 - i!1`1 + p
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] 0 < i!1`1
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
{1}   i!1`1 < length[Identity](append[Identity](i!2`3, i!2`4))
[2]   car(i!2`4) = hu(1 + i!1`1)
[3]   i!1`1 = w!1

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets i!2`4,
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in 1,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.1.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = -1 - i!1`1 + p
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] 0 < i!1`1
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
{1}   i!1`1 < length(i!2`3) + length(i!2`4)
[2]   car(i!2`4) = hu(1 + i!1`1)
[3]   i!1`1 = w!1

Rerunning step: (delete -1 -2 -3 -6 -7 -8 -9 -10 -11 -12 -13 -15 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.1.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  i!1`1 < p - 1
  |-------
[1]   i!1`1 < length(i!2`3) + length(i!2`4)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.1.1.1.2.


This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.1.1.1.

restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = p - 1 - i!1`1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] 0 < i!1`1
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
{1}   EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
              nl2: {x: list[Nonce] | length(x) = i!1`1 - mid}):
        conc(nlist(append(i!2`1, (: i!1`2 :))),
             ilist(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4)))))
         =
         conc(nlist(append(nl1, cons(n_mid, nl2))),
              ilist(remove(hu_list, i!1`1 + 1)))
[2]   i!1`1 = w!1

Rerunning step: (inst 1 "nl1!1" "append(nl2!1,(:i!1`2:))")
Instantiating the top quantifier in 1 with the terms: 
 nl1!1, append(nl2!1,(:i!1`2:)),
this yields  2 subgoals: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = p - 1 - i!1`1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] 0 < i!1`1
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
{1}   conc(nlist(append(i!2`1, (: i!1`2 :))),
           ilist(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4)))))
       =
       conc(nlist(append(nl1!1, cons(n_mid, append(nl2!1, (: i!1`2 :))))),
            ilist(remove(hu_list, i!1`1 + 1)))
[2]   i!1`1 = w!1

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this yields  2 subgoals: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
{-5}  length(i!2`4) = -1 - i!1`1 + p
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] 0 < i!1`1
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
{1}   nlist(append(i!2`1, (: i!1`2 :))) =
       nlist(append(nl1!1, cons(n_mid, append(nl2!1, (: i!1`2 :)))))
[2]   i!1`1 = w!1

Rerunning step: (replace -11 1)
Replacing using formula -11,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = -1 - i!1`1 + p
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] 0 < i!1`1
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
{1}   nlist(append(append(nl1!1, cons(n_mid, nl2!1)), (: i!1`2 :))) =
       nlist(append(nl1!1, cons(n_mid, append(nl2!1, (: i!1`2 :)))))
[2]   i!1`1 = w!1

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

  |-------
[1]   nlist(append(append(nl1!1, cons(n_mid, nl2!1)), (: i!1`2 :))) =
       nlist(append(nl1!1, cons(n_mid, append(nl2!1, (: i!1`2 :)))))

Rerunning step: (rewrite "append_assoc" 1)
Found matching substitution:
l3: list[T] gets (: i!1`2 :),
l2: list[T] gets cons(n_mid, nl2!1),
l1: list[T] gets nl1!1,
Rewriting using append_assoc, matching in 1,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

  |-------
{1}   nlist(append(nl1!1, append(cons(n_mid, nl2!1), (: i!1`2 :)))) =
       nlist(append(nl1!1, cons(n_mid, append(nl2!1, (: i!1`2 :)))))

Rerunning step: (expand "append" 1 2)
Expanding the definition of append,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.1.

restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
{-5}  length(i!2`4) = -1 - i!1`1 + p
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] 0 < i!1`1
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
{1}   ilist(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4)))) =
       ilist(remove(hu_list, 1 + i!1`1))
[2]   i!1`1 = w!1

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = -1 - i!1`1 + p
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] 0 < i!1`1
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
{1}   append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))) =
       remove(hu_list, 1 + i!1`1)
[2]   i!1`1 = w!1

Rerunning step: (rewrite "length_nth_equality[Identity]" 1)
Found matching substitution:
l2: list[Identity] gets remove(hu_list, 1 + i!1`1),
l1: list[Identity] gets append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))),
Rewriting using length_nth_equality[Identity], matching in 1,
this yields  2 subgoals: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = -1 - i!1`1 + p
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] 0 < i!1`1
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
{1}   length[Identity](append(i!2`3, cons(hu(i!1`1), cdr(i!2`4)))) =
       length[Identity](remove(hu_list, 1 + i!1`1))
[2]   append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))) =
       remove(hu_list, 1 + i!1`1)
[3]   i!1`1 = w!1

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets cons(hu(i!1`1), cdr(i!2`4)),
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in 1,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = -1 - i!1`1 + p
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] 0 < i!1`1
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
{1}   length(cons(hu(i!1`1), cdr(i!2`4))) + length(i!2`3) =
       length[Identity](remove(hu_list, 1 + i!1`1))
[2]   append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))) =
       remove(hu_list, 1 + i!1`1)
[3]   i!1`1 = w!1

Rerunning step: (expand "length" 1 1)
Expanding the definition of length,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = -1 - i!1`1 + p
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] 0 < i!1`1
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
{1}   1 + length[Identity](cdr(i!2`4)) + length(i!2`3) =
       length[Identity](remove(hu_list, 1 + i!1`1))
[2]   append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))) =
       remove(hu_list, 1 + i!1`1)
[3]   i!1`1 = w!1

Rerunning step: (rewrite "length_cdr" 1)
Found matching substitution:
cons_l: (cons?[T]) gets i!2`4,
Rewriting using length_cdr, matching in 1,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = -1 - i!1`1 + p
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] 0 < i!1`1
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
{1}   1 + (length(i!2`4) - 1) + length(i!2`3) =
       length[Identity](remove(hu_list, 1 + i!1`1))
[2]   append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))) =
       remove(hu_list, 1 + i!1`1)
[3]   i!1`1 = w!1

Rerunning step: (rewrite "length_remove" 1 :dir rl)
Found matching substitution:
i: below[length(c)] gets 1 + i!1`1,
c: (cons?[T]) gets hu_list,
Rewriting using length_remove, matching in 1,
this yields  2 subgoals: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = -1 - i!1`1 + p
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] 0 < i!1`1
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
{1}   1 + (length(i!2`4) - 1) + length(i!2`3) =
       length[Identity](hu_list) - 1
[2]   append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))) =
       remove(hu_list, 1 + i!1`1)
[3]   i!1`1 = w!1

Rerunning step: (delete -1 -2 -3 -6 -7 -9 -10 -11 -12 -13 -14 -15 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  (length(hu_list) = p)
  |-------
[1]   1 + (length(i!2`4) - 1) + length(i!2`3) =
       length[Identity](hu_list) - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.1.1.

restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.1.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = -1 - i!1`1 + p
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] 0 < i!1`1
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
{1}   cons?[Identity](hu_list)
{2}   length(i!2`3) + length(i!2`4) =
       length[Identity](remove(hu_list, 1 + i!1`1))
[3]   append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))) =
       remove(hu_list, 1 + i!1`1)
[4]   i!1`1 = w!1

Rerunning step: (delete -1 -3 -4 -5 -6 -7 -9 -10 -11 -12 -13 -14 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.1.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  P!1 = p
[-2]  (length(hu_list) = p)
[-3]  2 <= p
  |-------
[1]   cons?[Identity](hu_list)

Rerunning step: (nonemptylist "hu_list")
Relating existence of a tail to a list's length,

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.1.2.


This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.1.

restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = -1 - i!1`1 + p
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] 0 < i!1`1
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
{1}   FORALL (i:
                below[length[Identity]
                          (append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))))]):
        nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i) =
         nth(remove(hu_list, 1 + i!1`1), i)
[2]   append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))) =
       remove(hu_list, 1 + i!1`1)
[3]   i!1`1 = w!1

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  i!4 < length[Identity](append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))))
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`1) = i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -1 - mid + i!1`1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-12] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-13] u!1 = hu(i!1`1)
[-14] 0 < i!1`1
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
{1}   nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i!4) =
       nth(remove(hu_list, 1 + i!1`1), i!4)
[2]   append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))) =
       remove(hu_list, 1 + i!1`1)
[3]   i!1`1 = w!1

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets cons(hu(i!1`1), cdr(i!2`4)),
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  i!4 < length(cons(hu(i!1`1), cdr(i!2`4))) + length(i!2`3)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`1) = i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -1 - mid + i!1`1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-12] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-13] u!1 = hu(i!1`1)
[-14] 0 < i!1`1
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
[1]   nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i!4) =
       nth(remove(hu_list, 1 + i!1`1), i!4)
[2]   append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))) =
       remove(hu_list, 1 + i!1`1)
[3]   i!1`1 = w!1

Rerunning step: (expand "length" -1 1)
Expanding the definition of length,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  i!4 < 1 + length[Identity](cdr(i!2`4)) + length(i!2`3)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`1) = i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -1 - mid + i!1`1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-12] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-13] u!1 = hu(i!1`1)
[-14] 0 < i!1`1
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
[1]   nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i!4) =
       nth(remove(hu_list, 1 + i!1`1), i!4)
[2]   append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))) =
       remove(hu_list, 1 + i!1`1)
[3]   i!1`1 = w!1

Rerunning step: (rewrite "length_cdr" -1)
Found matching substitution:
cons_l: (cons?[T]) gets i!2`4,
Rewriting using length_cdr, matching in -1,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`1) = i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -1 - mid + i!1`1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-12] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-13] u!1 = hu(i!1`1)
[-14] 0 < i!1`1
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
[1]   nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i!4) =
       nth(remove(hu_list, 1 + i!1`1), i!4)
[2]   append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))) =
       remove(hu_list, 1 + i!1`1)
[3]   i!1`1 = w!1

Rerunning step: (simplify -1)
Simplifying with decision procedures,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  i!4 < length(i!2`3) + length(i!2`4)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`1) = i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -1 - mid + i!1`1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-12] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-13] u!1 = hu(i!1`1)
[-14] 0 < i!1`1
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
[1]   nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i!4) =
       nth(remove(hu_list, 1 + i!1`1), i!4)
[2]   append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))) =
       remove(hu_list, 1 + i!1`1)
[3]   i!1`1 = w!1

Rerunning step: (delete -4 -7 -8 -12 -13 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!4 < length(i!2`3) + length(i!2`4)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = -1 - i!1`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  0 < i!1`1
[-10] i!1`1 < p - 1
[-11] 2 <= p
  |-------
[1]   nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i!4) =
       nth(remove(hu_list, 1 + i!1`1), i!4)

Rerunning step: (lemma "listprops[Identity].equality_nth"
                 ("l1" "append(i!2`3,i!2`4)" "l2"
                  "remove(hu_list,i!1`1)"))
Applying listprops[Identity].equality_nth where 
  l1 gets append(i!2`3, i!2`4),
  l2 gets remove(hu_list, i!1`1),
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  append(i!2`3, i!2`4) = remove(hu_list, i!1`1) IMPLIES
       FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
         nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-2]  i!4 < length(i!2`3) + length(i!2`4)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] 0 < i!1`1
[-11] i!1`1 < p - 1
[-12] 2 <= p
  |-------
[1]   nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i!4) =
       nth(remove(hu_list, 1 + i!1`1), i!4)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-2]  i!4 < length(i!2`3) + length(i!2`4)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] 0 < i!1`1
[-11] i!1`1 < p - 1
[-12] 2 <= p
  |-------
[1]   nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i!4) =
       nth(remove(hu_list, 1 + i!1`1), i!4)

Rerunning step: (lemma "listprops[Identity].nth_append"
                 ("l1" "i!2`3" "l2" "cons(hu(i!1`1),cdr(i!2`4))" "i"
                  "i!4"))
Applying listprops[Identity].nth_append where 
  l1 gets i!2`3,
  l2 gets cons(hu(i!1`1), cdr(i!2`4)),
  i gets i!4,
this yields  2 subgoals: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i!4) =
       IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
       ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
       ENDIF
[-2]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-3]  i!4 < length(i!2`3) + length(i!2`4)
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = -1 - i!1`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] 0 < i!1`1
[-12] i!1`1 < p - 1
[-13] 2 <= p
  |-------
[1]   nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i!4) =
       nth(remove(hu_list, 1 + i!1`1), i!4)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i!4) =
       IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
       ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
       ENDIF
[-2]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-3]  i!4 < length(i!2`3) + length(i!2`4)
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = -1 - i!1`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] 0 < i!1`1
[-12] i!1`1 < p - 1
[-13] 2 <= p
  |-------
{1}   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, 1 + i!1`1), i!4)

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-2]  i!4 < length(i!2`3) + length(i!2`4)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] 0 < i!1`1
[-11] i!1`1 < p - 1
[-12] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, 1 + i!1`1), i!4)

Rerunning step: (lemma "listprops[Identity].nth_remove"
                 ("l" "hu_list" "i" "1+i!1`1" "j" "i!4"))
Applying listprops[Identity].nth_remove where 
  l gets hu_list,
  i gets 1 + i!1`1,
  j gets i!4,
this yields  2 subgoals: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  nth(remove(hu_list, 1 + i!1`1), i!4) =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF
[-2]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-3]  i!4 < length(i!2`3) + length(i!2`4)
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = -1 - i!1`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] 0 < i!1`1
[-12] i!1`1 < p - 1
[-13] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, 1 + i!1`1), i!4)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  nth(remove(hu_list, 1 + i!1`1), i!4) =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF
[-2]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-3]  i!4 < length(i!2`3) + length(i!2`4)
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = -1 - i!1`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] 0 < i!1`1
[-12] i!1`1 < p - 1
[-13] 2 <= p
  |-------
{1}   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-2]  i!4 < length(i!2`3) + length(i!2`4)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] 0 < i!1`1
[-11] i!1`1 < p - 1
[-12] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (inst -1 "i!4")
Instantiating the top quantifier in -1 with the terms: 
 i!4,
this yields  2 subgoals: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  nth(append(i!2`3, i!2`4), i!4) = nth(remove(hu_list, i!1`1), i!4)
[-2]  i!4 < length(i!2`3) + length(i!2`4)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] 0 < i!1`1
[-11] i!1`1 < p - 1
[-12] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (lemma "listprops[Identity].nth_append"
                 ("l1" "i!2`3" "l2" "i!2`4" "i" "i!4"))
Applying listprops[Identity].nth_append where 
  l1 gets i!2`3,
  l2 gets i!2`4,
  i gets i!4,
this yields  2 subgoals: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.1.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  nth(append(i!2`3, i!2`4), i!4) =
       IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
       ELSE nth(i!2`4, i!4 - length[Identity](i!2`3))
       ENDIF
[-2]  nth(append(i!2`3, i!2`4), i!4) = nth(remove(hu_list, i!1`1), i!4)
[-3]  i!4 < length(i!2`3) + length(i!2`4)
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = -1 - i!1`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] 0 < i!1`1
[-12] i!1`1 < p - 1
[-13] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (replace -1 -2)
Replacing using formula -1,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.1.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  nth(append(i!2`3, i!2`4), i!4) =
       IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
       ELSE nth(i!2`4, i!4 - length[Identity](i!2`3))
       ENDIF
{-2}  IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(i!2`4, i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, i!1`1), i!4)
[-3]  i!4 < length(i!2`3) + length(i!2`4)
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = -1 - i!1`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] 0 < i!1`1
[-12] i!1`1 < p - 1
[-13] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.1.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(i!2`4, i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, i!1`1), i!4)
[-2]  i!4 < length(i!2`3) + length(i!2`4)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] 0 < i!1`1
[-11] i!1`1 < p - 1
[-12] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (lemma "listprops[Identity].nth_remove"
                 ("l" "hu_list" "i" "i!1`1" "j" "i!4"))
Ignoring 1 repeated TCCs.
Applying listprops[Identity].nth_remove where 
  l gets hu_list,
  i gets i!1`1,
  j gets i!4,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.1.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  nth(remove(hu_list, i!1`1), i!4) =
       IF i!4 < i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF
[-2]  IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(i!2`4, i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, i!1`1), i!4)
[-3]  i!4 < length(i!2`3) + length(i!2`4)
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = -1 - i!1`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] 0 < i!1`1
[-12] i!1`1 < p - 1
[-13] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (replace -1 -2)
Replacing using formula -1,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.1.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  nth(remove(hu_list, i!1`1), i!4) =
       IF i!4 < i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF
{-2}  IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(i!2`4, i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF
[-3]  i!4 < length(i!2`3) + length(i!2`4)
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = -1 - i!1`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] 0 < i!1`1
[-12] i!1`1 < p - 1
[-13] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.1.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(i!2`4, i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF
[-2]  i!4 < length(i!2`3) + length(i!2`4)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] 0 < i!1`1
[-11] i!1`1 < p - 1
[-12] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (inst -8 "i!1`1")
Instantiating the top quantifier in -8 with the terms: 
 i!1`1,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.1.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(i!2`4, i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF
[-2]  i!4 < length(i!2`3) + length(i!2`4)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  (length(hu_list) = p)
{-8}  nth(hu_list, i!1`1) = hu(i!1`1)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] 0 < i!1`1
[-11] i!1`1 < p - 1
[-12] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (expand "nth" 1 2)
Expanding the definition of nth,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.1.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(i!2`4, i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF
[-2]  i!4 < length(i!2`3) + length(i!2`4)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  (length(hu_list) = p)
[-8]  nth(hu_list, i!1`1) = hu(i!1`1)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] 0 < i!1`1
[-11] i!1`1 < p - 1
[-12] 2 <= p
  |-------
{1}   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN hu(i!1`1)
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (expand "nth" -1 2)
Expanding the definition of nth,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.1.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN car(i!2`4)
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF
[-2]  i!4 < length(i!2`3) + length(i!2`4)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  (length(hu_list) = p)
[-8]  nth(hu_list, i!1`1) = hu(i!1`1)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] 0 < i!1`1
[-11] i!1`1 < p - 1
[-12] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN hu(i!1`1)
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (case "i!4<i!1`1 OR i!4=i!1`1 OR i!4>i!1`1")
Case splitting on 
   i!4 < i!1`1 OR i!4 = i!1`1 OR i!4 > i!1`1, 
this yields  2 subgoals: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.1.1.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  i!4 < i!1`1 OR i!4 = i!1`1 OR i!4 > i!1`1
[-2]  IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN car(i!2`4)
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF
[-3]  i!4 < length(i!2`3) + length(i!2`4)
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = -1 - i!1`1 + p
[-8]  (length(hu_list) = p)
[-9]  nth(hu_list, i!1`1) = hu(i!1`1)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] 0 < i!1`1
[-12] i!1`1 < p - 1
[-13] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN hu(i!1`1)
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.1.1.1.1.

restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.1.1.1.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN car(i!2`4)
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF
[-2]  i!4 < length(i!2`3) + length(i!2`4)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  (length(hu_list) = p)
[-8]  nth(hu_list, i!1`1) = hu(i!1`1)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] 0 < i!1`1
[-11] i!1`1 < p - 1
[-12] 2 <= p
  |-------
{1}   i!4 < i!1`1 OR i!4 = i!1`1 OR i!4 > i!1`1
[2]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN hu(i!1`1)
           ELSE nth(cdr(i!2`4), -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.1.1.1.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

  |-------
[1]   i!4 < i!1`1 OR i!4 = i!1`1 OR i!4 > i!1`1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.1.1.1.2.


This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.1.1.1.

restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.1.1.2T (TCC):   

[-1]  nth(append(i!2`3, i!2`4), i!4) = nth(remove(hu_list, i!1`1), i!4)
[-2]  i!4 < length(i!2`3) + length(i!2`4)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] 0 < i!1`1
[-11] i!1`1 < p - 1
[-12] 2 <= p
  |-------
{1}   i!4 < length[Identity](i!2`3) + length[Identity](i!2`4)
[2]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

which is trivially true.

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.1.1.2T.


This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.1.1.

restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.1.2 (TCC):   

[-1]  i!4 < length(i!2`3) + length(i!2`4)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = -1 - i!1`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  0 < i!1`1
[-10] i!1`1 < p - 1
[-11] 2 <= p
  |-------
{1}   i!4 < length[Identity](append[Identity](i!2`3, i!2`4))
[2]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < 1 + i!1`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets i!2`4,
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in 1,

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.1.2.


This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.1.

restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.2T (TCC):   

[-1]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-2]  i!4 < length(i!2`3) + length(i!2`4)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] 0 < i!1`1
[-11] i!1`1 < p - 1
[-12] 2 <= p
  |-------
{1}   i!4 < length[Identity](hu_list) - 1
[2]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, 1 + i!1`1), i!4)

Rerunning step: (delete -1 -3 -4 -8 -9 -10 -11 -12 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.2T : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!4 < length(i!2`3) + length(i!2`4)
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = -1 - i!1`1 + p
[-4]  (length(hu_list) = p)
  |-------
[1]   i!4 < length[Identity](hu_list) - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.2T.


This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.1.

restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.2T (TCC):   

[-1]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-2]  i!4 < length(i!2`3) + length(i!2`4)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] 0 < i!1`1
[-11] i!1`1 < p - 1
[-12] 2 <= p
  |-------
{1}   i!4 <
       length[Identity](cons[Identity](hu(i!1`1), cdr[Identity](i!2`4))) +
        length[Identity](i!2`3)
[2]   nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i!4) =
       nth(remove(hu_list, 1 + i!1`1), i!4)

Rerunning step: (expand "length" 1 1)
Expanding the definition of length,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.2T : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-2]  i!4 < length(i!2`3) + length(i!2`4)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] 0 < i!1`1
[-11] i!1`1 < p - 1
[-12] 2 <= p
  |-------
{1}   i!4 <
       1 + length[Identity](cdr[Identity](i!2`4)) + length[Identity](i!2`3)
[2]   nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i!4) =
       nth(remove(hu_list, 1 + i!1`1), i!4)

Rerunning step: (rewrite "length_cdr" 1)
Found matching substitution:
cons_l: (cons?[T]) gets i!2`4,
Rewriting using length_cdr, matching in 1,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.2T : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-2]  i!4 < length(i!2`3) + length(i!2`4)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] 0 < i!1`1
[-11] i!1`1 < p - 1
[-12] 2 <= p
  |-------
{1}   i!4 < 1 + (length(i!2`4) - 1) + length[Identity](i!2`3)
[2]   nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i!4) =
       nth(remove(hu_list, 1 + i!1`1), i!4)

Rerunning step: (delete -1 -3 -4 -5 -6 -7 -8 -9 -10 -11 -12 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.2T : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!4 < length(i!2`3) + length(i!2`4)
  |-------
[1]   i!4 < 1 + (length(i!2`4) - 1) + length[Identity](i!2`3)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.2T.


This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.2.


This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.2.


This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.1.

restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.2 (TCC):   

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = p - 1 - i!1`1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] 0 < i!1`1
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
{1}   length[Nonce](append[Nonce](nl2!1, (: i!1`2 :))) = i!1`1 - mid
[2]   i!1`1 = w!1

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets (: i!1`2 :),
l1: list[T] gets nl2!1,
Rewriting using length_append, matching in 1,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = p - 1 - i!1`1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] 0 < i!1`1
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
{1}   length((: i!1`2 :)) + length(nl2!1) = i!1`1 - mid
[2]   i!1`1 = w!1

Rerunning step: (delete -1 -2
                  -3 -4
                  -5 -6
                  -8 -9
                  -10 -11
                  -12 -13
                  -14 -15
                  2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  length(nl2!1) = -1 - mid + i!1`1
  |-------
[1]   length((: i!1`2 :)) + length(nl2!1) = i!1`1 - mid

Rerunning step: (grind)
length rewrites length[Identity]((: :))
  to 0
length rewrites length((: i!1`2 :))
  to 1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.2.


This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.1.1.2.


This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.1.1.

restrictpostmid_middle.3.1.2.1.2.2.1.1.2 (TCC):   

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = p - 1 - i!1`1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] 0 < i!1`1
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
{1}   mid < 1 + i!1`1 AND 1 + i!1`1 <= w!1
[2]   i!1`1 = w!1

Rerunning step: (typepred "i!3")
Adding type constraints for  i!3,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  mid < i!3
{-2}  i!3 <= w!1
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`1) = i!1`1
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = p - 1 - i!1`1
[-8]  length(nl1!1) = mid
[-9]  length(nl2!1) = -1 - mid + i!1`1
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-13] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-14] u!1 = hu(i!1`1)
[-15] 0 < i!1`1
[-16] i!1`1 < p - 1
[-17] 2 <= p
  |-------
[1]   mid < 1 + i!1`1 AND 1 + i!1`1 <= w!1
[2]   i!1`1 = w!1

Rerunning step: (delete -4 -5
                  -6 -7
                  -8 -9
                  -10 -11
                  -12 -13
                  -14 -15
                  -16 -17)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  mid < i!3
[-2]  i!3 <= w!1
[-3]  i!3 = i!1`1
  |-------
[1]   mid < 1 + i!1`1 AND 1 + i!1`1 <= w!1
[2]   i!1`1 = w!1

Rerunning step: (comment "this is why we needed 2")
Adding comment: this is why we needed 2
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.1.2 : 
;;; this is why we needed 2

[-1]  mid < i!3
[-2]  i!3 <= w!1
[-3]  i!3 = i!1`1
  |-------
[1]   mid < 1 + i!1`1 AND 1 + i!1`1 <= w!1
[2]   i!1`1 = w!1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.1.2.


This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.1.

restrictpostmid_middle.3.1.2.1.2.2.1.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = p - 1 - i!1`1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] 0 < i!1`1
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
{1}   append(i!2`3, cons(hu(i!1`1), i!2`4)) = hu_list
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3,
                                         cons(hu(i!1`1), cdr(i!2`4)))))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (delete -3 -6 -7 -11 -13 -14 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = p - 1 - i!1`1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  u!1 = hu(i!1`1)
[-9]  2 <= p
  |-------
[1]   append(i!2`3, cons(hu(i!1`1), i!2`4)) = hu_list

Rerunning step: (rewrite "length_nth_equality[Identity]" 1)
Found matching substitution:
l2: list[Identity] gets hu_list,
l1: list[Identity] gets append(i!2`3, cons(hu(i!1`1), i!2`4)),
Rewriting using length_nth_equality[Identity], matching in 1,
this yields  2 subgoals: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`3) = i!1`1
{-4}  length(i!2`4) = -1 - i!1`1 + p
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  u!1 = hu(i!1`1)
[-9]  2 <= p
  |-------
{1}   length[Identity](append(i!2`3, cons(hu(i!1`1), i!2`4))) =
       length[Identity](hu_list)
[2]   append(i!2`3, cons(hu(i!1`1), i!2`4)) = hu_list

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets cons(hu(i!1`1), i!2`4),
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in 1,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = -1 - i!1`1 + p
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  u!1 = hu(i!1`1)
[-9]  2 <= p
  |-------
{1}   length(cons(hu(i!1`1), i!2`4)) + length(i!2`3) =
       length[Identity](hu_list)
[2]   append(i!2`3, cons(hu(i!1`1), i!2`4)) = hu_list

Rerunning step: (expand "length" 1 1)
Expanding the definition of length,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = -1 - i!1`1 + p
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  u!1 = hu(i!1`1)
[-9]  2 <= p
  |-------
{1}   1 + length(i!2`3) + length[Identity](i!2`4) =
       length[Identity](hu_list)
[2]   append(i!2`3, cons(hu(i!1`1), i!2`4)) = hu_list

Rerunning step: (delete -1 -2 -6 -7 -8 -9 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  (length(hu_list) = p)
  |-------
[1]   1 + length(i!2`3) + length[Identity](i!2`4) =
       length[Identity](hu_list)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.2.1.

restrictpostmid_middle.3.1.2.1.2.2.1.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`3) = i!1`1
{-4}  length(i!2`4) = -1 - i!1`1 + p
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  u!1 = hu(i!1`1)
[-9]  2 <= p
  |-------
{1}   FORALL (i:
                below[length[Identity]
                          (append(i!2`3, cons(hu(i!1`1), i!2`4)))]):
        nth(append(i!2`3, cons(hu(i!1`1), i!2`4)), i) = nth(hu_list, i)
[2]   append(i!2`3, cons(hu(i!1`1), i!2`4)) = hu_list

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  i!4 < length[Identity](append(i!2`3, cons(hu(i!1`1), i!2`4)))
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = -1 - i!1`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  u!1 = hu(i!1`1)
[-10] 2 <= p
  |-------
{1}   nth(append(i!2`3, cons(hu(i!1`1), i!2`4)), i!4) = nth(hu_list, i!4)
[2]   append(i!2`3, cons(hu(i!1`1), i!2`4)) = hu_list

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets cons(hu(i!1`1), i!2`4),
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  i!4 < length(cons(hu(i!1`1), i!2`4)) + length(i!2`3)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = -1 - i!1`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  u!1 = hu(i!1`1)
[-10] 2 <= p
  |-------
[1]   nth(append(i!2`3, cons(hu(i!1`1), i!2`4)), i!4) = nth(hu_list, i!4)
[2]   append(i!2`3, cons(hu(i!1`1), i!2`4)) = hu_list

Rerunning step: (expand "length" -1 1)
Expanding the definition of length,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  i!4 < 1 + length(i!2`3) + length[Identity](i!2`4)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = -1 - i!1`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  u!1 = hu(i!1`1)
[-10] 2 <= p
  |-------
[1]   nth(append(i!2`3, cons(hu(i!1`1), i!2`4)), i!4) = nth(hu_list, i!4)
[2]   append(i!2`3, cons(hu(i!1`1), i!2`4)) = hu_list

Rerunning step: (lemma "listprops[Identity].nth_append"
                 ("l1" "i!2`3" "l2" "cons(hu(i!1`1),i!2`4)" "i" "i!4"))
Applying listprops[Identity].nth_append where 
  l1 gets i!2`3,
  l2 gets cons(hu(i!1`1), i!2`4),
  i gets i!4,
this yields  2 subgoals: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  nth(append(i!2`3, cons(hu(i!1`1), i!2`4)), i!4) =
       IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
       ELSE nth(cons(hu(i!1`1), i!2`4), i!4 - length[Identity](i!2`3))
       ENDIF
[-2]  i!4 < 1 + length(i!2`3) + length[Identity](i!2`4)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] u!1 = hu(i!1`1)
[-11] 2 <= p
  |-------
[1]   nth(append(i!2`3, cons(hu(i!1`1), i!2`4)), i!4) = nth(hu_list, i!4)
[2]   append(i!2`3, cons(hu(i!1`1), i!2`4)) = hu_list

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  nth(append(i!2`3, cons(hu(i!1`1), i!2`4)), i!4) =
       IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
       ELSE nth(cons(hu(i!1`1), i!2`4), i!4 - length[Identity](i!2`3))
       ENDIF
[-2]  i!4 < 1 + length(i!2`3) + length[Identity](i!2`4)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] u!1 = hu(i!1`1)
[-11] 2 <= p
  |-------
{1}   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), i!2`4), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(hu_list, i!4)
[2]   append(i!2`3, cons(hu(i!1`1), i!2`4)) = hu_list

Rerunning step: (delete -1 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!4 < 1 + length(i!2`3) + length[Identity](i!2`4)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = -1 - i!1`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  u!1 = hu(i!1`1)
[-10] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), i!2`4), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (lemma "listprops[Identity].equality_nth"
                 ("l1" "append(i!2`3,i!2`4)" "l2"
                  "remove(hu_list,i!1`1)"))
Applying listprops[Identity].equality_nth where 
  l1 gets append(i!2`3, i!2`4),
  l2 gets remove(hu_list, i!1`1),
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  append(i!2`3, i!2`4) = remove(hu_list, i!1`1) IMPLIES
       FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
         nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-2]  i!4 < 1 + length(i!2`3) + length[Identity](i!2`4)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] u!1 = hu(i!1`1)
[-11] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), i!2`4), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-2]  i!4 < 1 + length(i!2`3) + length[Identity](i!2`4)
[-3]  i!3 = i!1`1
[-4]  P!1 = p
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] u!1 = hu(i!1`1)
[-11] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), i!2`4), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (lemma "listprops[Identity].nth_append"
                 ("l1" "i!2`3" "l2" "i!2`4"))
Applying listprops[Identity].nth_append where 
  l1 gets i!2`3,
  l2 gets i!2`4,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < length[Identity](i!2`3) THEN nth(i!2`3, i)
         ELSE nth(i!2`4, i - length[Identity](i!2`3))
         ENDIF
[-2]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-3]  i!4 < 1 + length(i!2`3) + length[Identity](i!2`4)
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = -1 - i!1`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] u!1 = hu(i!1`1)
[-12] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), i!2`4), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (lemma "listprops[Identity].nth_remove"
                 ("l" "hu_list" "i" "i!1`1"))
Applying listprops[Identity].nth_remove where 
  l gets hu_list,
  i gets i!1`1,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!1`1), j) =
         IF j < i!1`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-2]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < length[Identity](i!2`3) THEN nth(i!2`3, i)
         ELSE nth(i!2`4, i - length[Identity](i!2`3))
         ENDIF
[-3]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-4]  i!4 < 1 + length(i!2`3) + length[Identity](i!2`4)
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  length(i!2`3) = i!1`1
[-8]  length(i!2`4) = -1 - i!1`1 + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-12] u!1 = hu(i!1`1)
[-13] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), i!2`4), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (inst -10 "i!1`1")
Instantiating the top quantifier in -10 with the terms: 
 i!1`1,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!1`1), j) =
         IF j < i!1`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-2]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < length[Identity](i!2`3) THEN nth(i!2`3, i)
         ELSE nth(i!2`4, i - length[Identity](i!2`3))
         ENDIF
[-3]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-4]  i!4 < 1 + length(i!2`3) + length[Identity](i!2`4)
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  length(i!2`3) = i!1`1
[-8]  length(i!2`4) = -1 - i!1`1 + p
[-9]  (length(hu_list) = p)
{-10} nth(hu_list, i!1`1) = hu(i!1`1)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-12] u!1 = hu(i!1`1)
[-13] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), i!2`4), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (replace -10 1 rl)
Replacing using formula -10,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!1`1), j) =
         IF j < i!1`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-2]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < length[Identity](i!2`3) THEN nth(i!2`3, i)
         ELSE nth(i!2`4, i - length[Identity](i!2`3))
         ENDIF
[-3]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-4]  i!4 < 1 + length(i!2`3) + length[Identity](i!2`4)
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  length(i!2`3) = i!1`1
[-8]  length(i!2`4) = -1 - i!1`1 + p
[-9]  (length(hu_list) = p)
[-10] nth(hu_list, i!1`1) = hu(i!1`1)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-12] u!1 = hu(i!1`1)
[-13] 2 <= p
  |-------
{1}   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(nth(hu_list, i!1`1), i!2`4),
               i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (expand "nth" 1 2)
Expanding the definition of nth,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!1`1), j) =
         IF j < i!1`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-2]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < length[Identity](i!2`3) THEN nth(i!2`3, i)
         ELSE nth(i!2`4, i - length[Identity](i!2`3))
         ENDIF
[-3]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-4]  i!4 < 1 + length(i!2`3) + length[Identity](i!2`4)
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  length(i!2`3) = i!1`1
[-8]  length(i!2`4) = -1 - i!1`1 + p
[-9]  (length(hu_list) = p)
[-10] nth(hu_list, i!1`1) = hu(i!1`1)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-12] u!1 = hu(i!1`1)
[-13] 2 <= p
  |-------
{1}   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN nth(hu_list, i!1`1)
           ELSE nth(i!2`4, -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (case "i!4<i!1`1 OR i!4=i!1`1 OR i!4>i!1`1")
Case splitting on 
   i!4 < i!1`1 OR i!4 = i!1`1 OR i!4 > i!1`1, 
this yields  2 subgoals: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  i!4 < i!1`1 OR i!4 = i!1`1 OR i!4 > i!1`1
[-2]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!1`1), j) =
         IF j < i!1`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-3]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < length[Identity](i!2`3) THEN nth(i!2`3, i)
         ELSE nth(i!2`4, i - length[Identity](i!2`3))
         ENDIF
[-4]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-5]  i!4 < 1 + length(i!2`3) + length[Identity](i!2`4)
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  length(i!2`3) = i!1`1
[-9]  length(i!2`4) = -1 - i!1`1 + p
[-10] (length(hu_list) = p)
[-11] nth(hu_list, i!1`1) = hu(i!1`1)
[-12] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-13] u!1 = hu(i!1`1)
[-14] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN nth(hu_list, i!1`1)
           ELSE nth(i!2`4, -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (replace* -8)
Repeatedly applying the replace rule,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!4 < i!1`1 OR i!4 = i!1`1 OR i!4 > i!1`1
[-2]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!1`1), j) =
         IF j < i!1`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
{-3}  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < i!1`1 THEN nth(i!2`3, i) ELSE nth(i!2`4, i - i!1`1) ENDIF
[-4]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
{-5}  i!4 < 1 + i!1`1 + length[Identity](i!2`4)
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  length(i!2`3) = i!1`1
[-9]  length(i!2`4) = -1 - i!1`1 + p
[-10] (length(hu_list) = p)
[-11] nth(hu_list, i!1`1) = hu(i!1`1)
[-12] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-13] u!1 = hu(i!1`1)
[-14] 2 <= p
  |-------
{1}   IF i!4 < i!1`1 THEN nth(i!2`3, i!4)
      ELSE IF i!4 - i!1`1 = 0 THEN nth(hu_list, i!1`1)
           ELSE nth(i!2`4, -1 - i!1`1 + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (split)
Splitting conjunctions,
this yields  3 subgoals: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  i!4 < i!1`1
[-2]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!1`1), j) =
         IF j < i!1`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-3]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < i!1`1 THEN nth(i!2`3, i) ELSE nth(i!2`4, i - i!1`1) ENDIF
[-4]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-5]  i!4 < 1 + i!1`1 + length[Identity](i!2`4)
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  length(i!2`3) = i!1`1
[-9]  length(i!2`4) = -1 - i!1`1 + p
[-10] (length(hu_list) = p)
[-11] nth(hu_list, i!1`1) = hu(i!1`1)
[-12] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-13] u!1 = hu(i!1`1)
[-14] 2 <= p
  |-------
[1]   IF i!4 < i!1`1 THEN nth(i!2`3, i!4)
      ELSE IF i!4 - i!1`1 = 0 THEN nth(hu_list, i!1`1)
           ELSE nth(i!2`4, -1 - i!1`1 + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (lazy-grind :exclude ("nth" "append" "remove"))
By skolemization, if-lifting, simplification and instantiation,

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.1.

restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  i!4 = i!1`1
[-2]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!1`1), j) =
         IF j < i!1`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-3]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < i!1`1 THEN nth(i!2`3, i) ELSE nth(i!2`4, i - i!1`1) ENDIF
[-4]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-5]  i!4 < 1 + i!1`1 + length[Identity](i!2`4)
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  length(i!2`3) = i!1`1
[-9]  length(i!2`4) = -1 - i!1`1 + p
[-10] (length(hu_list) = p)
[-11] nth(hu_list, i!1`1) = hu(i!1`1)
[-12] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-13] u!1 = hu(i!1`1)
[-14] 2 <= p
  |-------
[1]   IF i!4 < i!1`1 THEN nth(i!2`3, i!4)
      ELSE IF i!4 - i!1`1 = 0 THEN nth(hu_list, i!1`1)
           ELSE nth(i!2`4, -1 - i!1`1 + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (lazy-grind :exclude ("nth" "append" "remove"))
By skolemization, if-lifting, simplification and instantiation,

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.2.

restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.3 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  i!4 > i!1`1
[-2]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!1`1), j) =
         IF j < i!1`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-3]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < i!1`1 THEN nth(i!2`3, i) ELSE nth(i!2`4, i - i!1`1) ENDIF
[-4]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-5]  i!4 < 1 + i!1`1 + length[Identity](i!2`4)
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  length(i!2`3) = i!1`1
[-9]  length(i!2`4) = -1 - i!1`1 + p
[-10] (length(hu_list) = p)
[-11] nth(hu_list, i!1`1) = hu(i!1`1)
[-12] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-13] u!1 = hu(i!1`1)
[-14] 2 <= p
  |-------
[1]   IF i!4 < i!1`1 THEN nth(i!2`3, i!4)
      ELSE IF i!4 - i!1`1 = 0 THEN nth(hu_list, i!1`1)
           ELSE nth(i!2`4, -1 - i!1`1 + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (case "0<=i!4-1 AND i!4-1<p-1")
Case splitting on 
   0 <= i!4 - 1 AND i!4 - 1 < p - 1, 
this yields  2 subgoals: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.3.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  0 <= i!4 - 1 AND i!4 - 1 < p - 1
[-2]  i!4 > i!1`1
[-3]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!1`1), j) =
         IF j < i!1`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-4]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < i!1`1 THEN nth(i!2`3, i) ELSE nth(i!2`4, i - i!1`1) ENDIF
[-5]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-6]  i!4 < 1 + i!1`1 + length[Identity](i!2`4)
[-7]  i!3 = i!1`1
[-8]  P!1 = p
[-9]  length(i!2`3) = i!1`1
[-10] length(i!2`4) = -1 - i!1`1 + p
[-11] (length(hu_list) = p)
[-12] nth(hu_list, i!1`1) = hu(i!1`1)
[-13] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-14] u!1 = hu(i!1`1)
[-15] 2 <= p
  |-------
[1]   IF i!4 < i!1`1 THEN nth(i!2`3, i!4)
      ELSE IF i!4 - i!1`1 = 0 THEN nth(hu_list, i!1`1)
           ELSE nth(i!2`4, -1 - i!1`1 + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (inst -3 "i!4-1")
Instantiating the top quantifier in -3 with the terms: 
 i!4-1,
this yields  2 subgoals: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.3.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  0 <= i!4 - 1 AND i!4 - 1 < p - 1
[-2]  i!4 > i!1`1
{-3}  nth(remove(hu_list, i!1`1), i!4 - 1) =
       IF i!4 - 1 < i!1`1 THEN nth(hu_list, i!4 - 1)
       ELSE nth(hu_list, i!4 - 1 + 1)
       ENDIF
[-4]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < i!1`1 THEN nth(i!2`3, i) ELSE nth(i!2`4, i - i!1`1) ENDIF
[-5]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-6]  i!4 < 1 + i!1`1 + length[Identity](i!2`4)
[-7]  i!3 = i!1`1
[-8]  P!1 = p
[-9]  length(i!2`3) = i!1`1
[-10] length(i!2`4) = -1 - i!1`1 + p
[-11] (length(hu_list) = p)
[-12] nth(hu_list, i!1`1) = hu(i!1`1)
[-13] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-14] u!1 = hu(i!1`1)
[-15] 2 <= p
  |-------
[1]   IF i!4 < i!1`1 THEN nth(i!2`3, i!4)
      ELSE IF i!4 - i!1`1 = 0 THEN nth(hu_list, i!1`1)
           ELSE nth(i!2`4, -1 - i!1`1 + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (inst -4 "i!4-1")
Instantiating the top quantifier in -4 with the terms: 
 i!4-1,
this yields  2 subgoals: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.3.1.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  0 <= i!4 - 1 AND i!4 - 1 < p - 1
[-2]  i!4 > i!1`1
[-3]  nth(remove(hu_list, i!1`1), i!4 - 1) =
       IF i!4 - 1 < i!1`1 THEN nth(hu_list, i!4 - 1)
       ELSE nth(hu_list, i!4 - 1 + 1)
       ENDIF
{-4}  nth(append(i!2`3, i!2`4), i!4 - 1) =
       IF i!4 - 1 < i!1`1 THEN nth(i!2`3, i!4 - 1)
       ELSE nth(i!2`4, i!4 - 1 - i!1`1)
       ENDIF
[-5]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-6]  i!4 < 1 + i!1`1 + length[Identity](i!2`4)
[-7]  i!3 = i!1`1
[-8]  P!1 = p
[-9]  length(i!2`3) = i!1`1
[-10] length(i!2`4) = -1 - i!1`1 + p
[-11] (length(hu_list) = p)
[-12] nth(hu_list, i!1`1) = hu(i!1`1)
[-13] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-14] u!1 = hu(i!1`1)
[-15] 2 <= p
  |-------
[1]   IF i!4 < i!1`1 THEN nth(i!2`3, i!4)
      ELSE IF i!4 - i!1`1 = 0 THEN nth(hu_list, i!1`1)
           ELSE nth(i!2`4, -1 - i!1`1 + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (inst -5 "i!4-1")
Instantiating the top quantifier in -5 with the terms: 
 i!4-1,
this yields  2 subgoals: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.3.1.1.1.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  0 <= i!4 - 1 AND i!4 - 1 < p - 1
[-2]  i!4 > i!1`1
[-3]  nth(remove(hu_list, i!1`1), i!4 - 1) =
       IF i!4 - 1 < i!1`1 THEN nth(hu_list, i!4 - 1)
       ELSE nth(hu_list, i!4 - 1 + 1)
       ENDIF
[-4]  nth(append(i!2`3, i!2`4), i!4 - 1) =
       IF i!4 - 1 < i!1`1 THEN nth(i!2`3, i!4 - 1)
       ELSE nth(i!2`4, i!4 - 1 - i!1`1)
       ENDIF
{-5}  nth(append(i!2`3, i!2`4), i!4 - 1) =
       nth(remove(hu_list, i!1`1), i!4 - 1)
[-6]  i!4 < 1 + i!1`1 + length[Identity](i!2`4)
[-7]  i!3 = i!1`1
[-8]  P!1 = p
[-9]  length(i!2`3) = i!1`1
[-10] length(i!2`4) = -1 - i!1`1 + p
[-11] (length(hu_list) = p)
[-12] nth(hu_list, i!1`1) = hu(i!1`1)
[-13] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-14] u!1 = hu(i!1`1)
[-15] 2 <= p
  |-------
[1]   IF i!4 < i!1`1 THEN nth(i!2`3, i!4)
      ELSE IF i!4 - i!1`1 = 0 THEN nth(hu_list, i!1`1)
           ELSE nth(i!2`4, -1 - i!1`1 + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.3.1.1.1.1.

restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.3.1.1.1.2 (TCC):   

[-1]  0 <= i!4 - 1 AND i!4 - 1 < p - 1
[-2]  i!4 > i!1`1
[-3]  nth(remove(hu_list, i!1`1), i!4 - 1) =
       IF i!4 - 1 < i!1`1 THEN nth(hu_list, i!4 - 1)
       ELSE nth(hu_list, i!4 - 1 + 1)
       ENDIF
[-4]  nth(append(i!2`3, i!2`4), i!4 - 1) =
       IF i!4 - 1 < i!1`1 THEN nth(i!2`3, i!4 - 1)
       ELSE nth(i!2`4, i!4 - 1 - i!1`1)
       ENDIF
[-5]  i!4 < 1 + i!1`1 + length[Identity](i!2`4)
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  length(i!2`3) = i!1`1
[-9]  length(i!2`4) = -1 - i!1`1 + p
[-10] (length(hu_list) = p)
[-11] nth(hu_list, i!1`1) = hu(i!1`1)
[-12] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-13] u!1 = hu(i!1`1)
[-14] 2 <= p
  |-------
{1}   i!4 - 1 >= 0
[2]   IF i!4 < i!1`1 THEN nth(i!2`3, i!4)
      ELSE IF i!4 - i!1`1 = 0 THEN nth(hu_list, i!1`1)
           ELSE nth(i!2`4, -1 - i!1`1 + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (delete -2 -3 -4 -5 -6 -7 -8 -9 -10 -11 -12 -13 -14 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.3.1.1.1.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  0 <= i!4 - 1 AND i!4 - 1 < p - 1
  |-------
[1]   i!4 - 1 >= 0

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.3.1.1.1.2.


This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.3.1.1.1.

restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.3.1.1.2 (TCC):   

[-1]  0 <= i!4 - 1 AND i!4 - 1 < p - 1
[-2]  i!4 > i!1`1
[-3]  nth(remove(hu_list, i!1`1), i!4 - 1) =
       IF i!4 - 1 < i!1`1 THEN nth(hu_list, i!4 - 1)
       ELSE nth(hu_list, i!4 - 1 + 1)
       ENDIF
[-4]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-5]  i!4 < 1 + i!1`1 + length[Identity](i!2`4)
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  length(i!2`3) = i!1`1
[-9]  length(i!2`4) = -1 - i!1`1 + p
[-10] (length(hu_list) = p)
[-11] nth(hu_list, i!1`1) = hu(i!1`1)
[-12] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-13] u!1 = hu(i!1`1)
[-14] 2 <= p
  |-------
{1}   i!4 - 1 >= 0 AND
       i!4 - 1 < length[Identity](i!2`3) + length[Identity](i!2`4)
[2]   IF i!4 < i!1`1 THEN nth(i!2`3, i!4)
      ELSE IF i!4 - i!1`1 = 0 THEN nth(hu_list, i!1`1)
           ELSE nth(i!2`4, -1 - i!1`1 + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (delete -2 -3 -4 -6 -7 -9 -10 -11 -12 -13 -14 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.3.1.1.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  0 <= i!4 - 1 AND i!4 - 1 < p - 1
[-2]  i!4 < 1 + i!1`1 + length[Identity](i!2`4)
[-3]  length(i!2`3) = i!1`1
  |-------
[1]   i!4 - 1 >= 0 AND
       i!4 - 1 < length[Identity](i!2`3) + length[Identity](i!2`4)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.3.1.1.2.


This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.3.1.1.

restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.3.1.2 (TCC):   

[-1]  0 <= i!4 - 1 AND i!4 - 1 < p - 1
[-2]  i!4 > i!1`1
[-3]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < i!1`1 THEN nth(i!2`3, i) ELSE nth(i!2`4, i - i!1`1) ENDIF
[-4]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-5]  i!4 < 1 + i!1`1 + length[Identity](i!2`4)
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  length(i!2`3) = i!1`1
[-9]  length(i!2`4) = -1 - i!1`1 + p
[-10] (length(hu_list) = p)
[-11] nth(hu_list, i!1`1) = hu(i!1`1)
[-12] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-13] u!1 = hu(i!1`1)
[-14] 2 <= p
  |-------
{1}   i!4 - 1 >= 0 AND i!4 - 1 < length[Identity](hu_list) - 1
[2]   IF i!4 < i!1`1 THEN nth(i!2`3, i!4)
      ELSE IF i!4 - i!1`1 = 0 THEN nth(hu_list, i!1`1)
           ELSE nth(i!2`4, -1 - i!1`1 + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (delete -2 -3 -4 -6 -7 -8 -11 -12 -13 -14 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.3.1.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  0 <= i!4 - 1 AND i!4 - 1 < p - 1
[-2]  i!4 < 1 + i!1`1 + length[Identity](i!2`4)
[-3]  length(i!2`4) = -1 - i!1`1 + p
[-4]  (length(hu_list) = p)
  |-------
[1]   i!4 - 1 >= 0 AND i!4 - 1 < length[Identity](hu_list) - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.3.1.2.


This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.3.1.

restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.3.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!4 > i!1`1
[-2]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!1`1), j) =
         IF j < i!1`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-3]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < i!1`1 THEN nth(i!2`3, i) ELSE nth(i!2`4, i - i!1`1) ENDIF
[-4]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-5]  i!4 < 1 + i!1`1 + length[Identity](i!2`4)
[-6]  i!3 = i!1`1
[-7]  P!1 = p
[-8]  length(i!2`3) = i!1`1
[-9]  length(i!2`4) = -1 - i!1`1 + p
[-10] (length(hu_list) = p)
[-11] nth(hu_list, i!1`1) = hu(i!1`1)
[-12] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-13] u!1 = hu(i!1`1)
[-14] 2 <= p
  |-------
{1}   0 <= i!4 - 1 AND i!4 - 1 < p - 1
[2]   IF i!4 < i!1`1 THEN nth(i!2`3, i!4)
      ELSE IF i!4 - i!1`1 = 0 THEN nth(hu_list, i!1`1)
           ELSE nth(i!2`4, -1 - i!1`1 + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (delete -2 -3 -4 -6 -7 -10 -11 -12 -13 -14 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.3.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!4 > i!1`1
[-2]  i!4 < 1 + i!1`1 + length[Identity](i!2`4)
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = -1 - i!1`1 + p
  |-------
[1]   0 <= i!4 - 1 AND i!4 - 1 < p - 1

Rerunning step: (typepred "i!1`1")
Adding type constraints for  i!1`1,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.3.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  0 < i!1`1
{-2}  i!1`1 < P!1 - 1
[-3]  i!4 > i!1`1
[-4]  i!4 < 1 + i!1`1 + length[Identity](i!2`4)
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
  |-------
[1]   0 <= i!4 - 1 AND i!4 - 1 < p - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.3.2.


This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.3.


This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.1.

restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!1`1), j) =
         IF j < i!1`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-2]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < length[Identity](i!2`3) THEN nth(i!2`3, i)
         ELSE nth(i!2`4, i - length[Identity](i!2`3))
         ENDIF
[-3]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-4]  i!4 < 1 + length(i!2`3) + length[Identity](i!2`4)
[-5]  i!3 = i!1`1
[-6]  P!1 = p
[-7]  length(i!2`3) = i!1`1
[-8]  length(i!2`4) = -1 - i!1`1 + p
[-9]  (length(hu_list) = p)
[-10] nth(hu_list, i!1`1) = hu(i!1`1)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-12] u!1 = hu(i!1`1)
[-13] 2 <= p
  |-------
{1}   i!4 < i!1`1 OR i!4 = i!1`1 OR i!4 > i!1`1
[2]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE IF i!4 - length[Identity](i!2`3) = 0 THEN nth(hu_list, i!1`1)
           ELSE nth(i!2`4, -1 - length[Identity](i!2`3) + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

  |-------
[1]   i!4 < i!1`1 OR i!4 = i!1`1 OR i!4 > i!1`1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.2.


This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.2.2.1.

restrictpostmid_middle.3.1.2.1.2.2.1.2.2.2T (TCC):   

[-1]  i!4 < 1 + length(i!2`3) + length[Identity](i!2`4)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = -1 - i!1`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  u!1 = hu(i!1`1)
[-10] 2 <= p
  |-------
{1}   i!4 <
       length[Identity](cons[Identity](hu(i!1`1), i!2`4)) +
        length[Identity](i!2`3)
[2]   nth(append(i!2`3, cons(hu(i!1`1), i!2`4)), i!4) = nth(hu_list, i!4)
[3]   append(i!2`3, cons(hu(i!1`1), i!2`4)) = hu_list

Rerunning step: (expand "length" 1 1)
Expanding the definition of length,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.2.2.2T : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!4 < 1 + length(i!2`3) + length[Identity](i!2`4)
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = -1 - i!1`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  u!1 = hu(i!1`1)
[-10] 2 <= p
  |-------
{1}   i!4 < 1 + length[Identity](i!2`3) + length[Identity](i!2`4)
[2]   nth(append(i!2`3, cons(hu(i!1`1), i!2`4)), i!4) = nth(hu_list, i!4)
[3]   append(i!2`3, cons(hu(i!1`1), i!2`4)) = hu_list

which is trivially true.

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.2.2.2T.


This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.2.2.


This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.2.

restrictpostmid_middle.3.1.2.1.2.2.1.3 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = p - 1 - i!1`1
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -1 - mid + i!1`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(i!1`1)
[-13] 0 < i!1`1
[-14] i!1`1 < p - 1
[-15] 2 <= p
  |-------
{1}   nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (p - 2))) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3,
                                         cons(hu(i!1`1), cdr(i!2`4)))))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (lemma "select_right_nonce2" ("P" "P!1"))
Applying select_right_nonce2 where 
  P gets P!1,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.3 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  (P!1 = p IMPLIES floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid)
       AND
       floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1 AND
        floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-2]  i!3 = i!1`1
[-3]  P!1 = p
[-4]  length(i!2`1) = i!1`1
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = p - 1 - i!1`1
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -1 - mid + i!1`1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-12] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-13] u!1 = hu(i!1`1)
[-14] 0 < i!1`1
[-15] i!1`1 < p - 1
[-16] 2 <= p
  |-------
[1]   nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (p - 2))) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3,
                                         cons(hu(i!1`1), cdr(i!2`4)))))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.3 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) = mid
{-2}  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
{-3}  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`1) = i!1`1
[-7]  length(i!2`3) = i!1`1
[-8]  length(i!2`4) = p - 1 - i!1`1
[-9]  length(nl1!1) = mid
[-10] length(nl2!1) = -1 - mid + i!1`1
[-11] (length(hu_list) = p)
[-12] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-13] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-14] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-15] u!1 = hu(i!1`1)
[-16] 0 < i!1`1
[-17] i!1`1 < p - 1
[-18] 2 <= p
  |-------
[1]   nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (p - 2))) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3,
                                         cons(hu(i!1`1), cdr(i!2`4)))))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (replace -5 -1)
Replacing using formula -5,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.3 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  floor(((mid - 1) / (p - 2)) * (p - 2) + 1) = mid
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`1) = i!1`1
[-7]  length(i!2`3) = i!1`1
[-8]  length(i!2`4) = p - 1 - i!1`1
[-9]  length(nl1!1) = mid
[-10] length(nl2!1) = -1 - mid + i!1`1
[-11] (length(hu_list) = p)
[-12] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-13] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-14] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-15] u!1 = hu(i!1`1)
[-16] 0 < i!1`1
[-17] i!1`1 < p - 1
[-18] 2 <= p
  |-------
[1]   nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (p - 2))) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3,
                                         cons(hu(i!1`1), cdr(i!2`4)))))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.3 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  floor(((mid - 1) / (p - 2)) * (p - 2) + 1) = mid
[-2]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) >= 1
[-3]  floor(((mid - 1) / (p - 2)) * (P!1 - 2) + 1) < P!1 - 1
[-4]  i!3 = i!1`1
[-5]  P!1 = p
[-6]  length(i!2`1) = i!1`1
[-7]  length(i!2`3) = i!1`1
[-8]  length(i!2`4) = p - 1 - i!1`1
[-9]  length(nl1!1) = mid
[-10] length(nl2!1) = -1 - mid + i!1`1
[-11] (length(hu_list) = p)
[-12] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-13] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-14] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-15] u!1 = hu(i!1`1)
[-16] 0 < i!1`1
[-17] i!1`1 < p - 1
[-18] 2 <= p
  |-------
{1}   nth(i!2`1, mid) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3,
                                         cons(hu(i!1`1), cdr(i!2`4)))))))
[3]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * p)

Rerunning step: (delete -1 -2
                  -3 -4
                  -5 -6
                  -7 -8
                  -10 -11
                  -12 -13
                  -15 -16
                  -17 -18
                  2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.3 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  length(nl1!1) = mid
[-2]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
  |-------
[1]   nth(i!2`1, mid) = n_mid

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.3 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  length(nl1!1) = mid
[-2]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
  |-------
{1}   nth(append(nl1!1, cons(n_mid, nl2!1)), mid) = n_mid

Rerunning step: (rewrite "nth_append" 1)
Found matching substitution:
i: below[length(l1) + length(l2)] gets mid,
l2: list[T] gets cons(n_mid, nl2!1),
l1: list[T] gets nl1!1,
Rewriting using nth_append, matching in 1,
this yields  2 subgoals: 
restrictpostmid_middle.3.1.2.1.2.2.1.3.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  length(nl1!1) = mid
[-2]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
  |-------
{1}   nth(cons(n_mid, nl2!1), mid - length[Identity](nl1!1)) = n_mid

Rerunning step: (expand "nth" 1)
Expanding the definition of nth,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.3.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  length(nl1!1) = mid
[-2]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.3.1.

restrictpostmid_middle.3.1.2.1.2.2.1.3.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  length(nl1!1) = mid
[-2]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
  |-------
{1}   mid <
       length[Identity](cons[Nonce](n_mid, nl2!1)) + length[Identity](nl1!1)
[2]   nth(append(nl1!1, cons(n_mid, nl2!1)), mid) = n_mid

Rerunning step: (expand "length" 1 1)
Expanding the definition of length,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.3.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  length(nl1!1) = mid
[-2]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
  |-------
{1}   mid < 1 + length[Identity](nl1!1) + length[Identity](nl2!1)
[2]   nth(append(nl1!1, cons(n_mid, nl2!1)), mid) = n_mid

Rerunning step: (delete -2 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.1.3.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  length(nl1!1) = mid
  |-------
[1]   mid < 1 + length[Identity](nl1!1) + length[Identity](nl2!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.3.2.


This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.3.


This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.1.

restrictpostmid_middle.3.1.2.1.2.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  P!1 = p
[-2]  length(i!2`1) = i!1`1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  length(nl1!1) = mid
[-6]  length(nl2!1) = -1 - mid + i!3
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(i!3)
[-12] 0 < i!1`1
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
{1}   i!3 = i!1`1
[2]   i!1`1 = w!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2))) = n_mid
[3]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[4]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (replace -10 -2)
Replacing using formula -10,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  P!1 = p
{-2}  length(append(nl1!1, cons(n_mid, nl2!1))) = i!1`1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  length(nl1!1) = mid
[-6]  length(nl2!1) = -1 - mid + i!3
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(i!3)
[-12] 0 < i!1`1
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
[1]   i!3 = i!1`1
[2]   i!1`1 = w!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2))) = n_mid
[3]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[4]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (rewrite "length_append" -2)
Found matching substitution:
l2: list[T] gets cons(n_mid, nl2!1),
l1: list[T] gets nl1!1,
Rewriting using length_append, matching in -2,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  P!1 = p
{-2}  length(cons(n_mid, nl2!1)) + length(nl1!1) = i!1`1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  length(nl1!1) = mid
[-6]  length(nl2!1) = -1 - mid + i!3
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(i!3)
[-12] 0 < i!1`1
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
[1]   i!3 = i!1`1
[2]   i!1`1 = w!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2))) = n_mid
[3]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[4]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (expand "length" -2 1)
Expanding the definition of length,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  P!1 = p
{-2}  1 + length(nl1!1) + length[Identity](nl2!1) = i!1`1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  length(nl1!1) = mid
[-6]  length(nl2!1) = -1 - mid + i!3
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(i!3)
[-12] 0 < i!1`1
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
[1]   i!3 = i!1`1
[2]   i!1`1 = w!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2))) = n_mid
[3]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[4]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (delete -1 -3 -4 -7 -8 -9 -10 -11 -12 -13 -14 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  1 + length(nl1!1) + length[Identity](nl2!1) = i!1`1
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
  |-------
[1]   i!3 = i!1`1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.2.

restrictpostmid_middle.3.1.2.1.2.2.3 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  length(i!2`1) = i!1`1
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + i!3
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-9]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-10] u!1 = hu(i!3)
[-11] 0 < i!1`1
[-12] i!1`1 < P!1 - 1
[-13] 2 <= P!1
  |-------
{1}   P!1 = p
[2]   i!1`1 = w!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2))) = n_mid
[3]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[4]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (lemma "listprops[Identity].equality_length"
                 ("l1" "append(i!2`3,i!2`4)" "l2"
                  "remove(hu_list,i!3)"))
Applying listprops[Identity].equality_length where 
  l1 gets append(i!2`3, i!2`4),
  l2 gets remove(hu_list, i!3),
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.3 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  append(i!2`3, i!2`4) = remove(hu_list, i!3) IMPLIES
       length[Identity](append(i!2`3, i!2`4)) =
        length[Identity](remove(hu_list, i!3))
[-2]  length(i!2`1) = i!1`1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  length(nl1!1) = mid
[-6]  length(nl2!1) = -1 - mid + i!3
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(i!3)
[-12] 0 < i!1`1
[-13] i!1`1 < P!1 - 1
[-14] 2 <= P!1
  |-------
[1]   P!1 = p
[2]   i!1`1 = w!1 AND
       append(i!2`3, cons(u!1, i!2`4)) = hu_list AND
        nth(i!2`1, floor(1 + ((mid - 1) / (p - 2)) * (P!1 - 2))) = n_mid
[3]   rho_postmid(w!1)
                 (code(public(car(i!2`4)),
                       conc(nlist(append(i!2`1, (: i!1`2 :))),
                            ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[4]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (delete -2 -5 -6 -8 -10 -11 -12 -13 14 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.3 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  append(i!2`3, i!2`4) = remove(hu_list, i!3) IMPLIES
       length[Identity](append(i!2`3, i!2`4)) =
        length[Identity](remove(hu_list, i!3))
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  (length(hu_list) = p)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-6]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.3 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  length[Identity](append(i!2`3, i!2`4)) =
       length[Identity](remove(hu_list, i!3))
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  (length(hu_list) = p)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-6]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets i!2`4,
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.3 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  length(i!2`3) + length(i!2`4) = length[Identity](remove(hu_list, i!3))
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  (length(hu_list) = p)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-6]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (rewrite "length_remove" -1 :dir rl)
Found matching substitution:
i: below[length(c)] gets i!3,
c: (cons?[T]) gets hu_list,
Rewriting using length_remove, matching in -1,
this yields  2 subgoals: 
restrictpostmid_middle.3.1.2.1.2.2.3.1 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  length(i!2`3) + length(i!2`4) = length[Identity](hu_list) - 1
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  (length(hu_list) = p)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-6]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.3.1.

restrictpostmid_middle.3.1.2.1.2.2.3.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  length(i!2`3) + length(i!2`4) = length[Identity](remove(hu_list, i!3))
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  (length(hu_list) = p)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-6]  2 <= P!1
  |-------
{1}   cons?[Identity](hu_list)
[2]   P!1 = p

Rerunning step: (typepred "p")
Adding type constraints for  p,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.3.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

{-1}  3 <= p
[-2]  length(i!2`3) + length(i!2`4) = length[Identity](remove(hu_list, i!3))
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  (length(hu_list) = p)
[-6]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-7]  2 <= P!1
  |-------
[1]   cons?[Identity](hu_list)
[2]   P!1 = p

Rerunning step: (delete -2 -3 -4 -6 -7 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.1.2.2.3.2 : 
;;; first, distinguish between the two separate cases that would make -1 true

[-1]  3 <= p
[-2]  (length(hu_list) = p)
  |-------
[1]   cons?[Identity](hu_list)

Rerunning step: (nonemptylist "hu_list")
Relating existence of a tail to a list's length,

This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.3.2.


This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.3.


This completes the proof of restrictpostmid_middle.3.1.2.1.2.2.


This completes the proof of restrictpostmid_middle.3.1.2.1.2.


This completes the proof of restrictpostmid_middle.3.1.2.1.

restrictpostmid_middle.3.1.2.2 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
{1}   ((rec(u!1, nth(i!2`3, i!1`1 - 1),
            E(public(u!1),
              conc(ilist(append(i!2`3, i!2`4)),
                   nlist(cons(i!1`2, i!2`2)))))
         >>
         ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
           Stop[event]))
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
{2}   R_postmid(w!1)
               (trans(u!1, car(i!2`4),
                      E(public(car(i!2`4)),
                        conc(nlist(append(i!2`1, (: i!1`2 :))),
                             ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))))
{3}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(nlist(append(i!2`1, (: i!1`2 :))),
                   ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
       >>
       ((rec(u!1, nth(i!2`3, i!1`1 - 1),
             E(public(u!1),
               conc(ilist(append(i!2`3, i!2`4)),
                    nlist(cons(i!1`2, i!2`2)))))
          >>
          ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
            Stop[event]))
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   R_postmid(w!1)
               (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                               nth(i!2`1,
                                   floor(1 - 2 * ((mid - 1) / (p - 2))
                                         +
                                         ((mid - 1) / (p - 2)) * P!1)))))
[5]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[6]   i!1`2 = n_mid
[7]   P!1 = 2

Rerunning step: (delete 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.2 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   ((rec(u!1, nth(i!2`3, i!1`1 - 1),
            E(public(u!1),
              conc(ilist(append(i!2`3, i!2`4)),
                   nlist(cons(i!1`2, i!2`2)))))
         >>
         ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
           Stop[event]))
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictpostmid_middle.3.1.2.2 :  

{-1}  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(ilist(append(i!2`3, i!2`4)),
                         nlist(cons(i!1`2, i!2`2)))))
[-2]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
{1}   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
{2}   R_postmid(w!1)
               (rec(u!1, nth(i!2`3, i!1`1 - 1),
                    E(public(u!1),
                      conc(ilist(append(i!2`3, i!2`4)),
                           nlist(cons(i!1`2, i!2`2))))))
{3}   rec(u!1, nth(i!2`3, i!1`1 - 1),
          E(public(u!1),
            conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2)))))
       >>
       (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
          Stop[event])
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[5]   i!1`2 = n_mid
[6]   P!1 = 2

Rerunning step: (delete -2 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.2 :  

[-1]  rho_postmid(w!1)
                 (E(public(u!1),
                    conc(ilist(append(i!2`3, i!2`4)),
                         nlist(cons(i!1`2, i!2`2)))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (expand "E" -1)
Expanding the definition of E,
this simplifies to: 
restrictpostmid_middle.3.1.2.2 :  

{-1}  rho_postmid(w!1)
                 (code(public(u!1),
                       conc(ilist(append(i!2`3, i!2`4)),
                            nlist(cons(i!1`2, i!2`2)))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (expand "rho_postmid" -1)
Expanding the definition of rho_postmid,
this simplifies to: 
restrictpostmid_middle.3.1.2.2 :  

{-1}  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
       OR
       EXISTS (i: {x: nat | mid < x AND x <= w!1}):
         public(u!1) = public(hu(i)) AND
          EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                  nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
            conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
             conc(nlist(append(nl1, cons(n_mid, nl2))),
                  ilist(remove(hu_list, i)))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
restrictpostmid_middle.3.1.2.2.1 :  

{-1}  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (lemma "listprops[Nonce].elt_append2"
                 ("l1" "(:i!1`2:)" "l2" "i!2`2" "t" "n_mid"))
Applying listprops[Nonce].elt_append2 where 
  l1 gets (: i!1`2 :),
  l2 gets i!2`2,
  t gets n_mid,
this simplifies to: 
restrictpostmid_middle.3.1.2.2.1 :  

{-1}  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (delete -3 -4 -5 -6 -7 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.2.1 :  

[-1]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (expand "LastMessage")
Expanding the definition of LastMessage,
this simplifies to: 
restrictpostmid_middle.3.1.2.2.1 :  

[-1]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   ((IF i!1`1 = P!1 - 2
          THEN trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2)))
        ELSE trans(u!1, car(i!2`4),
                   E(public(car(i!2`4)),
                     conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                          nlist(i!2`2))))
        ENDIF
         >> Stop[event])
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (lift-if)
Lifting IF-conditions to the top level,
this simplifies to: 
restrictpostmid_middle.3.1.2.2.1 :  

[-1]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   IF i!1`1 = P!1 - 2
        THEN ((trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2)))
                >> Stop[event])
               # R_postmid(w!1))
              |>
              LAMBDA (t: list[event]):
                every(LAMBDA (e: event):
                        rec?(e) => rho_postmid(w!1)(msg(e)))
                     (t)
                 =>
                 every(LAMBDA (e: event):
                         NOT rec?(e) => rho_postmid(w!1)(msg(e)))
                      (t)
      ELSE ((trans(u!1, car(i!2`4),
                   E(public(car(i!2`4)),
                     conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                          nlist(i!2`2))))
              >> Stop[event])
             # R_postmid(w!1))
            |>
            LAMBDA (t: list[event]):
              every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))
                   (t)
               =>
               every(LAMBDA (e: event):
                       NOT rec?(e) => rho_postmid(w!1)(msg(e)))
                    (t)
      ENDIF

Rerunning step: (split 1)
Splitting conjunctions,
this yields  2 subgoals: 
restrictpostmid_middle.3.1.2.2.1.1 :  

[-1]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   i!1`1 = P!1 - 2 IMPLIES
       ((trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))) >>
          Stop[event])
         # R_postmid(w!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
           =>
           every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
                (t)

Rerunning step: (prefix2)
Applying prefix rule with adjusted if-lifting,
this yields  3 subgoals: 
restrictpostmid_middle.3.1.2.2.1.1.1 :  

{-1}  i!1`1 = P!1 - 2
[-2]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-3]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   rho_postmid(w!1)(E(public(car(i!2`4)), nlist(i!2`2)))
{2}   R_postmid(w!1)
               (trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))))
{3}   trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))) >>
       (Stop[event] # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.2.1.1.1 :  

[-1]  i!1`1 = P!1 - 2
[-2]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-3]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
  |-------
[1]   rho_postmid(w!1)(E(public(car(i!2`4)), nlist(i!2`2)))

Rerunning step: (grind :if-match nil :exclude "elt")
E rewrites E(public(car(i!2`4)), nlist(i!2`2))
  to code(public(car(i!2`4)), nlist(i!2`2))
rho_postmid rewrites rho_postmid(w!1)(nlist(i!2`2))
  to NOT elt(i!2`2, n_mid)
remove rewrites remove(cdr(hu_list), i - 1)
  to cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2))
remove rewrites remove(hu_list, i)
  to cons(car(hu_list),
           cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2)))
rho_postmid rewrites rho_postmid(w!1)(code(public(car(i!2`4)), nlist(i!2`2)))
  to NOT elt(i!2`2, n_mid)
append rewrites append((: :), i!2`2)
  to i!2`2
append rewrites append((: i!1`2 :), i!2`2)
  to cons(i!1`2, i!2`2)
rho_postmid rewrites rho_postmid(w!1)(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_postmid rewrites rho_postmid(w!1)(nlist(cons(i!1`2, i!2`2)))
  to FALSE
rho_postmid rewrites 
  rho_postmid(w!1)
             (conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
  to FALSE
E rewrites E(public(car(i!2`4)), nlist(i!2`2))
  to code(public(car(i!2`4)), nlist(i!2`2))
rho_postmid rewrites rho_postmid(w!1)(nlist(i!2`2))
  to NOT elt(i!2`2, n_mid)
remove rewrites remove(cdr(hu_list), i - 1)
  to cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2))
remove rewrites remove(hu_list, i)
  to cons(car(hu_list),
           cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2)))
rho_postmid rewrites rho_postmid(w!1)(code(public(car(i!2`4)), nlist(i!2`2)))
  to NOT elt(i!2`2, n_mid)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpostmid_middle.3.1.2.2.1.1.1.

restrictpostmid_middle.3.1.2.2.1.1.2 :  

{-1}  i!1`1 = P!1 - 2
[-2]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-3]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   (Stop[event] # R_postmid(w!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
{2}   R_postmid(w!1)
               (trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))))
{3}   trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))) >>
       (Stop[event] # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.2.1.1.2 :  

  |-------
[1]   (Stop[event] # R_postmid(w!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictpostmid_middle.3.1.2.2.1.1.2.

restrictpostmid_middle.3.1.2.2.1.1.3 :  

[-1]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   cons?[Identity](i!2`4)
{2}   i!1`1 = P!1 - 2 IMPLIES
       IF R_postmid(w!1)
                   (trans(u!1, car(i!2`4),
                          E(public(car(i!2`4)), nlist(i!2`2))))
         THEN Stop
       ELSE trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))) >>
             (Stop[event] # R_postmid(w!1))
       ENDIF
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
           =>
           every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
                (t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.2.1.1.3 :  

  |-------
[1]   cons?[Identity](i!2`4)

Rerunning step: (nonemptylist "i!2`4")
Relating existence of a tail to a list's length,

This completes the proof of restrictpostmid_middle.3.1.2.2.1.1.3.


This completes the proof of restrictpostmid_middle.3.1.2.2.1.1.

restrictpostmid_middle.3.1.2.2.1.2 :  

[-1]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   NOT i!1`1 = P!1 - 2 IMPLIES
       ((trans(u!1, car(i!2`4),
               E(public(car(i!2`4)),
                 conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                      nlist(i!2`2))))
          >> Stop[event])
         # R_postmid(w!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
           =>
           every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
                (t)

Rerunning step: (prefix2)
Applying prefix rule with adjusted if-lifting,
this yields  3 subgoals: 
restrictpostmid_middle.3.1.2.2.1.2.1 :  

[-1]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   rho_postmid(w!1)
                 (E(public(car(i!2`4)),
                    conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                         nlist(i!2`2))))
{2}   R_postmid(w!1)
               (trans(u!1, car(i!2`4),
                      E(public(car(i!2`4)),
                        conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                             nlist(i!2`2)))))
{3}   i!1`1 = P!1 - 2
{4}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                   nlist(i!2`2))))
       >> (Stop[event] # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.2.1.2.1 :  

[-1]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
  |-------
[1]   rho_postmid(w!1)
                 (E(public(car(i!2`4)),
                    conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                         nlist(i!2`2))))

Rerunning step: (grind :if-match nil :exclude "elt")
E rewrites 
  E(public(car(i!2`4)),
    conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)))
  to code(public(car(i!2`4)),
           conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)))
rho_postmid rewrites 
  rho_postmid(w!1)(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
  to TRUE
rho_postmid rewrites rho_postmid(w!1)(nlist(i!2`2))
  to NOT elt(i!2`2, n_mid)
rho_postmid rewrites 
  rho_postmid(w!1)
             (conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                   nlist(i!2`2)))
  to NOT elt(i!2`2, n_mid)
remove rewrites remove(cdr(hu_list), i - 1)
  to cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2))
remove rewrites remove(hu_list, i)
  to cons(car(hu_list),
           cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2)))
rho_postmid rewrites 
  rho_postmid(w!1)
             (code(public(car(i!2`4)),
                   conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                        nlist(i!2`2))))
  to NOT elt(i!2`2, n_mid) OR
       EXISTS (i: {x: nat | mid < x AND x <= w!1}):
         public(car(i!2`4)) = public(hu(i)) AND
          EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                  nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
            conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2))
             =
             conc(nlist(append(nl1, cons(n_mid, nl2))),
                  ilist(cons(car(hu_list),
                             cons(car(cdr(hu_list)),
                                  remove(cdr(cdr(hu_list)), i - 2)))))
append rewrites append((: :), i!2`2)
  to i!2`2
append rewrites append((: i!1`2 :), i!2`2)
  to cons(i!1`2, i!2`2)
rho_postmid rewrites rho_postmid(w!1)(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_postmid rewrites rho_postmid(w!1)(nlist(cons(i!1`2, i!2`2)))
  to FALSE
rho_postmid rewrites 
  rho_postmid(w!1)
             (conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
  to FALSE
E rewrites 
  E(public(car(i!2`4)),
    conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)))
  to code(public(car(i!2`4)),
           conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)))
rho_postmid rewrites 
  rho_postmid(w!1)(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
  to TRUE
rho_postmid rewrites rho_postmid(w!1)(nlist(i!2`2))
  to NOT elt(i!2`2, n_mid)
rho_postmid rewrites 
  rho_postmid(w!1)
             (conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                   nlist(i!2`2)))
  to NOT elt(i!2`2, n_mid)
remove rewrites remove(cdr(hu_list), i - 1)
  to cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2))
remove rewrites remove(hu_list, i)
  to cons(car(hu_list),
           cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2)))
rho_postmid rewrites 
  rho_postmid(w!1)
             (code(public(car(i!2`4)),
                   conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                        nlist(i!2`2))))
  to NOT elt(i!2`2, n_mid) OR
       EXISTS (i: {x: nat | mid < x AND x <= w!1}):
         public(car(i!2`4)) = public(hu(i)) AND
          EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                  nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
            conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2))
             =
             conc(nlist(append(nl1, cons(n_mid, nl2))),
                  ilist(cons(car(hu_list),
                             cons(car(cdr(hu_list)),
                                  remove(cdr(cdr(hu_list)), i - 2)))))
rho_postmid rewrites rho_postmid(w!1)(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_postmid rewrites rho_postmid(w!1)(nlist(cons(i!1`2, i!2`2)))
  to NOT elt(cons(i!1`2, i!2`2), n_mid)
rho_postmid rewrites 
  rho_postmid(w!1)
             (conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
  to NOT elt(cons(i!1`2, i!2`2), n_mid)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpostmid_middle.3.1.2.2.1.2.1.

restrictpostmid_middle.3.1.2.2.1.2.2 :  

[-1]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   (Stop[event] # R_postmid(w!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
{2}   R_postmid(w!1)
               (trans(u!1, car(i!2`4),
                      E(public(car(i!2`4)),
                        conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                             nlist(i!2`2)))))
{3}   i!1`1 = P!1 - 2
{4}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                   nlist(i!2`2))))
       >> (Stop[event] # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete - 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.2.1.2.2 :  

  |-------
[1]   (Stop[event] # R_postmid(w!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictpostmid_middle.3.1.2.2.1.2.2.

restrictpostmid_middle.3.1.2.2.1.2.3 :  

[-1]  elt(i!2`2, n_mid) IMPLIES elt(append((: i!1`2 :), i!2`2), n_mid)
[-2]  rho_postmid(w!1)
                 (conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2))))
  |-------
{1}   cons?[Identity](i!2`4)
{2}   NOT i!1`1 = P!1 - 2 IMPLIES
       IF R_postmid(w!1)
                   (trans(u!1, car(i!2`4),
                          E(public(car(i!2`4)),
                            conc(ilist(append
                                       (i!2`3, cons(u!1, cdr(i!2`4)))),
                                 nlist(i!2`2)))))
         THEN Stop
       ELSE trans(u!1, car(i!2`4),
                  E(public(car(i!2`4)),
                    conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                         nlist(i!2`2))))
             >> (Stop[event] # R_postmid(w!1))
       ENDIF
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
           =>
           every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
                (t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.2.1.2.3 :  

  |-------
[1]   cons?[Identity](i!2`4)

Rerunning step: (nonemptylist "i!2`4")
Relating existence of a tail to a list's length,

This completes the proof of restrictpostmid_middle.3.1.2.2.1.2.3.


This completes the proof of restrictpostmid_middle.3.1.2.2.1.2.


This completes the proof of restrictpostmid_middle.3.1.2.2.1.

restrictpostmid_middle.3.1.2.2.2 :  

{-1}  EXISTS (i: {x: nat | mid < x AND x <= w!1}):
        public(u!1) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, i)))
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
[-6]  2 <= P!1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictpostmid_middle.3.1.2.2.2 :  

{-1}  public(u!1) = public(hu(i!3))
{-2}  conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, i!3)))
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   i!1`2 = n_mid
[4]   P!1 = 2

Rerunning step: (delete -1 -3 -4 -5 -6 -7 +)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.1.2.2.2 :  

[-1]  conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, i!3)))
  |-------

Rerunning step: (decompose-equality -1)
Applying decompose-equality,

This completes the proof of restrictpostmid_middle.3.1.2.2.2.


This completes the proof of restrictpostmid_middle.3.1.2.2.


This completes the proof of restrictpostmid_middle.3.1.2.


This completes the proof of restrictpostmid_middle.3.1.

restrictpostmid_middle.3.2 :  

{-1}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-2}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
{1}   cons?[Identity](i!2`4)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (signal(running(i!1`1, append(i`3, cons(u!1, i`4)),
                          nth(i`1,
                              floor(1 - 2 * ((mid - 1) / (p - 2))
                                    +
                                    ((mid - 1) / (p - 2)) * P!1))))
            >>
            (trans(u!1, car(i`4),
                   E(public(car(i`4)),
                     conc(nlist(append(i`1, (: i!1`2 :))),
                          ilist(append(i`3, cons(u!1, cdr(i`4)))))))
              >>
              (rec(u!1, nth(i`3, i!1`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(i`3, i`4)),
                          nlist(cons(i!1`2, i`2)))))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete -1 -2 -3 2 3 4 5)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.2 :  

[-1]  i!1`1 < P!1 - 1
[-2]  2 <= P!1
  |-------
[1]   cons?[Identity](i!2`4)

Rerunning step: (nonemptylist "i!2`4")
Relating existence of a tail to a list's length,

This completes the proof of restrictpostmid_middle.3.2.

restrictpostmid_middle.3.3 :  

{-1}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-2}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
{1}   floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       length[Nonce](i!2`1)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (signal(running(i!1`1, append(i`3, cons(u!1, i`4)),
                          nth(i`1,
                              floor(1 - 2 * ((mid - 1) / (p - 2))
                                    +
                                    ((mid - 1) / (p - 2)) * P!1))))
            >>
            (trans(u!1, car(i`4),
                   E(public(car(i`4)),
                     conc(nlist(append(i`1, (: i!1`2 :))),
                          ilist(append(i`3, cons(u!1, cdr(i`4)))))))
              >>
              (rec(u!1, nth(i`3, i!1`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(i`3, i`4)),
                          nlist(cons(i!1`2, i`2)))))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (typepred "i!2`1")
Adding type constraints for  i!2`1,
this simplifies to: 
restrictpostmid_middle.3.3 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`1)
{-2}  length(i!2`1) = i!1`1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       length[Nonce](i!2`1)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (signal(running(i!1`1, append(i`3, cons(u!1, i`4)),
                          nth(i`1,
                              floor(1 - 2 * ((mid - 1) / (p - 2))
                                    +
                                    ((mid - 1) / (p - 2)) * P!1))))
            >>
            (trans(u!1, car(i`4),
                   E(public(car(i`4)),
                     conc(nlist(append(i`1, (: i!1`2 :))),
                          ilist(append(i`3, cons(u!1, cdr(i`4)))))))
              >>
              (rec(u!1, nth(i`3, i!1`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(i`3, i`4)),
                          nlist(cons(i!1`2, i`2)))))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete -1 -3 -4 -5 -6 -7 3 4 5)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.3 :  

[-1]  length(i!2`1) = i!1`1
  |-------
[1]   floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       length[Nonce](i!2`1)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.3.3.

restrictpostmid_middle.3.4 :  

{-1}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-2}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
{1}   i!1`1 - 1 < length[Identity](i!2`3)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (signal(running(i!1`1, append(i`3, cons(u!1, i`4)),
                          nth(i`1,
                              floor(1 - 2 * ((mid - 1) / (p - 2))
                                    +
                                    ((mid - 1) / (p - 2)) * P!1))))
            >>
            (trans(u!1, car(i`4),
                   E(public(car(i`4)),
                     conc(nlist(append(i`1, (: i!1`2 :))),
                          ilist(append(i`3, cons(u!1, cdr(i`4)))))))
              >>
              (rec(u!1, nth(i`3, i!1`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(i`3, i`4)),
                          nlist(cons(i!1`2, i`2)))))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (typepred "i!2`3")
Adding type constraints for  i!2`3,
this simplifies to: 
restrictpostmid_middle.3.4 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`3)
{-2}  length(i!2`3) = i!1`1
[-3]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-4]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
[-7]  2 <= P!1
  |-------
[1]   i!1`1 - 1 < length[Identity](i!2`3)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (signal(running(i!1`1, append(i`3, cons(u!1, i`4)),
                          nth(i`1,
                              floor(1 - 2 * ((mid - 1) / (p - 2))
                                    +
                                    ((mid - 1) / (p - 2)) * P!1))))
            >>
            (trans(u!1, car(i`4),
                   E(public(car(i`4)),
                     conc(nlist(append(i`1, (: i!1`2 :))),
                          ilist(append(i`3, cons(u!1, cdr(i`4)))))))
              >>
              (rec(u!1, nth(i`3, i!1`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(i`3, i`4)),
                          nlist(cons(i!1`2, i`2)))))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete -1 -3 -4 -5 -6 -7 2 3 4 5)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.4 :  

[-1]  length(i!2`3) = i!1`1
  |-------
[1]   i!1`1 - 1 < length[Identity](i!2`3)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_middle.3.4.

restrictpostmid_middle.3.5 :  

{-1}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
{-2}  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
{1}   FORALL (nl1: {x: list[Nonce] | length[Nonce](x) = i!1`1},
              nl2: {x: list[Nonce] | length[Nonce](x) = P!1 - 1 - i!1`1},
              il1: {x: list[Identity] | length[Identity](x) = i!1`1},
              il2:
                {x: list[Identity] |
                   length[Identity](x) = P!1 - 1 - i!1`1}):
        cons?[Identity](il2)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1: {x: list[Identity] | length(x) = i!1`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (signal(running(i!1`1, append(il1, cons(u!1, il2)),
                          nth(nl1,
                              floor(1 - 2 * ((mid - 1) / (p - 2))
                                    +
                                    ((mid - 1) / (p - 2)) * P!1))))
            >>
            (trans(u!1, car(il2),
                   E(public(car(il2)),
                     conc(nlist(append(nl1, (: i!1`2 :))),
                          ilist(append(il1, cons(u!1, cdr(il2)))))))
              >>
              (rec(u!1, nth(il1, i!1`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(il1, il2)),
                          nlist(cons(i!1`2, nl2)))))
                >>
                ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictpostmid_middle.3.5 :  

[-1]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) >=
       1
[-2]  floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1) <
       P!1 - 1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
[-5]  2 <= P!1
  |-------
{1}   cons?[Identity](il2!1)
[2]   i!1`1 <=
       floor(1 - 2 * ((mid - 1) / (p - 2)) + ((mid - 1) / (p - 2)) * P!1)
[3]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1: {x: list[Identity] | length(x) = i!1`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (signal(running(i!1`1, append(il1, cons(u!1, il2)),
                          nth(nl1,
                              floor(1 - 2 * ((mid - 1) / (p - 2))
                                    +
                                    ((mid - 1) / (p - 2)) * P!1))))
            >>
            (trans(u!1, car(il2),
                   E(public(car(il2)),
                     conc(nlist(append(nl1, (: i!1`2 :))),
                          ilist(append(il1, cons(u!1, cdr(il2)))))))
              >>
              (rec(u!1, nth(il1, i!1`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(il1, il2)),
                          nlist(cons(i!1`2, nl2)))))
                >>
                ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   i!1`2 = n_mid
[5]   P!1 = 2

Rerunning step: (delete -1 -2 -3 2 3 4 5)
Deleting some formulas,
this simplifies to: 
restrictpostmid_middle.3.5 :  

[-1]  i!1`1 < P!1 - 1
[-2]  2 <= P!1
  |-------
[1]   cons?[Identity](il2!1)

Rerunning step: (nonemptylist "il2!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictpostmid_middle.3.5.


This completes the proof of restrictpostmid_middle.3.

Q.E.D.


Run time  = 52.74 secs.
Real time = 57.15 secs.
nil
pvs(82): 
Installing rewrite rule sets.singleton_rew (all instances)
restrictpostmid_last :  

  |-------
{1}   FORALL (P: nat_from_2, u: Identity, w: {x: nat | mid < x AND x < p}):
        ((Interleave! (nnP: Nonces(P, u, P - 1)): UROLE_LAST(P, u, nnP)) #
          R_postmid(w))
         |> RankUser(rho_postmid(w))

Rerunning step: (auto-rewrite-theory "sets")
Rewriting relative to the theory: sets,
this simplifies to: 
restrictpostmid_last :  

  |-------
[1]   FORALL (P: nat_from_2, u: Identity, w: {x: nat | mid < x AND x < p}):
        ((Interleave! (nnP: Nonces(P, u, P - 1)): UROLE_LAST(P, u, nnP)) #
          R_postmid(w))
         |> RankUser(rho_postmid(w))

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictpostmid_last :  

  |-------
{1}   ((Interleave! (nnP: Nonces(P!1, u!1, P!1 - 1)):
          UROLE_LAST(P!1, u!1, nnP))
        # R_postmid(w!1))
       |> RankUser(rho_postmid(w!1))

Rerunning step: (expand "RankUser")
Expanding the definition of RankUser,
this simplifies to: 
restrictpostmid_last :  

  |-------
{1}   ((Interleave! (nnP: Nonces(P!1, u!1, P!1 - 1)):
          UROLE_LAST(P!1, u!1, nnP))
        # R_postmid(w!1))
       |>
       LAMBDA (tr: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(tr)
          =>
          every(LAMBDA (e: event):
                  complement(rec?)(e) => rho_postmid(w!1)(msg(e)))
               (tr)

Rerunning step: (interleaving2)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
Applying interleaving rule,
this simplifies to: 
restrictpostmid_last :  

  |-------
{1}   UROLE_LAST(P!1, u!1, i!1) # R_postmid(w!1) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (expand "UROLE_LAST")
Expanding the definition of UROLE_LAST,
this simplifies to: 
restrictpostmid_last :  

  |-------
{1}   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (signal(running(P!1 - 1, append(il, (: u!1 :)),
                          nth(nl,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(nlist(append(nl, (: i!1 :))),
                          ilist(append(cdr(il), (: u!1 :))))))
              >>
              (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (typepred "P!1")
Adding type constraints for  P!1,
this simplifies to: 
restrictpostmid_last :  

{-1}  2 <= P!1
  |-------
[1]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (signal(running(P!1 - 1, append(il, (: u!1 :)),
                          nth(nl,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(nlist(append(nl, (: i!1 :))),
                          ilist(append(cdr(il), (: u!1 :))))))
              >>
              (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (lemma "select_right_nonce3" ("P" "P!1"))
Applying select_right_nonce3 where 
  P gets P!1,
this simplifies to: 
restrictpostmid_last :  

{-1}  (P!1 = p IMPLIES floor((mid / (p - 1)) * (P!1 - 1)) = mid) AND
       floor((mid / (p - 1)) * (P!1 - 1)) >= 0 AND
        floor((mid / (p - 1)) * (P!1 - 1)) < P!1 - 1
[-2]  2 <= P!1
  |-------
[1]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (signal(running(P!1 - 1, append(il, (: u!1 :)),
                          nth(nl,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(nlist(append(nl, (: i!1 :))),
                          ilist(append(cdr(il), (: u!1 :))))))
              >>
              (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictpostmid_last :  

{-1}  (P!1 = p IMPLIES floor((mid / (p - 1)) * (P!1 - 1)) = mid)
{-2}  floor((mid / (p - 1)) * (P!1 - 1)) >= 0
{-3}  floor((mid / (p - 1)) * (P!1 - 1)) < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (signal(running(P!1 - 1, append(il, (: u!1 :)),
                          nth(nl,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(nlist(append(nl, (: i!1 :))),
                          ilist(append(cdr(il), (: u!1 :))))))
              >>
              (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last :  

[-1]  floor((mid / (p - 1)) * (P!1 - 1)) >= 0
[-2]  floor((mid / (p - 1)) * (P!1 - 1)) < P!1 - 1
[-3]  2 <= P!1
  |-------
[1]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (signal(running(P!1 - 1, append(il, (: u!1 :)),
                          nth(nl,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(nlist(append(nl, (: i!1 :))),
                          ilist(append(cdr(il), (: u!1 :))))))
              >>
              (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (choice3)
Applying choice rule,
this yields  7 subgoals: 
restrictpostmid_last.1 :  

[-1]  floor((mid / (p - 1)) * (P!1 - 1)) >= 0
[-2]  floor((mid / (p - 1)) * (P!1 - 1)) < P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   (rec(u!1, nth(i!2`2, P!1 - 2),
           E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
        >>
        (signal(running(P!1 - 1, append(i!2`2, (: u!1 :)),
                        nth(i!2`1,
                            floor((mid / (p - 1)) * P!1 -
                                   (mid / (p - 1))))))
          >>
          (trans(u!1, car(i!2`2),
                 E(public(car(i!2`2)),
                   conc(nlist(append(i!2`1, (: i!1 :))),
                        ilist(append(cdr(i!2`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i!2`2, P!1 - 2),
                 E(public(u!1), nlist((: i!1 :))))
              >> Stop[event]))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictpostmid_last.1 :  

{-1}  rho_postmid(w!1)(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
{-2}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
{-3}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  2 <= P!1
  |-------
{1}   ((signal(running(P!1 - 1, append(i!2`2, (: u!1 :)),
                       nth(i!2`1,
                           floor((mid / (p - 1)) * P!1 -
                                  (mid / (p - 1))))))
         >>
         (trans(u!1, car(i!2`2),
                E(public(car(i!2`2)),
                  conc(nlist(append(i!2`1, (: i!1 :))),
                       ilist(append(cdr(i!2`2), (: u!1 :))))))
           >>
           (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
             >> Stop[event])))
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
{2}   R_postmid(w!1)
               (rec(u!1, nth(i!2`2, P!1 - 2),
                    E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2)))))
{3}   rec(u!1, nth(i!2`2, P!1 - 2),
          E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
       >>
       ((signal(running(P!1 - 1, append(i!2`2, (: u!1 :)),
                        nth(i!2`1,
                            floor((mid / (p - 1)) * P!1 -
                                   (mid / (p - 1))))))
          >>
          (trans(u!1, car(i!2`2),
                 E(public(car(i!2`2)),
                   conc(nlist(append(i!2`1, (: i!1 :))),
                        ilist(append(cdr(i!2`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i!2`2, P!1 - 2),
                 E(public(u!1), nlist((: i!1 :))))
              >> Stop[event])))
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last.1 :  

[-1]  rho_postmid(w!1)(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   ((signal(running(P!1 - 1, append(i!2`2, (: u!1 :)),
                       nth(i!2`1,
                           floor((mid / (p - 1)) * P!1 -
                                  (mid / (p - 1))))))
         >>
         (trans(u!1, car(i!2`2),
                E(public(car(i!2`2)),
                  conc(nlist(append(i!2`1, (: i!1 :))),
                       ilist(append(cdr(i!2`2), (: u!1 :))))))
           >>
           (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
             >> Stop[event])))
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictpostmid_last.1.1 :  

[-1]  rho_postmid(w!1)(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  2 <= P!1
  |-------
{1}   rho_postmid(w!1)
                 (running(P!1 - 1, append(i!2`2, (: u!1 :)),
                          nth(i!2`1,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
{2}   R_postmid(w!1)
               (signal(running(P!1 - 1, append(i!2`2, (: u!1 :)),
                               nth(i!2`1,
                                   floor((mid / (p - 1)) * P!1
                                         -
                                         (mid / (p - 1)))))))
{3}   signal(running(P!1 - 1, append(i!2`2, (: u!1 :)),
                     nth(i!2`1,
                         floor((mid / (p - 1)) * P!1 - (mid / (p - 1))))))
       >>
       ((trans(u!1, car(i!2`2),
               E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :))))))
          >>
          (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
            >> Stop[event]))
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last.1.1 :  

  |-------
[1]   rho_postmid(w!1)
                 (running(P!1 - 1, append(i!2`2, (: u!1 :)),
                          nth(i!2`1,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))

Rerunning step: (expand "rho_postmid")
Expanding the definition of rho_postmid,
this simplifies to: 
restrictpostmid_last.1.1 :  

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictpostmid_last.1.1.

restrictpostmid_last.1.2 :  

[-1]  rho_postmid(w!1)(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  2 <= P!1
  |-------
{1}   ((trans(u!1, car(i!2`2),
              E(public(car(i!2`2)),
                conc(nlist(append(i!2`1, (: i!1 :))),
                     ilist(append(cdr(i!2`2), (: u!1 :))))))
         >>
         (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
           >> Stop[event]))
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
{2}   R_postmid(w!1)
               (signal(running(P!1 - 1, append(i!2`2, (: u!1 :)),
                               nth(i!2`1,
                                   floor((mid / (p - 1)) * P!1
                                         -
                                         (mid / (p - 1)))))))
{3}   signal(running(P!1 - 1, append(i!2`2, (: u!1 :)),
                     nth(i!2`1,
                         floor((mid / (p - 1)) * P!1 - (mid / (p - 1))))))
       >>
       ((trans(u!1, car(i!2`2),
               E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :))))))
          >>
          (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
            >> Stop[event]))
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last.1.2 :  

[-1]  rho_postmid(w!1)(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   ((trans(u!1, car(i!2`2),
              E(public(car(i!2`2)),
                conc(nlist(append(i!2`1, (: i!1 :))),
                     ilist(append(cdr(i!2`2), (: u!1 :))))))
         >>
         (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
           >> Stop[event]))
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   R_postmid(w!1)
               (signal(running(P!1 - 1, append(i!2`2, (: u!1 :)),
                               nth(i!2`1,
                                   floor((mid / (p - 1)) * P!1
                                         -
                                         (mid / (p - 1)))))))

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictpostmid_last.1.2.1 :  

[-1]  rho_postmid(w!1)(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  2 <= P!1
  |-------
{1}   rho_postmid(w!1)
                 (E(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))
{2}   R_postmid(w!1)
               (trans(u!1, car(i!2`2),
                      E(public(car(i!2`2)),
                        conc(nlist(append(i!2`1, (: i!1 :))),
                             ilist(append(cdr(i!2`2), (: u!1 :)))))))
{3}   trans(u!1, car(i!2`2),
            E(public(car(i!2`2)),
              conc(nlist(append(i!2`1, (: i!1 :))),
                   ilist(append(cdr(i!2`2), (: u!1 :))))))
       >>
       ((rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :)))) >>
          Stop[event])
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   R_postmid(w!1)
               (signal(running(P!1 - 1, append(i!2`2, (: u!1 :)),
                               nth(i!2`1,
                                   floor((mid / (p - 1)) * P!1
                                         -
                                         (mid / (p - 1)))))))

Rerunning step: (delete -2 -3 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last.1.2.1 :  

[-1]  rho_postmid(w!1)(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (E(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))
[2]   R_postmid(w!1)
               (signal(running(P!1 - 1, append(i!2`2, (: u!1 :)),
                               nth(i!2`1,
                                   floor((mid / (p - 1)) * P!1
                                         -
                                         (mid / (p - 1)))))))

Rerunning step: (expand "R_postmid")
Expanding the definition of R_postmid,
this simplifies to: 
restrictpostmid_last.1.2.1 :  

[-1]  rho_postmid(w!1)(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (E(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))
{2}   signal(running(P!1 - 1, append(i!2`2, (: u!1 :)),
                     nth(i!2`1,
                         floor((mid / (p - 1)) * P!1 - (mid / (p - 1))))))
       = signal(running(w!1, hu_list, n_mid))

Rerunning step: (case "w!1=P!1-1 AND append(i!2`2,(:u!1:))=hu_list AND nth(i!2`1,floor((mid/(p-1))*(P!1-1)))=n_mid")
Case splitting on 
   w!1 = P!1 - 1 AND
    append(i!2`2, (: u!1 :)) = hu_list AND
     nth(i!2`1, floor((mid / (p - 1)) * (P!1 - 1))) = n_mid, 
this yields  2 subgoals: 
restrictpostmid_last.1.2.1.1 :  

{-1}  w!1 = P!1 - 1 AND
       append(i!2`2, (: u!1 :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * (P!1 - 1))) = n_mid
[-2]  rho_postmid(w!1)(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-3]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (E(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))
[2]   signal(running(P!1 - 1, append(i!2`2, (: u!1 :)),
                     nth(i!2`1,
                         floor((mid / (p - 1)) * P!1 - (mid / (p - 1))))))
       = signal(running(w!1, hu_list, n_mid))

Rerunning step: (delete -2 -3 1)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last.1.2.1.1 :  

[-1]  w!1 = P!1 - 1 AND
       append(i!2`2, (: u!1 :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * (P!1 - 1))) = n_mid
  |-------
[1]   signal(running(P!1 - 1, append(i!2`2, (: u!1 :)),
                     nth(i!2`1,
                         floor((mid / (p - 1)) * P!1 - (mid / (p - 1))))))
       = signal(running(w!1, hu_list, n_mid))

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_last.1.2.1.1.

restrictpostmid_last.1.2.1.2 :  

[-1]  rho_postmid(w!1)(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
{1}   w!1 = P!1 - 1 AND
       append(i!2`2, (: u!1 :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * (P!1 - 1))) = n_mid
[2]   rho_postmid(w!1)
                 (E(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))
[3]   signal(running(P!1 - 1, append(i!2`2, (: u!1 :)),
                     nth(i!2`1,
                         floor((mid / (p - 1)) * P!1 - (mid / (p - 1))))))
       = signal(running(w!1, hu_list, n_mid))

Rerunning step: (delete 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last.1.2.1.2 :  

[-1]  rho_postmid(w!1)(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   w!1 = P!1 - 1 AND
       append(i!2`2, (: u!1 :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * (P!1 - 1))) = n_mid
[2]   rho_postmid(w!1)
                 (E(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (comment "explore the two reasons that could make -1 true")
Adding comment: explore the two reasons that could make -1 true
this simplifies to: 
restrictpostmid_last.1.2.1.2 : 
;;; explore the two reasons that could make -1 true

[-1]  rho_postmid(w!1)(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   w!1 = P!1 - 1 AND
       append(i!2`2, (: u!1 :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * (P!1 - 1))) = n_mid
[2]   rho_postmid(w!1)
                 (E(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (expand "E")
Expanding the definition of E,
this simplifies to: 
restrictpostmid_last.1.2.1.2 : 
;;; explore the two reasons that could make -1 true

{-1}  rho_postmid(w!1)(code(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   w!1 = P!1 - 1 AND
       append(i!2`2, (: u!1 :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * (P!1 - 1))) = n_mid
{2}   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(nlist(append(i!2`1, (: i!1 :))),
                            ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (expand "rho_postmid" -1)
Expanding the definition of rho_postmid,
this simplifies to: 
restrictpostmid_last.1.2.1.2 : 
;;; explore the two reasons that could make -1 true

{-1}  rho_postmid(w!1)(conc(nlist(i!2`1), ilist(i!2`2))) OR
       EXISTS (i: {x: nat | mid < x AND x <= w!1}):
         public(u!1) = public(hu(i)) AND
          EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                  nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
            conc(nlist(i!2`1), ilist(i!2`2)) =
             conc(nlist(append(nl1, cons(n_mid, nl2))),
                  ilist(remove(hu_list, i)))
[-2]  2 <= P!1
  |-------
[1]   w!1 = P!1 - 1 AND
       append(i!2`2, (: u!1 :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * (P!1 - 1))) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(nlist(append(i!2`1, (: i!1 :))),
                            ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (split -1)
Splitting conjunctions,
this yields  2 subgoals: 
restrictpostmid_last.1.2.1.2.1 : 
;;; explore the two reasons that could make -1 true

{-1}  rho_postmid(w!1)(conc(nlist(i!2`1), ilist(i!2`2)))
[-2]  2 <= P!1
  |-------
[1]   w!1 = P!1 - 1 AND
       append(i!2`2, (: u!1 :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * (P!1 - 1))) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(nlist(append(i!2`1, (: i!1 :))),
                            ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (delete 1)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last.1.2.1.2.1 : 
;;; explore the two reasons that could make -1 true

[-1]  rho_postmid(w!1)(conc(nlist(i!2`1), ilist(i!2`2)))
[-2]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(nlist(append(i!2`1, (: i!1 :))),
                            ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (typepred "i!1")
Adding type constraints for  i!1,
this simplifies to: 
restrictpostmid_last.1.2.1.2.1 : 
;;; explore the two reasons that could make -1 true

{-1}  IRpart(P!1, u!1, P!1 - 1)(i!1)
[-2]  rho_postmid(w!1)(conc(nlist(i!2`1), ilist(i!2`2)))
[-3]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(nlist(append(i!2`1, (: i!1 :))),
                            ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (lemma "n_prop" ("P" "P!1" "u" "u!1" "r" "P!1-1"))
Applying n_prop where 
  P gets P!1,
  u gets u!1,
  r gets P!1 - 1,
this simplifies to: 
restrictpostmid_last.1.2.1.2.1 : 
;;; explore the two reasons that could make -1 true

{-1}  (P!1 /= p OR P!1 - 1 /= mid) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, P!1 - 1)(n_mid)
[-2]  IRpart(P!1, u!1, P!1 - 1)(i!1)
[-3]  rho_postmid(w!1)(conc(nlist(i!2`1), ilist(i!2`2)))
[-4]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(nlist(append(i!2`1, (: i!1 :))),
                            ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (lemma "listprops[Nonce].elt_append3"
                 ("l1" "i!2`1" "l2" "(:i!1:)" "t" "n_mid"))
Applying listprops[Nonce].elt_append3 where 
  l1 gets i!2`1,
  l2 gets (: i!1 :),
  t gets n_mid,
this simplifies to: 
restrictpostmid_last.1.2.1.2.1 : 
;;; explore the two reasons that could make -1 true

{-1}  elt(append(i!2`1, (: i!1 :)), n_mid) IMPLIES
       elt(i!2`1, n_mid) OR elt((: i!1 :), n_mid)
[-2]  (P!1 /= p OR P!1 - 1 /= mid) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, P!1 - 1)(n_mid)
[-3]  IRpart(P!1, u!1, P!1 - 1)(i!1)
[-4]  rho_postmid(w!1)(conc(nlist(i!2`1), ilist(i!2`2)))
[-5]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(nlist(append(i!2`1, (: i!1 :))),
                            ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (lemma "listprops[Nonce].elt_singleton"
                 ("t1" "i!1" "t2" "n_mid"))
Applying listprops[Nonce].elt_singleton where 
  t1 gets i!1,
  t2 gets n_mid,
this simplifies to: 
restrictpostmid_last.1.2.1.2.1 : 
;;; explore the two reasons that could make -1 true

{-1}  elt((: i!1 :), n_mid) IFF i!1 = n_mid
[-2]  elt(append(i!2`1, (: i!1 :)), n_mid) IMPLIES
       elt(i!2`1, n_mid) OR elt((: i!1 :), n_mid)
[-3]  (P!1 /= p OR P!1 - 1 /= mid) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, P!1 - 1)(n_mid)
[-4]  IRpart(P!1, u!1, P!1 - 1)(i!1)
[-5]  rho_postmid(w!1)(conc(nlist(i!2`1), ilist(i!2`2)))
[-6]  2 <= P!1
  |-------
[1]   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(nlist(append(i!2`1, (: i!1 :))),
                            ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (grind :if-match nil :exclude "elt")
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
/= rewrites P!1 /= p
  to NOT (P!1 = p)
/= rewrites P!1 - 1 /= mid
  to TRUE
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
rho_postmid rewrites rho_postmid(w!1)(nlist(i!2`1))
  to FALSE
rho_postmid rewrites rho_postmid(w!1)(ilist(i!2`2))
  to TRUE
rho_postmid rewrites rho_postmid(w!1)(conc(nlist(i!2`1), ilist(i!2`2)))
  to FALSE
/= rewrites P!1 /= p
  to NOT (P!1 = p)
/= rewrites P!1 - 1 /= mid
  to TRUE
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
rho_postmid rewrites rho_postmid(w!1)(nlist(i!2`1))
  to NOT elt(i!2`1, n_mid)
rho_postmid rewrites rho_postmid(w!1)(ilist(i!2`2))
  to TRUE
rho_postmid rewrites rho_postmid(w!1)(conc(nlist(i!2`1), ilist(i!2`2)))
  to NOT elt(i!2`1, n_mid)
rho_postmid rewrites rho_postmid(w!1)(nlist(append(i!2`1, (: i!1 :))))
  to TRUE
rho_postmid rewrites rho_postmid(w!1)(ilist(append(cdr(i!2`2), (: u!1 :))))
  to TRUE
rho_postmid rewrites 
  rho_postmid(w!1)
             (conc(nlist(append(i!2`1, (: i!1 :))),
                   ilist(append(cdr(i!2`2), (: u!1 :)))))
  to TRUE
remove rewrites remove(cdr(hu_list), i - 1)
  to cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2))
remove rewrites remove(hu_list, i)
  to cons(car(hu_list),
           cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i - 2)))
rho_postmid rewrites 
  rho_postmid(w!1)
             (code(public(car(i!2`2)),
                   conc(nlist(append(i!2`1, (: i!1 :))),
                        ilist(append(cdr(i!2`2), (: u!1 :))))))
  to TRUE
/= rewrites P!1 /= p
  to NOT (P!1 = p)
/= rewrites P!1 - 1 /= mid
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpostmid_last.1.2.1.2.1.

restrictpostmid_last.1.2.1.2.2 : 
;;; explore the two reasons that could make -1 true

{-1}  EXISTS (i: {x: nat | mid < x AND x <= w!1}):
        public(u!1) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(i!2`1), ilist(i!2`2)) =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, i)))
[-2]  2 <= P!1
  |-------
[1]   w!1 = P!1 - 1 AND
       append(i!2`2, (: u!1 :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * (P!1 - 1))) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(nlist(append(i!2`1, (: i!1 :))),
                            ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (comment "2 cannot be true, so we will have to prove each conjunct of 1")
Adding comment: 2 cannot be true, so we will have to prove each conjunct of 1
this simplifies to: 
restrictpostmid_last.1.2.1.2.2 : 
;;; 2 cannot be true, so we will have to prove each conjunct of 1

[-1]  EXISTS (i: {x: nat | mid < x AND x <= w!1}):
        public(u!1) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           conc(nlist(i!2`1), ilist(i!2`2)) =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, i)))
[-2]  2 <= P!1
  |-------
[1]   w!1 = P!1 - 1 AND
       append(i!2`2, (: u!1 :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * (P!1 - 1))) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(nlist(append(i!2`1, (: i!1 :))),
                            ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2 : 
;;; 2 cannot be true, so we will have to prove each conjunct of 1

{-1}  public(u!1) = public(hu(i!3))
{-2}  conc(nlist(i!2`1), ilist(i!2`2)) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, i!3)))
[-3]  2 <= P!1
  |-------
[1]   w!1 = P!1 - 1 AND
       append(i!2`2, (: u!1 :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * (P!1 - 1))) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(nlist(append(i!2`1, (: i!1 :))),
                            ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2 : 
;;; 2 cannot be true, so we will have to prove each conjunct of 1

{-1}  u!1 = hu(i!3)
[-2]  conc(nlist(i!2`1), ilist(i!2`2)) =
       conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
            ilist(remove(hu_list, i!3)))
[-3]  2 <= P!1
  |-------
[1]   w!1 = P!1 - 1 AND
       append(i!2`2, (: u!1 :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * (P!1 - 1))) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(nlist(append(i!2`1, (: i!1 :))),
                            ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2 : 
;;; 2 cannot be true, so we will have to prove each conjunct of 1

{-1}  nlist(i!2`1) = nlist(append(nl1!1, cons(n_mid, nl2!1)))
{-2}  ilist(i!2`2) = ilist(remove(hu_list, i!3))
[-3]  u!1 = hu(i!3)
[-4]  2 <= P!1
  |-------
[1]   w!1 = P!1 - 1 AND
       append(i!2`2, (: u!1 :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * (P!1 - 1))) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(nlist(append(i!2`1, (: i!1 :))),
                            ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2 : 
;;; 2 cannot be true, so we will have to prove each conjunct of 1

{-1}  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-2]  ilist(i!2`2) = ilist(remove(hu_list, i!3))
[-3]  u!1 = hu(i!3)
[-4]  2 <= P!1
  |-------
[1]   w!1 = P!1 - 1 AND
       append(i!2`2, (: u!1 :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * (P!1 - 1))) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(nlist(append(i!2`1, (: i!1 :))),
                            ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2 : 
;;; 2 cannot be true, so we will have to prove each conjunct of 1

{-1}  i!2`2 = remove(hu_list, i!3)
[-2]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-3]  u!1 = hu(i!3)
[-4]  2 <= P!1
  |-------
[1]   w!1 = P!1 - 1 AND
       append(i!2`2, (: u!1 :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * (P!1 - 1))) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(nlist(append(i!2`1, (: i!1 :))),
                            ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (typepred "nl1!1" "nl2!1" "i!2`1" "i!2`2" "hu_list")
Adding type constraints for  nl1!1, nl2!1, i!2`1, i!2`2, hu_list,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2 : 
;;; 2 cannot be true, so we will have to prove each conjunct of 1

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl1!1)
{-2}  length(nl1!1) = mid
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
{-4}  length(nl2!1) = -1 - mid + i!3
{-5}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`1)
{-6}  length(i!2`1) = P!1 - 1
{-7}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`2)
{-8}  length(i!2`2) = P!1 - 1
{-9}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-10} (length(hu_list) = p)
{-11} FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] i!2`2 = remove(hu_list, i!3)
[-13] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-14] u!1 = hu(i!3)
[-15] 2 <= P!1
  |-------
[1]   w!1 = P!1 - 1 AND
       append(i!2`2, (: u!1 :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * (P!1 - 1))) = n_mid
[2]   rho_postmid(w!1)
                 (code(public(car(i!2`2)),
                       conc(nlist(append(i!2`1, (: i!1 :))),
                            ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (delete -1 -3 -5 -7 -9 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2 : 
;;; 2 cannot be true, so we will have to prove each conjunct of 1

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  i!2`2 = remove(hu_list, i!3)
[-8]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-9]  u!1 = hu(i!3)
[-10] 2 <= P!1
  |-------
[1]   w!1 = P!1 - 1 AND
       append(i!2`2, (: u!1 :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * (P!1 - 1))) = n_mid

Rerunning step: (case "P!1=p" "i!3=p-1")
Case splitting on 
   P!1 = p, 
   i!3 = p - 1, 
this yields  3 subgoals: 
restrictpostmid_last.1.2.1.2.2.1 : 
;;; 2 cannot be true, so we will have to prove each conjunct of 1

{-1}  i!3 = p - 1
{-2}  P!1 = p
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + i!3
[-5]  length(i!2`1) = P!1 - 1
[-6]  length(i!2`2) = P!1 - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!2`2 = remove(hu_list, i!3)
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(i!3)
[-12] 2 <= P!1
  |-------
[1]   w!1 = P!1 - 1 AND
       append(i!2`2, (: u!1 :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * (P!1 - 1))) = n_mid

Rerunning step: (replace* -1 -2 -11)
Repeatedly applying the replace rule,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.1 : 
;;; 2 cannot be true, so we will have to prove each conjunct of 1

[-1]  i!3 = p - 1
[-2]  P!1 = p
[-3]  length(nl1!1) = mid
{-4}  length(nl2!1) = -1 - mid + (p - 1)
{-5}  length(i!2`1) = p - 1
{-6}  length(i!2`2) = p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
{-9}  i!2`2 = remove(hu_list, p - 1)
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
{-11} u!1 = hu(p - 1)
{-12} 2 <= p
  |-------
{1}   w!1 = p - 1 AND
       append(i!2`2, (: hu(p - 1) :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * (p - 1))) = n_mid

Rerunning step: (comment "prove each of the conjuncts in 1, except for the first which will help to prove 2")
Adding comment: prove each of the conjuncts in 1, except for the first which will help to prove 2
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.1 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

[-1]  i!3 = p - 1
[-2]  P!1 = p
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + (p - 1)
[-5]  length(i!2`1) = p - 1
[-6]  length(i!2`2) = p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!2`2 = remove(hu_list, p - 1)
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(p - 1)
[-12] 2 <= p
  |-------
[1]   w!1 = p - 1 AND
       append(i!2`2, (: hu(p - 1) :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * (p - 1))) = n_mid

Rerunning step: (split)
Splitting conjunctions,
this yields  3 subgoals: 
restrictpostmid_last.1.2.1.2.2.1.1 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

[-1]  i!3 = p - 1
[-2]  P!1 = p
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + (p - 1)
[-5]  length(i!2`1) = p - 1
[-6]  length(i!2`2) = p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!2`2 = remove(hu_list, p - 1)
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(p - 1)
[-12] 2 <= p
  |-------
{1}   w!1 = p - 1

Rerunning step: (typepred "w!1" "i!3")
Adding type constraints for  w!1, i!3,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.1.1 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

{-1}  mid < w!1
{-2}  w!1 < p
{-3}  mid < i!3
{-4}  i!3 <= w!1
[-5]  i!3 = p - 1
[-6]  P!1 = p
[-7]  length(nl1!1) = mid
[-8]  length(nl2!1) = -1 - mid + (p - 1)
[-9]  length(i!2`1) = p - 1
[-10] length(i!2`2) = p - 1
[-11] (length(hu_list) = p)
[-12] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-13] i!2`2 = remove(hu_list, p - 1)
[-14] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-15] u!1 = hu(p - 1)
[-16] 2 <= p
  |-------
[1]   w!1 = p - 1

Rerunning step: (delete -1 -3 -6 -7 -8 -9 -10 -11 -12 -13 -14 -15 -16)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.1.1 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

[-1]  w!1 < p
[-2]  i!3 <= w!1
[-3]  i!3 = p - 1
  |-------
[1]   w!1 = p - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_last.1.2.1.2.2.1.1.

restrictpostmid_last.1.2.1.2.2.1.2 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

[-1]  i!3 = p - 1
[-2]  P!1 = p
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + (p - 1)
[-5]  length(i!2`1) = p - 1
[-6]  length(i!2`2) = p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!2`2 = remove(hu_list, p - 1)
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(p - 1)
[-12] 2 <= p
  |-------
{1}   append(i!2`2, (: hu(p - 1) :)) = hu_list

Rerunning step: (inst -8 "p-1")
Instantiating the top quantifier in -8 with the terms: 
 p-1,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.1.2 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

[-1]  i!3 = p - 1
[-2]  P!1 = p
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + (p - 1)
[-5]  length(i!2`1) = p - 1
[-6]  length(i!2`2) = p - 1
[-7]  (length(hu_list) = p)
{-8}  nth(hu_list, p - 1) = hu(p - 1)
[-9]  i!2`2 = remove(hu_list, p - 1)
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(p - 1)
[-12] 2 <= p
  |-------
[1]   append(i!2`2, (: hu(p - 1) :)) = hu_list

Rerunning step: (replace -8 1 rl)
Replacing using formula -8,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.1.2 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

[-1]  i!3 = p - 1
[-2]  P!1 = p
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + (p - 1)
[-5]  length(i!2`1) = p - 1
[-6]  length(i!2`2) = p - 1
[-7]  (length(hu_list) = p)
[-8]  nth(hu_list, p - 1) = hu(p - 1)
[-9]  i!2`2 = remove(hu_list, p - 1)
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(p - 1)
[-12] 2 <= p
  |-------
{1}   append(i!2`2, (: nth(hu_list, p - 1) :)) = hu_list

Rerunning step: (delete -3 -4 -5 -10 -11)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.1.2 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

[-1]  i!3 = p - 1
[-2]  P!1 = p
[-3]  length(i!2`2) = p - 1
[-4]  (length(hu_list) = p)
[-5]  nth(hu_list, p - 1) = hu(p - 1)
[-6]  i!2`2 = remove(hu_list, p - 1)
[-7]  2 <= p
  |-------
[1]   append(i!2`2, (: nth(hu_list, p - 1) :)) = hu_list

Rerunning step: (rewrite "length_nth_equality[Identity]")
Found matching substitution:
l2: list[Identity] gets hu_list,
l1: list[Identity] gets append(i!2`2, (: nth(hu_list, p - 1) :)),
Rewriting using length_nth_equality[Identity], matching in *,
this yields  2 subgoals: 
restrictpostmid_last.1.2.1.2.2.1.2.1 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

[-1]  i!3 = p - 1
[-2]  P!1 = p
[-3]  length(i!2`2) = p - 1
[-4]  (length(hu_list) = p)
[-5]  nth(hu_list, p - 1) = hu(p - 1)
[-6]  i!2`2 = remove(hu_list, p - 1)
[-7]  2 <= p
  |-------
{1}   length[Identity](append(i!2`2, (: nth(hu_list, p - 1) :))) =
       length[Identity](hu_list)
[2]   append(i!2`2, (: nth(hu_list, p - 1) :)) = hu_list

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets (: nth(hu_list, p - 1) :),
l1: list[T] gets i!2`2,
Rewriting using length_append, matching in 1,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.1.2.1 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

[-1]  i!3 = p - 1
[-2]  P!1 = p
[-3]  length(i!2`2) = p - 1
[-4]  (length(hu_list) = p)
[-5]  nth(hu_list, p - 1) = hu(p - 1)
[-6]  i!2`2 = remove(hu_list, p - 1)
[-7]  2 <= p
  |-------
{1}   length((: nth(hu_list, p - 1) :)) + length(i!2`2) =
       length[Identity](hu_list)
[2]   append(i!2`2, (: nth(hu_list, p - 1) :)) = hu_list

Rerunning step: (delete -1 -2 -5 -6 -7 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.1.2.1 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

[-1]  length(i!2`2) = p - 1
[-2]  (length(hu_list) = p)
  |-------
[1]   length((: nth(hu_list, p - 1) :)) + length(i!2`2) =
       length[Identity](hu_list)

Rerunning step: (grind)
nth rewrites nth(cdr(hu_list), p - 2)
  to nth(cdr(cdr(hu_list)), p - 3)
nth rewrites nth(hu_list, p - 1)
  to nth(cdr(cdr(hu_list)), p - 3)
length rewrites length[Identity]((: :))
  to 0
length rewrites length((: nth(cdr(cdr(hu_list)), p - 3) :))
  to 1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpostmid_last.1.2.1.2.2.1.2.1.

restrictpostmid_last.1.2.1.2.2.1.2.2 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

[-1]  i!3 = p - 1
[-2]  P!1 = p
[-3]  length(i!2`2) = p - 1
[-4]  (length(hu_list) = p)
[-5]  nth(hu_list, p - 1) = hu(p - 1)
[-6]  i!2`2 = remove(hu_list, p - 1)
[-7]  2 <= p
  |-------
{1}   FORALL (i:
                below[length[Identity]
                          (append(i!2`2, (: nth(hu_list, p - 1) :)))]):
        nth(append(i!2`2, (: nth(hu_list, p - 1) :)), i) = nth(hu_list, i)
[2]   append(i!2`2, (: nth(hu_list, p - 1) :)) = hu_list

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.1.2.2 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

{-1}  i!4 < length[Identity](append(i!2`2, (: nth(hu_list, p - 1) :)))
[-2]  i!3 = p - 1
[-3]  P!1 = p
[-4]  length(i!2`2) = p - 1
[-5]  (length(hu_list) = p)
[-6]  nth(hu_list, p - 1) = hu(p - 1)
[-7]  i!2`2 = remove(hu_list, p - 1)
[-8]  2 <= p
  |-------
{1}   nth(append(i!2`2, (: nth(hu_list, p - 1) :)), i!4) = nth(hu_list, i!4)
[2]   append(i!2`2, (: nth(hu_list, p - 1) :)) = hu_list

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets (: nth(hu_list, p - 1) :),
l1: list[T] gets i!2`2,
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.1.2.2 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

{-1}  i!4 < length((: nth(hu_list, p - 1) :)) + length(i!2`2)
[-2]  i!3 = p - 1
[-3]  P!1 = p
[-4]  length(i!2`2) = p - 1
[-5]  (length(hu_list) = p)
[-6]  nth(hu_list, p - 1) = hu(p - 1)
[-7]  i!2`2 = remove(hu_list, p - 1)
[-8]  2 <= p
  |-------
[1]   nth(append(i!2`2, (: nth(hu_list, p - 1) :)), i!4) = nth(hu_list, i!4)
[2]   append(i!2`2, (: nth(hu_list, p - 1) :)) = hu_list

Rerunning step: (lemma "listprops[Identity].nth_append"
                 ("l1" "i!2`2" "l2" "(:nth(hu_list,p-1):)" "i" "i!4"))
Applying listprops[Identity].nth_append where 
  l1 gets i!2`2,
  l2 gets (: nth(hu_list, p - 1) :),
  i gets i!4,
this yields  2 subgoals: 
restrictpostmid_last.1.2.1.2.2.1.2.2.1 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

{-1}  nth(append(i!2`2, (: nth(hu_list, p - 1) :)), i!4) =
       IF i!4 < length[Identity](i!2`2) THEN nth(i!2`2, i!4)
       ELSE nth((: nth(hu_list, p - 1) :), i!4 - length[Identity](i!2`2))
       ENDIF
[-2]  i!4 < length((: nth(hu_list, p - 1) :)) + length(i!2`2)
[-3]  i!3 = p - 1
[-4]  P!1 = p
[-5]  length(i!2`2) = p - 1
[-6]  (length(hu_list) = p)
[-7]  nth(hu_list, p - 1) = hu(p - 1)
[-8]  i!2`2 = remove(hu_list, p - 1)
[-9]  2 <= p
  |-------
[1]   nth(append(i!2`2, (: nth(hu_list, p - 1) :)), i!4) = nth(hu_list, i!4)
[2]   append(i!2`2, (: nth(hu_list, p - 1) :)) = hu_list

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.1.2.2.1 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

[-1]  nth(append(i!2`2, (: nth(hu_list, p - 1) :)), i!4) =
       IF i!4 < length[Identity](i!2`2) THEN nth(i!2`2, i!4)
       ELSE nth((: nth(hu_list, p - 1) :), i!4 - length[Identity](i!2`2))
       ENDIF
[-2]  i!4 < length((: nth(hu_list, p - 1) :)) + length(i!2`2)
[-3]  i!3 = p - 1
[-4]  P!1 = p
[-5]  length(i!2`2) = p - 1
[-6]  (length(hu_list) = p)
[-7]  nth(hu_list, p - 1) = hu(p - 1)
[-8]  i!2`2 = remove(hu_list, p - 1)
[-9]  2 <= p
  |-------
{1}   IF i!4 < length[Identity](i!2`2) THEN nth(i!2`2, i!4)
      ELSE nth((: nth(hu_list, p - 1) :), i!4 - length[Identity](i!2`2))
      ENDIF
       = nth(hu_list, i!4)
[2]   append(i!2`2, (: nth(hu_list, p - 1) :)) = hu_list

Rerunning step: (delete -1 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.1.2.2.1 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

[-1]  i!4 < length((: nth(hu_list, p - 1) :)) + length(i!2`2)
[-2]  i!3 = p - 1
[-3]  P!1 = p
[-4]  length(i!2`2) = p - 1
[-5]  (length(hu_list) = p)
[-6]  nth(hu_list, p - 1) = hu(p - 1)
[-7]  i!2`2 = remove(hu_list, p - 1)
[-8]  2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`2) THEN nth(i!2`2, i!4)
      ELSE nth((: nth(hu_list, p - 1) :), i!4 - length[Identity](i!2`2))
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (case "i!4<p-1 OR i!4=p-1")
Case splitting on 
   i!4 < p - 1 OR i!4 = p - 1, 
this yields  2 subgoals: 
restrictpostmid_last.1.2.1.2.2.1.2.2.1.1 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

{-1}  i!4 < p - 1 OR i!4 = p - 1
[-2]  i!4 < length((: nth(hu_list, p - 1) :)) + length(i!2`2)
[-3]  i!3 = p - 1
[-4]  P!1 = p
[-5]  length(i!2`2) = p - 1
[-6]  (length(hu_list) = p)
[-7]  nth(hu_list, p - 1) = hu(p - 1)
[-8]  i!2`2 = remove(hu_list, p - 1)
[-9]  2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!2`2) THEN nth(i!2`2, i!4)
      ELSE nth((: nth(hu_list, p - 1) :), i!4 - length[Identity](i!2`2))
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (grind :exclude ("nth" "append" "remove"))
length rewrites length[Identity]((: :))
  to 0
length rewrites length((: nth(hu_list, p - 1) :))
  to 1
length rewrites length[Identity]((: :))
  to 0
length rewrites length((: nth(hu_list, p - 1) :))
  to 1
Trying repeated skolemization, instantiation, and if-lifting,
this yields  2 subgoals: 
restrictpostmid_last.1.2.1.2.2.1.2.2.1.1.1 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

{-1}  i!4 < p - 1
{-2}  i!4 < p
[-3]  i!3 = p - 1
[-4]  P!1 = p
{-5}  length(remove(hu_list, p - 1)) = p - 1
[-6]  (length(hu_list) = p)
[-7]  nth(hu_list, p - 1) = hu(p - 1)
[-8]  i!2`2 = remove(hu_list, p - 1)
[-9]  2 <= p
  |-------
{1}   nth(remove(hu_list, p - 1), i!4) = nth(hu_list, i!4)

Rerunning step: (lemma "listprops[Identity].nth_remove"
                 ("l" "hu_list" "i" "p-1" "j" "i!4"))
Applying listprops[Identity].nth_remove where 
  l gets hu_list,
  i gets p - 1,
  j gets i!4,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.1.2.2.1.1.1 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

{-1}  nth(remove(hu_list, p - 1), i!4) =
       IF i!4 < p - 1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF
[-2]  i!4 < p - 1
[-3]  i!4 < p
[-4]  i!3 = p - 1
[-5]  P!1 = p
[-6]  length(remove(hu_list, p - 1)) = p - 1
[-7]  (length(hu_list) = p)
[-8]  nth(hu_list, p - 1) = hu(p - 1)
[-9]  i!2`2 = remove(hu_list, p - 1)
[-10] 2 <= p
  |-------
[1]   nth(remove(hu_list, p - 1), i!4) = nth(hu_list, i!4)

Rerunning step: (delete -3 -4 -5 -6 -7 -8 -9 -10)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.1.2.2.1.1.1 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

[-1]  nth(remove(hu_list, p - 1), i!4) =
       IF i!4 < p - 1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF
[-2]  i!4 < p - 1
  |-------
[1]   nth(remove(hu_list, p - 1), i!4) = nth(hu_list, i!4)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_last.1.2.1.2.2.1.2.2.1.1.1.

restrictpostmid_last.1.2.1.2.2.1.2.2.1.1.2 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

{-1}  i!4 = p - 1
{-2}  p - 1 < p
[-3]  i!3 = p - 1
[-4]  P!1 = p
{-5}  length(remove(hu_list, p - 1)) = p - 1
[-6]  (length(hu_list) = p)
[-7]  nth(hu_list, p - 1) = hu(p - 1)
[-8]  i!2`2 = remove(hu_list, p - 1)
[-9]  2 <= p
  |-------
{1}   nth((: hu(p - 1) :), 0) = hu(p - 1)

Rerunning step: (expand "nth" 1)
Expanding the definition of nth,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.1.2.2.1.1.2 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

[-1]  i!4 = p - 1
[-2]  p - 1 < p
[-3]  i!3 = p - 1
[-4]  P!1 = p
[-5]  length(remove(hu_list, p - 1)) = p - 1
[-6]  (length(hu_list) = p)
[-7]  nth(hu_list, p - 1) = hu(p - 1)
[-8]  i!2`2 = remove(hu_list, p - 1)
[-9]  2 <= p
  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictpostmid_last.1.2.1.2.2.1.2.2.1.1.2.


This completes the proof of restrictpostmid_last.1.2.1.2.2.1.2.2.1.1.

restrictpostmid_last.1.2.1.2.2.1.2.2.1.2 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

[-1]  i!4 < length((: nth(hu_list, p - 1) :)) + length(i!2`2)
[-2]  i!3 = p - 1
[-3]  P!1 = p
[-4]  length(i!2`2) = p - 1
[-5]  (length(hu_list) = p)
[-6]  nth(hu_list, p - 1) = hu(p - 1)
[-7]  i!2`2 = remove(hu_list, p - 1)
[-8]  2 <= p
  |-------
{1}   i!4 < p - 1 OR i!4 = p - 1
[2]   IF i!4 < length[Identity](i!2`2) THEN nth(i!2`2, i!4)
      ELSE nth((: nth(hu_list, p - 1) :), i!4 - length[Identity](i!2`2))
      ENDIF
       = nth(hu_list, i!4)

Rerunning step: (delete -2 -3 -5 -6 -7 -8 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.1.2.2.1.2 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

[-1]  i!4 < length((: nth(hu_list, p - 1) :)) + length(i!2`2)
[-2]  length(i!2`2) = p - 1
  |-------
[1]   i!4 < p - 1 OR i!4 = p - 1

Rerunning step: (grind)
nth rewrites nth(cdr(hu_list), p - 2)
  to nth(cdr(cdr(hu_list)), p - 3)
nth rewrites nth(hu_list, p - 1)
  to nth(cdr(cdr(hu_list)), p - 3)
length rewrites length[Identity]((: :))
  to 0
length rewrites length((: nth(cdr(cdr(hu_list)), p - 3) :))
  to 1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpostmid_last.1.2.1.2.2.1.2.2.1.2.


This completes the proof of restrictpostmid_last.1.2.1.2.2.1.2.2.1.

restrictpostmid_last.1.2.1.2.2.1.2.2.2T (TCC):   

[-1]  i!4 < length((: nth(hu_list, p - 1) :)) + length(i!2`2)
[-2]  i!3 = p - 1
[-3]  P!1 = p
[-4]  length(i!2`2) = p - 1
[-5]  (length(hu_list) = p)
[-6]  nth(hu_list, p - 1) = hu(p - 1)
[-7]  i!2`2 = remove(hu_list, p - 1)
[-8]  2 <= p
  |-------
{1}   i!4 <
       length[Identity]((: nth[Identity](hu_list, p - 1) :)) +
        length[Identity](i!2`2)
[2]   nth(append(i!2`2, (: nth(hu_list, p - 1) :)), i!4) = nth(hu_list, i!4)
[3]   append(i!2`2, (: nth(hu_list, p - 1) :)) = hu_list

which is trivially true.

This completes the proof of restrictpostmid_last.1.2.1.2.2.1.2.2.2T.


This completes the proof of restrictpostmid_last.1.2.1.2.2.1.2.2.


This completes the proof of restrictpostmid_last.1.2.1.2.2.1.2.

restrictpostmid_last.1.2.1.2.2.1.3 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

[-1]  i!3 = p - 1
[-2]  P!1 = p
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -1 - mid + (p - 1)
[-5]  length(i!2`1) = p - 1
[-6]  length(i!2`2) = p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!2`2 = remove(hu_list, p - 1)
[-10] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-11] u!1 = hu(p - 1)
[-12] 2 <= p
  |-------
{1}   nth(i!2`1, floor((mid / (p - 1)) * (p - 1))) = n_mid

Rerunning step: (lemma "select_right_nonce3" ("P" "P!1"))
Applying select_right_nonce3 where 
  P gets P!1,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.1.3 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

{-1}  (P!1 = p IMPLIES floor((mid / (p - 1)) * (P!1 - 1)) = mid) AND
       floor((mid / (p - 1)) * (P!1 - 1)) >= 0 AND
        floor((mid / (p - 1)) * (P!1 - 1)) < P!1 - 1
[-2]  i!3 = p - 1
[-3]  P!1 = p
[-4]  length(nl1!1) = mid
[-5]  length(nl2!1) = -1 - mid + (p - 1)
[-6]  length(i!2`1) = p - 1
[-7]  length(i!2`2) = p - 1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!2`2 = remove(hu_list, p - 1)
[-11] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-12] u!1 = hu(p - 1)
[-13] 2 <= p
  |-------
[1]   nth(i!2`1, floor((mid / (p - 1)) * (p - 1))) = n_mid

Rerunning step: (ground)
Applying propositional simplification and decision procedures,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.1.3 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

{-1}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) = mid
{-2}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
{-3}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  i!3 = p - 1
[-5]  P!1 = p
[-6]  length(nl1!1) = mid
{-7}  length(nl2!1) = -2 - mid + p
[-8]  length(i!2`1) = p - 1
[-9]  length(i!2`2) = p - 1
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] i!2`2 = remove(hu_list, p - 1)
[-13] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-14] u!1 = hu(p - 1)
[-15] 2 <= p
  |-------
{1}   nth(i!2`1, floor((mid / (p - 1)) * p - (mid / (p - 1)))) = n_mid

Rerunning step: (replace -5 -1)
Replacing using formula -5,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.1.3 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

{-1}  floor((mid / (p - 1)) * p - (mid / (p - 1))) = mid
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  i!3 = p - 1
[-5]  P!1 = p
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -2 - mid + p
[-8]  length(i!2`1) = p - 1
[-9]  length(i!2`2) = p - 1
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] i!2`2 = remove(hu_list, p - 1)
[-13] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-14] u!1 = hu(p - 1)
[-15] 2 <= p
  |-------
[1]   nth(i!2`1, floor((mid / (p - 1)) * p - (mid / (p - 1)))) = n_mid

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.1.3 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

[-1]  floor((mid / (p - 1)) * p - (mid / (p - 1))) = mid
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  i!3 = p - 1
[-5]  P!1 = p
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -2 - mid + p
[-8]  length(i!2`1) = p - 1
[-9]  length(i!2`2) = p - 1
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] i!2`2 = remove(hu_list, p - 1)
[-13] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-14] u!1 = hu(p - 1)
[-15] 2 <= p
  |-------
{1}   nth(i!2`1, mid) = n_mid

Rerunning step: (replace -13 1)
Replacing using formula -13,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.1.3 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

[-1]  floor((mid / (p - 1)) * p - (mid / (p - 1))) = mid
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  i!3 = p - 1
[-5]  P!1 = p
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -2 - mid + p
[-8]  length(i!2`1) = p - 1
[-9]  length(i!2`2) = p - 1
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] i!2`2 = remove(hu_list, p - 1)
[-13] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-14] u!1 = hu(p - 1)
[-15] 2 <= p
  |-------
{1}   nth(append(nl1!1, cons(n_mid, nl2!1)), mid) = n_mid

Rerunning step: (rewrite "nth_append" 1)
Found matching substitution:
i: below[length(l1) + length(l2)] gets mid,
l2: list[T] gets cons(n_mid, nl2!1),
l1: list[T] gets nl1!1,
Rewriting using nth_append, matching in 1,
this yields  2 subgoals: 
restrictpostmid_last.1.2.1.2.2.1.3.1 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

[-1]  floor((mid / (p - 1)) * p - (mid / (p - 1))) = mid
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  i!3 = p - 1
[-5]  P!1 = p
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -2 - mid + p
[-8]  length(i!2`1) = p - 1
[-9]  length(i!2`2) = p - 1
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] i!2`2 = remove(hu_list, p - 1)
[-13] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-14] u!1 = hu(p - 1)
[-15] 2 <= p
  |-------
{1}   nth(cons(n_mid, nl2!1), mid - length[Identity](nl1!1)) = n_mid

Rerunning step: (delete -1 -2
                  -3 -4
                  -5 -7
                  -8 -9
                  -10 -11
                  -12 -13
                  -14 -15
                  2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.1.3.1 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

[-1]  length(nl1!1) = mid
  |-------
[1]   nth(cons(n_mid, nl2!1), mid - length[Identity](nl1!1)) = n_mid

Rerunning step: (grind)
nth rewrites nth(cons(n_mid, nl2!1), mid - length[Identity](nl1!1))
  to n_mid
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpostmid_last.1.2.1.2.2.1.3.1.

restrictpostmid_last.1.2.1.2.2.1.3.2 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

[-1]  floor((mid / (p - 1)) * p - (mid / (p - 1))) = mid
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  i!3 = p - 1
[-5]  P!1 = p
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -2 - mid + p
[-8]  length(i!2`1) = p - 1
[-9]  length(i!2`2) = p - 1
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] i!2`2 = remove(hu_list, p - 1)
[-13] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-14] u!1 = hu(p - 1)
[-15] 2 <= p
  |-------
{1}   mid <
       length[Identity](cons[Nonce](n_mid, nl2!1)) + length[Identity](nl1!1)
[2]   nth(append(nl1!1, cons(n_mid, nl2!1)), mid) = n_mid

Rerunning step: (expand "length" 1 1)
Expanding the definition of length,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.1.3.2 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

[-1]  floor((mid / (p - 1)) * p - (mid / (p - 1))) = mid
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  i!3 = p - 1
[-5]  P!1 = p
[-6]  length(nl1!1) = mid
[-7]  length(nl2!1) = -2 - mid + p
[-8]  length(i!2`1) = p - 1
[-9]  length(i!2`2) = p - 1
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] i!2`2 = remove(hu_list, p - 1)
[-13] i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-14] u!1 = hu(p - 1)
[-15] 2 <= p
  |-------
{1}   mid < 1 + length[Identity](nl1!1) + length[Identity](nl2!1)
[2]   nth(append(nl1!1, cons(n_mid, nl2!1)), mid) = n_mid

Rerunning step: (delete -1 -2
                  -3 -4
                  -5 -8
                  -9 -10
                  -11 -12
                  -13 -14
                  -15 2
                  3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.1.3.2 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -2 - mid + p
  |-------
[1]   mid < 1 + length[Identity](nl1!1) + length[Identity](nl2!1)

Rerunning step: (typepred "mid")
Adding type constraints for  mid,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.1.3.2 : 
;;; prove each of the conjuncts in 1, except for the first which will help to prove 2

{-1}  0 < mid
{-2}  mid < p - 1
[-3]  length(nl1!1) = mid
[-4]  length(nl2!1) = -2 - mid + p
  |-------
[1]   mid < 1 + length[Identity](nl1!1) + length[Identity](nl2!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_last.1.2.1.2.2.1.3.2.


This completes the proof of restrictpostmid_last.1.2.1.2.2.1.3.


This completes the proof of restrictpostmid_last.1.2.1.2.2.1.

restrictpostmid_last.1.2.1.2.2.2 : 
;;; 2 cannot be true, so we will have to prove each conjunct of 1

{-1}  P!1 = p
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  length(i!2`1) = P!1 - 1
[-5]  length(i!2`2) = P!1 - 1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!2`2 = remove(hu_list, i!3)
[-9]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-10] u!1 = hu(i!3)
[-11] 2 <= P!1
  |-------
{1}   i!3 = p - 1
[2]   w!1 = P!1 - 1 AND
       append(i!2`2, (: u!1 :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * (P!1 - 1))) = n_mid

Rerunning step: (replace -9 -4)
Replacing using formula -9,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.2 : 
;;; 2 cannot be true, so we will have to prove each conjunct of 1

[-1]  P!1 = p
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
{-4}  length(append(nl1!1, cons(n_mid, nl2!1))) = P!1 - 1
[-5]  length(i!2`2) = P!1 - 1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!2`2 = remove(hu_list, i!3)
[-9]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-10] u!1 = hu(i!3)
[-11] 2 <= P!1
  |-------
[1]   i!3 = p - 1
[2]   w!1 = P!1 - 1 AND
       append(i!2`2, (: u!1 :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * (P!1 - 1))) = n_mid

Rerunning step: (rewrite "length_append" -4)
Found matching substitution:
l2: list[T] gets cons(n_mid, nl2!1),
l1: list[T] gets nl1!1,
Rewriting using length_append, matching in -4,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.2 : 
;;; 2 cannot be true, so we will have to prove each conjunct of 1

[-1]  P!1 = p
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
{-4}  length(cons(n_mid, nl2!1)) + length(nl1!1) = P!1 - 1
[-5]  length(i!2`2) = P!1 - 1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!2`2 = remove(hu_list, i!3)
[-9]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-10] u!1 = hu(i!3)
[-11] 2 <= P!1
  |-------
[1]   i!3 = p - 1
[2]   w!1 = P!1 - 1 AND
       append(i!2`2, (: u!1 :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * (P!1 - 1))) = n_mid

Rerunning step: (expand "length" -4 1)
Expanding the definition of length,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.2 : 
;;; 2 cannot be true, so we will have to prove each conjunct of 1

[-1]  P!1 = p
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
{-4}  1 + length(nl1!1) + length[Identity](nl2!1) = P!1 - 1
[-5]  length(i!2`2) = P!1 - 1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!2`2 = remove(hu_list, i!3)
[-9]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-10] u!1 = hu(i!3)
[-11] 2 <= P!1
  |-------
[1]   i!3 = p - 1
[2]   w!1 = P!1 - 1 AND
       append(i!2`2, (: u!1 :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * (P!1 - 1))) = n_mid

Rerunning step: (delete -5 -6 -7 -8 -9 -10 -11 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.2 : 
;;; 2 cannot be true, so we will have to prove each conjunct of 1

[-1]  P!1 = p
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  1 + length(nl1!1) + length[Identity](nl2!1) = P!1 - 1
  |-------
[1]   i!3 = p - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_last.1.2.1.2.2.2.

restrictpostmid_last.1.2.1.2.2.3 : 
;;; 2 cannot be true, so we will have to prove each conjunct of 1

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  i!2`2 = remove(hu_list, i!3)
[-8]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-9]  u!1 = hu(i!3)
[-10] 2 <= P!1
  |-------
{1}   P!1 = p
[2]   w!1 = P!1 - 1 AND
       append(i!2`2, (: u!1 :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * (P!1 - 1))) = n_mid

Rerunning step: (replace -7 -4)
Replacing using formula -7,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.3 : 
;;; 2 cannot be true, so we will have to prove each conjunct of 1

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  length(i!2`1) = P!1 - 1
{-4}  length(remove(hu_list, i!3)) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  i!2`2 = remove(hu_list, i!3)
[-8]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-9]  u!1 = hu(i!3)
[-10] 2 <= P!1
  |-------
[1]   P!1 = p
[2]   w!1 = P!1 - 1 AND
       append(i!2`2, (: u!1 :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * (P!1 - 1))) = n_mid

Rerunning step: (rewrite "length_remove" -4 :dir rl)
Found matching substitution:
i: below[length(c)] gets i!3,
c: (cons?[T]) gets hu_list,
Rewriting using length_remove, matching in -4,
this yields  2 subgoals: 
restrictpostmid_last.1.2.1.2.2.3.1 : 
;;; 2 cannot be true, so we will have to prove each conjunct of 1

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  length(i!2`1) = P!1 - 1
{-4}  length[Identity](hu_list) - 1 = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  i!2`2 = remove(hu_list, i!3)
[-8]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-9]  u!1 = hu(i!3)
[-10] 2 <= P!1
  |-------
[1]   P!1 = p
[2]   w!1 = P!1 - 1 AND
       append(i!2`2, (: u!1 :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * (P!1 - 1))) = n_mid

Rerunning step: (delete -1 -2 -3 -6 -7 -8 -9 -10 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.3.1 : 
;;; 2 cannot be true, so we will have to prove each conjunct of 1

[-1]  length[Identity](hu_list) - 1 = P!1 - 1
[-2]  (length(hu_list) = p)
  |-------
[1]   P!1 = p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_last.1.2.1.2.2.3.1.

restrictpostmid_last.1.2.1.2.2.3.2 : 
;;; 2 cannot be true, so we will have to prove each conjunct of 1

[-1]  length(nl1!1) = mid
[-2]  length(nl2!1) = -1 - mid + i!3
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(remove(hu_list, i!3)) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  i!2`2 = remove(hu_list, i!3)
[-8]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-9]  u!1 = hu(i!3)
[-10] 2 <= P!1
  |-------
{1}   cons?[Identity](hu_list)
[2]   P!1 = p
{3}   w!1 = P!1 - 1 AND
       append(i!2`2, (: u!1 :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * P!1 - (mid / (p - 1)))) = n_mid

Rerunning step: (typepred "p")
Adding type constraints for  p,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.3.2 : 
;;; 2 cannot be true, so we will have to prove each conjunct of 1

{-1}  3 <= p
[-2]  length(nl1!1) = mid
[-3]  length(nl2!1) = -1 - mid + i!3
[-4]  length(i!2`1) = P!1 - 1
[-5]  length(remove(hu_list, i!3)) = P!1 - 1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!2`2 = remove(hu_list, i!3)
[-9]  i!2`1 = append(nl1!1, cons(n_mid, nl2!1))
[-10] u!1 = hu(i!3)
[-11] 2 <= P!1
  |-------
[1]   cons?[Identity](hu_list)
[2]   P!1 = p
[3]   w!1 = P!1 - 1 AND
       append(i!2`2, (: u!1 :)) = hu_list AND
        nth(i!2`1, floor((mid / (p - 1)) * P!1 - (mid / (p - 1)))) = n_mid

Rerunning step: (delete -2 -3 -4 -5 -7 -8 -9 -10 -11 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last.1.2.1.2.2.3.2 : 
;;; 2 cannot be true, so we will have to prove each conjunct of 1

[-1]  3 <= p
[-2]  (length(hu_list) = p)
  |-------
[1]   cons?[Identity](hu_list)

Rerunning step: (nonemptylist "hu_list")
Relating existence of a tail to a list's length,

This completes the proof of restrictpostmid_last.1.2.1.2.2.3.2.


This completes the proof of restrictpostmid_last.1.2.1.2.2.3.


This completes the proof of restrictpostmid_last.1.2.1.2.2.


This completes the proof of restrictpostmid_last.1.2.1.2.


This completes the proof of restrictpostmid_last.1.2.1.

restrictpostmid_last.1.2.2 :  

[-1]  rho_postmid(w!1)(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  2 <= P!1
  |-------
{1}   ((rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :)))) >>
         Stop[event])
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
{2}   R_postmid(w!1)
               (trans(u!1, car(i!2`2),
                      E(public(car(i!2`2)),
                        conc(nlist(append(i!2`1, (: i!1 :))),
                             ilist(append(cdr(i!2`2), (: u!1 :)))))))
{3}   trans(u!1, car(i!2`2),
            E(public(car(i!2`2)),
              conc(nlist(append(i!2`1, (: i!1 :))),
                   ilist(append(cdr(i!2`2), (: u!1 :))))))
       >>
       ((rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :)))) >>
          Stop[event])
         # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   R_postmid(w!1)
               (signal(running(P!1 - 1, append(i!2`2, (: u!1 :)),
                               nth(i!2`1,
                                   floor((mid / (p - 1)) * P!1
                                         -
                                         (mid / (p - 1)))))))

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last.1.2.2 :  

[-1]  rho_postmid(w!1)(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-4]  2 <= P!1
  |-------
[1]   ((rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :)))) >>
         Stop[event])
        # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[2]   R_postmid(w!1)
               (signal(running(P!1 - 1, append(i!2`2, (: u!1 :)),
                               nth(i!2`1,
                                   floor((mid / (p - 1)) * P!1
                                         -
                                         (mid / (p - 1)))))))

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictpostmid_last.1.2.2 :  

{-1}  rho_postmid(w!1)(E(public(u!1), nlist((: i!1 :))))
[-2]  rho_postmid(w!1)(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-4]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-5]  2 <= P!1
  |-------
{1}   (Stop[event] # R_postmid(w!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
{2}   R_postmid(w!1)
               (rec(u!1, nth(i!2`2, P!1 - 2),
                    E(public(u!1), nlist((: i!1 :)))))
{3}   rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :)))) >>
       (Stop[event] # R_postmid(w!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)
[4]   R_postmid(w!1)
               (signal(running(P!1 - 1, append(i!2`2, (: u!1 :)),
                               nth(i!2`1,
                                   floor((mid / (p - 1)) * P!1
                                         -
                                         (mid / (p - 1)))))))

Rerunning step: (delete - 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last.1.2.2 :  

  |-------
[1]   (Stop[event] # R_postmid(w!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictpostmid_last.1.2.2.


This completes the proof of restrictpostmid_last.1.2.


This completes the proof of restrictpostmid_last.1.

restrictpostmid_last.2 :  

{-1}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
{-2}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!1 :))
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (signal(running(P!1 - 1, append(i`2, (: u!1 :)),
                          nth(i`1,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(nlist(append(i`1, (: i!1 :))),
                          ilist(append(cdr(i`2), (: u!1 :))))))
              >>
              (rec(u!1, nth(i`2, P!1 - 2),
                   E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last.2 :  

  |-------
[1]   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!1 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!1 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpostmid_last.2.

restrictpostmid_last.3 :  

{-1}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
{-2}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   cons?[Identity](i!2`2)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (signal(running(P!1 - 1, append(i`2, (: u!1 :)),
                          nth(i`1,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(nlist(append(i`1, (: i!1 :))),
                          ilist(append(cdr(i`2), (: u!1 :))))))
              >>
              (rec(u!1, nth(i`2, P!1 - 2),
                   E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -2 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last.3 :  

[-1]  2 <= P!1
  |-------
[1]   cons?[Identity](i!2`2)

Rerunning step: (nonemptylist "i!2`2")
Relating existence of a tail to a list's length,

This completes the proof of restrictpostmid_last.3.

restrictpostmid_last.4 :  

{-1}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
{-2}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < length[Nonce](i!2`1)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (signal(running(P!1 - 1, append(i`2, (: u!1 :)),
                          nth(i`1,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(nlist(append(i`1, (: i!1 :))),
                          ilist(append(cdr(i`2), (: u!1 :))))))
              >>
              (rec(u!1, nth(i`2, P!1 - 2),
                   E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (typepred "i!2`1")
Adding type constraints for  i!2`1,
this simplifies to: 
restrictpostmid_last.4 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`1)
{-2}  length(i!2`1) = P!1 - 1
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-4]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < length[Nonce](i!2`1)
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (signal(running(P!1 - 1, append(i`2, (: u!1 :)),
                          nth(i`1,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(nlist(append(i`1, (: i!1 :))),
                          ilist(append(cdr(i`2), (: u!1 :))))))
              >>
              (rec(u!1, nth(i`2, P!1 - 2),
                   E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -3 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last.4 :  

[-1]  length(i!2`1) = P!1 - 1
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-3]  2 <= P!1
  |-------
[1]   floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < length[Nonce](i!2`1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_last.4.

restrictpostmid_last.5 :  

{-1}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
{-2}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   P!1 - 2 < length[Identity](i!2`2)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (signal(running(P!1 - 1, append(i`2, (: u!1 :)),
                          nth(i`1,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(nlist(append(i`1, (: i!1 :))),
                          ilist(append(cdr(i`2), (: u!1 :))))))
              >>
              (rec(u!1, nth(i`2, P!1 - 2),
                   E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (typepred "i!2`2")
Adding type constraints for  i!2`2,
this simplifies to: 
restrictpostmid_last.5 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`2)
{-2}  length(i!2`2) = P!1 - 1
[-3]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-4]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-5]  2 <= P!1
  |-------
[1]   P!1 - 2 < length[Identity](i!2`2)
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (signal(running(P!1 - 1, append(i`2, (: u!1 :)),
                          nth(i`1,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(nlist(append(i`1, (: i!1 :))),
                          ilist(append(cdr(i`2), (: u!1 :))))))
              >>
              (rec(u!1, nth(i`2, P!1 - 2),
                   E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
         # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -3 -4 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last.5 :  

[-1]  length(i!2`2) = P!1 - 1
[-2]  2 <= P!1
  |-------
[1]   P!1 - 2 < length[Identity](i!2`2)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictpostmid_last.5.

restrictpostmid_last.6 :  

{-1}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
{-2}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!1 :))
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (signal(running(P!1 - 1, append(il, (: u!1 :)),
                          nth(nl,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(nlist(append(nl, (: i!1 :))),
                          ilist(append(cdr(il), (: u!1 :))))))
              >>
              (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last.6 :  

  |-------
[1]   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!1 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!1 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictpostmid_last.6.

restrictpostmid_last.7 :  

{-1}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
{-2}  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        cons?[Identity](il)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (signal(running(P!1 - 1, append(il, (: u!1 :)),
                          nth(nl,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(nlist(append(nl, (: i!1 :))),
                          ilist(append(cdr(il), (: u!1 :))))))
              >>
              (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictpostmid_last.7 :  

[-1]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) >= 0
[-2]  floor((mid / (p - 1)) * P!1 - (mid / (p - 1))) < P!1 - 1
[-3]  2 <= P!1
  |-------
{1}   cons?[Identity](il!1)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (signal(running(P!1 - 1, append(il, (: u!1 :)),
                          nth(nl,
                              floor((mid / (p - 1)) * P!1
                                    -
                                    (mid / (p - 1))))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(nlist(append(nl, (: i!1 :))),
                          ilist(append(cdr(il), (: u!1 :))))))
              >>
              (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_postmid(w!1)(msg(e)))(t)
          =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -2 2)
Deleting some formulas,
this simplifies to: 
restrictpostmid_last.7 :  

[-1]  2 <= P!1
  |-------
[1]   cons?[Identity](il!1)

Rerunning step: (nonemptylist "il!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictpostmid_last.7.

Q.E.D.


Run time  = 4.31 secs.
Real time = 5.86 secs.
nil
pvs(87): 
Installing rewrite rule sets.singleton_rew (all instances)
authentication_postmid :  

  |-------
{1}   FORALL (w: {x: nat | mid < x AND x < p}):
        network(USER) |> auth(T, R_postmid(w))

Rerunning step: (auto-rewrite-theory "sets")
Rewriting relative to the theory: sets,
this simplifies to: 
authentication_postmid :  

  |-------
[1]   FORALL (w: {x: nat | mid < x AND x < p}):
        network(USER) |> auth(T, R_postmid(w))

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_postmid :  

  |-------
{1}   network(USER) |> auth(T, R_postmid(w!1))

Rerunning step: (rewrite "authentication_by_rank" +
                 ("rho" "rho_postmid(w!1)"))
Found matching substitution:
R: setof[event] gets R_postmid(w!1),
T: setof[event] gets T,
users: [Identity -> process[event]] gets USER,
rho: setof[Message] gets rho_postmid(w!1),
member rewrites member(x, INIT)
  to INIT(x)
member rewrites member(x, rho_postmid(w!1))
  to rho_postmid(w!1)(x)
subset? rewrites subset?(INIT, rho_postmid(w!1))
  to FORALL (x: Message): INIT(x) => rho_postmid(w!1)(x)
member rewrites member(x, S)
  to S(x)
member rewrites member(x, rho_postmid(w!1))
  to rho_postmid(w!1)(x)
subset? rewrites subset?(S, rho_postmid(w!1))
  to FORALL (x: Message): S(x) => rho_postmid(w!1)(x)
Rewriting using authentication_by_rank, matching in + where
  rho gets rho_postmid(w!1),
this yields  4 subgoals: 
authentication_postmid.1 :  

  |-------
{1}   FORALL (x: Message): INIT(x) => rho_postmid(w!1)(x)
[2]   network(USER) |> auth(T, R_postmid(w!1))

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_postmid.1 :  

  |-------
[1]   FORALL (x: Message): INIT(x) => rho_postmid(w!1)(x)

Rerunning step: (comment "intruder's initial knowledge is in rho")
Adding comment: intruder's initial knowledge is in rho
this simplifies to: 
authentication_postmid.1 : 
;;; intruder's initial knowledge is in rho

  |-------
[1]   FORALL (x: Message): INIT(x) => rho_postmid(w!1)(x)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_postmid.1 : 
;;; intruder's initial knowledge is in rho

  |-------
{1}   INIT(x!1) => rho_postmid(w!1)(x!1)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_postmid.1 : 
;;; intruder's initial knowledge is in rho

{-1}  INIT(x!1)
  |-------
{1}   rho_postmid(w!1)(x!1)

Rerunning step: (expand "INIT")
Expanding the definition of INIT,
this simplifies to: 
authentication_postmid.1 : 
;;; intruder's initial knowledge is in rho

{-1}  CASES x!1
        OF user(z): TRUE,
           nonce(z): z /= n_mid,
           public(z): TRUE,
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i))
        ELSE FALSE
        ENDCASES
  |-------
[1]   rho_postmid(w!1)(x!1)

Rerunning step: (expand "rho_postmid")
Expanding the definition of rho_postmid,
this simplifies to: 
authentication_postmid.1 : 
;;; intruder's initial knowledge is in rho

[-1]  CASES x!1
        OF user(z): TRUE,
           nonce(z): z /= n_mid,
           public(z): TRUE,
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i))
        ELSE FALSE
        ENDCASES
  |-------
{1}   CASES x!1
        OF nonce(z): z /= n_mid,
           nlist(z): NOT elt(z, n_mid),
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i)),
           conc(z1, z2): rho_postmid(w!1)(z1) AND rho_postmid(w!1)(z2),
           commit(z1, z2, z3): z1 /= mid OR z2 /= hu_list OR z3 /= n_mid,
           code(z1, z2):
             rho_postmid(w!1)(z2) OR
              EXISTS (i: {x: nat | mid < x AND x <= w!1}):
                z1 = public(hu(i)) AND
                 EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                         nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
                   z2 =
                    conc(nlist(append(nl1, cons(n_mid, nl2))),
                         ilist(remove(hu_list, i)))
        ELSE TRUE
        ENDCASES

Rerunning step: (smash)
Repeatedly simplifying with BDDs, decision procedures, rewriting,
and if-lifting,

This completes the proof of authentication_postmid.1.

authentication_postmid.2 :  

  |-------
{1}   FORALL (S: setof[Message]), (m: Message):
        (FORALL (x: Message): S(x) => rho_postmid(w!1)(x)) AND (S |- m)
         IMPLIES rho_postmid(w!1)(m)
[2]   network(USER) |> auth(T, R_postmid(w!1))

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2 :  

  |-------
[1]   FORALL (S: setof[Message]), (m: Message):
        (FORALL (x: Message): S(x) => rho_postmid(w!1)(x)) AND (S |- m)
         IMPLIES rho_postmid(w!1)(m)

Rerunning step: (comment "from of a set of messages in rho, no message not in rho can be generated")
Adding comment: from of a set of messages in rho, no message not in rho can be generated
this simplifies to: 
authentication_postmid.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   FORALL (S: setof[Message]), (m: Message):
        (FORALL (x: Message): S(x) => rho_postmid(w!1)(x)) AND (S |- m)
         IMPLIES rho_postmid(w!1)(m)

Rerunning step: (expand "|-")
Expanding the definition of |-,
this simplifies to: 
authentication_postmid.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   FORALL (S: setof[Message]), (m: Message):
        (FORALL (x: Message): S(x) => rho_postmid(w!1)(x)) AND Gen(S, m)
         IMPLIES rho_postmid(w!1)(m)

Rerunning step: (rule-induct "Gen")
Applying rule (co)induction over Gen,
this simplifies to: 
authentication_postmid.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  FORALL (x: Message): S!1(x) => rho_postmid(w!1)(x)
  |-------
{1}   FORALL (m: Message):
        (     S!1(m)
          OR (EXISTS m1, m2:
                rho_postmid(w!1)(m1) AND
                 rho_postmid(w!1)(m2) AND m = conc(m1, m2))
          OR (EXISTS m1: rho_postmid(w!1)(conc(m1, m)))
          OR (EXISTS m2: rho_postmid(w!1)(conc(m, m2)))
          OR (EXISTS (n: Nonce):
                rho_postmid(w!1)(nonce(n)) AND m = nlist((: n :)))
          OR (EXISTS (n: Nonce):
                rho_postmid(w!1)(nlist((: n :))) AND m = nonce(n))
          OR (EXISTS (nl1, nl2: list[Nonce]):
                rho_postmid(w!1)(nlist(nl1)) AND
                 rho_postmid(w!1)(nlist(nl2)) AND
                  m = nlist(append(nl1, nl2)))
          OR (EXISTS (nl, nl1, nl2: list[Nonce]):
                rho_postmid(w!1)(nlist(nl)) AND
                 nl = append(nl1, nl2) AND m = nlist(nl1))
          OR (EXISTS (nl, nl1, nl2: list[Nonce]):
                rho_postmid(w!1)(nlist(nl)) AND
                 nl = append(nl1, nl2) AND m = nlist(nl2))
          OR (EXISTS (i: Identity):
                rho_postmid(w!1)(user(i)) AND m = ilist((: i :)))
          OR (EXISTS (i: Identity):
                rho_postmid(w!1)(ilist((: i :))) AND m = user(i))
          OR (EXISTS (il1, il2: list[Identity]):
                rho_postmid(w!1)(ilist(il1)) AND
                 rho_postmid(w!1)(ilist(il2)) AND
                  m = ilist(append(il1, il2)))
          OR (EXISTS (il, il1, il2: list[Identity]):
                rho_postmid(w!1)(ilist(il)) AND
                 il = append(il1, il2) AND m = ilist(il1))
          OR (EXISTS (il, il1, il2: list[Identity]):
                rho_postmid(w!1)(ilist(il)) AND
                 il = append(il1, il2) AND m = ilist(il2))
          OR EXISTS m1, k:
               rho_postmid(w!1)(m1) AND
                rho_postmid(w!1)(k) AND m = E(k, m1))
         IMPLIES rho_postmid(w!1)(m)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_postmid.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  FORALL (x: Message): S!1(x) => rho_postmid(w!1)(x)
  |-------
{1}   (     S!1(m!2)
        OR (EXISTS m1, m2:
              rho_postmid(w!1)(m1) AND
               rho_postmid(w!1)(m2) AND m!2 = conc(m1, m2))
        OR (EXISTS m1: rho_postmid(w!1)(conc(m1, m!2)))
        OR (EXISTS m2: rho_postmid(w!1)(conc(m!2, m2)))
        OR (EXISTS (n: Nonce):
              rho_postmid(w!1)(nonce(n)) AND m!2 = nlist((: n :)))
        OR (EXISTS (n: Nonce):
              rho_postmid(w!1)(nlist((: n :))) AND m!2 = nonce(n))
        OR (EXISTS (nl1, nl2: list[Nonce]):
              rho_postmid(w!1)(nlist(nl1)) AND
               rho_postmid(w!1)(nlist(nl2)) AND
                m!2 = nlist(append(nl1, nl2)))
        OR (EXISTS (nl, nl1, nl2: list[Nonce]):
              rho_postmid(w!1)(nlist(nl)) AND
               nl = append(nl1, nl2) AND m!2 = nlist(nl1))
        OR (EXISTS (nl, nl1, nl2: list[Nonce]):
              rho_postmid(w!1)(nlist(nl)) AND
               nl = append(nl1, nl2) AND m!2 = nlist(nl2))
        OR (EXISTS (i: Identity):
              rho_postmid(w!1)(user(i)) AND m!2 = ilist((: i :)))
        OR (EXISTS (i: Identity):
              rho_postmid(w!1)(ilist((: i :))) AND m!2 = user(i))
        OR (EXISTS (il1, il2: list[Identity]):
              rho_postmid(w!1)(ilist(il1)) AND
               rho_postmid(w!1)(ilist(il2)) AND
                m!2 = ilist(append(il1, il2)))
        OR (EXISTS (il, il1, il2: list[Identity]):
              rho_postmid(w!1)(ilist(il)) AND
               il = append(il1, il2) AND m!2 = ilist(il1))
        OR (EXISTS (il, il1, il2: list[Identity]):
              rho_postmid(w!1)(ilist(il)) AND
               il = append(il1, il2) AND m!2 = ilist(il2))
        OR EXISTS m1, k:
             rho_postmid(w!1)(m1) AND
              rho_postmid(w!1)(k) AND m!2 = E(k, m1))
       IMPLIES rho_postmid(w!1)(m!2)

Rerunning step: (smash)
Repeatedly simplifying with BDDs, decision procedures, rewriting,
and if-lifting,
this yields  15 subgoals: 
authentication_postmid.2.1 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  S!1(m!2)
[-2]  FORALL (x: Message): S!1(x) => rho_postmid(w!1)(x)
  |-------
{1}   rho_postmid(w!1)(m!2)

Rerunning step: (inst -2 "m!2")
Instantiating the top quantifier in -2 with the terms: 
 m!2,
this simplifies to: 
authentication_postmid.2.1 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  S!1(m!2)
{-2}  S!1(m!2) => rho_postmid(w!1)(m!2)
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_postmid.2.1.

authentication_postmid.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS m1, m2:
        rho_postmid(w!1)(m1) AND rho_postmid(w!1)(m2) AND m!2 = conc(m1, m2)
[-2]  FORALL (x: Message): S!1(x) => rho_postmid(w!1)(x)
  |-------
{1}   rho_postmid(w!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS m1, m2:
        rho_postmid(w!1)(m1) AND rho_postmid(w!1)(m2) AND m!2 = conc(m1, m2)
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_postmid.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(m1!1) AND
       rho_postmid(w!1)(m2!1) AND m!2 = conc(m1!1, m2!1)
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_postmid.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(m1!1)
{-2}  rho_postmid(w!1)(m2!1)
{-3}  m!2 = conc(m1!1, m2!1)
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_postmid.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_postmid(w!1)(m1!1)
[-2]  rho_postmid(w!1)(m2!1)
[-3]  m!2 = conc(m1!1, m2!1)
  |-------
{1}   rho_postmid(w!1)(conc(m1!1, m2!1))

Rerunning step: (expand "rho_postmid" 1)
Expanding the definition of rho_postmid,
this simplifies to: 
authentication_postmid.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_postmid(w!1)(m1!1)
[-2]  rho_postmid(w!1)(m2!1)
[-3]  m!2 = conc(m1!1, m2!1)
  |-------
{1}   rho_postmid(w!1)(m1!1) AND rho_postmid(w!1)(m2!1)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_postmid.2.2.

authentication_postmid.2.3 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS m1: rho_postmid(w!1)(conc(m1, m!2))
[-2]  FORALL (x: Message): S!1(x) => rho_postmid(w!1)(x)
  |-------
{1}   rho_postmid(w!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.3 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS m1: rho_postmid(w!1)(conc(m1, m!2))
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_postmid.2.3 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(conc(m1!1, m!2))
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (expand "rho_postmid" -1)
Expanding the definition of rho_postmid,
this simplifies to: 
authentication_postmid.2.3 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  FALSE
  |-------
[1]   rho_postmid(w!1)(m!2)

which is trivially true.

This completes the proof of authentication_postmid.2.3.

authentication_postmid.2.4 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS m2: rho_postmid(w!1)(conc(m!2, m2))
[-2]  FORALL (x: Message): S!1(x) => rho_postmid(w!1)(x)
  |-------
{1}   rho_postmid(w!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.4 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS m2: rho_postmid(w!1)(conc(m!2, m2))
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_postmid.2.4 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(conc(m!2, m2!1))
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (expand "rho_postmid" -1)
Expanding the definition of rho_postmid,
this simplifies to: 
authentication_postmid.2.4 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  FALSE
  |-------
[1]   rho_postmid(w!1)(m!2)

which is trivially true.

This completes the proof of authentication_postmid.2.4.

authentication_postmid.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (n: Nonce): rho_postmid(w!1)(nonce(n)) AND m!2 = nlist((: n :))
[-2]  FORALL (x: Message): S!1(x) => rho_postmid(w!1)(x)
  |-------
{1}   rho_postmid(w!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (n: Nonce): rho_postmid(w!1)(nonce(n)) AND m!2 = nlist((: n :))
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_postmid.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(nonce(n!1)) AND m!2 = nlist((: n!1 :))
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_postmid.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(nonce(n!1))
{-2}  m!2 = nlist((: n!1 :))
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (expand "rho_postmid" -1)
Expanding the definition of rho_postmid,
this simplifies to: 
authentication_postmid.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  n!1 /= n_mid
[-2]  m!2 = nlist((: n!1 :))
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
authentication_postmid.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  n!1 /= n_mid
[-2]  m!2 = nlist((: n!1 :))
  |-------
{1}   rho_postmid(w!1)(nlist((: n!1 :)))

Rerunning step: (expand "rho_postmid")
Expanding the definition of rho_postmid,
this simplifies to: 
authentication_postmid.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  n!1 /= n_mid
[-2]  m!2 = nlist((: n!1 :))
{-3}  elt((: n!1 :), n_mid)
  |-------

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  n!1 /= n_mid
[-2]  elt((: n!1 :), n_mid)
  |-------

Rerunning step: (grind)
/= rewrites n!1 /= n_mid
  to NOT (n!1 = n_mid)
elt rewrites elt((: n!1 :), n_mid)
  to EXISTS (i: below[length((: n!1 :))]): nth((: n!1 :), i) = n_mid
length rewrites length[Nonce]((: :))
  to 0
length rewrites length((: n!1 :))
  to 1
nth rewrites nth((: n!1 :), i!1)
  to n!1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_postmid.2.5.

authentication_postmid.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (n: Nonce): rho_postmid(w!1)(nlist((: n :))) AND m!2 = nonce(n)
[-2]  FORALL (x: Message): S!1(x) => rho_postmid(w!1)(x)
  |-------
{1}   rho_postmid(w!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (n: Nonce): rho_postmid(w!1)(nlist((: n :))) AND m!2 = nonce(n)
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_postmid.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(nlist((: n!1 :))) AND m!2 = nonce(n!1)
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_postmid.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(nlist((: n!1 :)))
{-2}  m!2 = nonce(n!1)
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
authentication_postmid.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_postmid(w!1)(nlist((: n!1 :)))
[-2]  m!2 = nonce(n!1)
  |-------
{1}   rho_postmid(w!1)(nonce(n!1))

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_postmid(w!1)(nlist((: n!1 :)))
  |-------
[1]   rho_postmid(w!1)(nonce(n!1))

Rerunning step: (expand "rho_postmid")
Expanding the definition of rho_postmid,
this simplifies to: 
authentication_postmid.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   elt((: n!1 :), n_mid)
{2}   n!1 /= n_mid

Rerunning step: (expand "elt")
Expanding the definition of elt,
this simplifies to: 
authentication_postmid.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   EXISTS (i: below[length((: n!1 :))]): nth((: n!1 :), i) = n_mid
[2]   n!1 /= n_mid

Rerunning step: (inst 1 "0")
Instantiating the top quantifier in 1 with the terms: 
 0,
this yields  2 subgoals: 
authentication_postmid.2.6.1 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   nth((: n!1 :), 0) = n_mid
[2]   n!1 /= n_mid

Rerunning step: (grind)
nth rewrites nth((: n!1 :), 0)
  to n!1
/= rewrites n!1 /= n_mid
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_postmid.2.6.1.

authentication_postmid.2.6.2 (TCC):   

  |-------
{1}   0 < length[Nonce]((: n!1 :))
[2]   n!1 /= n_mid

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.6.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   0 < length[Nonce]((: n!1 :))

Rerunning step: (grind)
length rewrites length[Nonce]((: :))
  to 0
length rewrites length[Nonce]((: n!1 :))
  to 1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_postmid.2.6.2.


This completes the proof of authentication_postmid.2.6.

authentication_postmid.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (nl1, nl2: list[Nonce]):
        rho_postmid(w!1)(nlist(nl1)) AND
         rho_postmid(w!1)(nlist(nl2)) AND m!2 = nlist(append(nl1, nl2))
[-2]  FORALL (x: Message): S!1(x) => rho_postmid(w!1)(x)
  |-------
{1}   rho_postmid(w!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (nl1, nl2: list[Nonce]):
        rho_postmid(w!1)(nlist(nl1)) AND
         rho_postmid(w!1)(nlist(nl2)) AND m!2 = nlist(append(nl1, nl2))
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_postmid.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(nlist(nl1!1)) AND
       rho_postmid(w!1)(nlist(nl2!1)) AND m!2 = nlist(append(nl1!1, nl2!1))
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_postmid.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(nlist(nl1!1))
{-2}  rho_postmid(w!1)(nlist(nl2!1))
{-3}  m!2 = nlist(append(nl1!1, nl2!1))
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_postmid.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_postmid(w!1)(nlist(nl1!1))
[-2]  rho_postmid(w!1)(nlist(nl2!1))
[-3]  m!2 = nlist(append(nl1!1, nl2!1))
  |-------
{1}   rho_postmid(w!1)(nlist(append(nl1!1, nl2!1)))

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_postmid(w!1)(nlist(nl1!1))
[-2]  rho_postmid(w!1)(nlist(nl2!1))
  |-------
[1]   rho_postmid(w!1)(nlist(append(nl1!1, nl2!1)))

Rerunning step: (expand "rho_postmid")
Expanding the definition of rho_postmid,
this simplifies to: 
authentication_postmid.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(append(nl1!1, nl2!1), n_mid)
  |-------
{1}   elt(nl1!1, n_mid)
{2}   elt(nl2!1, n_mid)

Rerunning step: (lemma "listprops[Nonce].elt_append3"
                 ("l1" "nl1!1" "l2" "nl2!1" "t" "n_mid"))
Applying listprops[Nonce].elt_append3 where 
  l1 gets nl1!1,
  l2 gets nl2!1,
  t gets n_mid,
this simplifies to: 
authentication_postmid.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(append(nl1!1, nl2!1), n_mid) IMPLIES
       elt(nl1!1, n_mid) OR elt(nl2!1, n_mid)
[-2]  elt(append(nl1!1, nl2!1), n_mid)
  |-------
[1]   elt(nl1!1, n_mid)
[2]   elt(nl2!1, n_mid)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_postmid.2.7.

authentication_postmid.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (nl, nl1, nl2: list[Nonce]):
        rho_postmid(w!1)(nlist(nl)) AND
         nl = append(nl1, nl2) AND m!2 = nlist(nl1)
[-2]  FORALL (x: Message): S!1(x) => rho_postmid(w!1)(x)
  |-------
{1}   rho_postmid(w!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (nl, nl1, nl2: list[Nonce]):
        rho_postmid(w!1)(nlist(nl)) AND
         nl = append(nl1, nl2) AND m!2 = nlist(nl1)
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_postmid.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(nlist(nl!1)) AND
       nl!1 = append(nl1!1, nl2!1) AND m!2 = nlist(nl1!1)
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_postmid.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(nlist(nl!1))
{-2}  nl!1 = append(nl1!1, nl2!1)
{-3}  m!2 = nlist(nl1!1)
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_postmid.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_postmid(w!1)(nlist(nl!1))
[-2]  nl!1 = append(nl1!1, nl2!1)
[-3]  m!2 = nlist(nl1!1)
  |-------
{1}   rho_postmid(w!1)(nlist(nl1!1))

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_postmid(w!1)(nlist(nl!1))
[-2]  nl!1 = append(nl1!1, nl2!1)
  |-------
[1]   rho_postmid(w!1)(nlist(nl1!1))

Rerunning step: (replace -2 -1)
Replacing using formula -2,
this simplifies to: 
authentication_postmid.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(nlist(append(nl1!1, nl2!1)))
[-2]  nl!1 = append(nl1!1, nl2!1)
  |-------
[1]   rho_postmid(w!1)(nlist(nl1!1))

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_postmid(w!1)(nlist(append(nl1!1, nl2!1)))
  |-------
[1]   rho_postmid(w!1)(nlist(nl1!1))

Rerunning step: (expand "rho_postmid")
Expanding the definition of rho_postmid,
this simplifies to: 
authentication_postmid.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(nl1!1, n_mid)
  |-------
{1}   elt(append(nl1!1, nl2!1), n_mid)

Rerunning step: (lemma "listprops[Nonce].elt_append1"
                 ("l1" "nl1!1" "l2" "nl2!1" "t" "n_mid"))
Applying listprops[Nonce].elt_append1 where 
  l1 gets nl1!1,
  l2 gets nl2!1,
  t gets n_mid,
this simplifies to: 
authentication_postmid.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(nl1!1, n_mid) IMPLIES elt(append(nl1!1, nl2!1), n_mid)
[-2]  elt(nl1!1, n_mid)
  |-------
[1]   elt(append(nl1!1, nl2!1), n_mid)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_postmid.2.8.

authentication_postmid.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (nl, nl1, nl2: list[Nonce]):
        rho_postmid(w!1)(nlist(nl)) AND
         nl = append(nl1, nl2) AND m!2 = nlist(nl2)
[-2]  FORALL (x: Message): S!1(x) => rho_postmid(w!1)(x)
  |-------
{1}   rho_postmid(w!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (nl, nl1, nl2: list[Nonce]):
        rho_postmid(w!1)(nlist(nl)) AND
         nl = append(nl1, nl2) AND m!2 = nlist(nl2)
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_postmid.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(nlist(nl!1)) AND
       nl!1 = append(nl1!1, nl2!1) AND m!2 = nlist(nl2!1)
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_postmid.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(nlist(nl!1))
{-2}  nl!1 = append(nl1!1, nl2!1)
{-3}  m!2 = nlist(nl2!1)
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_postmid.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_postmid(w!1)(nlist(nl!1))
[-2]  nl!1 = append(nl1!1, nl2!1)
[-3]  m!2 = nlist(nl2!1)
  |-------
{1}   rho_postmid(w!1)(nlist(nl2!1))

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_postmid(w!1)(nlist(nl!1))
[-2]  nl!1 = append(nl1!1, nl2!1)
  |-------
[1]   rho_postmid(w!1)(nlist(nl2!1))

Rerunning step: (replace -2 -1)
Replacing using formula -2,
this simplifies to: 
authentication_postmid.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(nlist(append(nl1!1, nl2!1)))
[-2]  nl!1 = append(nl1!1, nl2!1)
  |-------
[1]   rho_postmid(w!1)(nlist(nl2!1))

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_postmid(w!1)(nlist(append(nl1!1, nl2!1)))
  |-------
[1]   rho_postmid(w!1)(nlist(nl2!1))

Rerunning step: (expand "rho_postmid")
Expanding the definition of rho_postmid,
this simplifies to: 
authentication_postmid.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(nl2!1, n_mid)
  |-------
{1}   elt(append(nl1!1, nl2!1), n_mid)

Rerunning step: (lemma "listprops[Nonce].elt_append2"
                 ("l1" "nl1!1" "l2" "nl2!1" "t" "n_mid"))
Applying listprops[Nonce].elt_append2 where 
  l1 gets nl1!1,
  l2 gets nl2!1,
  t gets n_mid,
this simplifies to: 
authentication_postmid.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(nl2!1, n_mid) IMPLIES elt(append(nl1!1, nl2!1), n_mid)
[-2]  elt(nl2!1, n_mid)
  |-------
[1]   elt(append(nl1!1, nl2!1), n_mid)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_postmid.2.9.

authentication_postmid.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (i: Identity):
        rho_postmid(w!1)(user(i)) AND m!2 = ilist((: i :))
[-2]  FORALL (x: Message): S!1(x) => rho_postmid(w!1)(x)
  |-------
{1}   rho_postmid(w!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (i: Identity):
        rho_postmid(w!1)(user(i)) AND m!2 = ilist((: i :))
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_postmid.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(user(i!1)) AND m!2 = ilist((: i!1 :))
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_postmid.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(user(i!1))
{-2}  m!2 = ilist((: i!1 :))
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
authentication_postmid.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_postmid(w!1)(user(i!1))
[-2]  m!2 = ilist((: i!1 :))
  |-------
{1}   rho_postmid(w!1)(ilist((: i!1 :)))

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_postmid(w!1)(user(i!1))
  |-------
[1]   rho_postmid(w!1)(ilist((: i!1 :)))

Rerunning step: (expand "rho_postmid" 1)
Expanding the definition of rho_postmid,
this simplifies to: 
authentication_postmid.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_postmid(w!1)(user(i!1))
  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_postmid.2.10.

authentication_postmid.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (i: Identity):
        rho_postmid(w!1)(ilist((: i :))) AND m!2 = user(i)
[-2]  FORALL (x: Message): S!1(x) => rho_postmid(w!1)(x)
  |-------
{1}   rho_postmid(w!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (i: Identity):
        rho_postmid(w!1)(ilist((: i :))) AND m!2 = user(i)
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_postmid.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(ilist((: i!1 :))) AND m!2 = user(i!1)
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_postmid.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(ilist((: i!1 :)))
{-2}  m!2 = user(i!1)
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
authentication_postmid.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_postmid(w!1)(ilist((: i!1 :)))
[-2]  m!2 = user(i!1)
  |-------
{1}   rho_postmid(w!1)(user(i!1))

Rerunning step: (delete -)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   rho_postmid(w!1)(user(i!1))

Rerunning step: (expand "rho_postmid")
Expanding the definition of rho_postmid,
this simplifies to: 
authentication_postmid.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_postmid.2.11.

authentication_postmid.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (il1, il2: list[Identity]):
        rho_postmid(w!1)(ilist(il1)) AND
         rho_postmid(w!1)(ilist(il2)) AND m!2 = ilist(append(il1, il2))
[-2]  FORALL (x: Message): S!1(x) => rho_postmid(w!1)(x)
  |-------
{1}   rho_postmid(w!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (il1, il2: list[Identity]):
        rho_postmid(w!1)(ilist(il1)) AND
         rho_postmid(w!1)(ilist(il2)) AND m!2 = ilist(append(il1, il2))
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_postmid.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(ilist(il1!1)) AND
       rho_postmid(w!1)(ilist(il2!1)) AND m!2 = ilist(append(il1!1, il2!1))
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_postmid.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(ilist(il1!1))
{-2}  rho_postmid(w!1)(ilist(il2!1))
{-3}  m!2 = ilist(append(il1!1, il2!1))
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_postmid.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_postmid(w!1)(ilist(il1!1))
[-2]  rho_postmid(w!1)(ilist(il2!1))
[-3]  m!2 = ilist(append(il1!1, il2!1))
  |-------
{1}   rho_postmid(w!1)(ilist(append(il1!1, il2!1)))

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_postmid(w!1)(ilist(il1!1))
[-2]  rho_postmid(w!1)(ilist(il2!1))
  |-------
[1]   rho_postmid(w!1)(ilist(append(il1!1, il2!1)))

Rerunning step: (expand "rho_postmid" 1)
Expanding the definition of rho_postmid,
this simplifies to: 
authentication_postmid.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_postmid(w!1)(ilist(il1!1))
[-2]  rho_postmid(w!1)(ilist(il2!1))
  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_postmid.2.12.

authentication_postmid.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (il, il1, il2: list[Identity]):
        rho_postmid(w!1)(ilist(il)) AND
         il = append(il1, il2) AND m!2 = ilist(il1)
[-2]  FORALL (x: Message): S!1(x) => rho_postmid(w!1)(x)
  |-------
{1}   rho_postmid(w!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (il, il1, il2: list[Identity]):
        rho_postmid(w!1)(ilist(il)) AND
         il = append(il1, il2) AND m!2 = ilist(il1)
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_postmid.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(ilist(il!1)) AND
       il!1 = append(il1!1, il2!1) AND m!2 = ilist(il1!1)
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_postmid.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(ilist(il!1))
{-2}  il!1 = append(il1!1, il2!1)
{-3}  m!2 = ilist(il1!1)
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_postmid.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_postmid(w!1)(ilist(il!1))
[-2]  il!1 = append(il1!1, il2!1)
[-3]  m!2 = ilist(il1!1)
  |-------
{1}   rho_postmid(w!1)(ilist(il1!1))

Rerunning step: (delete -)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   rho_postmid(w!1)(ilist(il1!1))

Rerunning step: (expand "rho_postmid")
Expanding the definition of rho_postmid,
this simplifies to: 
authentication_postmid.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_postmid.2.13.

authentication_postmid.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (il, il1, il2: list[Identity]):
        rho_postmid(w!1)(ilist(il)) AND
         il = append(il1, il2) AND m!2 = ilist(il2)
[-2]  FORALL (x: Message): S!1(x) => rho_postmid(w!1)(x)
  |-------
{1}   rho_postmid(w!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (il, il1, il2: list[Identity]):
        rho_postmid(w!1)(ilist(il)) AND
         il = append(il1, il2) AND m!2 = ilist(il2)
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_postmid.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(ilist(il!1)) AND
       il!1 = append(il1!1, il2!1) AND m!2 = ilist(il2!1)
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_postmid.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(ilist(il!1))
{-2}  il!1 = append(il1!1, il2!1)
{-3}  m!2 = ilist(il2!1)
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_postmid.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_postmid(w!1)(ilist(il!1))
[-2]  il!1 = append(il1!1, il2!1)
[-3]  m!2 = ilist(il2!1)
  |-------
{1}   rho_postmid(w!1)(ilist(il2!1))

Rerunning step: (delete -)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   rho_postmid(w!1)(ilist(il2!1))

Rerunning step: (expand "rho_postmid")
Expanding the definition of rho_postmid,
this simplifies to: 
authentication_postmid.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_postmid.2.14.

authentication_postmid.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS m1, k:
        rho_postmid(w!1)(m1) AND rho_postmid(w!1)(k) AND m!2 = E(k, m1)
[-2]  FORALL (x: Message): S!1(x) => rho_postmid(w!1)(x)
  |-------
{1}   rho_postmid(w!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS m1, k:
        rho_postmid(w!1)(m1) AND rho_postmid(w!1)(k) AND m!2 = E(k, m1)
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_postmid.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(m1!1) AND
       rho_postmid(w!1)(k!1) AND m!2 = E(k!1, m1!1)
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_postmid.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_postmid(w!1)(m1!1)
{-2}  rho_postmid(w!1)(k!1)
{-3}  m!2 = E(k!1, m1!1)
  |-------
[1]   rho_postmid(w!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_postmid.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_postmid(w!1)(m1!1)
[-2]  rho_postmid(w!1)(k!1)
[-3]  m!2 = E(k!1, m1!1)
  |-------
{1}   rho_postmid(w!1)(E(k!1, m1!1))

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
authentication_postmid.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_postmid(w!1)(m1!1)
[-2]  rho_postmid(w!1)(k!1)
  |-------
[1]   rho_postmid(w!1)(E(k!1, m1!1))

Rerunning step: (typepred "k!1")
Adding type constraints for  k!1,
this simplifies to: 
authentication_postmid.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  public?(k!1) OR secret?(k!1)
[-2]  rho_postmid(w!1)(m1!1)
[-3]  rho_postmid(w!1)(k!1)
  |-------
[1]   rho_postmid(w!1)(E(k!1, m1!1))

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
authentication_postmid.2.15.1 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  public?(k!1)
[-2]  rho_postmid(w!1)(m1!1)
[-3]  rho_postmid(w!1)(k!1)
  |-------
[1]   rho_postmid(w!1)(E(k!1, m1!1))

Rerunning step: (grind)
rho_postmid rewrites rho_postmid(w!1)(k!1)
  to TRUE
E rewrites E(k!1, m1!1)
  to CASES m1!1
        OF code(k1, m1):
             CASES k1
               OF public(u):
                    IF k!1 = secret(u) THEN m1 ELSE code(k!1, m1!1) ENDIF,
                  secret(u):
                    IF k!1 = public(u) THEN m1 ELSE code(k!1, m1!1) ENDIF
               ENDCASES
        ELSE code(k!1, m1!1)
        ENDCASES
rho_postmid rewrites rho_postmid(w!1)(code(k!1, m1!1))
  to TRUE
rho_postmid rewrites rho_postmid(w!1)(public(x_secret(x_code(m1!1))))
  to TRUE
rho_postmid rewrites rho_postmid(w!1)(m1!1)
  to FALSE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_postmid.2.15.1.

authentication_postmid.2.15.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  secret?(k!1)
[-2]  rho_postmid(w!1)(m1!1)
[-3]  rho_postmid(w!1)(k!1)
  |-------
[1]   rho_postmid(w!1)(E(k!1, m1!1))

Rerunning step: (expand "rho_postmid" -3)
Expanding the definition of rho_postmid,
this simplifies to: 
authentication_postmid.2.15.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  secret?(k!1)
[-2]  rho_postmid(w!1)(m1!1)
{-3}  CASES k!1
        OF nonce(z): z /= n_mid,
           nlist(z): NOT elt(z, n_mid),
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i)),
           conc(z1, z2): rho_postmid(w!1)(z1) AND rho_postmid(w!1)(z2),
           commit(z1, z2, z3): z1 /= mid OR z2 /= hu_list OR z3 /= n_mid,
           code(z1, z2):
             rho_postmid(w!1)(z2) OR
              EXISTS (i: {x: nat | mid < x AND x <= w!1}):
                z1 = public(hu(i)) AND
                 EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                         nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
                   z2 =
                    conc(nlist(append(nl1, cons(n_mid, nl2))),
                         ilist(remove(hu_list, i)))
        ELSE TRUE
        ENDCASES
  |-------
[1]   rho_postmid(w!1)(E(k!1, m1!1))

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
authentication_postmid.2.15.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  secret?(k!1)
[-2]  rho_postmid(w!1)(m1!1)
  |-------
{1}   EXISTS (i: nat_to_p): x_secret(k!1) = hu(i)
[2]   rho_postmid(w!1)(E(k!1, m1!1))

Rerunning step: (lazy-grind)
E rewrites E(k!1, m1!1)
  to CASES m1!1
        OF code(k1, m1):
             CASES k1
               OF public(u):
                    IF k!1 = secret(u) THEN m1 ELSE code(k!1, m1!1) ENDIF,
                  secret(u):
                    IF k!1 = public(u) THEN m1 ELSE code(k!1, m1!1) ENDIF
               ENDCASES
        ELSE code(k!1, m1!1)
        ENDCASES
rho_postmid rewrites rho_postmid(w!1)(code(k!1, m1!1))
  to TRUE
rho_postmid rewrites rho_postmid(w!1)(m1!1)
  to EXISTS (i: {x: nat | mid < x AND x <= w!1}):
        x_code(m1!1) = public(hu(i)) AND
         EXISTS (nl1: {x: list[Nonce] | length(x) = mid},
                 nl2: {x: list[Nonce] | length(x) = i - 1 - mid}):
           y_code(m1!1) =
            conc(nlist(append(nl1, cons(n_mid, nl2))),
                 ilist(remove(hu_list, i)))
remove rewrites remove(cdr(hu_list), i!1 - 1)
  to cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i!1 - 2))
remove rewrites remove(hu_list, i!1)
  to cons(car(hu_list),
           cons(car(cdr(hu_list)), remove(cdr(cdr(hu_list)), i!1 - 2)))
elt rewrites elt(append(nl1!1, cons(n_mid, nl2!1)), n_mid)
  to EXISTS (i: below[length(append(nl1!1, cons(n_mid, nl2!1)))]):
        nth(append(nl1!1, cons(n_mid, nl2!1)), i) = n_mid
rho_postmid rewrites 
  rho_postmid(w!1)(nlist(append(nl1!1, cons(n_mid, nl2!1))))
  to NOT EXISTS (i: below[length(append(nl1!1, cons(n_mid, nl2!1)))]):
            nth(append(nl1!1, cons(n_mid, nl2!1)), i) = n_mid
rho_postmid rewrites 
  rho_postmid(w!1)
             (ilist(cons(car(hu_list),
                         cons(car(cdr(hu_list)),
                              remove(cdr(cdr(hu_list)), i!1 - 2)))))
  to TRUE
rho_postmid rewrites 
  rho_postmid(w!1)
             (conc(nlist(append(nl1!1, cons(n_mid, nl2!1))),
                   ilist(cons(car(hu_list),
                              cons(car(cdr(hu_list)),
                                   remove(cdr(cdr(hu_list)), i!1 - 2))))))
  to NOT EXISTS (i: below[length(append(nl1!1, cons(n_mid, nl2!1)))]):
            nth(append(nl1!1, cons(n_mid, nl2!1)), i) = n_mid

By skolemization, if-lifting, simplification and instantiation,

This completes the proof of authentication_postmid.2.15.2.


This completes the proof of authentication_postmid.2.15.


This completes the proof of authentication_postmid.2.

authentication_postmid.3 :  

  |-------
{1}   FORALL (i: Identity):
        USER(i) # R_postmid(w!1) |> RankUser(rho_postmid(w!1))
[2]   network(USER) |> auth(T, R_postmid(w!1))

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_postmid.3 :  

  |-------
[1]   FORALL (i: Identity):
        USER(i) # R_postmid(w!1) |> RankUser(rho_postmid(w!1))

Rerunning step: (comment "users maintain the rank function")
Adding comment: users maintain the rank function
this simplifies to: 
authentication_postmid.3 : 
;;; users maintain the rank function

  |-------
[1]   FORALL (i: Identity):
        USER(i) # R_postmid(w!1) |> RankUser(rho_postmid(w!1))

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_postmid.3 : 
;;; users maintain the rank function

  |-------
{1}   USER(i!1) # R_postmid(w!1) |> RankUser(rho_postmid(w!1))

Rerunning step: (expand "USER")
Expanding the definition of USER,
this simplifies to: 
authentication_postmid.3 : 
;;; users maintain the rank function

  |-------
{1}   (Interleave! (P: nat_from_2):
         (Interleave! (nn0: Nonces(P, i!1, 0)): UROLE_INIT(P, i!1, nn0)) //
          (Interleave! (nnP: Nonces(P, i!1, P - 1)):
             UROLE_LAST(P, i!1, nnP))
          //
          IF P = 2 THEN Stop[event]
          ELSE (Interleave! (j: nat_1_to(P), nnJ: Nonces(P, i!1, j)):
                  UROLE_MIDDLE(P, j, i!1, nnJ))
          ENDIF)
       # R_postmid(w!1)
       |> RankUser(rho_postmid(w!1))

Rerunning step: (expand "RankUser")
Expanding the definition of RankUser,
this simplifies to: 
authentication_postmid.3 : 
;;; users maintain the rank function

  |-------
{1}   (Interleave! (P: nat_from_2):
         (Interleave! (nn0: Nonces(P, i!1, 0)): UROLE_INIT(P, i!1, nn0)) //
          (Interleave! (nnP: Nonces(P, i!1, P - 1)):
             UROLE_LAST(P, i!1, nnP))
          //
          IF P = 2 THEN Stop[event]
          ELSE (Interleave! (j: nat_1_to(P), nnJ: Nonces(P, i!1, j)):
                  UROLE_MIDDLE(P, j, i!1, nnJ))
          ENDIF)
       # R_postmid(w!1)
       |>
       LAMBDA (tr: list[event]):
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
              (tr)
          IMPLIES
          every(LAMBDA (e: event):
                  complement(rec?)(e) IMPLIES rho_postmid(w!1)(msg(e)))
               (tr)

Rerunning step: (interleaving2)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
Applying interleaving rule,
this simplifies to: 
authentication_postmid.3 : 
;;; users maintain the rank function

  |-------
{1}   (Interleave! (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
       //
       (Interleave! (nnP: Nonces(i!2, i!1, i!2 - 1)):
          UROLE_LAST(i!2, i!1, nnP))
       //
       IF i!2 = 2 THEN Stop[event]
       ELSE (Interleave! (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
               UROLE_MIDDLE(i!2, j, i!1, nnJ))
       ENDIF
       # R_postmid(w!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
              (t)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
               (t)

Rerunning step: (interleaving)
Applying interleaving rule,
this yields  2 subgoals: 
authentication_postmid.3.1 : 
;;; users maintain the rank function

  |-------
{1}   (((Interleave! (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
         //
         (Interleave! (nnP: Nonces(i!2, i!1, i!2 - 1)):
            UROLE_LAST(i!2, i!1, nnP))
         # R_postmid(w!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
                (t))

Rerunning step: (interleaving)
Applying interleaving rule,
this yields  2 subgoals: 
authentication_postmid.3.1.1 : 
;;; users maintain the rank function

  |-------
{1}   (((Interleave! (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
         # R_postmid(w!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
                (t))

Rerunning step: (lemma "restrictpostmid_init" ("P" "i!2" "u" "i!1"))
Applying restrictpostmid_init where 
  P gets i!2,
  u gets i!1,
this simplifies to: 
authentication_postmid.3.1.1 : 
;;; users maintain the rank function

{-1}  FORALL (w: {x: nat | mid < x AND x < p}):
        ((Interleave! (nn0: Nonces(i!2, i!1, 0)):
            UROLE_INIT(i!2, i!1, nn0))
          # R_postmid(w))
         |> RankUser(rho_postmid(w))
  |-------
[1]   (((Interleave! (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
         # R_postmid(w!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
                (t))

Rerunning step: (grind :exclude ("rho_postmid" "UROLE_INIT"))
Interleave rewrites 
  (Interleave! (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
  to Par(emptyset)
         (LAMBDA (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
# rewrites 
  (Par(emptyset)
      (LAMBDA (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
    # R_postmid(w!1))
  to Par(R_postmid(w!1))
         (Par(emptyset)
             (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                UROLE_INIT(i!2, i!1, nn0)),
          Stop)
Par rewrites 
  Par(R_postmid(w!1))
     (Par(emptyset)
         (LAMBDA (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                       UROLE_INIT(i!2, i!1, nn0)))),
             (t2: (Stop)):
        prod(R_postmid(w!1))(t1, t2, x)
member rewrites 
  member(x,
         Par(R_postmid(w!1))
            (Par(emptyset)
                (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                   UROLE_INIT(i!2, i!1, nn0)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                       UROLE_INIT(i!2, i!1, nn0)))),
             (t2: (Stop)):
        prod(R_postmid(w!1))(t1, t2, x)
member rewrites 
  member(x,
         LAMBDA (t: list[event]):
           every(LAMBDA (e: event):
                   rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
                (t)
            =>
            every(LAMBDA (e: event):
                    NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
                 (t))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))(x)
       =>
       every(LAMBDA (e: event):
               NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
            (x)
subset? rewrites 
  subset?(Par(R_postmid(w!1))
             (Par(emptyset)
                 (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                    UROLE_INIT(i!2, i!1, nn0)),
              Stop),
          LAMBDA (t: list[event]):
            every(LAMBDA (e: event):
                    rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
                 (t)
             =>
             every(LAMBDA (e: event):
                     NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
                  (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                          UROLE_INIT(i!2, i!1, nn0)))),
                (t2: (Stop)):
           prod(R_postmid(w!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
              (x)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
               (x)
|> rewrites 
  (Par(R_postmid(w!1))
      (Par(emptyset)
          (LAMBDA (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0)),
       Stop)
    |>
    LAMBDA (t: list[event]):
      every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))(t)
       =>
       every(LAMBDA (e: event):
               NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
            (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                          UROLE_INIT(i!2, i!1, nn0)))),
                (t2: (Stop)):
           prod(R_postmid(w!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
              (x)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
               (x)
# rewrites 
  (Par(emptyset)
      (LAMBDA (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
    # R_postmid(w))
  to Par(R_postmid(w))
         (Par(emptyset)
             (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                UROLE_INIT(i!2, i!1, nn0)),
          Stop)
Par rewrites 
  Par(R_postmid(w))
     (Par(emptyset)
         (LAMBDA (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                       UROLE_INIT(i!2, i!1, nn0)))),
             (t2: (Stop)):
        prod(R_postmid(w))(t1, t2, x)
member rewrites 
  member(x,
         Par(R_postmid(w))
            (Par(emptyset)
                (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                   UROLE_INIT(i!2, i!1, nn0)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                       UROLE_INIT(i!2, i!1, nn0)))),
             (t2: (Stop)):
        prod(R_postmid(w))(t1, t2, x)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
RankUser rewrites RankUser(rho_postmid(w))(x)
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w)(msg(e)))(x)
       IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_postmid(w)(msg(e)))
            (x)
member rewrites member(x, RankUser(rho_postmid(w)))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w)(msg(e)))(x)
       IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_postmid(w)(msg(e)))
            (x)
subset? rewrites 
  subset?(Par(R_postmid(w))
             (Par(emptyset)
                 (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                    UROLE_INIT(i!2, i!1, nn0)),
              Stop),
          RankUser(rho_postmid(w)))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                          UROLE_INIT(i!2, i!1, nn0)))),
                (t2: (Stop)):
           prod(R_postmid(w))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w)(msg(e)))
              (x)
          IMPLIES
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_postmid(w)(msg(e)))
               (x)
|> rewrites 
  Par(R_postmid(w))
     (Par(emptyset)
         (LAMBDA (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0)),
      Stop)
   |> RankUser(rho_postmid(w))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                          UROLE_INIT(i!2, i!1, nn0)))),
                (t2: (Stop)):
           prod(R_postmid(w))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w)(msg(e)))
              (x)
          IMPLIES
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_postmid(w)(msg(e)))
               (x)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_postmid.3.1.1.

authentication_postmid.3.1.2 : 
;;; users maintain the rank function

  |-------
{1}   (((Interleave! (nnP: Nonces(i!2, i!1, i!2 - 1)):
           UROLE_LAST(i!2, i!1, nnP))
         # R_postmid(w!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
                (t))

Rerunning step: (lemma "restrictpostmid_last" ("P" "i!2" "u" "i!1"))
Applying restrictpostmid_last where 
  P gets i!2,
  u gets i!1,
this simplifies to: 
authentication_postmid.3.1.2 : 
;;; users maintain the rank function

{-1}  FORALL (w: {x: nat | mid < x AND x < p}):
        ((Interleave! (nnP: Nonces(i!2, i!1, i!2 - 1)):
            UROLE_LAST(i!2, i!1, nnP))
          # R_postmid(w))
         |> RankUser(rho_postmid(w))
  |-------
[1]   (((Interleave! (nnP: Nonces(i!2, i!1, i!2 - 1)):
           UROLE_LAST(i!2, i!1, nnP))
         # R_postmid(w!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
                (t))

Rerunning step: (grind :exclude ("rho_postmid" "UROLE_LAST"))
Interleave rewrites 
  (Interleave! (nnP: Nonces(i!2, i!1, i!2 - 1)): UROLE_LAST(i!2, i!1, nnP))
  to Par(emptyset)
         (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
            UROLE_LAST(i!2, i!1, nnP))
# rewrites 
  (Par(emptyset)
      (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)): UROLE_LAST(i!2, i!1, nnP))
    # R_postmid(w!1))
  to Par(R_postmid(w!1))
         (Par(emptyset)
             (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                UROLE_LAST(i!2, i!1, nnP)),
          Stop)
Par rewrites 
  Par(R_postmid(w!1))
     (Par(emptyset)
         (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
            UROLE_LAST(i!2, i!1, nnP)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                       UROLE_LAST(i!2, i!1, nnP)))),
             (t2: (Stop)):
        prod(R_postmid(w!1))(t1, t2, x)
member rewrites 
  member(x,
         Par(R_postmid(w!1))
            (Par(emptyset)
                (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                   UROLE_LAST(i!2, i!1, nnP)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                       UROLE_LAST(i!2, i!1, nnP)))),
             (t2: (Stop)):
        prod(R_postmid(w!1))(t1, t2, x)
member rewrites 
  member(x,
         LAMBDA (t: list[event]):
           every(LAMBDA (e: event):
                   rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
                (t)
            =>
            every(LAMBDA (e: event):
                    NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
                 (t))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))(x)
       =>
       every(LAMBDA (e: event):
               NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
            (x)
subset? rewrites 
  subset?(Par(R_postmid(w!1))
             (Par(emptyset)
                 (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                    UROLE_LAST(i!2, i!1, nnP)),
              Stop),
          LAMBDA (t: list[event]):
            every(LAMBDA (e: event):
                    rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
                 (t)
             =>
             every(LAMBDA (e: event):
                     NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
                  (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                          UROLE_LAST(i!2, i!1, nnP)))),
                (t2: (Stop)):
           prod(R_postmid(w!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
              (x)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
               (x)
|> rewrites 
  (Par(R_postmid(w!1))
      (Par(emptyset)
          (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
             UROLE_LAST(i!2, i!1, nnP)),
       Stop)
    |>
    LAMBDA (t: list[event]):
      every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))(t)
       =>
       every(LAMBDA (e: event):
               NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
            (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                          UROLE_LAST(i!2, i!1, nnP)))),
                (t2: (Stop)):
           prod(R_postmid(w!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
              (x)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
               (x)
# rewrites 
  (Par(emptyset)
      (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)): UROLE_LAST(i!2, i!1, nnP))
    # R_postmid(w))
  to Par(R_postmid(w))
         (Par(emptyset)
             (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                UROLE_LAST(i!2, i!1, nnP)),
          Stop)
Par rewrites 
  Par(R_postmid(w))
     (Par(emptyset)
         (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
            UROLE_LAST(i!2, i!1, nnP)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                       UROLE_LAST(i!2, i!1, nnP)))),
             (t2: (Stop)):
        prod(R_postmid(w))(t1, t2, x)
member rewrites 
  member(x,
         Par(R_postmid(w))
            (Par(emptyset)
                (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                   UROLE_LAST(i!2, i!1, nnP)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                       UROLE_LAST(i!2, i!1, nnP)))),
             (t2: (Stop)):
        prod(R_postmid(w))(t1, t2, x)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
RankUser rewrites RankUser(rho_postmid(w))(x)
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w)(msg(e)))(x)
       IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_postmid(w)(msg(e)))
            (x)
member rewrites member(x, RankUser(rho_postmid(w)))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w)(msg(e)))(x)
       IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_postmid(w)(msg(e)))
            (x)
subset? rewrites 
  subset?(Par(R_postmid(w))
             (Par(emptyset)
                 (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                    UROLE_LAST(i!2, i!1, nnP)),
              Stop),
          RankUser(rho_postmid(w)))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                          UROLE_LAST(i!2, i!1, nnP)))),
                (t2: (Stop)):
           prod(R_postmid(w))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w)(msg(e)))
              (x)
          IMPLIES
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_postmid(w)(msg(e)))
               (x)
|> rewrites 
  Par(R_postmid(w))
     (Par(emptyset)
         (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
            UROLE_LAST(i!2, i!1, nnP)),
      Stop)
   |> RankUser(rho_postmid(w))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                          UROLE_LAST(i!2, i!1, nnP)))),
                (t2: (Stop)):
           prod(R_postmid(w))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w)(msg(e)))
              (x)
          IMPLIES
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_postmid(w)(msg(e)))
               (x)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_postmid.3.1.2.


This completes the proof of authentication_postmid.3.1.

authentication_postmid.3.2 : 
;;; users maintain the rank function

  |-------
{1}   ((IF i!2 = 2 THEN Stop[event]
        ELSE (Interleave! (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                UROLE_MIDDLE(i!2, j, i!1, nnJ))
        ENDIF
         # R_postmid(w!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
                (t))

Rerunning step: (lift-if)
Lifting IF-conditions to the top level,
this simplifies to: 
authentication_postmid.3.2 : 
;;; users maintain the rank function

  |-------
{1}   IF i!2 = 2
        THEN ((Stop[event] # R_postmid(w!1)) |>
               LAMBDA (t: list[event]):
                 every(LAMBDA (e: event):
                         rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
                      (t)
                  =>
                  every(LAMBDA (e: event):
                          NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
                       (t))
      ELSE (((Interleave! (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                UROLE_MIDDLE(i!2, j, i!1, nnJ))
              # R_postmid(w!1))
             |>
             LAMBDA (t: list[event]):
               every(LAMBDA (e: event):
                       rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
                    (t)
                =>
                every(LAMBDA (e: event):
                        NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
                     (t))
      ENDIF

Rerunning step: (prop)
Applying propositional simplification,
this yields  2 subgoals: 
authentication_postmid.3.2.1 : 
;;; users maintain the rank function

{-1}  i!2 = 2
  |-------
{1}   ((Stop[event] # R_postmid(w!1)) |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
                (t))

Rerunning step: (stop)
Applying stop rule,

This completes the proof of authentication_postmid.3.2.1.

authentication_postmid.3.2.2 : 
;;; users maintain the rank function

  |-------
{1}   i!2 = 2
{2}   (((Interleave! (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
           UROLE_MIDDLE(i!2, j, i!1, nnJ))
         # R_postmid(w!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
                (t))

Rerunning step: (lemma "restrictpostmid_middle" ("P" "i!2" "u" "i!1"))
Applying restrictpostmid_middle where 
  P gets i!2,
  u gets i!1,
this simplifies to: 
authentication_postmid.3.2.2 : 
;;; users maintain the rank function

{-1}  FORALL (w: {x: nat | mid < x AND x < p}):
        i!2 /= 2 =>
         (((Interleave! (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
              UROLE_MIDDLE(i!2, k, i!1, nnK))
            # R_postmid(w))
           |> RankUser(rho_postmid(w)))
  |-------
[1]   i!2 = 2
[2]   (((Interleave! (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
           UROLE_MIDDLE(i!2, j, i!1, nnJ))
         # R_postmid(w!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
                (t))

Rerunning step: (grind :exclude ("rho_postmid" "UROLE_MIDDLE"))
Interleave rewrites 
  (Interleave! (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
     UROLE_MIDDLE(i!2, j, i!1, nnJ))
  to Par(emptyset)
         (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
            UROLE_MIDDLE(i!2, j, i!1, nnJ))
# rewrites 
  (Par(emptyset)
      (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
         UROLE_MIDDLE(i!2, j, i!1, nnJ))
    # R_postmid(w!1))
  to Par(R_postmid(w!1))
         (Par(emptyset)
             (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                UROLE_MIDDLE(i!2, j, i!1, nnJ)),
          Stop)
Par rewrites 
  Par(R_postmid(w!1))
     (Par(emptyset)
         (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
            UROLE_MIDDLE(i!2, j, i!1, nnJ)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                       UROLE_MIDDLE(i!2, j, i!1, nnJ)))),
             (t2: (Stop)):
        prod(R_postmid(w!1))(t1, t2, x)
member rewrites 
  member(x,
         Par(R_postmid(w!1))
            (Par(emptyset)
                (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                   UROLE_MIDDLE(i!2, j, i!1, nnJ)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                       UROLE_MIDDLE(i!2, j, i!1, nnJ)))),
             (t2: (Stop)):
        prod(R_postmid(w!1))(t1, t2, x)
member rewrites 
  member(x,
         LAMBDA (t: list[event]):
           every(LAMBDA (e: event):
                   rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
                (t)
            =>
            every(LAMBDA (e: event):
                    NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
                 (t))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))(x)
       =>
       every(LAMBDA (e: event):
               NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
            (x)
subset? rewrites 
  subset?(Par(R_postmid(w!1))
             (Par(emptyset)
                 (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                    UROLE_MIDDLE(i!2, j, i!1, nnJ)),
              Stop),
          LAMBDA (t: list[event]):
            every(LAMBDA (e: event):
                    rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
                 (t)
             =>
             every(LAMBDA (e: event):
                     NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
                  (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (j: nat_1_to(i!2),
                                nnJ: Nonces(i!2, i!1, j)):
                          UROLE_MIDDLE(i!2, j, i!1, nnJ)))),
                (t2: (Stop)):
           prod(R_postmid(w!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
              (x)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
               (x)
|> rewrites 
  (Par(R_postmid(w!1))
      (Par(emptyset)
          (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
             UROLE_MIDDLE(i!2, j, i!1, nnJ)),
       Stop)
    |>
    LAMBDA (t: list[event]):
      every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))(t)
       =>
       every(LAMBDA (e: event):
               NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
            (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (j: nat_1_to(i!2),
                                nnJ: Nonces(i!2, i!1, j)):
                          UROLE_MIDDLE(i!2, j, i!1, nnJ)))),
                (t2: (Stop)):
           prod(R_postmid(w!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
              (x)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_postmid(w!1)(msg(e)))
               (x)
# rewrites 
  (Par(emptyset)
      (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
         UROLE_MIDDLE(i!2, j, i!1, nnJ))
    # R_postmid(w))
  to Par(R_postmid(w))
         (Par(emptyset)
             (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                UROLE_MIDDLE(i!2, j, i!1, nnJ)),
          Stop)
Par rewrites 
  Par(R_postmid(w))
     (Par(emptyset)
         (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
            UROLE_MIDDLE(i!2, j, i!1, nnJ)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                       UROLE_MIDDLE(i!2, j, i!1, nnJ)))),
             (t2: (Stop)):
        prod(R_postmid(w))(t1, t2, x)
member rewrites 
  member(x,
         Par(R_postmid(w))
            (Par(emptyset)
                (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                   UROLE_MIDDLE(i!2, j, i!1, nnJ)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                       UROLE_MIDDLE(i!2, j, i!1, nnJ)))),
             (t2: (Stop)):
        prod(R_postmid(w))(t1, t2, x)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
RankUser rewrites RankUser(rho_postmid(w))(x)
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w)(msg(e)))(x)
       IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_postmid(w)(msg(e)))
            (x)
member rewrites member(x, RankUser(rho_postmid(w)))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w)(msg(e)))(x)
       IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_postmid(w)(msg(e)))
            (x)
subset? rewrites 
  subset?(Par(R_postmid(w))
             (Par(emptyset)
                 (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                    UROLE_MIDDLE(i!2, j, i!1, nnJ)),
              Stop),
          RankUser(rho_postmid(w)))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (j: nat_1_to(i!2),
                                nnJ: Nonces(i!2, i!1, j)):
                          UROLE_MIDDLE(i!2, j, i!1, nnJ)))),
                (t2: (Stop)):
           prod(R_postmid(w))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w)(msg(e)))
              (x)
          IMPLIES
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_postmid(w)(msg(e)))
               (x)
|> rewrites 
  (Par(R_postmid(w))
      (Par(emptyset)
          (LAMBDA (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
             UROLE_MIDDLE(i!2, j, i!1, nnJ)),
       Stop)
    |> RankUser(rho_postmid(w)))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (j: nat_1_to(i!2),
                                nnJ: Nonces(i!2, i!1, j)):
                          UROLE_MIDDLE(i!2, j, i!1, nnJ)))),
                (t2: (Stop)):
           prod(R_postmid(w))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_postmid(w)(msg(e)))
              (x)
          IMPLIES
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_postmid(w)(msg(e)))
               (x)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_postmid.3.2.2.


This completes the proof of authentication_postmid.3.2.


This completes the proof of authentication_postmid.3.

authentication_postmid.4 :  

  |-------
{1}   FORALL (e: (T)): NOT rho_postmid(w!1)(msg(e))
[2]   network(USER) |> auth(T, R_postmid(w!1))

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_postmid.4 :  

  |-------
[1]   FORALL (e: (T)): NOT rho_postmid(w!1)(msg(e))

Rerunning step: (comment "T is not in rho")
Adding comment: T is not in rho
this simplifies to: 
authentication_postmid.4 : 
;;; T is not in rho

  |-------
[1]   FORALL (e: (T)): NOT rho_postmid(w!1)(msg(e))

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
authentication_postmid.4 : 
;;; T is not in rho

{-1}  T(e!1)
{-2}  rho_postmid(w!1)(msg(e!1))
  |-------

Rerunning step: (expand "T")
Expanding the definition of T,
this simplifies to: 
authentication_postmid.4 : 
;;; T is not in rho

{-1}  e!1 = signal(commit(mid, hu_list, n_mid))
[-2]  rho_postmid(w!1)(msg(e!1))
  |-------

Rerunning step: (replace -1 -2)
Replacing using formula -1,
this simplifies to: 
authentication_postmid.4 : 
;;; T is not in rho

[-1]  e!1 = signal(commit(mid, hu_list, n_mid))
{-2}  rho_postmid(w!1)(msg(signal(commit(mid, hu_list, n_mid))))
  |-------

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
authentication_postmid.4 : 
;;; T is not in rho

[-1]  rho_postmid(w!1)(msg(signal(commit(mid, hu_list, n_mid))))
  |-------

Rerunning step: (grind)
rho_postmid rewrites rho_postmid(w!1)(commit(mid, hu_list, n_mid))
  to FALSE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_postmid.4.

Q.E.D.


Run time  = 2.35 secs.
Real time = 5.74 secs.
nil
pvs(92): 
