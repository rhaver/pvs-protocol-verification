Starting pvs-allegro -qq ...
International Allegro CL Enterprise Edition
10.1 [64-bit Linux (x86-64)] (Nov 14, 2020 18:29)
Copyright (C) 1985-2017, Franz Inc., Oakland, CA, USA.  All Rights Reserved.

This dynamic runtime copy of Allegro CL was built by:
   [TC21720] SRI International

;; Optimization settings: safety 1, space 1, speed 3, debug 1.
;; For a complete description of all compiler switches given the
;; current optimization settings evaluate (explain-compiler-settings).
;;---
;; Current reader case mode: :case-sensitive-lower

pvs(1): 
pvs(2): 
Defining stop. 
Defining stop$. 
Defining choice. 
Defining choice$. 
Defining choice2. 
Defining choice2$. 
Defining choice3. 
Defining choice3$. 
Defining prefix. 
Defining prefix$. 
Defining interleaving. 
Defining interleaving$. 
Defining interleaving2. 
Defining interleaving2$. 
Defining parallel. 
Defining parallel$. 
Defining parallel2. 
Defining parallel2$. 
Defining fix1. 
Defining fix1$. 
Defining fix2. 
Defining fix2$. 
Defining run. 
Defining run$. 
Defining mdecompose-equality. 
Defining mdecompose-equality$. 
Defining mdec-eq-last. 
Defining mdec-eq-last$. 
Defining grind-dec-eq. 
Defining grind-dec-eq$. 
stop exists as a defined rule.
Redefining stop. 
stop$ exists as a strategy.
Redefining stop$. 
choice exists as a defined rule.
Redefining choice. 
choice$ exists as a strategy.
Redefining choice$. 
choice2 exists as a defined rule.
Redefining choice2. 
choice2$ exists as a strategy.
Redefining choice2$. 
choice3 exists as a defined rule.
Redefining choice3. 
choice3$ exists as a strategy.
Redefining choice3$. 
Warning: |(defstep) prefix|, :operator was defined in
         /home/ubuntu/Desktop/csp_rules/pvs-strategies and is now being
         defined in /home/ubuntu/Desktop/gnsl/pvs-strategies

prefix exists as a defined rule.
Redefining prefix. 
prefix$ exists as a strategy.
Redefining prefix$. 
Defining prefix2. 
Defining prefix2$. 
interleaving exists as a defined rule.
Redefining interleaving. 
interleaving$ exists as a strategy.
Redefining interleaving$. 
interleaving2 exists as a defined rule.
Redefining interleaving2. 
interleaving2$ exists as a strategy.
Redefining interleaving2$. 
parallel exists as a defined rule.
Redefining parallel. 
parallel$ exists as a strategy.
Redefining parallel$. 
parallel2 exists as a defined rule.
Redefining parallel2. 
parallel2$ exists as a strategy.
Redefining parallel2$. 
fix1 exists as a defined rule.
Redefining fix1. 
fix1$ exists as a strategy.
Redefining fix1$. 
fix2 exists as a defined rule.
Redefining fix2. 
fix2$ exists as a strategy.
Redefining fix2$. 
Warning: |(defstep) run|, :operator was defined in
         /home/ubuntu/Desktop/csp_rules/pvs-strategies and is now being
         defined in /home/ubuntu/Desktop/gnsl/pvs-strategies

run exists as a defined rule.
Redefining run. 
run$ exists as a strategy.
Redefining run$. 
mdecompose-equality exists as a defined rule.
Redefining mdecompose-equality. 
mdecompose-equality$ exists as a strategy.
Redefining mdecompose-equality$. 
Warning: |(defstep) mdec-eq-last|, :operator was defined in
         /home/ubuntu/Desktop/csp_rules/pvs-strategies and is now being
         defined in /home/ubuntu/Desktop/gnsl/pvs-strategies

mdec-eq-last exists as a defined rule.
Redefining mdec-eq-last. 
mdec-eq-last$ exists as a strategy.
Redefining mdec-eq-last$. 
grind-dec-eq exists as a defined rule.
Redefining grind-dec-eq. 
grind-dec-eq$ exists as a strategy.
Redefining grind-dec-eq$. 
Defining nonemptylist. 
Defining nonemptylist$. 
stop exists as a defined rule.
Redefining stop. 
stop$ exists as a strategy.
Redefining stop$. 
choice exists as a defined rule.
Redefining choice. 
choice$ exists as a strategy.
Redefining choice$. 
choice2 exists as a defined rule.
Redefining choice2. 
choice2$ exists as a strategy.
Redefining choice2$. 
choice3 exists as a defined rule.
Redefining choice3. 
choice3$ exists as a strategy.
Redefining choice3$. 
prefix exists as a defined rule.
Redefining prefix. 
prefix$ exists as a strategy.
Redefining prefix$. 
prefix2 exists as a defined rule.
Redefining prefix2. 
prefix2$ exists as a strategy.
Redefining prefix2$. 
interleaving exists as a defined rule.
Redefining interleaving. 
interleaving$ exists as a strategy.
Redefining interleaving$. 
interleaving2 exists as a defined rule.
Redefining interleaving2. 
interleaving2$ exists as a strategy.
Redefining interleaving2$. 
parallel exists as a defined rule.
Redefining parallel. 
parallel$ exists as a strategy.
Redefining parallel$. 
parallel2 exists as a defined rule.
Redefining parallel2. 
parallel2$ exists as a strategy.
Redefining parallel2$. 
fix1 exists as a defined rule.
Redefining fix1. 
fix1$ exists as a strategy.
Redefining fix1$. 
fix2 exists as a defined rule.
Redefining fix2. 
fix2$ exists as a strategy.
Redefining fix2$. 
run exists as a defined rule.
Redefining run. 
run$ exists as a strategy.
Redefining run$. 
mdecompose-equality exists as a defined rule.
Redefining mdecompose-equality. 
mdecompose-equality$ exists as a strategy.
Redefining mdecompose-equality$. 
mdec-eq-last exists as a defined rule.
Redefining mdec-eq-last. 
mdec-eq-last$ exists as a strategy.
Redefining mdec-eq-last$. 
grind-dec-eq exists as a defined rule.
Redefining grind-dec-eq. 
grind-dec-eq$ exists as a strategy.
Redefining grind-dec-eq$. 
nonemptylist exists as a defined rule.
Redefining nonemptylist. 
nonemptylist$ exists as a strategy.
Redefining nonemptylist$. 
Installing rewrite rule sets.singleton_rew (all instances)
n_prop :  

  |-------
{1}   FORALL (P: nat_from_2, u: Identity, r: Role):
        (P /= p OR r /= 0) =>
         NOT pt[[nat_from_2, Identity, Role], Nonce](P, u, r)(n_init)

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
n_prop :  

{-1}  2 <= P!1
{-2}  u!1 >= 0
{-3}  r!1 >= 0
  |-------
{1}   (P!1 /= p OR r!1 /= 0) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, r!1)(n_init)

Rerunning step: (typepred "n_init")
Adding type constraints for  n_init,
this simplifies to: 
n_prop :  

{-1}  IRpart(p, hu(0), 0)(n_init)
[-2]  2 <= P!1
[-3]  u!1 >= 0
[-4]  r!1 >= 0
  |-------
[1]   (P!1 /= p OR r!1 /= 0) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, r!1)(n_init)

Rerunning step: (typepred "pt[[nat_from_2, Identity, Role], Nonce]")
Adding type constraints for  pt[[nat_from_2, Identity, Role], Nonce],
this simplifies to: 
n_prop :  

{-1}  FORALL (i: [nat_from_2, Identity, Role]),
             (j: [nat_from_2, Identity, Role]), (n: Nonce):
        i /= j AND pt[[nat_from_2, Identity, Role], Nonce](i)(n) =>
         NOT pt[[nat_from_2, Identity, Role], Nonce](j)(n)
{-2}  FORALL (i: [nat_from_2, Identity, Role]):
        EXISTS (n: Nonce): pt[[nat_from_2, Identity, Role], Nonce](i)(n)
[-3]  IRpart(p, hu(0), 0)(n_init)
[-4]  2 <= P!1
[-5]  u!1 >= 0
[-6]  r!1 >= 0
  |-------
[1]   (P!1 /= p OR r!1 /= 0) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, r!1)(n_init)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
n_prop :  

[-1]  FORALL (i: [nat_from_2, Identity, Role]),
             (j: [nat_from_2, Identity, Role]), (n: Nonce):
        i /= j AND pt[[nat_from_2, Identity, Role], Nonce](i)(n) =>
         NOT pt[[nat_from_2, Identity, Role], Nonce](j)(n)
[-2]  IRpart(p, hu(0), 0)(n_init)
[-3]  2 <= P!1
[-4]  u!1 >= 0
[-5]  r!1 >= 0
  |-------
[1]   (P!1 /= p OR r!1 /= 0) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, r!1)(n_init)

Rerunning step: (inst -1 "(P!1, u!1, r!1)" "(p, hu(0), 0)" "n_init")
Instantiating the top quantifier in -1 with the terms: 
 (P!1, u!1, r!1), (p, hu(0), 0), n_init,
this simplifies to: 
n_prop :  

{-1}  (P!1, u!1, r!1) /= (p, hu(0), 0) AND
       pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, r!1)(n_init)
       => NOT pt[[nat_from_2, Identity, Role], Nonce](p, hu(0), 0)(n_init)
[-2]  IRpart(p, hu(0), 0)(n_init)
[-3]  2 <= P!1
[-4]  u!1 >= 0
[-5]  r!1 >= 0
  |-------
[1]   (P!1 /= p OR r!1 /= 0) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, r!1)(n_init)

Rerunning step: (grind)
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
/= rewrites P!1 /= p
  to NOT (P!1 = p)
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
/= rewrites r!1 /= 0
  to NOT (r!1 = 0)
Trying repeated skolemization, instantiation, and if-lifting,
Q.E.D.


Run time  = 0.13 secs.
Real time = 0.40 secs.
nil
pvs(22): 
Installing rewrite rule sets.singleton_rew (all instances)
n_orig :  

  |-------
{1}   FORALL (P: nat_from_2, u: Identity):
        IRpart(P, u, 0)(n_init) => (P = p AND u = hu(0))

Rerunning step: (skosimp)
Skolemizing and flattening,
this simplifies to: 
n_orig :  

{-1}  IRpart(P!1, u!1, 0)(n_init)
  |-------
{1}   (P!1 = p AND u!1 = hu(0))

Rerunning step: (typepred "pt[[nat_from_2, Identity, Role], Nonce]"
                 "n_init")
Adding type constraints for  pt[[nat_from_2, Identity, Role],
                                Nonce], n_init,
this simplifies to: 
n_orig :  

{-1}  FORALL (i: [nat_from_2, Identity, Role]),
             (j: [nat_from_2, Identity, Role]), (n: Nonce):
        i /= j AND pt[[nat_from_2, Identity, Role], Nonce](i)(n) =>
         NOT pt[[nat_from_2, Identity, Role], Nonce](j)(n)
{-2}  FORALL (i: [nat_from_2, Identity, Role]):
        EXISTS (n: Nonce): pt[[nat_from_2, Identity, Role], Nonce](i)(n)
{-3}  IRpart(p, hu(0), 0)(n_init)
[-4]  IRpart(P!1, u!1, 0)(n_init)
  |-------
[1]   (P!1 = p AND u!1 = hu(0))

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
n_orig :  

[-1]  FORALL (i: [nat_from_2, Identity, Role]),
             (j: [nat_from_2, Identity, Role]), (n: Nonce):
        i /= j AND pt[[nat_from_2, Identity, Role], Nonce](i)(n) =>
         NOT pt[[nat_from_2, Identity, Role], Nonce](j)(n)
[-2]  IRpart(p, hu(0), 0)(n_init)
[-3]  IRpart(P!1, u!1, 0)(n_init)
  |-------
[1]   (P!1 = p AND u!1 = hu(0))

Rerunning step: (inst -1 "(P!1, u!1, 0)" "(p, hu(0), 0)" "n_init")
Instantiating the top quantifier in -1 with the terms: 
 (P!1, u!1, 0), (p, hu(0), 0), n_init,
this simplifies to: 
n_orig :  

{-1}  (P!1, u!1, 0) /= (p, hu(0), 0) AND
       pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, 0)(n_init)
       => NOT pt[[nat_from_2, Identity, Role], Nonce](p, hu(0), 0)(n_init)
[-2]  IRpart(p, hu(0), 0)(n_init)
[-3]  IRpart(P!1, u!1, 0)(n_init)
  |-------
[1]   (P!1 = p AND u!1 = hu(0))

Rerunning step: (expand "IRpart")
Expanding the definition of IRpart,
this simplifies to: 
n_orig :  

[-1]  (P!1, u!1, 0) /= (p, hu(0), 0) AND
       pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, 0)(n_init)
       => NOT pt[[nat_from_2, Identity, Role], Nonce](p, hu(0), 0)(n_init)
{-2}  pt[[nat_from_2, Identity, Role], Nonce](p, hu(0), 0)(n_init)
{-3}  pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, 0)(n_init)
  |-------
[1]   (P!1 = p AND u!1 = hu(0))

Rerunning step: (ground)
Applying propositional simplification and decision procedures,
Q.E.D.


Run time  = 0.05 secs.
Real time = 0.18 secs.
nil
pvs(27): 
Installing rewrite rule sets.singleton_rew (all instances)
hu_list_exists :  

  |-------
{1}   EXISTS (x1:
                {x: list[Identity] |
                   (length[Identity](x) = p) AND
                    (FORALL (i: nat_to_p): nth[Identity](x, i) = hu(i))}):
        TRUE

Rerunning step: (typepred "p")
Adding type constraints for  p,
this simplifies to: 
hu_list_exists :  

{-1}  2 <= p
  |-------
[1]   EXISTS (x1:
                {x: list[Identity] |
                   (length[Identity](x) = p) AND
                    (FORALL (i: nat_to_p): nth[Identity](x, i) = hu(i))}):
        TRUE

Rerunning step: (inst 1 "gen_f_list(p, 0, hu)")
Instantiating the top quantifier in 1 with the terms: 
 gen_f_list(p, 0, hu),
this yields  2 subgoals: 
hu_list_exists.1 (TCC):   

[-1]  2 <= p
  |-------
{1}   (length[Identity](gen_f_list[Identity](p, 0, hu)) = p) AND
       FORALL (i: nat_to_p):
         nth[Identity](gen_f_list[Identity](p, 0, hu), i) = hu(i)

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
hu_list_exists.1.1 :  

[-1]  2 <= p
  |-------
{1}   (length[Identity](gen_f_list[Identity](p, 0, hu)) = p)

Rerunning step: (rewrite "gen1")
Found matching substitution:
f: [below[k] -> T] gets hu,
i: below[k] gets 0,
k: nat gets p,
Rewriting using gen1, matching in *,

This completes the proof of hu_list_exists.1.1.

hu_list_exists.1.2 :  

[-1]  2 <= p
  |-------
{1}   FORALL (i: nat_to_p):
        nth[Identity](gen_f_list[Identity](p, 0, hu), i) = hu(i)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
hu_list_exists.1.2 :  

[-1]  2 <= p
  |-------
{1}   nth[Identity](gen_f_list[Identity](p, 0, hu), i!1) = hu(i!1)

Rerunning step: (rewrite "gen2")
Found matching substitution:
j: below[k - i] gets i!1,
f: [below[k] -> T] gets hu,
i: below[k] gets 0,
k: nat gets p,
Rewriting using gen2, matching in *,

This completes the proof of hu_list_exists.1.2.


This completes the proof of hu_list_exists.1.

hu_list_exists.2 (TCC):   

[-1]  2 <= p
  |-------
{1}   0 < p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of hu_list_exists.2.

Q.E.D.


Run time  = 0.14 secs.
Real time = 0.24 secs.
nil
pvs(32): 
Installing rewrite rule sets.singleton_rew (all instances)
cons_hu_list :  

  |-------
{1}   cons?(hu_list) AND length(hu_list) = p

Rerunning step: (typepred "p")
Adding type constraints for  p,
this simplifies to: 
cons_hu_list :  

{-1}  2 <= p
  |-------
[1]   cons?(hu_list) AND length(hu_list) = p

Rerunning step: (typepred "hu_list")
Adding type constraints for  hu_list,
this simplifies to: 
cons_hu_list :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-2}  (length(hu_list) = p)
{-3}  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-4]  2 <= p
  |-------
[1]   cons?(hu_list) AND length(hu_list) = p

Rerunning step: (delete -1 -3)
Deleting some formulas,
this simplifies to: 
cons_hu_list :  

[-1]  (length(hu_list) = p)
[-2]  2 <= p
  |-------
[1]   cons?(hu_list) AND length(hu_list) = p

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
cons_hu_list :  

[-1]  (length(hu_list) = p)
[-2]  2 <= p
  |-------
{1}   cons?(hu_list)

Rerunning step: (expand "length" -1)
Expanding the definition of length,
this simplifies to: 
cons_hu_list :  

{-1}  (CASES hu_list OF null: 0, cons(x, y): length[Identity](y) + 1
         ENDCASES
        = p)
[-2]  2 <= p
  |-------
[1]   cons?(hu_list)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,
Q.E.D.


Run time  = 0.04 secs.
Real time = 0.12 secs.
nil
pvs(37): 
Installing rewrite rule sets.singleton_rew (all instances)
restrictmiddle_init :  

  |-------
{1}   FORALL (P: nat_from_2, i: nat_1_to(p), u: Identity):
        ((Interleave! (nn0: Nonces(P, u, 0)): UROLE_INIT(P, u, nn0)) #
          R_middle(i))
         |> RankUser(rho_middle(i))

Rerunning step: (auto-rewrite-theory "sets")
Rewriting relative to the theory: sets,
this simplifies to: 
restrictmiddle_init :  

  |-------
[1]   FORALL (P: nat_from_2, i: nat_1_to(p), u: Identity):
        ((Interleave! (nn0: Nonces(P, u, 0)): UROLE_INIT(P, u, nn0)) #
          R_middle(i))
         |> RankUser(rho_middle(i))

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictmiddle_init :  

  |-------
{1}   ((Interleave! (nn0: Nonces(P!1, u!1, 0)): UROLE_INIT(P!1, u!1, nn0))
        # R_middle(i!1))
       |> RankUser(rho_middle(i!1))

Rerunning step: (expand "RankUser")
Expanding the definition of RankUser,
this simplifies to: 
restrictmiddle_init :  

  |-------
{1}   ((Interleave! (nn0: Nonces(P!1, u!1, 0)): UROLE_INIT(P!1, u!1, nn0))
        # R_middle(i!1))
       |>
       LAMBDA (tr: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(tr)
          =>
          every(LAMBDA (e: event):
                  complement(rec?)(e) => rho_middle(i!1)(msg(e)))
               (tr)

Rerunning step: (interleaving2)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
Applying interleaving rule,
this simplifies to: 
restrictmiddle_init :  

  |-------
{1}   UROLE_INIT(P!1, u!1, i!2) # R_middle(i!1) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (expand "UROLE_INIT")
Expanding the definition of UROLE_INIT,
this simplifies to: 
restrictmiddle_init :  

  |-------
{1}   IF i!2 = n_init
        THEN Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
                      il:
                        {x: list[Identity] |
                           (length(x) = P!1 - 1) AND
                            FORALL (i: below[P!1 - 1]):
                              nth(x, i) = hu(1 + i)}):
               (trans(u!1, car(il),
                      E(public(car(il)),
                        conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(il))))))
                 >>
                 (rec(u!1, nth(il, P!1 - 2),
                      E(public(u!1),
                        conc(nlist(cons(i!2, nl)), ilist(il))))
                   >>
                   (trans(u!1, car(il),
                          E(public(car(il)),
                            conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                     >>
                     (signal(commit(0, cons(u!1, il), i!2)) >>
                       Stop[event]))))
      ELSE Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
                    il: {x: list[Identity] | length(x) = P!1 - 1}):
             (trans(u!1, car(il),
                    E(public(car(il)),
                      conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(il))))))
               >>
               (rec(u!1, nth(il, P!1 - 2),
                    E(public(u!1), conc(nlist(cons(i!2, nl)), ilist(il))))
                 >>
                 (trans(u!1, car(il),
                        E(public(car(il)),
                          conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                   >>
                   (signal(commit(0, cons(u!1, il), i!2)) >>
                     Stop[event]))))
      ENDIF
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (lift-if)
Lifting IF-conditions to the top level,
this simplifies to: 
restrictmiddle_init :  

  |-------
{1}   IF i!2 = n_init
        THEN Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
                      il:
                        {x: list[Identity] |
                           (length(x) = P!1 - 1) AND
                            FORALL (i: below[P!1 - 1]):
                              nth(x, i) = hu(1 + i)}):
               (trans(u!1, car(il),
                      E(public(car(il)),
                        conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(il))))))
                 >>
                 (rec(u!1, nth(il, P!1 - 2),
                      E(public(u!1),
                        conc(nlist(cons(i!2, nl)), ilist(il))))
                   >>
                   (trans(u!1, car(il),
                          E(public(car(il)),
                            conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                     >>
                     (signal(commit(0, cons(u!1, il), i!2)) >>
                       Stop[event]))))
              # R_middle(i!1)
              |>
              LAMBDA (t: list[event]):
                every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))
                     (t)
                 =>
                 every(LAMBDA (e: event):
                         NOT rec?(e) => rho_middle(i!1)(msg(e)))
                      (t)
      ELSE Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
                    il: {x: list[Identity] | length(x) = P!1 - 1}):
             (trans(u!1, car(il),
                    E(public(car(il)),
                      conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(il))))))
               >>
               (rec(u!1, nth(il, P!1 - 2),
                    E(public(u!1), conc(nlist(cons(i!2, nl)), ilist(il))))
                 >>
                 (trans(u!1, car(il),
                        E(public(car(il)),
                          conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                   >>
                   (signal(commit(0, cons(u!1, il), i!2)) >>
                     Stop[event]))))
            # R_middle(i!1)
            |>
            LAMBDA (t: list[event]):
              every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))
                   (t)
               =>
               every(LAMBDA (e: event):
                       NOT rec?(e) => rho_middle(i!1)(msg(e)))
                    (t)
      ENDIF

Rerunning step: (prop)
Applying propositional simplification,
this yields  2 subgoals: 
restrictmiddle_init.1 :  

{-1}  i!2 = n_init
  |-------
{1}   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1) AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, nl)), ilist(il))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
              >> (signal(commit(0, cons(u!1, il), i!2)) >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (typepred "p")
Adding type constraints for  p,
this simplifies to: 
restrictmiddle_init.1 :  

{-1}  2 <= p
[-2]  i!2 = n_init
  |-------
[1]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1) AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, nl)), ilist(il))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
              >> (signal(commit(0, cons(u!1, il), i!2)) >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (choice3)
Applying choice rule,
this yields  12 subgoals: 
restrictmiddle_init.1.1 :  

[-1]  2 <= p
[-2]  i!2 = n_init
  |-------
{1}   (trans(u!1, car(i!3`2),
             E(public(car(i!3`2)),
               conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i!3`2))))))
        >>
        (rec(u!1, nth(i!3`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
          >>
          (trans(u!1, car(i!3`2),
                 E(public(car(i!3`2)),
                   conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
            >> (signal(commit(0, cons(u!1, i!3`2), i!2)) >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (comment "establish obvious equalities")
Adding comment: establish obvious equalities
this simplifies to: 
restrictmiddle_init.1.1 : 
;;; establish obvious equalities

[-1]  2 <= p
[-2]  i!2 = n_init
  |-------
[1]   (trans(u!1, car(i!3`2),
             E(public(car(i!3`2)),
               conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i!3`2))))))
        >>
        (rec(u!1, nth(i!3`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
          >>
          (trans(u!1, car(i!3`2),
                 E(public(car(i!3`2)),
                   conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
            >> (signal(commit(0, cons(u!1, i!3`2), i!2)) >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (case "u!1=hu(0) AND p=P!1")
Case splitting on 
   u!1 = hu(0) AND p = P!1, 
this yields  2 subgoals: 
restrictmiddle_init.1.1.1 : 
;;; establish obvious equalities

{-1}  u!1 = hu(0) AND p = P!1
[-2]  2 <= p
[-3]  i!2 = n_init
  |-------
[1]   (trans(u!1, car(i!3`2),
             E(public(car(i!3`2)),
               conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i!3`2))))))
        >>
        (rec(u!1, nth(i!3`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
          >>
          (trans(u!1, car(i!3`2),
                 E(public(car(i!3`2)),
                   conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
            >> (signal(commit(0, cons(u!1, i!3`2), i!2)) >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictmiddle_init.1.1.1 : 
;;; establish obvious equalities

{-1}  u!1 = hu(0)
{-2}  p = P!1
[-3]  2 <= p
[-4]  i!2 = n_init
  |-------
[1]   (trans(u!1, car(i!3`2),
             E(public(car(i!3`2)),
               conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i!3`2))))))
        >>
        (rec(u!1, nth(i!3`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
          >>
          (trans(u!1, car(i!3`2),
                 E(public(car(i!3`2)),
                   conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
            >> (signal(commit(0, cons(u!1, i!3`2), i!2)) >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictmiddle_init.1.1.1 : 
;;; establish obvious equalities

[-1]  u!1 = hu(0)
[-2]  p = P!1
[-3]  2 <= p
[-4]  i!2 = n_init
  |-------
{1}   (trans(hu(0), car(i!3`2),
             E(public(car(i!3`2)),
               conc(nlist((: i!2 :)), ilist(cons(hu(0), cdr(i!3`2))))))
        >>
        (rec(hu(0), nth(i!3`2, P!1 - 2),
             E(public(hu(0)), conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
          >>
          (trans(hu(0), car(i!3`2),
                 E(public(car(i!3`2)),
                   conc(ilist(cons(hu(0), cdr(i!3`2))), nlist(i!3`1))))
            >>
            (signal(commit(0, cons(hu(0), i!3`2), i!2)) >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (replace -2 1 rl)
Replacing using formula -2,
this simplifies to: 
restrictmiddle_init.1.1.1 : 
;;; establish obvious equalities

[-1]  u!1 = hu(0)
[-2]  p = P!1
[-3]  2 <= p
[-4]  i!2 = n_init
  |-------
{1}   (trans(hu(0), car(i!3`2),
             E(public(car(i!3`2)),
               conc(nlist((: i!2 :)), ilist(cons(hu(0), cdr(i!3`2))))))
        >>
        (rec(hu(0), nth(i!3`2, p - 2),
             E(public(hu(0)), conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
          >>
          (trans(hu(0), car(i!3`2),
                 E(public(car(i!3`2)),
                   conc(ilist(cons(hu(0), cdr(i!3`2))), nlist(i!3`1))))
            >>
            (signal(commit(0, cons(hu(0), i!3`2), i!2)) >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (replace -4 1)
Replacing using formula -4,
this simplifies to: 
restrictmiddle_init.1.1.1 : 
;;; establish obvious equalities

[-1]  u!1 = hu(0)
[-2]  p = P!1
[-3]  2 <= p
[-4]  i!2 = n_init
  |-------
{1}   (trans(hu(0), car(i!3`2),
             E(public(car(i!3`2)),
               conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!3`2))))))
        >>
        (rec(hu(0), nth(i!3`2, p - 2),
             E(public(hu(0)),
               conc(nlist(cons(n_init, i!3`1)), ilist(i!3`2))))
          >>
          (trans(hu(0), car(i!3`2),
                 E(public(car(i!3`2)),
                   conc(ilist(cons(hu(0), cdr(i!3`2))), nlist(i!3`1))))
            >>
            (signal(commit(0, cons(hu(0), i!3`2), n_init)) >>
              Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -4)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.1.1 : 
;;; establish obvious equalities

[-1]  p = P!1
[-2]  2 <= p
  |-------
[1]   (trans(hu(0), car(i!3`2),
             E(public(car(i!3`2)),
               conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!3`2))))))
        >>
        (rec(hu(0), nth(i!3`2, p - 2),
             E(public(hu(0)),
               conc(nlist(cons(n_init, i!3`1)), ilist(i!3`2))))
          >>
          (trans(hu(0), car(i!3`2),
                 E(public(car(i!3`2)),
                   conc(ilist(cons(hu(0), cdr(i!3`2))), nlist(i!3`1))))
            >>
            (signal(commit(0, cons(hu(0), i!3`2), n_init)) >>
              Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictmiddle_init.1.1.1.1 : 
;;; establish obvious equalities

[-1]  p = P!1
[-2]  2 <= p
  |-------
{1}   rho_middle(i!1)
                (E(public(car(i!3`2)),
                   conc(nlist((: n_init :)),
                        ilist(cons(hu(0), cdr(i!3`2))))))
{2}   R_middle(i!1)
              (trans(hu(0), car(i!3`2),
                     E(public(car(i!3`2)),
                       conc(nlist((: n_init :)),
                            ilist(cons(hu(0), cdr(i!3`2)))))))
{3}   trans(hu(0), car(i!3`2),
            E(public(car(i!3`2)),
              conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!3`2))))))
       >>
       ((rec(hu(0), nth(i!3`2, p - 2),
             E(public(hu(0)),
               conc(nlist(cons(n_init, i!3`1)), ilist(i!3`2))))
          >>
          (trans(hu(0), car(i!3`2),
                 E(public(car(i!3`2)),
                   conc(ilist(cons(hu(0), cdr(i!3`2))), nlist(i!3`1))))
            >>
            (signal(commit(0, cons(hu(0), i!3`2), n_init)) >>
              Stop[event])))
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.1.1.1 : 
;;; establish obvious equalities

[-1]  p = P!1
[-2]  2 <= p
  |-------
[1]   rho_middle(i!1)
                (E(public(car(i!3`2)),
                   conc(nlist((: n_init :)),
                        ilist(cons(hu(0), cdr(i!3`2))))))

Rerunning step: (grind :if-match nil)
E rewrites 
  E(public(car(i!3`2)),
    conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!3`2)))))
  to code(public(car(i!3`2)),
           conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!3`2)))))
elt rewrites elt((: n_init :), n_init)
  to EXISTS (i: below[length((: n_init :))]): nth((: n_init :), i) = n_init
rho_middle rewrites rho_middle(i!1)(nlist((: n_init :)))
  to NOT EXISTS (i: below[length((: n_init :))]):
            nth((: n_init :), i) = n_init
rho_middle rewrites rho_middle(i!1)(ilist(cons(hu(0), cdr(i!3`2))))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)(conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!3`2)))))
  to NOT EXISTS (i: below[length((: n_init :))]):
            nth((: n_init :), i) = n_init
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites 
  rho_middle(i!1)
            (code(public(car(i!3`2)),
                  conc(nlist((: n_init :)),
                       ilist(cons(hu(0), cdr(i!3`2))))))
  to NOT EXISTS (i: below[length((: n_init :))]):
            nth((: n_init :), i) = n_init
       OR
       EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
         public(car(i!3`2)) = public(hu(j)) AND
          EXISTS (l: {x: list[Nonce] | length(x) = j - 1}):
            conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!3`2)))) =
             conc(nlist(cons(n_init, l)),
                  ilist(cons(car(hu_list), remove(cdr(hu_list), j - 1))))
length rewrites length((: :))
  to 0
length rewrites length((: n_init :))
  to 1
nth rewrites nth((: n_init :), i!4)
  to n_init
Trying repeated skolemization, instantiation, and if-lifting,
this simplifies to: 
restrictmiddle_init.1.1.1.1 : 
;;; establish obvious equalities

{-1}  i!4 < 1
[-2]  p = P!1
{-3}  2 <= P!1
  |-------
{1}   EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
        public(car(i!3`2)) = public(hu(j)) AND
         EXISTS (l: {x: list[Nonce] | length(x) = j - 1}):
           conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!3`2)))) =
            conc(nlist(cons(n_init, l)),
                 ilist(cons(car(hu_list), remove(cdr(hu_list), j - 1))))

Rerunning step: (comment "hu(0) sends a message (that is `escaped' in rho) to hu(1)")
Adding comment: hu(0) sends a message (that is `escaped' in rho) to hu(1)
this simplifies to: 
restrictmiddle_init.1.1.1.1 : 
;;; hu(0) sends a message (that is `escaped' in rho) to hu(1)

[-1]  i!4 < 1
[-2]  p = P!1
[-3]  2 <= P!1
  |-------
[1]   EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
        public(car(i!3`2)) = public(hu(j)) AND
         EXISTS (l: {x: list[Nonce] | length(x) = j - 1}):
           conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!3`2)))) =
            conc(nlist(cons(n_init, l)),
                 ilist(cons(car(hu_list), remove(cdr(hu_list), j - 1))))

Rerunning step: (inst 1 "1")
Instantiating the top quantifier in 1 with the terms: 
 1,
this simplifies to: 
restrictmiddle_init.1.1.1.1 : 
;;; hu(0) sends a message (that is `escaped' in rho) to hu(1)

[-1]  i!4 < 1
[-2]  p = P!1
[-3]  2 <= P!1
  |-------
{1}   public(car(i!3`2)) = public(hu(1)) AND
       EXISTS (l: {x: list[Nonce] | length(x) = 0}):
         conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!3`2)))) =
          conc(nlist(cons(n_init, l)),
               ilist(cons(car(hu_list), remove(cdr(hu_list), 1 - 1))))

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
restrictmiddle_init.1.1.1.1.1 : 
;;; hu(0) sends a message (that is `escaped' in rho) to hu(1)

[-1]  i!4 < 1
[-2]  p = P!1
[-3]  2 <= P!1
  |-------
{1}   public(car(i!3`2)) = public(hu(1))

Rerunning step: (comment "prove that the intended recipient is 1")
Adding comment: prove that the intended recipient is 1
this simplifies to: 
restrictmiddle_init.1.1.1.1.1 : 
;;; prove that the intended recipient is 1

[-1]  i!4 < 1
[-2]  p = P!1
[-3]  2 <= P!1
  |-------
[1]   public(car(i!3`2)) = public(hu(1))

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_init.1.1.1.1.1 : 
;;; prove that the intended recipient is 1

[-1]  i!4 < 1
[-2]  p = P!1
[-3]  2 <= P!1
  |-------
{1}   car(i!3`2) = hu(1)

Rerunning step: (typepred "i!3`2")
Adding type constraints for  i!3`2,
this simplifies to: 
restrictmiddle_init.1.1.1.1.1 : 
;;; prove that the intended recipient is 1

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`2)
{-2}  (length(i!3`2) = P!1 - 1)
{-3}  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(1 + i)
[-4]  i!4 < 1
[-5]  p = P!1
[-6]  2 <= P!1
  |-------
[1]   car(i!3`2) = hu(1)

Rerunning step: (delete -1 -2 -4 -5 -6)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.1.1.1.1 : 
;;; prove that the intended recipient is 1

[-1]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(1 + i)
  |-------
[1]   car(i!3`2) = hu(1)

Rerunning step: (inst -1 "0")
Instantiating the top quantifier in -1 with the terms: 
 0,
this simplifies to: 
restrictmiddle_init.1.1.1.1.1 : 
;;; prove that the intended recipient is 1

{-1}  nth(i!3`2, 0) = hu(1 + 0)
  |-------
[1]   car(i!3`2) = hu(1)

Rerunning step: (grind)
nth rewrites nth(i!3`2, 0)
  to car(i!3`2)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_init.1.1.1.1.1.

restrictmiddle_init.1.1.1.1.2 : 
;;; hu(0) sends a message (that is `escaped' in rho) to hu(1)

[-1]  i!4 < 1
[-2]  p = P!1
[-3]  2 <= P!1
  |-------
{1}   EXISTS (l: {x: list[Nonce] | length(x) = 0}):
        conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!3`2)))) =
         conc(nlist(cons(n_init, l)),
              ilist(cons(car(hu_list), remove(cdr(hu_list), 1 - 1))))

Rerunning step: (comment "prove that the message has the right structure")
Adding comment: prove that the message has the right structure
this simplifies to: 
restrictmiddle_init.1.1.1.1.2 : 
;;; prove that the message has the right structure

[-1]  i!4 < 1
[-2]  p = P!1
[-3]  2 <= P!1
  |-------
[1]   EXISTS (l: {x: list[Nonce] | length(x) = 0}):
        conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!3`2)))) =
         conc(nlist(cons(n_init, l)),
              ilist(cons(car(hu_list), remove(cdr(hu_list), 1 - 1))))

Rerunning step: (inst 1 "null")
length rewrites length[Nonce](null[Nonce])
  to 0
Instantiating the top quantifier in 1 with the terms: 
 null,
this simplifies to: 
restrictmiddle_init.1.1.1.1.2 : 
;;; prove that the message has the right structure

[-1]  i!4 < 1
[-2]  p = P!1
[-3]  2 <= P!1
  |-------
{1}   conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!3`2)))) =
       conc(nlist(cons(n_init, null)),
            ilist(cons(car(hu_list), remove(cdr(hu_list), 1 - 1))))

Rerunning step: (decompose-equality 1)
remove rewrites remove(cdr(hu_list), 0)
  to cdr(cdr(hu_list))
Applying decompose-equality,
this simplifies to: 
restrictmiddle_init.1.1.1.1.2 : 
;;; prove that the message has the right structure

[-1]  i!4 < 1
[-2]  p = P!1
[-3]  2 <= P!1
  |-------
{1}   ilist(cons(hu(0), cdr(i!3`2))) =
       ilist(cons(car(hu_list), cdr(cdr(hu_list))))

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_init.1.1.1.1.2 : 
;;; prove that the message has the right structure

[-1]  i!4 < 1
[-2]  p = P!1
[-3]  2 <= P!1
  |-------
{1}   cons(hu(0), cdr(i!3`2)) = cons(car(hu_list), cdr(cdr(hu_list)))

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this yields  2 subgoals: 
restrictmiddle_init.1.1.1.1.2.1 : 
;;; prove that the message has the right structure

[-1]  i!4 < 1
[-2]  p = P!1
[-3]  2 <= P!1
  |-------
{1}   hu(0) = car(hu_list)

Rerunning step: (typepred "hu_list")
Adding type constraints for  hu_list,
this simplifies to: 
restrictmiddle_init.1.1.1.1.2.1 : 
;;; prove that the message has the right structure

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-2}  (length(hu_list) = p)
{-3}  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-4]  i!4 < 1
[-5]  p = P!1
[-6]  2 <= P!1
  |-------
[1]   hu(0) = car(hu_list)

Rerunning step: (delete -1 -2 -4 -5 -6)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.1.1.1.2.1 : 
;;; prove that the message has the right structure

[-1]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
  |-------
[1]   hu(0) = car(hu_list)

Rerunning step: (inst -1 "0")
Instantiating the top quantifier in -1 with the terms: 
 0,
this simplifies to: 
restrictmiddle_init.1.1.1.1.2.1 : 
;;; prove that the message has the right structure

{-1}  nth(hu_list, 0) = hu(0)
  |-------
[1]   hu(0) = car(hu_list)

Rerunning step: (grind)
nth rewrites nth(hu_list, 0)
  to car(hu_list)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_init.1.1.1.1.2.1.

restrictmiddle_init.1.1.1.1.2.2 : 
;;; prove that the message has the right structure

[-1]  i!4 < 1
[-2]  p = P!1
[-3]  2 <= P!1
  |-------
{1}   cdr(i!3`2) = cdr(cdr(hu_list))

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.1.1.1.2.2 : 
;;; prove that the message has the right structure

[-1]  p = P!1
[-2]  2 <= P!1
  |-------
[1]   cdr(i!3`2) = cdr(cdr(hu_list))

Rerunning step: (comment "prove that the two lists are equal by showing that their lengths and elements are equal")
Adding comment: prove that the two lists are equal by showing that their lengths and elements are equal
this simplifies to: 
restrictmiddle_init.1.1.1.1.2.2 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  p = P!1
[-2]  2 <= P!1
  |-------
[1]   cdr(i!3`2) = cdr(cdr(hu_list))

Rerunning step: (typepred "i!3`2" "hu_list")
Adding type constraints for  i!3`2, hu_list,
this simplifies to: 
restrictmiddle_init.1.1.1.1.2.2 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`2)
{-2}  (length(i!3`2) = P!1 - 1)
{-3}  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(1 + i)
{-4}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-5}  (length(hu_list) = p)
{-6}  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  p = P!1
[-8]  2 <= P!1
  |-------
[1]   cdr(i!3`2) = cdr(cdr(hu_list))

Rerunning step: (delete -1 -4)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.1.1.1.2.2 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  (length(i!3`2) = P!1 - 1)
[-2]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(1 + i)
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  p = P!1
[-6]  2 <= P!1
  |-------
[1]   cdr(i!3`2) = cdr(cdr(hu_list))

Rerunning step: (rewrite "length_nth_equality[Identity]")
Found matching substitution:
l2: list[Identity] gets cdr(cdr(hu_list)),
l1: list[Identity] gets cdr(i!3`2),
Rewriting using length_nth_equality[Identity], matching in *,
this yields  2 subgoals: 
restrictmiddle_init.1.1.1.1.2.2.1 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  (length(i!3`2) = P!1 - 1)
[-2]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(1 + i)
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  p = P!1
[-6]  2 <= P!1
  |-------
{1}   length[Identity](cdr(i!3`2)) = length[Identity](cdr(cdr(hu_list)))
[2]   cdr(i!3`2) = cdr(cdr(hu_list))

Rerunning step: (delete -2 -4 -6 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.1.1.1.2.2.1 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  (length(i!3`2) = P!1 - 1)
[-2]  (length(hu_list) = p)
[-3]  p = P!1
  |-------
[1]   length[Identity](cdr(i!3`2)) = length[Identity](cdr(cdr(hu_list)))

Rerunning step: (rewrite "length_cdr")
Found matching substitution:
cons_l: (cons?[T]) gets i!3`2,
Rewriting using length_cdr, matching in *,
this simplifies to: 
restrictmiddle_init.1.1.1.1.2.2.1 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  (length(i!3`2) = P!1 - 1)
[-2]  (length(hu_list) = p)
[-3]  p = P!1
  |-------
{1}   length(i!3`2) - 1 = length[Identity](cdr(cdr(hu_list)))

Rerunning step: (rewrite "length_cdr")
Found matching substitution:
cons_l: (cons?[T]) gets cdr(hu_list),
Rewriting using length_cdr, matching in *,
this simplifies to: 
restrictmiddle_init.1.1.1.1.2.2.1 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  (length(i!3`2) = P!1 - 1)
[-2]  (length(hu_list) = p)
[-3]  p = P!1
  |-------
{1}   length(i!3`2) - 1 = length(cdr(hu_list)) - 1

Rerunning step: (rewrite "length_cdr")
Found matching substitution:
cons_l: (cons?[T]) gets hu_list,
Rewriting using length_cdr, matching in *,
this simplifies to: 
restrictmiddle_init.1.1.1.1.2.2.1 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  (length(i!3`2) = P!1 - 1)
[-2]  (length(hu_list) = p)
[-3]  p = P!1
  |-------
{1}   length(i!3`2) - 1 = length(hu_list) - 1 - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_init.1.1.1.1.2.2.1.

restrictmiddle_init.1.1.1.1.2.2.2 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  (length(i!3`2) = P!1 - 1)
[-2]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(1 + i)
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  p = P!1
[-6]  2 <= P!1
  |-------
{1}   FORALL (i: below[length[Identity](cdr(i!3`2))]):
        nth(cdr(i!3`2), i) = nth(cdr(cdr(hu_list)), i)
[2]   cdr(i!3`2) = cdr(cdr(hu_list))

Rerunning step: (delete -3 -6 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.1.1.1.2.2.2 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  (length(i!3`2) = P!1 - 1)
[-2]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(1 + i)
[-3]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-4]  p = P!1
  |-------
[1]   FORALL (i: below[length[Identity](cdr(i!3`2))]):
        nth(cdr(i!3`2), i) = nth(cdr(cdr(hu_list)), i)

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictmiddle_init.1.1.1.1.2.2.2 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

{-1}  i!5 < length[Identity](cdr(i!3`2))
[-2]  (length(i!3`2) = P!1 - 1)
[-3]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(1 + i)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  p = P!1
  |-------
{1}   nth(cdr(i!3`2), i!5) = nth(cdr(cdr(hu_list)), i!5)

Rerunning step: (inst -3 "i!5+1")
Instantiating the top quantifier in -3 with the terms: 
 i!5+1,
this yields  2 subgoals: 
restrictmiddle_init.1.1.1.1.2.2.2.1 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  i!5 < length[Identity](cdr(i!3`2))
[-2]  (length(i!3`2) = P!1 - 1)
{-3}  nth(i!3`2, i!5 + 1) = hu(1 + (i!5 + 1))
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  p = P!1
  |-------
[1]   nth(cdr(i!3`2), i!5) = nth(cdr(cdr(hu_list)), i!5)

Rerunning step: (inst -4 "i!5+2")
Instantiating the top quantifier in -4 with the terms: 
 i!5+2,
this yields  2 subgoals: 
restrictmiddle_init.1.1.1.1.2.2.2.1.1 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  i!5 < length[Identity](cdr(i!3`2))
[-2]  (length(i!3`2) = P!1 - 1)
[-3]  nth(i!3`2, i!5 + 1) = hu(1 + (i!5 + 1))
{-4}  nth(hu_list, i!5 + 2) = hu(i!5 + 2)
[-5]  p = P!1
  |-------
[1]   nth(cdr(i!3`2), i!5) = nth(cdr(cdr(hu_list)), i!5)

Rerunning step: (delete -1 -2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.1.1.1.2.2.2.1.1 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  nth(i!3`2, i!5 + 1) = hu(1 + (i!5 + 1))
[-2]  nth(hu_list, i!5 + 2) = hu(i!5 + 2)
[-3]  p = P!1
  |-------
[1]   nth(cdr(i!3`2), i!5) = nth(cdr(cdr(hu_list)), i!5)

Rerunning step: (grind)
nth rewrites nth(i!3`2, 1 + i!5)
  to nth(cdr(i!3`2), i!5)
nth rewrites nth(cdr(hu_list), 1 + i!5)
  to nth(cdr(cdr(hu_list)), i!5)
nth rewrites nth(hu_list, 2 + i!5)
  to nth(cdr(cdr(hu_list)), i!5)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_init.1.1.1.1.2.2.2.1.1.

restrictmiddle_init.1.1.1.1.2.2.2.1.2 (TCC):   

[-1]  i!5 < length[Identity](cdr(i!3`2))
[-2]  (length(i!3`2) = P!1 - 1)
[-3]  nth(i!3`2, i!5 + 1) = hu(1 + (i!5 + 1))
[-4]  p = P!1
  |-------
{1}   2 + i!5 < p
[2]   nth(cdr(i!3`2), i!5) = nth(cdr(cdr(hu_list)), i!5)

Rerunning step: (delete -3 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.1.1.1.2.2.2.1.2 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  i!5 < length[Identity](cdr(i!3`2))
[-2]  (length(i!3`2) = P!1 - 1)
[-3]  p = P!1
  |-------
[1]   2 + i!5 < p

Rerunning step: (rewrite "length_cdr")
Found matching substitution:
cons_l: (cons?[T]) gets i!3`2,
Rewriting using length_cdr, matching in *,
this simplifies to: 
restrictmiddle_init.1.1.1.1.2.2.2.1.2 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

{-1}  i!5 < length(i!3`2) - 1
[-2]  (length(i!3`2) = P!1 - 1)
[-3]  p = P!1
  |-------
[1]   2 + i!5 < p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_init.1.1.1.1.2.2.2.1.2.


This completes the proof of restrictmiddle_init.1.1.1.1.2.2.2.1.

restrictmiddle_init.1.1.1.1.2.2.2.2 (TCC):   

[-1]  i!5 < length[Identity](cdr(i!3`2))
[-2]  (length(i!3`2) = P!1 - 1)
[-3]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-4]  p = P!1
  |-------
{1}   1 + i!5 < P!1 - 1
[2]   nth(cdr(i!3`2), i!5) = nth(cdr(cdr(hu_list)), i!5)

Rerunning step: (delete -3 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.1.1.1.2.2.2.2 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  i!5 < length[Identity](cdr(i!3`2))
[-2]  (length(i!3`2) = P!1 - 1)
[-3]  p = P!1
  |-------
[1]   1 + i!5 < P!1 - 1

Rerunning step: (rewrite "length_cdr")
Found matching substitution:
cons_l: (cons?[T]) gets i!3`2,
Rewriting using length_cdr, matching in *,
this simplifies to: 
restrictmiddle_init.1.1.1.1.2.2.2.2 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

{-1}  i!5 < length(i!3`2) - 1
[-2]  (length(i!3`2) = P!1 - 1)
[-3]  p = P!1
  |-------
[1]   1 + i!5 < P!1 - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_init.1.1.1.1.2.2.2.2.


This completes the proof of restrictmiddle_init.1.1.1.1.2.2.2.


This completes the proof of restrictmiddle_init.1.1.1.1.2.2.


This completes the proof of restrictmiddle_init.1.1.1.1.2.


This completes the proof of restrictmiddle_init.1.1.1.1.

restrictmiddle_init.1.1.1.2 : 
;;; establish obvious equalities

[-1]  p = P!1
[-2]  2 <= p
  |-------
{1}   ((rec(hu(0), nth(i!3`2, p - 2),
            E(public(hu(0)),
              conc(nlist(cons(n_init, i!3`1)), ilist(i!3`2))))
         >>
         (trans(hu(0), car(i!3`2),
                E(public(car(i!3`2)),
                  conc(ilist(cons(hu(0), cdr(i!3`2))), nlist(i!3`1))))
           >>
           (signal(commit(0, cons(hu(0), i!3`2), n_init)) >> Stop[event])))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (trans(hu(0), car(i!3`2),
                     E(public(car(i!3`2)),
                       conc(nlist((: n_init :)),
                            ilist(cons(hu(0), cdr(i!3`2)))))))
{3}   trans(hu(0), car(i!3`2),
            E(public(car(i!3`2)),
              conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!3`2))))))
       >>
       ((rec(hu(0), nth(i!3`2, p - 2),
             E(public(hu(0)),
               conc(nlist(cons(n_init, i!3`1)), ilist(i!3`2))))
          >>
          (trans(hu(0), car(i!3`2),
                 E(public(car(i!3`2)),
                   conc(ilist(cons(hu(0), cdr(i!3`2))), nlist(i!3`1))))
            >>
            (signal(commit(0, cons(hu(0), i!3`2), n_init)) >>
              Stop[event])))
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.1.1.2 : 
;;; establish obvious equalities

[-1]  p = P!1
[-2]  2 <= p
  |-------
[1]   ((rec(hu(0), nth(i!3`2, p - 2),
            E(public(hu(0)),
              conc(nlist(cons(n_init, i!3`1)), ilist(i!3`2))))
         >>
         (trans(hu(0), car(i!3`2),
                E(public(car(i!3`2)),
                  conc(ilist(cons(hu(0), cdr(i!3`2))), nlist(i!3`1))))
           >>
           (signal(commit(0, cons(hu(0), i!3`2), n_init)) >> Stop[event])))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictmiddle_init.1.1.1.2 : 
;;; establish obvious equalities

{-1}  rho_middle(i!1)
                (E(public(hu(0)),
                   conc(nlist(cons(n_init, i!3`1)), ilist(i!3`2))))
[-2]  p = P!1
[-3]  2 <= p
  |-------
{1}   ((trans(hu(0), car(i!3`2),
              E(public(car(i!3`2)),
                conc(ilist(cons(hu(0), cdr(i!3`2))), nlist(i!3`1))))
         >> (signal(commit(0, cons(hu(0), i!3`2), n_init)) >> Stop[event]))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (rec(hu(0), nth(i!3`2, p - 2),
                   E(public(hu(0)),
                     conc(nlist(cons(n_init, i!3`1)), ilist(i!3`2)))))
{3}   rec(hu(0), nth(i!3`2, p - 2),
          E(public(hu(0)), conc(nlist(cons(n_init, i!3`1)), ilist(i!3`2))))
       >>
       ((trans(hu(0), car(i!3`2),
               E(public(car(i!3`2)),
                 conc(ilist(cons(hu(0), cdr(i!3`2))), nlist(i!3`1))))
          >>
          (signal(commit(0, cons(hu(0), i!3`2), n_init)) >> Stop[event]))
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -2 -3 +)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.1.1.2 : 
;;; establish obvious equalities

[-1]  rho_middle(i!1)
                (E(public(hu(0)),
                   conc(nlist(cons(n_init, i!3`1)), ilist(i!3`2))))
  |-------

Rerunning step: (comment "-1 evaluates to false")
Adding comment: -1 evaluates to false
this simplifies to: 
restrictmiddle_init.1.1.1.2 : 
;;; -1 evaluates to false

[-1]  rho_middle(i!1)
                (E(public(hu(0)),
                   conc(nlist(cons(n_init, i!3`1)), ilist(i!3`2))))
  |-------

Rerunning step: (grind :if-match nil)
E rewrites E(public(hu(0)), conc(nlist(cons(n_init, i!3`1)), ilist(i!3`2)))
  to code(public(hu(0)), conc(nlist(cons(n_init, i!3`1)), ilist(i!3`2)))
elt rewrites elt(cons(n_init, i!3`1), n_init)
  to EXISTS (i: below[length(cons(n_init, i!3`1))]):
        nth(cons(n_init, i!3`1), i) = n_init
rho_middle rewrites rho_middle(i!1)(nlist(cons(n_init, i!3`1)))
  to NOT EXISTS (i: below[length(cons(n_init, i!3`1))]):
            nth(cons(n_init, i!3`1), i) = n_init
rho_middle rewrites rho_middle(i!1)(ilist(i!3`2))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)(conc(nlist(cons(n_init, i!3`1)), ilist(i!3`2)))
  to NOT EXISTS (i: below[length(cons(n_init, i!3`1))]):
            nth(cons(n_init, i!3`1), i) = n_init
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites 
  rho_middle(i!1)
            (code(public(hu(0)),
                  conc(nlist(cons(n_init, i!3`1)), ilist(i!3`2))))
  to NOT EXISTS (i: below[length(cons(n_init, i!3`1))]):
            nth(cons(n_init, i!3`1), i) = n_init
       OR
       EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
         public(hu(0)) = public(hu(j)) AND
          EXISTS (l: {x: list[Nonce] | length(x) = j - 1}):
            conc(nlist(cons(n_init, i!3`1)), ilist(i!3`2)) =
             conc(nlist(cons(n_init, l)),
                  ilist(cons(car(hu_list), remove(cdr(hu_list), j - 1))))
Trying repeated skolemization, instantiation, and if-lifting,
this yields  2 subgoals: 
restrictmiddle_init.1.1.1.2.1 : 
;;; -1 evaluates to false

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
{-2}  length(l!1) = j!1 - 1
{-3}  0 < j!1
{-4}  j!1 <= i!1
{-5}  public(hu(0)) = public(hu(j!1))
{-6}  conc(nlist(cons(n_init, i!3`1)), ilist(i!3`2)) =
       conc(nlist(cons(n_init, l!1)),
            ilist(cons(car(hu_list), remove(cdr(hu_list), j!1 - 1))))
  |-------

Rerunning step: (comment "contradiction in terms -3 and -5")
Adding comment: contradiction in terms -3 and -5
this simplifies to: 
restrictmiddle_init.1.1.1.2.1 : 
;;; contradiction in terms -3 and -5

[-1]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
[-2]  length(l!1) = j!1 - 1
[-3]  0 < j!1
[-4]  j!1 <= i!1
[-5]  public(hu(0)) = public(hu(j!1))
[-6]  conc(nlist(cons(n_init, i!3`1)), ilist(i!3`2)) =
       conc(nlist(cons(n_init, l!1)),
            ilist(cons(car(hu_list), remove(cdr(hu_list), j!1 - 1))))
  |-------

Rerunning step: (delete -1 -2 -4 -6)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.1.1.2.1 : 
;;; contradiction in terms -3 and -5

[-1]  0 < j!1
[-2]  public(hu(0)) = public(hu(j!1))
  |-------

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_init.1.1.1.2.1 : 
;;; contradiction in terms -3 and -5

{-1}  hu(0) = hu(j!1)
[-2]  0 < j!1
  |-------

Rerunning step: (typepred "hu")
Adding type constraints for  hu,
this simplifies to: 
restrictmiddle_init.1.1.1.2.1 : 
;;; contradiction in terms -3 and -5

{-1}  FORALL (i, j: nat_to_p): i /= j IMPLIES hu(i) /= hu(j)
[-2]  hu(0) = hu(j!1)
[-3]  0 < j!1
  |-------

Rerunning step: (inst -1 "0" "j!1")
Instantiating the top quantifier in -1 with the terms: 
 0, j!1,
this simplifies to: 
restrictmiddle_init.1.1.1.2.1 : 
;;; contradiction in terms -3 and -5

{-1}  0 /= j!1 IMPLIES hu(0) /= hu(j!1)
[-2]  hu(0) = hu(j!1)
[-3]  0 < j!1
  |-------

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_init.1.1.1.2.1.

restrictmiddle_init.1.1.1.2.2 : 
;;; -1 evaluates to false

  |-------
{1}   EXISTS (i: below[length(cons(n_init, i!3`1))]):
        nth(cons(n_init, i!3`1), i) = n_init

Rerunning step: (comment "consequent 1 was a negated antecedent")
Adding comment: consequent 1 was a negated antecedent
this simplifies to: 
restrictmiddle_init.1.1.1.2.2 : 
;;; consequent 1 was a negated antecedent

  |-------
[1]   EXISTS (i: below[length(cons(n_init, i!3`1))]):
        nth(cons(n_init, i!3`1), i) = n_init

Rerunning step: (inst 1 "0")
length rewrites length[Nonce](cons[Nonce](n_init, i!3`1))
  to 1 + length(i!3`1)
Instantiating the top quantifier in 1 with the terms: 
 0,
this simplifies to: 
restrictmiddle_init.1.1.1.2.2 : 
;;; consequent 1 was a negated antecedent

  |-------
{1}   nth(cons(n_init, i!3`1), 0) = n_init

Rerunning step: (expand "nth")
Expanding the definition of nth,
this simplifies to: 
restrictmiddle_init.1.1.1.2.2 : 
;;; consequent 1 was a negated antecedent

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictmiddle_init.1.1.1.2.2.


This completes the proof of restrictmiddle_init.1.1.1.2.


This completes the proof of restrictmiddle_init.1.1.1.

restrictmiddle_init.1.1.2 : 
;;; establish obvious equalities

[-1]  2 <= p
[-2]  i!2 = n_init
  |-------
{1}   u!1 = hu(0) AND p = P!1
[2]   (trans(u!1, car(i!3`2),
             E(public(car(i!3`2)),
               conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i!3`2))))))
        >>
        (rec(u!1, nth(i!3`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
          >>
          (trans(u!1, car(i!3`2),
                 E(public(car(i!3`2)),
                   conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
            >> (signal(commit(0, cons(u!1, i!3`2), i!2)) >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -1 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.1.2 : 
;;; establish obvious equalities

[-1]  i!2 = n_init
  |-------
[1]   u!1 = hu(0) AND p = P!1

Rerunning step: (typepred "i!2")
Adding type constraints for  i!2,
this simplifies to: 
restrictmiddle_init.1.1.2 : 
;;; establish obvious equalities

{-1}  IRpart(P!1, u!1, 0)(i!2)
[-2]  i!2 = n_init
  |-------
[1]   u!1 = hu(0) AND p = P!1

Rerunning step: (lemma "n_orig" ("P" "P!1" "u" "u!1"))
Applying n_orig where 
  P gets P!1,
  u gets u!1,
this simplifies to: 
restrictmiddle_init.1.1.2 : 
;;; establish obvious equalities

{-1}  IRpart(P!1, u!1, 0)(n_init) => (P!1 = p AND u!1 = hu(0))
[-2]  IRpart(P!1, u!1, 0)(i!2)
[-3]  i!2 = n_init
  |-------
[1]   u!1 = hu(0) AND p = P!1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_init.1.1.2.


This completes the proof of restrictmiddle_init.1.1.

restrictmiddle_init.1.2 :  

[-1]  2 <= p
[-2]  i!2 = n_init
  |-------
{1}   P!1 - 2 < length[Identity](i!3`2)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     (length(x) = P!1 - 1) AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, i`1)), ilist(i`2))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
              >> (signal(commit(0, cons(u!1, i`2), i!2)) >> Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (typepred "i!3`2")
Adding type constraints for  i!3`2,
this simplifies to: 
restrictmiddle_init.1.2 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`2)
{-2}  (length(i!3`2) = P!1 - 1)
{-3}  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(1 + i)
[-4]  2 <= p
[-5]  i!2 = n_init
  |-------
[1]   P!1 - 2 < length[Identity](i!3`2)
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     (length(x) = P!1 - 1) AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, i`1)), ilist(i`2))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
              >> (signal(commit(0, cons(u!1, i`2), i!2)) >> Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -3 -4 -5 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.2 :  

[-1]  (length(i!3`2) = P!1 - 1)
  |-------
[1]   P!1 - 2 < length[Identity](i!3`2)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_init.1.2.

restrictmiddle_init.1.3 :  

[-1]  2 <= p
[-2]  i!2 = n_init
  |-------
{1}   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!2 :))
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     (length(x) = P!1 - 1) AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, i`1)), ilist(i`2))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
              >> (signal(commit(0, cons(u!1, i`2), i!2)) >> Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.3 :  

[-1]  2 <= p
[-2]  i!2 = n_init
  |-------
[1]   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!2 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!2 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_init.1.3.

restrictmiddle_init.1.4 :  

[-1]  2 <= p
[-2]  i!2 = n_init
  |-------
{1}   cons?[Identity](i!3`2)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     (length(x) = P!1 - 1) AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, i`1)), ilist(i`2))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
              >> (signal(commit(0, cons(u!1, i`2), i!2)) >> Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.4 :  

[-1]  2 <= p
[-2]  i!2 = n_init
  |-------
[1]   cons?[Identity](i!3`2)

Rerunning step: (nonemptylist "i!3`2")
Relating existence of a tail to a list's length,

This completes the proof of restrictmiddle_init.1.4.

restrictmiddle_init.1.5 :  

[-1]  2 <= p
[-2]  i!2 = n_init
  |-------
{1}   (length(x!1) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     (length(x) = P!1 - 1) AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, i`1)), ilist(i`2))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
              >> (signal(commit(0, cons(u!1, i`2), i!2)) >> Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -1 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.5 :  

[-1]  i!2 = n_init
  |-------
[1]   (length(x!1) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p

Rerunning step: (typepred "i!2")
Adding type constraints for  i!2,
this simplifies to: 
restrictmiddle_init.1.5 :  

{-1}  IRpart(P!1, u!1, 0)(i!2)
[-2]  i!2 = n_init
  |-------
[1]   (length(x!1) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p

Rerunning step: (lemma "n_orig" ("P" "P!1" "u" "u!1"))
Applying n_orig where 
  P gets P!1,
  u gets u!1,
this simplifies to: 
restrictmiddle_init.1.5 :  

{-1}  IRpart(P!1, u!1, 0)(n_init) => (P!1 = p AND u!1 = hu(0))
[-2]  IRpart(P!1, u!1, 0)(i!2)
[-3]  i!2 = n_init
  |-------
[1]   (length(x!1) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_init.1.5.

restrictmiddle_init.1.6 :  

[-1]  2 <= p
[-2]  i!2 = n_init
  |-------
{1}   (length(x!1) = P!1 - 1) IMPLIES
       FORALL (i: below[P!1 - 1]): i < length[Identity](x!1)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     (length(x) = P!1 - 1) AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, i`1)), ilist(i`2))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
              >> (signal(commit(0, cons(u!1, i`2), i!2)) >> Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.6 :  

  |-------
[1]   (length(x!1) = P!1 - 1) IMPLIES
       FORALL (i: below[P!1 - 1]): i < length[Identity](x!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_init.1.6.

restrictmiddle_init.1.7 :  

[-1]  2 <= p
[-2]  i!2 = n_init
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il:
                {x: list[Identity] |
                   (length[Identity](x) = P!1 - 1) AND
                    FORALL (i: below[P!1 - 1]):
                      nth[Identity](x, i) = hu(1 + i)}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!2 :))
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1) AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, nl)), ilist(il))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
              >> (signal(commit(0, cons(u!1, il), i!2)) >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.7 :  

[-1]  2 <= p
[-2]  i!2 = n_init
  |-------
[1]   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il:
                {x: list[Identity] |
                   (length[Identity](x) = P!1 - 1) AND
                    FORALL (i: below[P!1 - 1]):
                      nth[Identity](x, i) = hu(1 + i)}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!2 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!2 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_init.1.7.

restrictmiddle_init.1.8 :  

[-1]  2 <= p
[-2]  i!2 = n_init
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il:
                {x: list[Identity] |
                   (length[Identity](x) = P!1 - 1) AND
                    FORALL (i: below[P!1 - 1]):
                      nth[Identity](x, i) = hu(1 + i)}):
        cons?[Identity](il)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1) AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, nl)), ilist(il))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
              >> (signal(commit(0, cons(u!1, il), i!2)) >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (skolem-typepred 1)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictmiddle_init.1.8 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl!1)
{-2}  length(nl!1) = P!1 - 1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (il!1)
{-4}  (length(il!1) = P!1 - 1)
{-5}  FORALL (i: below[P!1 - 1]): nth(il!1, i) = hu(1 + i)
[-6]  2 <= p
[-7]  i!2 = n_init
  |-------
{1}   cons?[Identity](il!1)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1) AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, nl)), ilist(il))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
              >> (signal(commit(0, cons(u!1, il), i!2)) >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -2 -3 -5 -6 -7 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.8 :  

[-1]  (length(il!1) = P!1 - 1)
  |-------
[1]   cons?[Identity](il!1)

Rerunning step: (typepred "P!1")
Adding type constraints for  P!1,
this simplifies to: 
restrictmiddle_init.1.8 :  

{-1}  2 <= P!1
[-2]  (length(il!1) = P!1 - 1)
  |-------
[1]   cons?[Identity](il!1)

Rerunning step: (nonemptylist "il!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictmiddle_init.1.8.

restrictmiddle_init.1.9 :  

[-1]  2 <= p
[-2]  i!2 = n_init
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              x: list[Identity]):
        (length(x) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1) AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, nl)), ilist(il))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
              >> (signal(commit(0, cons(u!1, il), i!2)) >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -1 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.9 :  

[-1]  i!2 = n_init
  |-------
[1]   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              x: list[Identity]):
        (length(x) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictmiddle_init.1.9 :  

[-1]  i!2 = n_init
  |-------
{1}   (length(x!1) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p

Rerunning step: (typepred "i!2")
Adding type constraints for  i!2,
this simplifies to: 
restrictmiddle_init.1.9 :  

{-1}  IRpart(P!1, u!1, 0)(i!2)
[-2]  i!2 = n_init
  |-------
[1]   (length(x!1) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p

Rerunning step: (lemma "n_orig" ("P" "P!1" "u" "u!1"))
Applying n_orig where 
  P gets P!1,
  u gets u!1,
this simplifies to: 
restrictmiddle_init.1.9 :  

{-1}  IRpart(P!1, u!1, 0)(n_init) => (P!1 = p AND u!1 = hu(0))
[-2]  IRpart(P!1, u!1, 0)(i!2)
[-3]  i!2 = n_init
  |-------
[1]   (length(x!1) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_init.1.9.

restrictmiddle_init.1.10 :  

[-1]  2 <= p
[-2]  i!2 = n_init
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              x: list[Identity]):
        (length(x) = P!1 - 1) IMPLIES
         FORALL (i: below[P!1 - 1]): i < length[Identity](x)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1) AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, nl)), ilist(il))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
              >> (signal(commit(0, cons(u!1, il), i!2)) >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.10 :  

  |-------
[1]   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              x: list[Identity]):
        (length(x) = P!1 - 1) IMPLIES
         FORALL (i: below[P!1 - 1]): i < length[Identity](x)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictmiddle_init.1.10 :  

  |-------
{1}   (length(x!1) = P!1 - 1) IMPLIES
       FORALL (i: below[P!1 - 1]): i < length[Identity](x!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_init.1.10.

restrictmiddle_init.1.11 :  

[-1]  2 <= p
[-2]  i!2 = n_init
  |-------
{1}   FORALL (x: list[Identity]):
        (length(x) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1) AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, nl)), ilist(il))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
              >> (signal(commit(0, cons(u!1, il), i!2)) >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -1 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.11 :  

[-1]  i!2 = n_init
  |-------
[1]   FORALL (x: list[Identity]):
        (length(x) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictmiddle_init.1.11 :  

[-1]  i!2 = n_init
  |-------
{1}   (length(x!1) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p

Rerunning step: (typepred i!2)
Adding type constraints for  i!2,
this simplifies to: 
restrictmiddle_init.1.11 :  

{-1}  IRpart(P!1, u!1, 0)(i!2)
[-2]  i!2 = n_init
  |-------
[1]   (length(x!1) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p

Rerunning step: (lemma "n_orig" ("P" "P!1" "u" "u!1"))
Applying n_orig where 
  P gets P!1,
  u gets u!1,
this simplifies to: 
restrictmiddle_init.1.11 :  

{-1}  IRpart(P!1, u!1, 0)(n_init) => (P!1 = p AND u!1 = hu(0))
[-2]  IRpart(P!1, u!1, 0)(i!2)
[-3]  i!2 = n_init
  |-------
[1]   (length(x!1) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_init.1.11.

restrictmiddle_init.1.12 :  

[-1]  2 <= p
[-2]  i!2 = n_init
  |-------
{1}   FORALL (x: list[Identity]):
        (length(x) = P!1 - 1) IMPLIES
         FORALL (i: below[P!1 - 1]): i < length[Identity](x)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1) AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, nl)), ilist(il))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
              >> (signal(commit(0, cons(u!1, il), i!2)) >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.12 :  

  |-------
[1]   FORALL (x: list[Identity]):
        (length(x) = P!1 - 1) IMPLIES
         FORALL (i: below[P!1 - 1]): i < length[Identity](x)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictmiddle_init.1.12 :  

  |-------
{1}   (length(x!1) = P!1 - 1) IMPLIES
       FORALL (i: below[P!1 - 1]): i < length[Identity](x!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_init.1.12.


This completes the proof of restrictmiddle_init.1.

restrictmiddle_init.2 :  

  |-------
{1}   i!2 = n_init
{2}   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, nl)), ilist(il))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
              >> (signal(commit(0, cons(u!1, il), i!2)) >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (typepred "P!1")
Adding type constraints for  P!1,
this simplifies to: 
restrictmiddle_init.2 :  

{-1}  2 <= P!1
  |-------
[1]   i!2 = n_init
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, nl)), ilist(il))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
              >> (signal(commit(0, cons(u!1, il), i!2)) >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (choice3)
Applying choice rule,
this yields  6 subgoals: 
restrictmiddle_init.2.1 :  

[-1]  2 <= P!1
  |-------
[1]   i!2 = n_init
{2}   (trans(u!1, car(i!3`2),
             E(public(car(i!3`2)),
               conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i!3`2))))))
        >>
        (rec(u!1, nth(i!3`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
          >>
          (trans(u!1, car(i!3`2),
                 E(public(car(i!3`2)),
                   conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
            >> (signal(commit(0, cons(u!1, i!3`2), i!2)) >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictmiddle_init.2.1.1 :  

[-1]  2 <= P!1
  |-------
{1}   rho_middle(i!1)
                (E(public(car(i!3`2)),
                   conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i!3`2))))))
{2}   R_middle(i!1)
              (trans(u!1, car(i!3`2),
                     E(public(car(i!3`2)),
                       conc(nlist((: i!2 :)),
                            ilist(cons(u!1, cdr(i!3`2)))))))
{3}   trans(u!1, car(i!3`2),
            E(public(car(i!3`2)),
              conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i!3`2))))))
       >>
       ((rec(u!1, nth(i!3`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
          >>
          (trans(u!1, car(i!3`2),
                 E(public(car(i!3`2)),
                   conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
            >> (signal(commit(0, cons(u!1, i!3`2), i!2)) >> Stop[event])))
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   i!2 = n_init

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.2.1.1 :  

[-1]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (E(public(car(i!3`2)),
                   conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i!3`2))))))
[2]   i!2 = n_init

Rerunning step: (grind)
E rewrites 
  E(public(car(i!3`2)),
    conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i!3`2)))))
  to code(public(car(i!3`2)),
           conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i!3`2)))))
elt rewrites elt((: i!2 :), n_init)
  to EXISTS (i: below[length((: i!2 :))]): nth((: i!2 :), i) = n_init
rho_middle rewrites rho_middle(i!1)(nlist((: i!2 :)))
  to NOT EXISTS (i: below[length((: i!2 :))]): nth((: i!2 :), i) = n_init
rho_middle rewrites rho_middle(i!1)(ilist(cons(u!1, cdr(i!3`2))))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)(conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i!3`2)))))
  to NOT EXISTS (i: below[length((: i!2 :))]): nth((: i!2 :), i) = n_init
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites 
  rho_middle(i!1)
            (code(public(car(i!3`2)),
                  conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i!3`2))))))
  to NOT EXISTS (i: below[length((: i!2 :))]): nth((: i!2 :), i) = n_init
       OR
       EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
         public(car(i!3`2)) = public(hu(j)) AND
          EXISTS (l: {x: list[Nonce] | length(x) = j - 1}):
            conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i!3`2)))) =
             conc(nlist(cons(n_init, l)),
                  ilist(cons(car(hu_list), remove(cdr(hu_list), j - 1))))
length rewrites length((: :))
  to 0
length rewrites length((: i!2 :))
  to 1
nth rewrites nth((: i!2 :), i!4)
  to i!2
length rewrites length((: :))
  to 0
length rewrites length((: i!2 :))
  to 1
nth rewrites nth((: i!2 :), i!4)
  to i!2
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_init.2.1.1.

restrictmiddle_init.2.1.2 :  

[-1]  2 <= P!1
  |-------
{1}   ((rec(u!1, nth(i!3`2, P!1 - 2),
            E(public(u!1), conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
         >>
         (trans(u!1, car(i!3`2),
                E(public(car(i!3`2)),
                  conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
           >> (signal(commit(0, cons(u!1, i!3`2), i!2)) >> Stop[event])))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (trans(u!1, car(i!3`2),
                     E(public(car(i!3`2)),
                       conc(nlist((: i!2 :)),
                            ilist(cons(u!1, cdr(i!3`2)))))))
{3}   trans(u!1, car(i!3`2),
            E(public(car(i!3`2)),
              conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i!3`2))))))
       >>
       ((rec(u!1, nth(i!3`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
          >>
          (trans(u!1, car(i!3`2),
                 E(public(car(i!3`2)),
                   conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
            >> (signal(commit(0, cons(u!1, i!3`2), i!2)) >> Stop[event])))
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   i!2 = n_init

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.2.1.2 :  

[-1]  2 <= P!1
  |-------
[1]   ((rec(u!1, nth(i!3`2, P!1 - 2),
            E(public(u!1), conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
         >>
         (trans(u!1, car(i!3`2),
                E(public(car(i!3`2)),
                  conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
           >> (signal(commit(0, cons(u!1, i!3`2), i!2)) >> Stop[event])))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[2]   i!2 = n_init

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictmiddle_init.2.1.2 :  

{-1}  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
{1}   ((trans(u!1, car(i!3`2),
              E(public(car(i!3`2)),
                conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
         >> (signal(commit(0, cons(u!1, i!3`2), i!2)) >> Stop[event]))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (rec(u!1, nth(i!3`2, P!1 - 2),
                   E(public(u!1),
                     conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2)))))
{3}   rec(u!1, nth(i!3`2, P!1 - 2),
          E(public(u!1), conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
       >>
       ((trans(u!1, car(i!3`2),
               E(public(car(i!3`2)),
                 conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
          >> (signal(commit(0, cons(u!1, i!3`2), i!2)) >> Stop[event]))
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   i!2 = n_init

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.2.1.2 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
[1]   ((trans(u!1, car(i!3`2),
              E(public(car(i!3`2)),
                conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
         >> (signal(commit(0, cons(u!1, i!3`2), i!2)) >> Stop[event]))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[2]   i!2 = n_init

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictmiddle_init.2.1.2.1 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
{1}   rho_middle(i!1)
                (E(public(car(i!3`2)),
                   conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
{2}   R_middle(i!1)
              (trans(u!1, car(i!3`2),
                     E(public(car(i!3`2)),
                       conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1)))))
{3}   trans(u!1, car(i!3`2),
            E(public(car(i!3`2)),
              conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
       >>
       ((signal(commit(0, cons(u!1, i!3`2), i!2)) >> Stop[event]) #
         R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   i!2 = n_init

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.2.1.2.1 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (E(public(car(i!3`2)),
                   conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
[2]   i!2 = n_init

Rerunning step: (expand "rho_middle" -1)
Expanding the definition of rho_middle,
this simplifies to: 
restrictmiddle_init.2.1.2.1 :  

{-1}  CASES E(public(u!1), conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2)))
        OF nonce(z): z /= n_init,
           nlist(z): NOT elt(z, n_init),
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i)),
           conc(z1, z2): rho_middle(i!1)(z1) AND rho_middle(i!1)(z2),
           commit(z1, z2, z3): z1 /= 0 OR z2 /= hu_list OR z3 /= n_init,
           code(z1, z2):
             rho_middle(i!1)(z2) OR
              EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
                z1 = public(hu(j)) AND
                 EXISTS (l: {x: list[Nonce] | length(x) = j - 1}):
                   z2 =
                    conc(nlist(cons(n_init, l)), ilist(remove(hu_list, j)))
        ELSE TRUE
        ENDCASES
[-2]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (E(public(car(i!3`2)),
                   conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
[2]   i!2 = n_init

Rerunning step: (grind :exclude "rho_middle")
E rewrites 
  E(public(car(i!3`2)), conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1)))
  to code(public(car(i!3`2)),
           conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1)))
E rewrites E(public(u!1), conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2)))
  to code(public(u!1), conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2)))
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
Trying repeated skolemization, instantiation, and if-lifting,
this yields  2 subgoals: 
restrictmiddle_init.2.1.2.1.1 :  

{-1}  rho_middle(i!1)(conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2)))
[-2]  2 <= P!1
  |-------
{1}   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
[2]   i!2 = n_init

Rerunning step: (comment "-1 means that nonce n_init is not in the nlist")
Adding comment: -1 means that nonce n_init is not in the nlist
this simplifies to: 
restrictmiddle_init.2.1.2.1.1 : 
;;; -1 means that nonce n_init is not in the nlist

[-1]  rho_middle(i!1)(conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2)))
[-2]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
[2]   i!2 = n_init

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.2.1.2.1.1 : 
;;; -1 means that nonce n_init is not in the nlist

[-1]  rho_middle(i!1)(conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2)))
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
[2]   i!2 = n_init

Rerunning step: (expand "rho_middle" -1)
Expanding the definition of rho_middle,
this simplifies to: 
restrictmiddle_init.2.1.2.1.1 : 
;;; -1 means that nonce n_init is not in the nlist

{-1}  rho_middle(i!1)(nlist(cons(i!2, i!3`1))) AND
       rho_middle(i!1)(ilist(i!3`2))
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
[2]   i!2 = n_init

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictmiddle_init.2.1.2.1.1 : 
;;; -1 means that nonce n_init is not in the nlist

{-1}  rho_middle(i!1)(nlist(cons(i!2, i!3`1)))
{-2}  rho_middle(i!1)(ilist(i!3`2))
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
[2]   i!2 = n_init

Rerunning step: (lemma "listprops[Nonce].elt_append2"
                 ("l1" "(: i!2 :)" "l2" "i!3`1" "t" "n_init"))
Applying listprops[Nonce].elt_append2 where 
  l1 gets (: i!2 :),
  l2 gets i!3`1,
  t gets n_init,
this simplifies to: 
restrictmiddle_init.2.1.2.1.1 : 
;;; -1 means that nonce n_init is not in the nlist

{-1}  elt(i!3`1, n_init) IMPLIES elt(append((: i!2 :), i!3`1), n_init)
[-2]  rho_middle(i!1)(nlist(cons(i!2, i!3`1)))
[-3]  rho_middle(i!1)(ilist(i!3`2))
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
[2]   i!2 = n_init

Rerunning step: (grind :exclude "elt")
append rewrites append((: :), i!3`1)
  to i!3`1
append rewrites append((: i!2 :), i!3`1)
  to cons(i!2, i!3`1)
rho_middle rewrites rho_middle(i!1)(ilist(cons(u!1, cdr(i!3`2))))
  to TRUE
rho_middle rewrites rho_middle(i!1)(nlist(i!3`1))
  to NOT elt(i!3`1, n_init)
rho_middle rewrites 
  rho_middle(i!1)(conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1)))
  to NOT elt(i!3`1, n_init)
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites 
  rho_middle(i!1)
            (code(public(car(i!3`2)),
                  conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
  to NOT elt(i!3`1, n_init) OR
       EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
         public(car(i!3`2)) = public(hu(j)) AND
          EXISTS (l: {x: list[Nonce] | length(x) = j - 1}):
            conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1)) =
             conc(nlist(cons(n_init, l)),
                  ilist(cons(car(hu_list), remove(cdr(hu_list), j - 1))))
rho_middle rewrites rho_middle(i!1)(nlist(cons(i!2, i!3`1)))
  to FALSE
rho_middle rewrites rho_middle(i!1)(ilist(cons(u!1, cdr(i!3`2))))
  to TRUE
rho_middle rewrites rho_middle(i!1)(nlist(i!3`1))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)(conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1)))
  to TRUE
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites 
  rho_middle(i!1)
            (code(public(car(i!3`2)),
                  conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_init.2.1.2.1.1.

restrictmiddle_init.2.1.2.1.2 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
{-2}  length(l!1) = j!1 - 1
{-3}  0 < j!1
{-4}  j!1 <= i!1
{-5}  public(u!1) = public(hu(j!1))
{-6}  conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2)) =
       conc(nlist(cons(n_init, l!1)),
            ilist(cons(car(hu_list), remove(cdr(hu_list), j!1 - 1))))
[-7]  2 <= P!1
  |-------
{1}   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
[2]   i!2 = n_init

Rerunning step: (comment "i!2 = n_init is provable from -6")
Adding comment: i!2 = n_init is provable from -6
this simplifies to: 
restrictmiddle_init.2.1.2.1.2 : 
;;; i!2 = n_init is provable from -6

[-1]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
[-2]  length(l!1) = j!1 - 1
[-3]  0 < j!1
[-4]  j!1 <= i!1
[-5]  public(u!1) = public(hu(j!1))
[-6]  conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2)) =
       conc(nlist(cons(n_init, l!1)),
            ilist(cons(car(hu_list), remove(cdr(hu_list), j!1 - 1))))
[-7]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
[2]   i!2 = n_init

Rerunning step: (mdecompose-equality -6)
Decomposing equalities,

This completes the proof of restrictmiddle_init.2.1.2.1.2.


This completes the proof of restrictmiddle_init.2.1.2.1.

restrictmiddle_init.2.1.2.2 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
{1}   ((signal(commit(0, cons(u!1, i!3`2), i!2)) >> Stop[event]) #
        R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (trans(u!1, car(i!3`2),
                     E(public(car(i!3`2)),
                       conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1)))))
{3}   trans(u!1, car(i!3`2),
            E(public(car(i!3`2)),
              conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
       >>
       ((signal(commit(0, cons(u!1, i!3`2), i!2)) >> Stop[event]) #
         R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   i!2 = n_init

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.2.1.2.2 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
[1]   ((signal(commit(0, cons(u!1, i!3`2), i!2)) >> Stop[event]) #
        R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[2]   i!2 = n_init

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictmiddle_init.2.1.2.2.1 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
{1}   rho_middle(i!1)(commit(0, cons(u!1, i!3`2), i!2))
{2}   R_middle(i!1)(signal(commit(0, cons(u!1, i!3`2), i!2)))
{3}   signal(commit(0, cons(u!1, i!3`2), i!2)) >>
       (Stop[event] # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   i!2 = n_init

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.2.1.2.2.1 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
[1]   rho_middle(i!1)(commit(0, cons(u!1, i!3`2), i!2))
[2]   i!2 = n_init

Rerunning step: (comment "1 and 2 are mutually exclusive")
Adding comment: 1 and 2 are mutually exclusive
this simplifies to: 
restrictmiddle_init.2.1.2.2.1 : 
;;; 1 and 2 are mutually exclusive

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
[1]   rho_middle(i!1)(commit(0, cons(u!1, i!3`2), i!2))
[2]   i!2 = n_init

Rerunning step: (grind)
/= rewrites cons(u!1, i!3`2) /= hu_list
  to NOT (cons(u!1, i!3`2) = hu_list)
rho_middle rewrites rho_middle(i!1)(commit(0, cons(u!1, i!3`2), i!2))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_init.2.1.2.2.1.

restrictmiddle_init.2.1.2.2.2 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
{1}   (Stop[event] # R_middle(i!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)(signal(commit(0, cons(u!1, i!3`2), i!2)))
{3}   signal(commit(0, cons(u!1, i!3`2), i!2)) >>
       (Stop[event] # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   i!2 = n_init

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.2.1.2.2.2 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
[1]   (Stop[event] # R_middle(i!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[2]   i!2 = n_init

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictmiddle_init.2.1.2.2.2.


This completes the proof of restrictmiddle_init.2.1.2.2.


This completes the proof of restrictmiddle_init.2.1.2.


This completes the proof of restrictmiddle_init.2.1.

restrictmiddle_init.2.2 :  

[-1]  2 <= P!1
  |-------
{1}   P!1 - 2 < length[Identity](i!3`2)
[2]   i!2 = n_init
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, i`1)), ilist(i`2))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
              >> (signal(commit(0, cons(u!1, i`2), i!2)) >> Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.2.2 :  

  |-------
[1]   P!1 - 2 < length[Identity](i!3`2)

Rerunning step: (typepred "i!3`2")
Adding type constraints for  i!3`2,
this simplifies to: 
restrictmiddle_init.2.2 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`2)
{-2}  length(i!3`2) = P!1 - 1
  |-------
[1]   P!1 - 2 < length[Identity](i!3`2)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_init.2.2.

restrictmiddle_init.2.3 :  

[-1]  2 <= P!1
  |-------
{1}   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!2 :))
[2]   i!2 = n_init
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, i`1)), ilist(i`2))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
              >> (signal(commit(0, cons(u!1, i`2), i!2)) >> Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.2.3 :  

[-1]  2 <= P!1
  |-------
[1]   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!2 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!2 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_init.2.3.

restrictmiddle_init.2.4 :  

[-1]  2 <= P!1
  |-------
{1}   cons?[Identity](i!3`2)
[2]   i!2 = n_init
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, i`1)), ilist(i`2))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
              >> (signal(commit(0, cons(u!1, i`2), i!2)) >> Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.2.4 :  

[-1]  2 <= P!1
  |-------
[1]   cons?[Identity](i!3`2)

Rerunning step: (nonemptylist "i!3`2")
Relating existence of a tail to a list's length,

This completes the proof of restrictmiddle_init.2.4.

restrictmiddle_init.2.5 :  

[-1]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!2 :))
[2]   i!2 = n_init
[3]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, nl)), ilist(il))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
              >> (signal(commit(0, cons(u!1, il), i!2)) >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.2.5 :  

  |-------
[1]   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!2 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!2 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_init.2.5.

restrictmiddle_init.2.6 :  

[-1]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        cons?[Identity](il)
[2]   i!2 = n_init
[3]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, nl)), ilist(il))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
              >> (signal(commit(0, cons(u!1, il), i!2)) >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (skolem-typepred 1)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictmiddle_init.2.6 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl!1)
{-2}  length(nl!1) = P!1 - 1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (il!1)
{-4}  length(il!1) = P!1 - 1
[-5]  2 <= P!1
  |-------
{1}   cons?[Identity](il!1)
[2]   i!2 = n_init
[3]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, nl)), ilist(il))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
              >> (signal(commit(0, cons(u!1, il), i!2)) >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -2 -3 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.2.6 :  

[-1]  length(il!1) = P!1 - 1
[-2]  2 <= P!1
  |-------
[1]   cons?[Identity](il!1)

Rerunning step: (lemma "more_list_props[Identity].length_non_zero"
                 ("l" "il!1"))
Applying more_list_props[Identity].length_non_zero where 
  l gets il!1,
this simplifies to: 
restrictmiddle_init.2.6 :  

{-1}  length(il!1) > 0 IFF cons?(il!1)
[-2]  length(il!1) = P!1 - 1
[-3]  2 <= P!1
  |-------
[1]   cons?[Identity](il!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_init.2.6.


This completes the proof of restrictmiddle_init.2.

Q.E.D.


Run time  = 4.71 secs.
Real time = 6.26 secs.
nil
pvs(42): 
Installing rewrite rule sets.singleton_rew (all instances)
restrictmiddle_middle :  

  |-------
{1}   FORALL (P: nat_from_2, i: nat_1_to(p), u: Identity):
        P /= 2 =>
         (((Interleave! (k: nat_1_to(P), nnK: Nonces(P, u, k)):
              UROLE_MIDDLE(P, k, u, nnK))
            # R_middle(i))
           |> RankUser(rho_middle(i)))

Rerunning step: (auto-rewrite-theory "sets")
Rewriting relative to the theory: sets,
this simplifies to: 
restrictmiddle_middle :  

  |-------
[1]   FORALL (P: nat_from_2, i: nat_1_to(p), u: Identity):
        P /= 2 =>
         (((Interleave! (k: nat_1_to(P), nnK: Nonces(P, u, k)):
              UROLE_MIDDLE(P, k, u, nnK))
            # R_middle(i))
           |> RankUser(rho_middle(i)))

Rerunning step: (auto-rewrite "USER_TCC2")
Installing rewrite rule gnsl_init.USER_TCC2
Installing automatic rewrites from: 
  USER_TCC2
this simplifies to: 
restrictmiddle_middle :  

  |-------
[1]   FORALL (P: nat_from_2, i: nat_1_to(p), u: Identity):
        P /= 2 =>
         (((Interleave! (k: nat_1_to(P), nnK: Nonces(P, u, k)):
              UROLE_MIDDLE(P, k, u, nnK))
            # R_middle(i))
           |> RankUser(rho_middle(i)))

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictmiddle_middle :  

  |-------
{1}   P!1 /= 2 =>
       (((Interleave! (k: nat_1_to(P!1), nnK: Nonces(P!1, u!1, k)):
            UROLE_MIDDLE(P!1, k, u!1, nnK))
          # R_middle(i!1))
         |> RankUser(rho_middle(i!1)))

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictmiddle_middle :  

  |-------
{1}   P!1 = 2
{2}   (((Interleave! (k: nat_1_to(P!1), nnK: Nonces(P!1, u!1, k)):
           UROLE_MIDDLE(P!1, k, u!1, nnK))
         # R_middle(i!1))
        |> RankUser(rho_middle(i!1)))

Rerunning step: (expand "RankUser")
Expanding the definition of RankUser,
this simplifies to: 
restrictmiddle_middle :  

  |-------
[1]   P!1 = 2
{2}   (((Interleave! (k: nat_1_to(P!1), nnK: Nonces(P!1, u!1, k)):
           UROLE_MIDDLE(P!1, k, u!1, nnK))
         # R_middle(i!1))
        |>
        LAMBDA (tr: list[event]):
          every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(tr)
           =>
           every(LAMBDA (e: event):
                   complement(rec?)(e) => rho_middle(i!1)(msg(e)))
                (tr))

Rerunning step: (interleaving2)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
USER_TCC2 rewrites EXISTS (x: [k: nat_1_to(P!1), Nonces(P!1, u!1, k)]): TRUE
  to TRUE
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
USER_TCC2 rewrites EXISTS (x: [k: nat_1_to(P!1), Nonces(P!1, u!1, k)]): TRUE
  to TRUE
Applying interleaving rule,
this simplifies to: 
restrictmiddle_middle :  

  |-------
[1]   P!1 = 2
{2}   UROLE_MIDDLE(P!1, i!2`1, u!1, i!2`2) # R_middle(i!1) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (expand "UROLE_MIDDLE")
Expanding the definition of UROLE_MIDDLE,
this simplifies to: 
restrictmiddle_middle :  

  |-------
[1]   P!1 = 2
{2}   Choice! (nl1: {x: list[Nonce] | length(x) = i!2`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!2`1},
               il1: {x: list[Identity] | length(x) = i!2`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!2`1}):
        (rec(u!1, nth(il1, i!2`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (signal(running(i!2`1, append(il1, cons(u!1, il2)), car(nl1))) >>
            (trans(u!1, car(il2),
                   E(public(car(il2)),
                     conc(nlist(append(nl1, (: i!2`2 :))),
                          ilist(append(il1, cons(u!1, cdr(il2)))))))
              >>
              (rec(u!1, nth(il1, i!2`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(il1, il2)),
                          nlist(cons(i!2`2, nl2)))))
                >>
                ((LastMessage(P!1, i!2`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (typepred "P!1" "i!2`1")
Adding type constraints for  P!1, i!2`1,
this simplifies to: 
restrictmiddle_middle :  

{-1}  2 <= P!1
{-2}  0 < i!2`1
{-3}  i!2`1 < P!1 - 1
  |-------
[1]   P!1 = 2
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!2`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!2`1},
               il1: {x: list[Identity] | length(x) = i!2`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!2`1}):
        (rec(u!1, nth(il1, i!2`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (signal(running(i!2`1, append(il1, cons(u!1, il2)), car(nl1))) >>
            (trans(u!1, car(il2),
                   E(public(car(il2)),
                     conc(nlist(append(nl1, (: i!2`2 :))),
                          ilist(append(il1, cons(u!1, cdr(il2)))))))
              >>
              (rec(u!1, nth(il1, i!2`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(il1, il2)),
                          nlist(cons(i!2`2, nl2)))))
                >>
                ((LastMessage(P!1, i!2`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (choice3)
Applying choice rule,
this yields  6 subgoals: 
restrictmiddle_middle.1 :  

[-1]  2 <= P!1
[-2]  0 < i!2`1
[-3]  i!2`1 < P!1 - 1
  |-------
[1]   P!1 = 2
{2}   (rec(u!1, nth(i!3`3, i!2`1 - 1),
           E(public(u!1), conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
        >>
        (signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                        car(i!3`1)))
          >>
          (trans(u!1, car(i!3`4),
                 E(public(car(i!3`4)),
                   conc(nlist(append(i!3`1, (: i!2`2 :))),
                        ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
            >>
            (rec(u!1, nth(i!3`3, i!2`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i!3`3, i!3`4)),
                        nlist(cons(i!2`2, i!3`2)))))
              >>
              ((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4))
                >> Stop[event])))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictmiddle_middle.1 :  

{-1}  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
{1}   ((signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)), car(i!3`1)))
         >>
         (trans(u!1, car(i!3`4),
                E(public(car(i!3`4)),
                  conc(nlist(append(i!3`1, (: i!2`2 :))),
                       ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
           >>
           (rec(u!1, nth(i!3`3, i!2`1 - 1),
                E(public(u!1),
                  conc(ilist(append(i!3`3, i!3`4)),
                       nlist(cons(i!2`2, i!3`2)))))
             >>
             ((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
               Stop[event]))))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (rec(u!1, nth(i!3`3, i!2`1 - 1),
                   E(public(u!1),
                     conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))))
{3}   rec(u!1, nth(i!3`3, i!2`1 - 1),
          E(public(u!1), conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
       >>
       ((signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                        car(i!3`1)))
          >>
          (trans(u!1, car(i!3`4),
                 E(public(car(i!3`4)),
                   conc(nlist(append(i!3`1, (: i!2`2 :))),
                        ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
            >>
            (rec(u!1, nth(i!3`3, i!2`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i!3`3, i!3`4)),
                        nlist(cons(i!2`2, i!3`2)))))
              >>
              ((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4))
                >> Stop[event]))))
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   ((signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)), car(i!3`1)))
         >>
         (trans(u!1, car(i!3`4),
                E(public(car(i!3`4)),
                  conc(nlist(append(i!3`1, (: i!2`2 :))),
                       ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
           >>
           (rec(u!1, nth(i!3`3, i!2`1 - 1),
                E(public(u!1),
                  conc(ilist(append(i!3`3, i!3`4)),
                       nlist(cons(i!2`2, i!3`2)))))
             >>
             ((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
               Stop[event]))))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[2]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictmiddle_middle.1.1 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
{1}   rho_middle(i!1)
                (running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                         car(i!3`1)))
{2}   R_middle(i!1)
              (signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                              car(i!3`1))))
{3}   signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)), car(i!3`1)))
       >>
       ((trans(u!1, car(i!3`4),
               E(public(car(i!3`4)),
                 conc(nlist(append(i!3`1, (: i!2`2 :))),
                      ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
          >>
          (rec(u!1, nth(i!3`3, i!2`1 - 1),
               E(public(u!1),
                 conc(ilist(append(i!3`3, i!3`4)),
                      nlist(cons(i!2`2, i!3`2)))))
            >>
            ((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
              Stop[event])))
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   P!1 = 2

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.1 :  

  |-------
[1]   rho_middle(i!1)
                (running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                         car(i!3`1)))
[2]   P!1 = 2

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
restrictmiddle_middle.1.1 :  

  |-------
{1}   TRUE
[2]   P!1 = 2

which is trivially true.

This completes the proof of restrictmiddle_middle.1.1.

restrictmiddle_middle.1.2 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
{1}   ((trans(u!1, car(i!3`4),
              E(public(car(i!3`4)),
                conc(nlist(append(i!3`1, (: i!2`2 :))),
                     ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
         >>
         (rec(u!1, nth(i!3`3, i!2`1 - 1),
              E(public(u!1),
                conc(ilist(append(i!3`3, i!3`4)),
                     nlist(cons(i!2`2, i!3`2)))))
           >>
           ((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
             Stop[event])))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                              car(i!3`1))))
{3}   signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)), car(i!3`1)))
       >>
       ((trans(u!1, car(i!3`4),
               E(public(car(i!3`4)),
                 conc(nlist(append(i!3`1, (: i!2`2 :))),
                      ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
          >>
          (rec(u!1, nth(i!3`3, i!2`1 - 1),
               E(public(u!1),
                 conc(ilist(append(i!3`3, i!3`4)),
                      nlist(cons(i!2`2, i!3`2)))))
            >>
            ((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
              Stop[event])))
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   P!1 = 2

Rerunning step: (delete 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   ((trans(u!1, car(i!3`4),
              E(public(car(i!3`4)),
                conc(nlist(append(i!3`1, (: i!2`2 :))),
                     ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
         >>
         (rec(u!1, nth(i!3`3, i!2`1 - 1),
              E(public(u!1),
                conc(ilist(append(i!3`3, i!3`4)),
                     nlist(cons(i!2`2, i!3`2)))))
           >>
           ((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
             Stop[event])))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[2]   R_middle(i!1)
              (signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                              car(i!3`1))))
[3]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.1 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
{1}   rho_middle(i!1)
                (E(public(car(i!3`4)),
                   conc(nlist(append(i!3`1, (: i!2`2 :))),
                        ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
{2}   R_middle(i!1)
              (trans(u!1, car(i!3`4),
                     E(public(car(i!3`4)),
                       conc(nlist(append(i!3`1, (: i!2`2 :))),
                            ilist(append(i!3`3, cons(u!1, cdr(i!3`4))))))))
{3}   trans(u!1, car(i!3`4),
            E(public(car(i!3`4)),
              conc(nlist(append(i!3`1, (: i!2`2 :))),
                   ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
       >>
       ((rec(u!1, nth(i!3`3, i!2`1 - 1),
             E(public(u!1),
               conc(ilist(append(i!3`3, i!3`4)),
                    nlist(cons(i!2`2, i!3`2)))))
          >>
          ((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
            Stop[event]))
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   R_middle(i!1)
              (signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                              car(i!3`1))))
[5]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.1 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   rho_middle(i!1)
                (E(public(car(i!3`4)),
                   conc(nlist(append(i!3`1, (: i!2`2 :))),
                        ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[2]   R_middle(i!1)
              (signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                              car(i!3`1))))
[3]   P!1 = 2

Rerunning step: (expand "R_middle")
Expanding the definition of R_middle,
this simplifies to: 
restrictmiddle_middle.1.2.1 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   rho_middle(i!1)
                (E(public(car(i!3`4)),
                   conc(nlist(append(i!3`1, (: i!2`2 :))),
                        ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
{2}   signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)), car(i!3`1))) =
       signal(running(i!1, hu_list, n_init))
[3]   P!1 = 2

Rerunning step: (comment "the process is either blocked on R or continues")
Adding comment: the process is either blocked on R or continues
this simplifies to: 
restrictmiddle_middle.1.2.1 : 
;;; the process is either blocked on R or continues

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   rho_middle(i!1)
                (E(public(car(i!3`4)),
                   conc(nlist(append(i!3`1, (: i!2`2 :))),
                        ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[2]   signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)), car(i!3`1))) =
       signal(running(i!1, hu_list, n_init))
[3]   P!1 = 2

Rerunning step: (case "i!2`1=i!1 AND append(i!3`3,cons(u!1,i!3`4))=hu_list AND car(i!3`1)=n_init")
Case splitting on 
   i!2`1 = i!1 AND
    append(i!3`3, cons(u!1, i!3`4)) = hu_list AND car(i!3`1) = n_init, 
this yields  2 subgoals: 
restrictmiddle_middle.1.2.1.1 : 
;;; the process is either blocked on R or continues

{-1}  i!2`1 = i!1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND car(i!3`1) = n_init
[-2]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
[1]   rho_middle(i!1)
                (E(public(car(i!3`4)),
                   conc(nlist(append(i!3`1, (: i!2`2 :))),
                        ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[2]   signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)), car(i!3`1))) =
       signal(running(i!1, hu_list, n_init))
[3]   P!1 = 2

Rerunning step: (delete -2 -3 -4 -5 1 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.1.1 : 
;;; the process is either blocked on R or continues

[-1]  i!2`1 = i!1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND car(i!3`1) = n_init
  |-------
[1]   signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)), car(i!3`1))) =
       signal(running(i!1, hu_list, n_init))

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_middle.1.2.1.1.

restrictmiddle_middle.1.2.1.2 : 
;;; the process is either blocked on R or continues

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
{1}   i!2`1 = i!1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND car(i!3`1) = n_init
[2]   rho_middle(i!1)
                (E(public(car(i!3`4)),
                   conc(nlist(append(i!3`1, (: i!2`2 :))),
                        ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[3]   signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)), car(i!3`1))) =
       signal(running(i!1, hu_list, n_init))
[4]   P!1 = 2

Rerunning step: (delete 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.1.2 : 
;;; the process is either blocked on R or continues

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   i!2`1 = i!1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND car(i!3`1) = n_init
[2]   rho_middle(i!1)
                (E(public(car(i!3`4)),
                   conc(nlist(append(i!3`1, (: i!2`2 :))),
                        ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[3]   P!1 = 2

Rerunning step: (comment "first and foremost, let us prove that i!2`2 /= n_init")
Adding comment: first and foremost, let us prove that i!2`2 /= n_init
this simplifies to: 
restrictmiddle_middle.1.2.1.2 : 
;;; first and foremost, let us prove that i!2`2 /= n_init

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   i!2`1 = i!1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND car(i!3`1) = n_init
[2]   rho_middle(i!1)
                (E(public(car(i!3`4)),
                   conc(nlist(append(i!3`1, (: i!2`2 :))),
                        ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[3]   P!1 = 2

Rerunning step: (case "i!2`2 /= n_init")
Case splitting on 
   i!2`2 /= n_init, 
this yields  2 subgoals: 
restrictmiddle_middle.1.2.1.2.1 : 
;;; first and foremost, let us prove that i!2`2 /= n_init

{-1}  i!2`2 /= n_init
[-2]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
[1]   i!2`1 = i!1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND car(i!3`1) = n_init
[2]   rho_middle(i!1)
                (E(public(car(i!3`4)),
                   conc(nlist(append(i!3`1, (: i!2`2 :))),
                        ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[3]   P!1 = 2

Rerunning step: (expand "rho_middle" -2)
Expanding the definition of rho_middle,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1 : 
;;; first and foremost, let us prove that i!2`2 /= n_init

[-1]  i!2`2 /= n_init
{-2}  CASES E(public(u!1), conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
        OF nonce(z): z /= n_init,
           nlist(z): NOT elt(z, n_init),
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i)),
           conc(z1, z2): rho_middle(i!1)(z1) AND rho_middle(i!1)(z2),
           commit(z1, z2, z3): z1 /= 0 OR z2 /= hu_list OR z3 /= n_init,
           code(z1, z2):
             rho_middle(i!1)(z2) OR
              EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
                z1 = public(hu(j)) AND
                 EXISTS (l: {x: list[Nonce] | length(x) = j - 1}):
                   z2 =
                    conc(nlist(cons(n_init, l)), ilist(remove(hu_list, j)))
        ELSE TRUE
        ENDCASES
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
[1]   i!2`1 = i!1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND car(i!3`1) = n_init
[2]   rho_middle(i!1)
                (E(public(car(i!3`4)),
                   conc(nlist(append(i!3`1, (: i!2`2 :))),
                        ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[3]   P!1 = 2

Rerunning step: (grind :exclude ("rho_middle" "remove"))
/= rewrites i!2`2 /= n_init
  to NOT (i!2`2 = n_init)
E rewrites 
  E(public(car(i!3`4)),
    conc(nlist(append(i!3`1, (: i!2`2 :))),
         ilist(append(i!3`3, cons(u!1, cdr(i!3`4))))))
  to code(public(car(i!3`4)),
           conc(nlist(append(i!3`1, (: i!2`2 :))),
                ilist(append(i!3`3, cons(u!1, cdr(i!3`4))))))
E rewrites E(public(u!1), conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
  to code(public(u!1), conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
/= rewrites i!2`2 /= n_init
  to NOT (i!2`2 = n_init)
E rewrites 
  E(public(car(i!3`4)),
    conc(nlist(append(i!3`1, (: i!2`2 :))),
         ilist(append(i!3`3, cons(u!1, cdr(i!3`4))))))
  to code(public(car(i!3`4)),
           conc(nlist(append(i!3`1, (: i!2`2 :))),
                ilist(append(i!3`3, cons(u!1, cdr(i!3`4))))))
E rewrites E(public(u!1), conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
  to code(public(u!1), conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
/= rewrites i!2`2 /= n_init
  to NOT (i!2`2 = n_init)
E rewrites 
  E(public(car(i!3`4)),
    conc(nlist(append(i!3`1, (: i!2`2 :))),
         ilist(append(i!3`3, cons(u!1, cdr(i!3`4))))))
  to code(public(car(i!3`4)),
           conc(nlist(append(i!3`1, (: i!2`2 :))),
                ilist(append(i!3`3, cons(u!1, cdr(i!3`4))))))
E rewrites E(public(u!1), conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
  to code(public(u!1), conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
Trying repeated skolemization, instantiation, and if-lifting,
this yields  6 subgoals: 
restrictmiddle_middle.1.2.1.2.1.1 : 
;;; first and foremost, let us prove that i!2`2 /= n_init

{-1}  rho_middle(i!1)(conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
{1}   (i!2`2 = n_init)
{2}   car(i!3`1) = n_init
{3}   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[4]   P!1 = 2

Rerunning step: (comment "due to -1 (and i!2`2 /= n_init), 3 will be satisfied")
Adding comment: due to -1 (and i!2`2 /= n_init), 3 will be satisfied
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.1 : 
;;; due to -1 (and i!2`2 /= n_init), 3 will be satisfied

[-1]  rho_middle(i!1)(conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   (i!2`2 = n_init)
[2]   car(i!3`1) = n_init
[3]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[4]   P!1 = 2

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.1 : 
;;; due to -1 (and i!2`2 /= n_init), 3 will be satisfied

[-1]  rho_middle(i!1)(conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   (i!2`2 = n_init)
[2]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[3]   P!1 = 2

Rerunning step: (lemma "listprops[Nonce].elt_append3"
                 ("l1" "i!3`1" "l2" "(: i!2`2 :)" "t" "n_init"))
Applying listprops[Nonce].elt_append3 where 
  l1 gets i!3`1,
  l2 gets (: i!2`2 :),
  t gets n_init,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.1 : 
;;; due to -1 (and i!2`2 /= n_init), 3 will be satisfied

{-1}  elt(append(i!3`1, (: i!2`2 :)), n_init) IMPLIES
       elt(i!3`1, n_init) OR elt((: i!2`2 :), n_init)
[-2]  rho_middle(i!1)(conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
[1]   (i!2`2 = n_init)
[2]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[3]   P!1 = 2

Rerunning step: (lemma "listprops[Nonce].elt_singleton"
                 ("t1" "i!2`2" "t2" "n_init"))
Applying listprops[Nonce].elt_singleton where 
  t1 gets i!2`2,
  t2 gets n_init,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.1 : 
;;; due to -1 (and i!2`2 /= n_init), 3 will be satisfied

{-1}  elt((: i!2`2 :), n_init) IFF i!2`2 = n_init
[-2]  elt(append(i!3`1, (: i!2`2 :)), n_init) IMPLIES
       elt(i!3`1, n_init) OR elt((: i!2`2 :), n_init)
[-3]  rho_middle(i!1)(conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
[-4]  2 <= P!1
[-5]  0 < i!2`1
[-6]  i!2`1 < P!1 - 1
  |-------
[1]   (i!2`2 = n_init)
[2]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[3]   P!1 = 2

Rerunning step: (grind :exclude "elt")
rho_middle rewrites rho_middle(i!1)(nlist(append(i!3`1, (: i!2`2 :))))
  to NOT elt(append(i!3`1, (: i!2`2 :)), n_init)
rho_middle rewrites 
  rho_middle(i!1)(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)
            (conc(nlist(append(i!3`1, (: i!2`2 :))),
                  ilist(append(i!3`3, cons(u!1, cdr(i!3`4))))))
  to NOT elt(append(i!3`1, (: i!2`2 :)), n_init)
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites 
  rho_middle(i!1)
            (code(public(car(i!3`4)),
                  conc(nlist(append(i!3`1, (: i!2`2 :))),
                       ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
  to NOT elt(append(i!3`1, (: i!2`2 :)), n_init) OR
       EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
         public(car(i!3`4)) = public(hu(j)) AND
          EXISTS (l: {x: list[Nonce] | length(x) = j - 1}):
            conc(nlist(append(i!3`1, (: i!2`2 :))),
                 ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))
             =
             conc(nlist(cons(n_init, l)),
                  ilist(cons(car(hu_list), remove(cdr(hu_list), j - 1))))
rho_middle rewrites rho_middle(i!1)(nlist(i!3`1))
  to FALSE
rho_middle rewrites rho_middle(i!1)(ilist(append(i!3`3, i!3`4)))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)(conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
  to FALSE
rho_middle rewrites rho_middle(i!1)(nlist(append(i!3`1, (: i!2`2 :))))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)
            (conc(nlist(append(i!3`1, (: i!2`2 :))),
                  ilist(append(i!3`3, cons(u!1, cdr(i!3`4))))))
  to TRUE
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites 
  rho_middle(i!1)
            (code(public(car(i!3`4)),
                  conc(nlist(append(i!3`1, (: i!2`2 :))),
                       ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_middle.1.2.1.2.1.1.

restrictmiddle_middle.1.2.1.2.1.2 : 
;;; first and foremost, let us prove that i!2`2 /= n_init

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
{-2}  length(l!1) = j!1 - 1
{-3}  0 < j!1
{-4}  j!1 <= i!1
{-5}  public(u!1) = public(hu(j!1))
{-6}  conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))) =
       conc(nlist(cons(n_init, l!1)), ilist(remove(hu_list, j!1)))
[-7]  2 <= P!1
[-8]  0 < i!2`1
[-9]  i!2`1 < P!1 - 1
  |-------
{1}   (i!2`2 = n_init)
{2}   car(i!3`1) = n_init
{3}   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[4]   P!1 = 2

Rerunning step: (comment "2 follows from -6")
Adding comment: 2 follows from -6
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.2 : 
;;; 2 follows from -6

[-1]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
[-2]  length(l!1) = j!1 - 1
[-3]  0 < j!1
[-4]  j!1 <= i!1
[-5]  public(u!1) = public(hu(j!1))
[-6]  conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))) =
       conc(nlist(cons(n_init, l!1)), ilist(remove(hu_list, j!1)))
[-7]  2 <= P!1
[-8]  0 < i!2`1
[-9]  i!2`1 < P!1 - 1
  |-------
[1]   (i!2`2 = n_init)
[2]   car(i!3`1) = n_init
[3]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[4]   P!1 = 2

Rerunning step: (delete -1 -2 -3 -4 -5 -7 -8 -9 1 3 4)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.2 : 
;;; 2 follows from -6

[-1]  conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))) =
       conc(nlist(cons(n_init, l!1)), ilist(remove(hu_list, j!1)))
  |-------
[1]   car(i!3`1) = n_init

Rerunning step: (mdecompose-equality -1)
Decomposing equalities,

This completes the proof of restrictmiddle_middle.1.2.1.2.1.2.

restrictmiddle_middle.1.2.1.2.1.3 : 
;;; first and foremost, let us prove that i!2`2 /= n_init

{-1}  rho_middle(i!1)(conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
{1}   (i!2`2 = n_init)
{2}   append(i!3`3, cons(u!1, i!3`4)) = hu_list
{3}   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[4]   P!1 = 2

Rerunning step: (comment "due to -1 (and i!2`2 /= n_init), 3 will be satisfied")
Adding comment: due to -1 (and i!2`2 /= n_init), 3 will be satisfied
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.3 : 
;;; due to -1 (and i!2`2 /= n_init), 3 will be satisfied

[-1]  rho_middle(i!1)(conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   (i!2`2 = n_init)
[2]   append(i!3`3, cons(u!1, i!3`4)) = hu_list
[3]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[4]   P!1 = 2

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.3 : 
;;; due to -1 (and i!2`2 /= n_init), 3 will be satisfied

[-1]  rho_middle(i!1)(conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   (i!2`2 = n_init)
[2]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[3]   P!1 = 2

Rerunning step: (lemma "listprops[Nonce].elt_append3"
                 ("l1" "i!3`1" "l2" "(: i!2`2 :)" "t" "n_init"))
Applying listprops[Nonce].elt_append3 where 
  l1 gets i!3`1,
  l2 gets (: i!2`2 :),
  t gets n_init,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.3 : 
;;; due to -1 (and i!2`2 /= n_init), 3 will be satisfied

{-1}  elt(append(i!3`1, (: i!2`2 :)), n_init) IMPLIES
       elt(i!3`1, n_init) OR elt((: i!2`2 :), n_init)
[-2]  rho_middle(i!1)(conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
[1]   (i!2`2 = n_init)
[2]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[3]   P!1 = 2

Rerunning step: (lemma "listprops[Nonce].elt_singleton"
                 ("t1" "i!2`2" "t2" "n_init"))
Applying listprops[Nonce].elt_singleton where 
  t1 gets i!2`2,
  t2 gets n_init,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.3 : 
;;; due to -1 (and i!2`2 /= n_init), 3 will be satisfied

{-1}  elt((: i!2`2 :), n_init) IFF i!2`2 = n_init
[-2]  elt(append(i!3`1, (: i!2`2 :)), n_init) IMPLIES
       elt(i!3`1, n_init) OR elt((: i!2`2 :), n_init)
[-3]  rho_middle(i!1)(conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
[-4]  2 <= P!1
[-5]  0 < i!2`1
[-6]  i!2`1 < P!1 - 1
  |-------
[1]   (i!2`2 = n_init)
[2]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[3]   P!1 = 2

Rerunning step: (grind :exclude "elt")
rho_middle rewrites rho_middle(i!1)(nlist(append(i!3`1, (: i!2`2 :))))
  to NOT elt(append(i!3`1, (: i!2`2 :)), n_init)
rho_middle rewrites 
  rho_middle(i!1)(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)
            (conc(nlist(append(i!3`1, (: i!2`2 :))),
                  ilist(append(i!3`3, cons(u!1, cdr(i!3`4))))))
  to NOT elt(append(i!3`1, (: i!2`2 :)), n_init)
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites 
  rho_middle(i!1)
            (code(public(car(i!3`4)),
                  conc(nlist(append(i!3`1, (: i!2`2 :))),
                       ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
  to NOT elt(append(i!3`1, (: i!2`2 :)), n_init) OR
       EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
         public(car(i!3`4)) = public(hu(j)) AND
          EXISTS (l: {x: list[Nonce] | length(x) = j - 1}):
            conc(nlist(append(i!3`1, (: i!2`2 :))),
                 ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))
             =
             conc(nlist(cons(n_init, l)),
                  ilist(cons(car(hu_list), remove(cdr(hu_list), j - 1))))
rho_middle rewrites rho_middle(i!1)(nlist(i!3`1))
  to FALSE
rho_middle rewrites rho_middle(i!1)(ilist(append(i!3`3, i!3`4)))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)(conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
  to FALSE
rho_middle rewrites rho_middle(i!1)(nlist(append(i!3`1, (: i!2`2 :))))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)
            (conc(nlist(append(i!3`1, (: i!2`2 :))),
                  ilist(append(i!3`3, cons(u!1, cdr(i!3`4))))))
  to TRUE
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites 
  rho_middle(i!1)
            (code(public(car(i!3`4)),
                  conc(nlist(append(i!3`1, (: i!2`2 :))),
                       ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_middle.1.2.1.2.1.3.

restrictmiddle_middle.1.2.1.2.1.4 : 
;;; first and foremost, let us prove that i!2`2 /= n_init

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
{-2}  length(l!1) = j!1 - 1
{-3}  0 < j!1
{-4}  j!1 <= i!1
{-5}  public(u!1) = public(hu(j!1))
{-6}  conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))) =
       conc(nlist(cons(n_init, l!1)), ilist(remove(hu_list, j!1)))
[-7]  2 <= P!1
[-8]  0 < i!2`1
[-9]  i!2`1 < P!1 - 1
  |-------
{1}   (i!2`2 = n_init)
{2}   append(i!3`3, cons(u!1, i!3`4)) = hu_list
{3}   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[4]   P!1 = 2

Rerunning step: (typepred "i!3`1" "i!3`3" "i!3`4" "hu_list" "i!1")
Adding type constraints for  i!3`1, i!3`3, i!3`4, hu_list, i!1,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4 : 
;;; first and foremost, let us prove that i!2`2 /= n_init

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`1)
{-2}  length(i!3`1) = i!2`1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`3)
{-4}  length(i!3`3) = i!2`1
{-5}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`4)
{-6}  length(i!3`4) = P!1 - 1 - i!2`1
{-7}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-8}  (length(hu_list) = p)
{-9}  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
{-10} 0 < i!1
{-11} i!1 < p - 1
[-12] every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
[-13] length(l!1) = j!1 - 1
[-14] 0 < j!1
[-15] j!1 <= i!1
[-16] public(u!1) = public(hu(j!1))
[-17] conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))) =
       conc(nlist(cons(n_init, l!1)), ilist(remove(hu_list, j!1)))
[-18] 2 <= P!1
[-19] 0 < i!2`1
[-20] i!2`1 < P!1 - 1
  |-------
[1]   (i!2`2 = n_init)
[2]   append(i!3`3, cons(u!1, i!3`4)) = hu_list
[3]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[4]   P!1 = 2

Rerunning step: (delete -1 -3 -5 -7 -10 -12 -14 -19 1 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4 : 
;;; first and foremost, let us prove that i!2`2 /= n_init

[-1]  length(i!3`1) = i!2`1
[-2]  length(i!3`3) = i!2`1
[-3]  length(i!3`4) = P!1 - 1 - i!2`1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  i!1 < p - 1
[-7]  length(l!1) = j!1 - 1
[-8]  j!1 <= i!1
[-9]  public(u!1) = public(hu(j!1))
[-10] conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))) =
       conc(nlist(cons(n_init, l!1)), ilist(remove(hu_list, j!1)))
[-11] 2 <= P!1
[-12] i!2`1 < P!1 - 1
  |-------
[1]   append(i!3`3, cons(u!1, i!3`4)) = hu_list
[2]   P!1 = 2

Rerunning step: (comment "1 follows from -10")
Adding comment: 1 follows from -10
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4 : 
;;; 1 follows from -10

[-1]  length(i!3`1) = i!2`1
[-2]  length(i!3`3) = i!2`1
[-3]  length(i!3`4) = P!1 - 1 - i!2`1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  i!1 < p - 1
[-7]  length(l!1) = j!1 - 1
[-8]  j!1 <= i!1
[-9]  public(u!1) = public(hu(j!1))
[-10] conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))) =
       conc(nlist(cons(n_init, l!1)), ilist(remove(hu_list, j!1)))
[-11] 2 <= P!1
[-12] i!2`1 < P!1 - 1
  |-------
[1]   append(i!3`3, cons(u!1, i!3`4)) = hu_list
[2]   P!1 = 2

Rerunning step: (decompose-equality -9)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4 : 
;;; 1 follows from -10

{-1}  u!1 = hu(j!1)
[-2]  length(i!3`1) = i!2`1
[-3]  length(i!3`3) = i!2`1
[-4]  length(i!3`4) = P!1 - 1 - i!2`1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  i!1 < p - 1
[-8]  length(l!1) = j!1 - 1
[-9]  j!1 <= i!1
[-10] conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))) =
       conc(nlist(cons(n_init, l!1)), ilist(remove(hu_list, j!1)))
[-11] 2 <= P!1
[-12] i!2`1 < P!1 - 1
  |-------
[1]   append(i!3`3, cons(u!1, i!3`4)) = hu_list
[2]   P!1 = 2

Rerunning step: (decompose-equality -10)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4 : 
;;; 1 follows from -10

{-1}  nlist(i!3`1) = nlist(cons(n_init, l!1))
{-2}  ilist(append(i!3`3, i!3`4)) = ilist(remove(hu_list, j!1))
[-3]  u!1 = hu(j!1)
[-4]  length(i!3`1) = i!2`1
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = P!1 - 1 - i!2`1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] length(l!1) = j!1 - 1
[-11] j!1 <= i!1
[-12] 2 <= P!1
[-13] i!2`1 < P!1 - 1
  |-------
[1]   append(i!3`3, cons(u!1, i!3`4)) = hu_list
[2]   P!1 = 2

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4 : 
;;; 1 follows from -10

{-1}  i!3`1 = cons(n_init, l!1)
[-2]  ilist(append(i!3`3, i!3`4)) = ilist(remove(hu_list, j!1))
[-3]  u!1 = hu(j!1)
[-4]  length(i!3`1) = i!2`1
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = P!1 - 1 - i!2`1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] length(l!1) = j!1 - 1
[-11] j!1 <= i!1
[-12] 2 <= P!1
[-13] i!2`1 < P!1 - 1
  |-------
[1]   append(i!3`3, cons(u!1, i!3`4)) = hu_list
[2]   P!1 = 2

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4 : 
;;; 1 follows from -10

{-1}  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-2]  i!3`1 = cons(n_init, l!1)
[-3]  u!1 = hu(j!1)
[-4]  length(i!3`1) = i!2`1
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = P!1 - 1 - i!2`1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] length(l!1) = j!1 - 1
[-11] j!1 <= i!1
[-12] 2 <= P!1
[-13] i!2`1 < P!1 - 1
  |-------
[1]   append(i!3`3, cons(u!1, i!3`4)) = hu_list
[2]   P!1 = 2

Rerunning step: (comment "establish some obvious equalities")
Adding comment: establish some obvious equalities
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4 : 
;;; establish some obvious equalities

[-1]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-2]  i!3`1 = cons(n_init, l!1)
[-3]  u!1 = hu(j!1)
[-4]  length(i!3`1) = i!2`1
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = P!1 - 1 - i!2`1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] length(l!1) = j!1 - 1
[-11] j!1 <= i!1
[-12] 2 <= P!1
[-13] i!2`1 < P!1 - 1
  |-------
[1]   append(i!3`3, cons(u!1, i!3`4)) = hu_list
[2]   P!1 = 2

Rerunning step: (case "P!1=p AND j!1=i!2`1 AND length(append(i!3`3, cons(u!1, i!3`4)))=p")
Case splitting on 
   P!1 = p AND
    j!1 = i!2`1 AND length(append(i!3`3, cons(u!1, i!3`4))) = p, 
this yields  2 subgoals: 
restrictmiddle_middle.1.2.1.2.1.4.1 : 
;;; establish some obvious equalities

{-1}  P!1 = p AND
       j!1 = i!2`1 AND length(append(i!3`3, cons(u!1, i!3`4))) = p
[-2]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  u!1 = hu(j!1)
[-5]  length(i!3`1) = i!2`1
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = P!1 - 1 - i!2`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1 < p - 1
[-11] length(l!1) = j!1 - 1
[-12] j!1 <= i!1
[-13] 2 <= P!1
[-14] i!2`1 < P!1 - 1
  |-------
[1]   append(i!3`3, cons(u!1, i!3`4)) = hu_list
[2]   P!1 = 2

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4.1 : 
;;; establish some obvious equalities

{-1}  P!1 = p
{-2}  j!1 = i!2`1
{-3}  length(append(i!3`3, cons(u!1, i!3`4))) = p
[-4]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-5]  i!3`1 = cons(n_init, l!1)
[-6]  u!1 = hu(j!1)
[-7]  length(i!3`1) = i!2`1
[-8]  length(i!3`3) = i!2`1
[-9]  length(i!3`4) = P!1 - 1 - i!2`1
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] i!1 < p - 1
[-13] length(l!1) = j!1 - 1
[-14] j!1 <= i!1
[-15] 2 <= P!1
[-16] i!2`1 < P!1 - 1
  |-------
[1]   append(i!3`3, cons(u!1, i!3`4)) = hu_list
[2]   P!1 = 2

Rerunning step: (replace* -1)
Repeatedly applying the replace rule,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4.1 : 
;;; establish some obvious equalities

[-1]  P!1 = p
[-2]  j!1 = i!2`1
[-3]  length(append(i!3`3, cons(u!1, i!3`4))) = p
[-4]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-5]  i!3`1 = cons(n_init, l!1)
[-6]  u!1 = hu(j!1)
[-7]  length(i!3`1) = i!2`1
[-8]  length(i!3`3) = i!2`1
{-9}  length(i!3`4) = p - 1 - i!2`1
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] i!1 < p - 1
[-13] length(l!1) = j!1 - 1
[-14] j!1 <= i!1
{-15} 2 <= p
{-16} i!2`1 < p - 1
  |-------
[1]   append(i!3`3, cons(u!1, i!3`4)) = hu_list
{2}   p = 2

Rerunning step: (replace* -2)
Repeatedly applying the replace rule,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4.1 : 
;;; establish some obvious equalities

[-1]  P!1 = p
[-2]  j!1 = i!2`1
[-3]  length(append(i!3`3, cons(u!1, i!3`4))) = p
{-4}  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-5]  i!3`1 = cons(n_init, l!1)
{-6}  u!1 = hu(i!2`1)
[-7]  length(i!3`1) = i!2`1
[-8]  length(i!3`3) = i!2`1
[-9]  length(i!3`4) = p - 1 - i!2`1
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] i!1 < p - 1
{-13} length(l!1) = i!2`1 - 1
{-14} i!2`1 <= i!1
[-15] 2 <= p
[-16] i!2`1 < p - 1
  |-------
[1]   append(i!3`3, cons(u!1, i!3`4)) = hu_list
[2]   p = 2

Rerunning step: (replace* -6)
Repeatedly applying the replace rule,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4.1 : 
;;; establish some obvious equalities

[-1]  P!1 = p
[-2]  j!1 = i!2`1
{-3}  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-4]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-5]  i!3`1 = cons(n_init, l!1)
[-6]  u!1 = hu(i!2`1)
[-7]  length(i!3`1) = i!2`1
[-8]  length(i!3`3) = i!2`1
[-9]  length(i!3`4) = p - 1 - i!2`1
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] i!1 < p - 1
[-13] length(l!1) = i!2`1 - 1
[-14] i!2`1 <= i!1
[-15] 2 <= p
[-16] i!2`1 < p - 1
  |-------
{1}   append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list
[2]   p = 2

Rerunning step: (delete -1 -2 -5 -6)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4.1 : 
;;; establish some obvious equalities

[-1]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-2]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-3]  length(i!3`1) = i!2`1
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = p - 1 - i!2`1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!1 < p - 1
[-9]  length(l!1) = i!2`1 - 1
[-10] i!2`1 <= i!1
[-11] 2 <= p
[-12] i!2`1 < p - 1
  |-------
[1]   append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list
[2]   p = 2

Rerunning step: (comment "prove equality of lists by equality of length and elements")
Adding comment: prove equality of lists by equality of length and elements
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4.1 : 
;;; prove equality of lists by equality of length and elements

[-1]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-2]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-3]  length(i!3`1) = i!2`1
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = p - 1 - i!2`1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!1 < p - 1
[-9]  length(l!1) = i!2`1 - 1
[-10] i!2`1 <= i!1
[-11] 2 <= p
[-12] i!2`1 < p - 1
  |-------
[1]   append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list
[2]   p = 2

Rerunning step: (rewrite "length_nth_equality[Identity]" 1)
Found matching substitution:
l2: list[Identity] gets hu_list,
l1: list[Identity] gets append(i!3`3, cons(hu(i!2`1), i!3`4)),
Rewriting using length_nth_equality[Identity], matching in 1,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4.1 : 
;;; prove equality of lists by equality of length and elements

[-1]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-2]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-3]  length(i!3`1) = i!2`1
[-4]  length(i!3`3) = i!2`1
{-5}  length(i!3`4) = -1 - i!2`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!1 < p - 1
[-9]  length(l!1) = i!2`1 - 1
[-10] i!2`1 <= i!1
[-11] 2 <= p
[-12] i!2`1 < p - 1
  |-------
{1}   FORALL (i:
                below[length[Identity]
                          (append(i!3`3, cons(hu(i!2`1), i!3`4)))]):
        nth(append(i!3`3, cons(hu(i!2`1), i!3`4)), i) = nth(hu_list, i)
[2]   append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list
[3]   p = 2

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4.1 : 
;;; prove equality of lists by equality of length and elements

{-1}  i!4 < length[Identity](append(i!3`3, cons(hu(i!2`1), i!3`4)))
[-2]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-3]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-4]  length(i!3`1) = i!2`1
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] length(l!1) = i!2`1 - 1
[-11] i!2`1 <= i!1
[-12] 2 <= p
[-13] i!2`1 < p - 1
  |-------
{1}   nth(append(i!3`3, cons(hu(i!2`1), i!3`4)), i!4) = nth(hu_list, i!4)
[2]   append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list
[3]   p = 2

Rerunning step: (lemma "listprops[Identity].equality_nth"
                 ("l1" "append(i!3`3, i!3`4)" "l2"
                  "remove(hu_list, i!2`1)"))
Applying listprops[Identity].equality_nth where 
  l1 gets append(i!3`3, i!3`4),
  l2 gets remove(hu_list, i!2`1),
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4.1 : 
;;; prove equality of lists by equality of length and elements

{-1}  append(i!3`3, i!3`4) = remove(hu_list, i!2`1) IMPLIES
       FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
         nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-2]  i!4 < length[Identity](append(i!3`3, cons(hu(i!2`1), i!3`4)))
[-3]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-4]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-5]  length(i!3`1) = i!2`1
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = -1 - i!2`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1 < p - 1
[-11] length(l!1) = i!2`1 - 1
[-12] i!2`1 <= i!1
[-13] 2 <= p
[-14] i!2`1 < p - 1
  |-------
[1]   nth(append(i!3`3, cons(hu(i!2`1), i!3`4)), i!4) = nth(hu_list, i!4)
[2]   append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list
[3]   p = 2

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4.1 : 
;;; prove equality of lists by equality of length and elements

{-1}  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-2]  i!4 < length[Identity](append(i!3`3, cons(hu(i!2`1), i!3`4)))
[-3]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-4]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-5]  length(i!3`1) = i!2`1
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = -1 - i!2`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1 < p - 1
[-11] length(l!1) = i!2`1 - 1
[-12] i!2`1 <= i!1
[-13] 2 <= p
[-14] i!2`1 < p - 1
  |-------
[1]   nth(append(i!3`3, cons(hu(i!2`1), i!3`4)), i!4) = nth(hu_list, i!4)
[2]   append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list
[3]   p = 2

Rerunning step: (lemma "listprops[Identity].nth_remove"
                 ("l" "hu_list" "i" "i!2`1"))
Applying listprops[Identity].nth_remove where 
  l gets hu_list,
  i gets i!2`1,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4.1 : 
;;; prove equality of lists by equality of length and elements

{-1}  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-2]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-3]  i!4 < length[Identity](append(i!3`3, cons(hu(i!2`1), i!3`4)))
[-4]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-5]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-6]  length(i!3`1) = i!2`1
[-7]  length(i!3`3) = i!2`1
[-8]  length(i!3`4) = -1 - i!2`1 + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] i!1 < p - 1
[-12] length(l!1) = i!2`1 - 1
[-13] i!2`1 <= i!1
[-14] 2 <= p
[-15] i!2`1 < p - 1
  |-------
[1]   nth(append(i!3`3, cons(hu(i!2`1), i!3`4)), i!4) = nth(hu_list, i!4)
[2]   append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list
[3]   p = 2

Rerunning step: (lemma "listprops[Identity].nth_append"
                 ("l1" "i!3`3" "l2" "i!3`4"))
Applying listprops[Identity].nth_append where 
  l1 gets i!3`3,
  l2 gets i!3`4,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4.1 : 
;;; prove equality of lists by equality of length and elements

{-1}  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-2]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-3]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-4]  i!4 < length[Identity](append(i!3`3, cons(hu(i!2`1), i!3`4)))
[-5]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-6]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-7]  length(i!3`1) = i!2`1
[-8]  length(i!3`3) = i!2`1
[-9]  length(i!3`4) = -1 - i!2`1 + p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] i!1 < p - 1
[-13] length(l!1) = i!2`1 - 1
[-14] i!2`1 <= i!1
[-15] 2 <= p
[-16] i!2`1 < p - 1
  |-------
[1]   nth(append(i!3`3, cons(hu(i!2`1), i!3`4)), i!4) = nth(hu_list, i!4)
[2]   append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list
[3]   p = 2

Rerunning step: (lemma "listprops[Identity].nth_append"
                 ("l1" "i!3`3" "l2" "cons(hu(i!2`1), i!3`4)" "i" "i!4"))
length rewrites length[Identity](cons[Identity](hu(i!2`1), i!3`4))
  to 1 + length(i!3`4)
Applying listprops[Identity].nth_append where 
  l1 gets i!3`3,
  l2 gets cons(hu(i!2`1), i!3`4),
  i gets i!4,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4.1 : 
;;; prove equality of lists by equality of length and elements

{-1}  nth(append(i!3`3, cons(hu(i!2`1), i!3`4)), i!4) =
       IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
       ELSE nth(cons(hu(i!2`1), i!3`4), i!4 - length[Identity](i!3`3))
       ENDIF
[-2]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-3]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-4]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-5]  i!4 < length[Identity](append(i!3`3, cons(hu(i!2`1), i!3`4)))
[-6]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-7]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-8]  length(i!3`1) = i!2`1
[-9]  length(i!3`3) = i!2`1
[-10] length(i!3`4) = -1 - i!2`1 + p
[-11] (length(hu_list) = p)
[-12] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-13] i!1 < p - 1
[-14] length(l!1) = i!2`1 - 1
[-15] i!2`1 <= i!1
[-16] 2 <= p
[-17] i!2`1 < p - 1
  |-------
[1]   nth(append(i!3`3, cons(hu(i!2`1), i!3`4)), i!4) = nth(hu_list, i!4)
[2]   append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list
[3]   p = 2

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4.1 : 
;;; prove equality of lists by equality of length and elements

[-1]  nth(append(i!3`3, cons(hu(i!2`1), i!3`4)), i!4) =
       IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
       ELSE nth(cons(hu(i!2`1), i!3`4), i!4 - length[Identity](i!3`3))
       ENDIF
[-2]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-3]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-4]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-5]  i!4 < length[Identity](append(i!3`3, cons(hu(i!2`1), i!3`4)))
[-6]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-7]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-8]  length(i!3`1) = i!2`1
[-9]  length(i!3`3) = i!2`1
[-10] length(i!3`4) = -1 - i!2`1 + p
[-11] (length(hu_list) = p)
[-12] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-13] i!1 < p - 1
[-14] length(l!1) = i!2`1 - 1
[-15] i!2`1 <= i!1
[-16] 2 <= p
[-17] i!2`1 < p - 1
  |-------
{1}   IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
      ELSE nth(cons(hu(i!2`1), i!3`4), i!4 - length[Identity](i!3`3))
      ENDIF
       = nth(hu_list, i!4)
[2]   append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list
[3]   p = 2

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4.1 : 
;;; prove equality of lists by equality of length and elements

[-1]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-2]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-3]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-4]  i!4 < length[Identity](append(i!3`3, cons(hu(i!2`1), i!3`4)))
[-5]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-6]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-7]  length(i!3`1) = i!2`1
[-8]  length(i!3`3) = i!2`1
[-9]  length(i!3`4) = -1 - i!2`1 + p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] i!1 < p - 1
[-13] length(l!1) = i!2`1 - 1
[-14] i!2`1 <= i!1
[-15] 2 <= p
[-16] i!2`1 < p - 1
  |-------
[1]   IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
      ELSE nth(cons(hu(i!2`1), i!3`4), i!4 - length[Identity](i!3`3))
      ENDIF
       = nth(hu_list, i!4)
[2]   append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list
[3]   p = 2

Rerunning step: (case "i!4<i!2`1 OR i!4=i!2`1 OR i!4>i!2`1")
Case splitting on 
   i!4 < i!2`1 OR i!4 = i!2`1 OR i!4 > i!2`1, 
this yields  2 subgoals: 
restrictmiddle_middle.1.2.1.2.1.4.1.1 : 
;;; prove equality of lists by equality of length and elements

{-1}  i!4 < i!2`1 OR i!4 = i!2`1 OR i!4 > i!2`1
[-2]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-3]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-4]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-5]  i!4 < length[Identity](append(i!3`3, cons(hu(i!2`1), i!3`4)))
[-6]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-7]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-8]  length(i!3`1) = i!2`1
[-9]  length(i!3`3) = i!2`1
[-10] length(i!3`4) = -1 - i!2`1 + p
[-11] (length(hu_list) = p)
[-12] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-13] i!1 < p - 1
[-14] length(l!1) = i!2`1 - 1
[-15] i!2`1 <= i!1
[-16] 2 <= p
[-17] i!2`1 < p - 1
  |-------
[1]   IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
      ELSE nth(cons(hu(i!2`1), i!3`4), i!4 - length[Identity](i!3`3))
      ENDIF
       = nth(hu_list, i!4)
[2]   append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list
[3]   p = 2

Rerunning step: (delete -7 -8 -13 -14 -15 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4.1.1 : 
;;; prove equality of lists by equality of length and elements

[-1]  i!4 < i!2`1 OR i!4 = i!2`1 OR i!4 > i!2`1
[-2]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-3]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-4]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-5]  i!4 < length[Identity](append(i!3`3, cons(hu(i!2`1), i!3`4)))
[-6]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-7]  length(i!3`3) = i!2`1
[-8]  length(i!3`4) = -1 - i!2`1 + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] 2 <= p
[-12] i!2`1 < p - 1
  |-------
[1]   IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
      ELSE nth(cons(hu(i!2`1), i!3`4), i!4 - length[Identity](i!3`3))
      ENDIF
       = nth(hu_list, i!4)
[2]   p = 2

Rerunning step: (grind :exclude ("append" "remove"))
nth rewrites nth(cdr(hu_list), j)
  to nth(cdr(cdr(hu_list)), j - 1)
nth rewrites nth(hu_list, 1 + j)
  to nth(cdr(cdr(hu_list)), j - 1)
nth rewrites nth(cdr(hu_list), j)
  to nth(cdr(cdr(hu_list)), j - 1)
nth rewrites nth(hu_list, 1 + j)
  to nth(cdr(cdr(hu_list)), j - 1)
nth rewrites nth(cons(hu(i!2`1), i!3`4), i!4 - length[Identity](i!3`3))
  to hu(i!2`1)
nth rewrites nth(hu_list, i!4)
  to nth(cdr(hu_list), i!4 - 1)
nth rewrites nth(cdr(hu_list), j)
  to nth(cdr(cdr(hu_list)), j - 1)
nth rewrites nth(hu_list, 1 + j)
  to nth(cdr(cdr(hu_list)), j - 1)
nth rewrites nth(cons(hu(i!2`1), i!3`4), i!4 - length[Identity](i!3`3))
  to nth(i!3`4, -1 - length[Identity](i!3`3) + i!4)
nth rewrites nth(cdr(hu_list), i!4 - 1)
  to nth(cdr(cdr(hu_list)), i!4 - 2)
nth rewrites nth(hu_list, i!4)
  to nth(cdr(cdr(hu_list)), i!4 - 2)
nth rewrites nth(cdr(remove(hu_list, i!2`1)), i!2`1)
  to nth(cdr(cdr(remove(hu_list, i!2`1))), i!2`1 - 1)
nth rewrites nth(remove(hu_list, i!2`1), 1 + i!2`1)
  to nth(cdr(cdr(remove(hu_list, i!2`1))), i!2`1 - 1)
nth rewrites nth(cdr(cdr(hu_list)), i!2`1)
  to nth(cdr(cdr(cdr(hu_list))), i!2`1 - 1)
nth rewrites nth(append(i!3`3, i!3`4), i!2`1)
  to nth(cdr(append(i!3`3, i!3`4)), i!2`1 - 1)
nth rewrites nth(remove(hu_list, i!2`1), i!2`1)
  to nth(cdr(remove(hu_list, i!2`1)), i!2`1 - 1)
nth rewrites nth(hu_list, i!2`1)
  to nth(cdr(hu_list), i!2`1 - 1)
nth rewrites nth(hu_list, i!2`1)
  to nth(cdr(hu_list), i!2`1 - 1)
nth rewrites nth(i!3`4, i - i!2`1)
  to car(i!3`4)
nth rewrites nth(cdr(append(i!3`3, i!3`4)), 0)
  to car(cdr(append(i!3`3, i!3`4)))
nth rewrites nth(append(i!3`3, i!3`4), 1)
  to car(cdr(append(i!3`3, i!3`4)))
nth rewrites nth(cdr(i!3`3), 0)
  to car(cdr(i!3`3))
nth rewrites nth(i!3`3, 1)
  to car(cdr(i!3`3))
nth rewrites nth(cdr(remove(hu_list, i!2`1)), 0)
  to car(cdr(remove(hu_list, i!2`1)))
nth rewrites nth(remove(hu_list, i!2`1), 1)
  to car(cdr(remove(hu_list, i!2`1)))
nth rewrites nth(cdr(hu_list), i!2`1 - 1)
  to nth(cdr(cdr(hu_list)), i!2`1 - 2)
nth rewrites nth(hu_list, i!2`1)
  to nth(cdr(cdr(hu_list)), i!2`1 - 2)
nth rewrites nth(cdr(hu_list), i!2`1 - 1)
  to nth(cdr(cdr(hu_list)), i!2`1 - 2)
nth rewrites nth(hu_list, i!2`1)
  to nth(cdr(cdr(hu_list)), i!2`1 - 2)
nth rewrites nth(cdr(remove(hu_list, i!2`1)), 0)
  to car(cdr(remove(hu_list, i!2`1)))
nth rewrites nth(remove(hu_list, i!2`1), 1)
  to car(cdr(remove(hu_list, i!2`1)))
nth rewrites nth(cdr(hu_list), i!2`1 - 1)
  to car(cdr(hu_list))
nth rewrites nth(hu_list, i!2`1)
  to car(cdr(hu_list))
nth rewrites nth(cdr(hu_list), i!2`1 - 1)
  to car(cdr(hu_list))
nth rewrites nth(hu_list, i!2`1)
  to car(cdr(hu_list))
nth rewrites nth(append(i!3`3, i!3`4), i!4 - 1)
  to nth(cdr(append(i!3`3, i!3`4)), i!4 - 2)
nth rewrites nth(remove(hu_list, i!2`1), i!4 - 1)
  to nth(cdr(remove(hu_list, i!2`1)), i!4 - 2)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_middle.1.2.1.2.1.4.1.1.

restrictmiddle_middle.1.2.1.2.1.4.1.2 : 
;;; prove equality of lists by equality of length and elements

[-1]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-2]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-3]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-4]  i!4 < length[Identity](append(i!3`3, cons(hu(i!2`1), i!3`4)))
[-5]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-6]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-7]  length(i!3`1) = i!2`1
[-8]  length(i!3`3) = i!2`1
[-9]  length(i!3`4) = -1 - i!2`1 + p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] i!1 < p - 1
[-13] length(l!1) = i!2`1 - 1
[-14] i!2`1 <= i!1
[-15] 2 <= p
[-16] i!2`1 < p - 1
  |-------
{1}   i!4 < i!2`1 OR i!4 = i!2`1 OR i!4 > i!2`1
[2]   IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
      ELSE nth(cons(hu(i!2`1), i!3`4), i!4 - length[Identity](i!3`3))
      ENDIF
       = nth(hu_list, i!4)
[3]   append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list
[4]   p = 2

Rerunning step: (delete - 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4.1.2 : 
;;; prove equality of lists by equality of length and elements

  |-------
[1]   i!4 < i!2`1 OR i!4 = i!2`1 OR i!4 > i!2`1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_middle.1.2.1.2.1.4.1.2.


This completes the proof of restrictmiddle_middle.1.2.1.2.1.4.1.

restrictmiddle_middle.1.2.1.2.1.4.2 : 
;;; establish some obvious equalities

[-1]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-2]  i!3`1 = cons(n_init, l!1)
[-3]  u!1 = hu(j!1)
[-4]  length(i!3`1) = i!2`1
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = P!1 - 1 - i!2`1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] length(l!1) = j!1 - 1
[-11] j!1 <= i!1
[-12] 2 <= P!1
[-13] i!2`1 < P!1 - 1
  |-------
{1}   P!1 = p AND
       j!1 = i!2`1 AND length(append(i!3`3, cons(u!1, i!3`4))) = p
[2]   append(i!3`3, cons(u!1, i!3`4)) = hu_list
[3]   P!1 = 2

Rerunning step: (lemma "listprops[Identity].equality_length"
                 ("l1" "append(i!3`3, i!3`4)" "l2"
                  "remove(hu_list, j!1)"))
Applying listprops[Identity].equality_length where 
  l1 gets append(i!3`3, i!3`4),
  l2 gets remove(hu_list, j!1),
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4.2 : 
;;; establish some obvious equalities

{-1}  append(i!3`3, i!3`4) = remove(hu_list, j!1) IMPLIES
       length[Identity](append(i!3`3, i!3`4)) =
        length[Identity](remove(hu_list, j!1))
[-2]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  u!1 = hu(j!1)
[-5]  length(i!3`1) = i!2`1
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = P!1 - 1 - i!2`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1 < p - 1
[-11] length(l!1) = j!1 - 1
[-12] j!1 <= i!1
[-13] 2 <= P!1
[-14] i!2`1 < P!1 - 1
  |-------
[1]   P!1 = p AND
       j!1 = i!2`1 AND length(append(i!3`3, cons(u!1, i!3`4))) = p
[2]   append(i!3`3, cons(u!1, i!3`4)) = hu_list
[3]   P!1 = 2

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets i!3`4,
l1: list[T] gets i!3`3,
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4.2 : 
;;; establish some obvious equalities

{-1}  append(i!3`3, i!3`4) = remove(hu_list, j!1) IMPLIES
       length(i!3`3) + length(i!3`4) =
        length[Identity](remove(hu_list, j!1))
[-2]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  u!1 = hu(j!1)
[-5]  length(i!3`1) = i!2`1
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = P!1 - 1 - i!2`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1 < p - 1
[-11] length(l!1) = j!1 - 1
[-12] j!1 <= i!1
[-13] 2 <= P!1
[-14] i!2`1 < P!1 - 1
  |-------
[1]   P!1 = p AND
       j!1 = i!2`1 AND length(append(i!3`3, cons(u!1, i!3`4))) = p
[2]   append(i!3`3, cons(u!1, i!3`4)) = hu_list
[3]   P!1 = 2

Rerunning step: (rewrite "length_remove" -1 :dir rl)
Found matching substitution:
i: below[length(c)] gets j!1,
c: (cons?[T]) gets hu_list,
length rewrites length(i!3`1)
  to 1 + length(cdr(i!3`1))
length rewrites length(hu_list)
  to 0
Rewriting using length_remove, matching in -1,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4.2 : 
;;; establish some obvious equalities

{-1}  append(i!3`3, i!3`4) = remove(hu_list, j!1) IMPLIES
       length(i!3`3) + length(i!3`4) = length[Identity](hu_list) - 1
[-2]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  u!1 = hu(j!1)
[-5]  length(i!3`1) = i!2`1
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = P!1 - 1 - i!2`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1 < p - 1
[-11] length(l!1) = j!1 - 1
[-12] j!1 <= i!1
[-13] 2 <= P!1
[-14] i!2`1 < P!1 - 1
  |-------
[1]   P!1 = p AND
       j!1 = i!2`1 AND length(append(i!3`3, cons(u!1, i!3`4))) = p
[2]   append(i!3`3, cons(u!1, i!3`4)) = hu_list
[3]   P!1 = 2

Rerunning step: (replace -3 -5)
Replacing using formula -3,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4.2 : 
;;; establish some obvious equalities

[-1]  append(i!3`3, i!3`4) = remove(hu_list, j!1) IMPLIES
       length(i!3`3) + length(i!3`4) = length[Identity](hu_list) - 1
[-2]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  u!1 = hu(j!1)
{-5}  length(cons(n_init, l!1)) = i!2`1
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = P!1 - 1 - i!2`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1 < p - 1
[-11] length(l!1) = j!1 - 1
[-12] j!1 <= i!1
[-13] 2 <= P!1
[-14] i!2`1 < P!1 - 1
  |-------
[1]   P!1 = p AND
       j!1 = i!2`1 AND length(append(i!3`3, cons(u!1, i!3`4))) = p
[2]   append(i!3`3, cons(u!1, i!3`4)) = hu_list
[3]   P!1 = 2

Rerunning step: (expand "length" -5)
Expanding the definition of length,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4.2 : 
;;; establish some obvious equalities

[-1]  append(i!3`3, i!3`4) = remove(hu_list, j!1) IMPLIES
       length(i!3`3) + length(i!3`4) = length[Identity](hu_list) - 1
[-2]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  u!1 = hu(j!1)
{-5}  1 + length(l!1) = i!2`1
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = P!1 - 1 - i!2`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1 < p - 1
[-11] length(l!1) = j!1 - 1
[-12] j!1 <= i!1
[-13] 2 <= P!1
[-14] i!2`1 < P!1 - 1
  |-------
[1]   P!1 = p AND
       j!1 = i!2`1 AND length(append(i!3`3, cons(u!1, i!3`4))) = p
[2]   append(i!3`3, cons(u!1, i!3`4)) = hu_list
[3]   P!1 = 2

Rerunning step: (replace -11 -5)
Replacing using formula -11,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4.2 : 
;;; establish some obvious equalities

[-1]  append(i!3`3, i!3`4) = remove(hu_list, j!1) IMPLIES
       length(i!3`3) + length(i!3`4) = length[Identity](hu_list) - 1
[-2]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  u!1 = hu(j!1)
{-5}  1 + (j!1 - 1) = i!2`1
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = P!1 - 1 - i!2`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1 < p - 1
[-11] length(l!1) = j!1 - 1
[-12] j!1 <= i!1
[-13] 2 <= P!1
[-14] i!2`1 < P!1 - 1
  |-------
[1]   P!1 = p AND
       j!1 = i!2`1 AND length(append(i!3`3, cons(u!1, i!3`4))) = p
[2]   append(i!3`3, cons(u!1, i!3`4)) = hu_list
[3]   P!1 = 2

Rerunning step: (ground)
Applying propositional simplification and decision procedures,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4.2 : 
;;; establish some obvious equalities

{-1}  length(i!3`3) + length(i!3`4) = length[Identity](hu_list) - 1
[-2]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  u!1 = hu(j!1)
{-5}  j!1 = i!2`1
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = P!1 - 1 - i!2`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1 < p - 1
[-11] length(l!1) = j!1 - 1
[-12] j!1 <= i!1
[-13] 2 <= P!1
[-14] i!2`1 < P!1 - 1
  |-------
{1}   length(append(i!3`3, cons(u!1, i!3`4))) = p
[2]   append(i!3`3, cons(u!1, i!3`4)) = hu_list
[3]   P!1 = 2

Rerunning step: (rewrite "length_append")
Found matching substitution:
l2: list[T] gets cons(u!1, i!3`4),
l1: list[T] gets i!3`3,
length rewrites length(cons(u!1, i!3`4))
  to 1 + length(i!3`4)
Rewriting using length_append, matching in *,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.4.2 : 
;;; establish some obvious equalities

[-1]  length(i!3`3) + length(i!3`4) = length[Identity](hu_list) - 1
[-2]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  u!1 = hu(j!1)
[-5]  j!1 = i!2`1
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = P!1 - 1 - i!2`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1 < p - 1
[-11] length(l!1) = j!1 - 1
[-12] j!1 <= i!1
[-13] 2 <= P!1
[-14] i!2`1 < P!1 - 1
  |-------
{1}   1 + length(i!3`3) + length(i!3`4) = p
[2]   append(i!3`3, cons(u!1, i!3`4)) = hu_list
[3]   P!1 = 2

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_middle.1.2.1.2.1.4.2.


This completes the proof of restrictmiddle_middle.1.2.1.2.1.4.

restrictmiddle_middle.1.2.1.2.1.5 : 
;;; first and foremost, let us prove that i!2`2 /= n_init

{-1}  rho_middle(i!1)(conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
{1}   (i!2`2 = n_init)
{2}   i!2`1 = i!1
{3}   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[4]   P!1 = 2

Rerunning step: (comment "due to -1 (and i!2`2 /= n_init), 3 will be satisfied")
Adding comment: due to -1 (and i!2`2 /= n_init), 3 will be satisfied
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.5 : 
;;; due to -1 (and i!2`2 /= n_init), 3 will be satisfied

[-1]  rho_middle(i!1)(conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   (i!2`2 = n_init)
[2]   i!2`1 = i!1
[3]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[4]   P!1 = 2

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.5 : 
;;; due to -1 (and i!2`2 /= n_init), 3 will be satisfied

[-1]  rho_middle(i!1)(conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   (i!2`2 = n_init)
[2]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[3]   P!1 = 2

Rerunning step: (lemma "listprops[Nonce].elt_append3"
                 ("l1" "i!3`1" "l2" "(: i!2`2 :)" "t" "n_init"))
Applying listprops[Nonce].elt_append3 where 
  l1 gets i!3`1,
  l2 gets (: i!2`2 :),
  t gets n_init,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.5 : 
;;; due to -1 (and i!2`2 /= n_init), 3 will be satisfied

{-1}  elt(append(i!3`1, (: i!2`2 :)), n_init) IMPLIES
       elt(i!3`1, n_init) OR elt((: i!2`2 :), n_init)
[-2]  rho_middle(i!1)(conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
[1]   (i!2`2 = n_init)
[2]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[3]   P!1 = 2

Rerunning step: (lemma "listprops[Nonce].elt_singleton"
                 ("t1" "i!2`2" "t2" "n_init"))
Applying listprops[Nonce].elt_singleton where 
  t1 gets i!2`2,
  t2 gets n_init,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.5 : 
;;; due to -1 (and i!2`2 /= n_init), 3 will be satisfied

{-1}  elt((: i!2`2 :), n_init) IFF i!2`2 = n_init
[-2]  elt(append(i!3`1, (: i!2`2 :)), n_init) IMPLIES
       elt(i!3`1, n_init) OR elt((: i!2`2 :), n_init)
[-3]  rho_middle(i!1)(conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
[-4]  2 <= P!1
[-5]  0 < i!2`1
[-6]  i!2`1 < P!1 - 1
  |-------
[1]   (i!2`2 = n_init)
[2]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[3]   P!1 = 2

Rerunning step: (grind :exclude "elt")
rho_middle rewrites rho_middle(i!1)(nlist(append(i!3`1, (: i!2`2 :))))
  to NOT elt(append(i!3`1, (: i!2`2 :)), n_init)
rho_middle rewrites 
  rho_middle(i!1)(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)
            (conc(nlist(append(i!3`1, (: i!2`2 :))),
                  ilist(append(i!3`3, cons(u!1, cdr(i!3`4))))))
  to NOT elt(append(i!3`1, (: i!2`2 :)), n_init)
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites 
  rho_middle(i!1)
            (code(public(car(i!3`4)),
                  conc(nlist(append(i!3`1, (: i!2`2 :))),
                       ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
  to NOT elt(append(i!3`1, (: i!2`2 :)), n_init) OR
       EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
         public(car(i!3`4)) = public(hu(j)) AND
          EXISTS (l: {x: list[Nonce] | length(x) = j - 1}):
            conc(nlist(append(i!3`1, (: i!2`2 :))),
                 ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))
             =
             conc(nlist(cons(n_init, l)),
                  ilist(cons(car(hu_list), remove(cdr(hu_list), j - 1))))
rho_middle rewrites rho_middle(i!1)(nlist(i!3`1))
  to FALSE
rho_middle rewrites rho_middle(i!1)(ilist(append(i!3`3, i!3`4)))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)(conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
  to FALSE
rho_middle rewrites rho_middle(i!1)(nlist(append(i!3`1, (: i!2`2 :))))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)
            (conc(nlist(append(i!3`1, (: i!2`2 :))),
                  ilist(append(i!3`3, cons(u!1, cdr(i!3`4))))))
  to TRUE
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites 
  rho_middle(i!1)
            (code(public(car(i!3`4)),
                  conc(nlist(append(i!3`1, (: i!2`2 :))),
                       ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_middle.1.2.1.2.1.5.

restrictmiddle_middle.1.2.1.2.1.6 : 
;;; first and foremost, let us prove that i!2`2 /= n_init

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
{-2}  length(l!1) = j!1 - 1
{-3}  0 < j!1
{-4}  j!1 <= i!1
{-5}  public(u!1) = public(hu(j!1))
{-6}  conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))) =
       conc(nlist(cons(n_init, l!1)), ilist(remove(hu_list, j!1)))
[-7]  2 <= P!1
[-8]  0 < i!2`1
[-9]  i!2`1 < P!1 - 1
  |-------
{1}   (i!2`2 = n_init)
{2}   i!2`1 = i!1
{3}   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[4]   P!1 = 2

Rerunning step: (typepred "i!3`1" "i!3`3" "i!3`4" "hu_list" "i!1")
Adding type constraints for  i!3`1, i!3`3, i!3`4, hu_list, i!1,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6 : 
;;; first and foremost, let us prove that i!2`2 /= n_init

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`1)
{-2}  length(i!3`1) = i!2`1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`3)
{-4}  length(i!3`3) = i!2`1
{-5}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`4)
{-6}  length(i!3`4) = P!1 - 1 - i!2`1
{-7}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-8}  (length(hu_list) = p)
{-9}  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
{-10} 0 < i!1
{-11} i!1 < p - 1
[-12] every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
[-13] length(l!1) = j!1 - 1
[-14] 0 < j!1
[-15] j!1 <= i!1
[-16] public(u!1) = public(hu(j!1))
[-17] conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))) =
       conc(nlist(cons(n_init, l!1)), ilist(remove(hu_list, j!1)))
[-18] 2 <= P!1
[-19] 0 < i!2`1
[-20] i!2`1 < P!1 - 1
  |-------
[1]   (i!2`2 = n_init)
[2]   i!2`1 = i!1
[3]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[4]   P!1 = 2

Rerunning step: (delete -1 -3 -5 -7 -10 -12 -14 -19 1)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6 : 
;;; first and foremost, let us prove that i!2`2 /= n_init

[-1]  length(i!3`1) = i!2`1
[-2]  length(i!3`3) = i!2`1
[-3]  length(i!3`4) = P!1 - 1 - i!2`1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  i!1 < p - 1
[-7]  length(l!1) = j!1 - 1
[-8]  j!1 <= i!1
[-9]  public(u!1) = public(hu(j!1))
[-10] conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))) =
       conc(nlist(cons(n_init, l!1)), ilist(remove(hu_list, j!1)))
[-11] 2 <= P!1
[-12] i!2`1 < P!1 - 1
  |-------
[1]   i!2`1 = i!1
[2]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[3]   P!1 = 2

Rerunning step: (comment "this is the case of the run under consideration, so 2 must be proven by showing the parameters satisfy the EXISTS quantor in rho")
Adding comment: this is the case of the run under consideration, so 2 must be proven by showing the parameters satisfy the EXISTS quantor in rho
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6 : 
;;; this is the case of the run under consideration, so 2 must be proven by showing the parameters satisfy the EXISTS quantor in rho

[-1]  length(i!3`1) = i!2`1
[-2]  length(i!3`3) = i!2`1
[-3]  length(i!3`4) = P!1 - 1 - i!2`1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  i!1 < p - 1
[-7]  length(l!1) = j!1 - 1
[-8]  j!1 <= i!1
[-9]  public(u!1) = public(hu(j!1))
[-10] conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))) =
       conc(nlist(cons(n_init, l!1)), ilist(remove(hu_list, j!1)))
[-11] 2 <= P!1
[-12] i!2`1 < P!1 - 1
  |-------
[1]   i!2`1 = i!1
[2]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[3]   P!1 = 2

Rerunning step: (decompose-equality -9)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6 : 
;;; this is the case of the run under consideration, so 2 must be proven by showing the parameters satisfy the EXISTS quantor in rho

{-1}  u!1 = hu(j!1)
[-2]  length(i!3`1) = i!2`1
[-3]  length(i!3`3) = i!2`1
[-4]  length(i!3`4) = P!1 - 1 - i!2`1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  i!1 < p - 1
[-8]  length(l!1) = j!1 - 1
[-9]  j!1 <= i!1
[-10] conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))) =
       conc(nlist(cons(n_init, l!1)), ilist(remove(hu_list, j!1)))
[-11] 2 <= P!1
[-12] i!2`1 < P!1 - 1
  |-------
[1]   i!2`1 = i!1
[2]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[3]   P!1 = 2

Rerunning step: (decompose-equality -10)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6 : 
;;; this is the case of the run under consideration, so 2 must be proven by showing the parameters satisfy the EXISTS quantor in rho

{-1}  nlist(i!3`1) = nlist(cons(n_init, l!1))
{-2}  ilist(append(i!3`3, i!3`4)) = ilist(remove(hu_list, j!1))
[-3]  u!1 = hu(j!1)
[-4]  length(i!3`1) = i!2`1
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = P!1 - 1 - i!2`1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] length(l!1) = j!1 - 1
[-11] j!1 <= i!1
[-12] 2 <= P!1
[-13] i!2`1 < P!1 - 1
  |-------
[1]   i!2`1 = i!1
[2]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[3]   P!1 = 2

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6 : 
;;; this is the case of the run under consideration, so 2 must be proven by showing the parameters satisfy the EXISTS quantor in rho

{-1}  i!3`1 = cons(n_init, l!1)
[-2]  ilist(append(i!3`3, i!3`4)) = ilist(remove(hu_list, j!1))
[-3]  u!1 = hu(j!1)
[-4]  length(i!3`1) = i!2`1
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = P!1 - 1 - i!2`1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] length(l!1) = j!1 - 1
[-11] j!1 <= i!1
[-12] 2 <= P!1
[-13] i!2`1 < P!1 - 1
  |-------
[1]   i!2`1 = i!1
[2]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[3]   P!1 = 2

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6 : 
;;; this is the case of the run under consideration, so 2 must be proven by showing the parameters satisfy the EXISTS quantor in rho

{-1}  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-2]  i!3`1 = cons(n_init, l!1)
[-3]  u!1 = hu(j!1)
[-4]  length(i!3`1) = i!2`1
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = P!1 - 1 - i!2`1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] length(l!1) = j!1 - 1
[-11] j!1 <= i!1
[-12] 2 <= P!1
[-13] i!2`1 < P!1 - 1
  |-------
[1]   i!2`1 = i!1
[2]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[3]   P!1 = 2

Rerunning step: (comment "establish some obvious equalities")
Adding comment: establish some obvious equalities
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6 : 
;;; establish some obvious equalities

[-1]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-2]  i!3`1 = cons(n_init, l!1)
[-3]  u!1 = hu(j!1)
[-4]  length(i!3`1) = i!2`1
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = P!1 - 1 - i!2`1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] length(l!1) = j!1 - 1
[-11] j!1 <= i!1
[-12] 2 <= P!1
[-13] i!2`1 < P!1 - 1
  |-------
[1]   i!2`1 = i!1
[2]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[3]   P!1 = 2

Rerunning step: (case "P!1=p AND j!1=i!2`1")
Case splitting on 
   P!1 = p AND j!1 = i!2`1, 
this yields  2 subgoals: 
restrictmiddle_middle.1.2.1.2.1.6.1 : 
;;; establish some obvious equalities

{-1}  P!1 = p AND j!1 = i!2`1
[-2]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  u!1 = hu(j!1)
[-5]  length(i!3`1) = i!2`1
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = P!1 - 1 - i!2`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1 < p - 1
[-11] length(l!1) = j!1 - 1
[-12] j!1 <= i!1
[-13] 2 <= P!1
[-14] i!2`1 < P!1 - 1
  |-------
[1]   i!2`1 = i!1
[2]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[3]   P!1 = 2

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1 : 
;;; establish some obvious equalities

{-1}  P!1 = p
{-2}  j!1 = i!2`1
[-3]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-4]  i!3`1 = cons(n_init, l!1)
[-5]  u!1 = hu(j!1)
[-6]  length(i!3`1) = i!2`1
[-7]  length(i!3`3) = i!2`1
[-8]  length(i!3`4) = P!1 - 1 - i!2`1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] i!1 < p - 1
[-12] length(l!1) = j!1 - 1
[-13] j!1 <= i!1
[-14] 2 <= P!1
[-15] i!2`1 < P!1 - 1
  |-------
[1]   i!2`1 = i!1
[2]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[3]   P!1 = 2

Rerunning step: (replace* -1 -2 -5)
Repeatedly applying the replace rule,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1 : 
;;; establish some obvious equalities

[-1]  P!1 = p
[-2]  j!1 = i!2`1
{-3}  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-4]  i!3`1 = cons(n_init, l!1)
{-5}  u!1 = hu(i!2`1)
[-6]  length(i!3`1) = i!2`1
[-7]  length(i!3`3) = i!2`1
{-8}  length(i!3`4) = p - 1 - i!2`1
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] i!1 < p - 1
{-12} length(l!1) = i!2`1 - 1
{-13} i!2`1 <= i!1
{-14} 2 <= p
{-15} i!2`1 < p - 1
  |-------
[1]   i!2`1 = i!1
{2}   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3,
                                        cons(hu(i!2`1), cdr(i!3`4)))))))
{3}   p = 2

Rerunning step: (delete -1 -2 -5)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1 : 
;;; establish some obvious equalities

[-1]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-2]  i!3`1 = cons(n_init, l!1)
[-3]  length(i!3`1) = i!2`1
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = p - 1 - i!2`1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!1 < p - 1
[-9]  length(l!1) = i!2`1 - 1
[-10] i!2`1 <= i!1
[-11] 2 <= p
[-12] i!2`1 < p - 1
  |-------
[1]   i!2`1 = i!1
[2]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3,
                                        cons(hu(i!2`1), cdr(i!3`4)))))))
[3]   p = 2

Rerunning step: (grind :if-match nil :exclude "remove")
length rewrites length(i!3`1)
  to 1 + length(cdr(i!3`1))
append rewrites append(i!3`1, (: i!2`2 :))
  to cons(car(i!3`1), append(cdr(i!3`1), (: i!2`2 :)))
elt rewrites elt(cons(car(i!3`1), append(cdr(i!3`1), (: i!2`2 :))), n_init)
  to EXISTS (i:
                below[length(cons(car(i!3`1),
                                  append(cdr(i!3`1), (: i!2`2 :))))]):
        nth(cons(car(i!3`1), append(cdr(i!3`1), (: i!2`2 :))), i) = n_init
rho_middle rewrites 
  rho_middle(i!1)(nlist(cons(car(i!3`1), append(cdr(i!3`1), (: i!2`2 :)))))
  to NOT EXISTS (i:
                    below[length(cons(car(i!3`1),
                                      append(cdr(i!3`1), (: i!2`2 :))))]):
            nth(cons(car(i!3`1), append(cdr(i!3`1), (: i!2`2 :))), i) =
             n_init
rho_middle rewrites 
  rho_middle(i!1)(ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)
            (conc(nlist(cons(car(i!3`1), append(cdr(i!3`1), (: i!2`2 :)))),
                  ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))))))
  to NOT EXISTS (i:
                    below[length(cons(car(i!3`1),
                                      append(cdr(i!3`1), (: i!2`2 :))))]):
            nth(cons(car(i!3`1), append(cdr(i!3`1), (: i!2`2 :))), i) =
             n_init
rho_middle rewrites 
  rho_middle(i!1)
            (code(public(car(i!3`4)),
                  conc(nlist(cons(car(i!3`1),
                                  append(cdr(i!3`1), (: i!2`2 :)))),
                       ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))))))
  to NOT EXISTS (i:
                    below[length(cons(car(i!3`1),
                                      append(cdr(i!3`1), (: i!2`2 :))))]):
            nth(cons(car(i!3`1), append(cdr(i!3`1), (: i!2`2 :))), i) =
             n_init
       OR
       EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
         public(car(i!3`4)) = public(hu(j)) AND
          EXISTS (l: {x: list[Nonce] | length(x) = j - 1}):
            conc(nlist(cons(car(i!3`1), append(cdr(i!3`1), (: i!2`2 :)))),
                 ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))))
             = conc(nlist(cons(n_init, l)), ilist(remove(hu_list, j)))
length rewrites length(cons(n_init, append(l!1, (: i!2`2 :))))
  to 1 + length(append(l!1, (: i!2`2 :)))
Trying repeated skolemization, instantiation, and if-lifting,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1 : 
;;; establish some obvious equalities

{-1}  i!4 < 1 + length(append(l!1, (: i!2`2 :)))
[-2]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  length(i!3`3) = i!2`1
{-5}  length(i!3`4) = -1 - i!2`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!1 < p - 1
[-9]  length(l!1) = i!2`1 - 1
[-10] i!2`1 <= i!1
{-11} nth(cons(n_init, append(l!1, (: i!2`2 :))), i!4) = n_init
[-12] 2 <= p
[-13] i!2`1 < p - 1
  |-------
[1]   i!2`1 = i!1
{2}   EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
        public(car(i!3`4)) = public(hu(j)) AND
         EXISTS (l: {x: list[Nonce] | length(x) = j - 1}):
           conc(nlist(cons(n_init, append(l!1, (: i!2`2 :)))),
                ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))))
            = conc(nlist(cons(n_init, l)), ilist(remove(hu_list, j)))
[3]   p = 2

Rerunning step: (comment "car(i!3`4)=hu(i!2`1+1), according to -2")
Adding comment: car(i!3`4)=hu(i!2`1+1), according to -2
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1 : 
;;; car(i!3`4)=hu(i!2`1+1), according to -2

[-1]  i!4 < 1 + length(append(l!1, (: i!2`2 :)))
[-2]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = -1 - i!2`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!1 < p - 1
[-9]  length(l!1) = i!2`1 - 1
[-10] i!2`1 <= i!1
[-11] nth(cons(n_init, append(l!1, (: i!2`2 :))), i!4) = n_init
[-12] 2 <= p
[-13] i!2`1 < p - 1
  |-------
[1]   i!2`1 = i!1
[2]   EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
        public(car(i!3`4)) = public(hu(j)) AND
         EXISTS (l: {x: list[Nonce] | length(x) = j - 1}):
           conc(nlist(cons(n_init, append(l!1, (: i!2`2 :)))),
                ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))))
            = conc(nlist(cons(n_init, l)), ilist(remove(hu_list, j)))
[3]   p = 2

Rerunning step: (inst 2 "i!2`1+1")
Instantiating the top quantifier in 2 with the terms: 
 i!2`1+1,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1 : 
;;; car(i!3`4)=hu(i!2`1+1), according to -2

[-1]  i!4 < 1 + length(append(l!1, (: i!2`2 :)))
[-2]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = -1 - i!2`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!1 < p - 1
[-9]  length(l!1) = i!2`1 - 1
[-10] i!2`1 <= i!1
[-11] nth(cons(n_init, append(l!1, (: i!2`2 :))), i!4) = n_init
[-12] 2 <= p
[-13] i!2`1 < p - 1
  |-------
[1]   i!2`1 = i!1
{2}   public(car(i!3`4)) = public(hu(i!2`1 + 1)) AND
       EXISTS (l: {x: list[Nonce] | length(x) = i!2`1}):
         conc(nlist(cons(n_init, append(l!1, (: i!2`2 :)))),
              ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))))
          = conc(nlist(cons(n_init, l)), ilist(remove(hu_list, i!2`1 + 1)))
[3]   p = 2

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.1.2.1.6.1.1 : 
;;; car(i!3`4)=hu(i!2`1+1), according to -2

[-1]  i!4 < 1 + length(append(l!1, (: i!2`2 :)))
[-2]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = -1 - i!2`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!1 < p - 1
[-9]  length(l!1) = i!2`1 - 1
[-10] i!2`1 <= i!1
[-11] nth(cons(n_init, append(l!1, (: i!2`2 :))), i!4) = n_init
[-12] 2 <= p
[-13] i!2`1 < p - 1
  |-------
{1}   public(car(i!3`4)) = public(hu(i!2`1 + 1))
[2]   i!2`1 = i!1
[3]   p = 2

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.1 : 
;;; car(i!3`4)=hu(i!2`1+1), according to -2

[-1]  i!4 < 1 + length(append(l!1, (: i!2`2 :)))
[-2]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = -1 - i!2`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!1 < p - 1
[-9]  length(l!1) = i!2`1 - 1
[-10] i!2`1 <= i!1
[-11] nth(cons(n_init, append(l!1, (: i!2`2 :))), i!4) = n_init
[-12] 2 <= p
[-13] i!2`1 < p - 1
  |-------
{1}   car(i!3`4) = hu(1 + i!2`1)
[2]   i!2`1 = i!1
[3]   p = 2

Rerunning step: (lemma "listprops[Identity].equality_nth"
                 ("l1" "append(i!3`3, i!3`4)" "l2"
                  "remove(hu_list, i!2`1)"))
Applying listprops[Identity].equality_nth where 
  l1 gets append(i!3`3, i!3`4),
  l2 gets remove(hu_list, i!2`1),
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.1 : 
;;; car(i!3`4)=hu(i!2`1+1), according to -2

{-1}  append(i!3`3, i!3`4) = remove(hu_list, i!2`1) IMPLIES
       FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
         nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-2]  i!4 < 1 + length(append(l!1, (: i!2`2 :)))
[-3]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-4]  i!3`1 = cons(n_init, l!1)
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] length(l!1) = i!2`1 - 1
[-11] i!2`1 <= i!1
[-12] nth(cons(n_init, append(l!1, (: i!2`2 :))), i!4) = n_init
[-13] 2 <= p
[-14] i!2`1 < p - 1
  |-------
[1]   car(i!3`4) = hu(1 + i!2`1)
[2]   i!2`1 = i!1
[3]   p = 2

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.1 : 
;;; car(i!3`4)=hu(i!2`1+1), according to -2

{-1}  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-2]  i!4 < 1 + length(append(l!1, (: i!2`2 :)))
[-3]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-4]  i!3`1 = cons(n_init, l!1)
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] length(l!1) = i!2`1 - 1
[-11] i!2`1 <= i!1
[-12] nth(cons(n_init, append(l!1, (: i!2`2 :))), i!4) = n_init
[-13] 2 <= p
[-14] i!2`1 < p - 1
  |-------
[1]   car(i!3`4) = hu(1 + i!2`1)
[2]   i!2`1 = i!1
[3]   p = 2

Rerunning step: (inst -1 "i!2`1")
Instantiating the top quantifier in -1 with the terms: 
 i!2`1,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.1.2.1.6.1.1.1 : 
;;; car(i!3`4)=hu(i!2`1+1), according to -2

{-1}  nth(append(i!3`3, i!3`4), i!2`1) = nth(remove(hu_list, i!2`1), i!2`1)
[-2]  i!4 < 1 + length(append(l!1, (: i!2`2 :)))
[-3]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-4]  i!3`1 = cons(n_init, l!1)
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] length(l!1) = i!2`1 - 1
[-11] i!2`1 <= i!1
[-12] nth(cons(n_init, append(l!1, (: i!2`2 :))), i!4) = n_init
[-13] 2 <= p
[-14] i!2`1 < p - 1
  |-------
[1]   car(i!3`4) = hu(1 + i!2`1)
[2]   i!2`1 = i!1
[3]   p = 2

Rerunning step: (rewrite "nth_append" -1)
Found matching substitution:
i: below[length(l1) + length(l2)] gets i!2`1,
l2: list[T] gets i!3`4,
l1: list[T] gets i!3`3,
nth rewrites nth(i!3`4, i!2`1 - length[Identity](i!3`3))
  to car(i!3`4)
Rewriting using nth_append, matching in -1,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.1.1 : 
;;; car(i!3`4)=hu(i!2`1+1), according to -2

{-1}  car(i!3`4) = nth(remove(hu_list, i!2`1), i!2`1)
[-2]  i!4 < 1 + length(append(l!1, (: i!2`2 :)))
[-3]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-4]  i!3`1 = cons(n_init, l!1)
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] length(l!1) = i!2`1 - 1
[-11] i!2`1 <= i!1
[-12] nth(cons(n_init, append(l!1, (: i!2`2 :))), i!4) = n_init
[-13] 2 <= p
[-14] i!2`1 < p - 1
  |-------
[1]   car(i!3`4) = hu(1 + i!2`1)
[2]   i!2`1 = i!1
[3]   p = 2

Rerunning step: (stop-rewrite "nth")Error: sequences.nth is not an auto-rewrite
Turned off list_props.nth
Turning off automatic rewriting for: 
   nth,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.1.1 : 
;;; car(i!3`4)=hu(i!2`1+1), according to -2

[-1]  car(i!3`4) = nth(remove(hu_list, i!2`1), i!2`1)
[-2]  i!4 < 1 + length(append(l!1, (: i!2`2 :)))
[-3]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-4]  i!3`1 = cons(n_init, l!1)
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] length(l!1) = i!2`1 - 1
[-11] i!2`1 <= i!1
[-12] nth(cons(n_init, append(l!1, (: i!2`2 :))), i!4) = n_init
[-13] 2 <= p
[-14] i!2`1 < p - 1
  |-------
[1]   car(i!3`4) = hu(1 + i!2`1)
[2]   i!2`1 = i!1
[3]   p = 2

Rerunning step: (rewrite "nth_remove" -1)
Found matching substitution:
j: below[length(l) - 1] gets i!2`1,
i: below[length(l)] gets i!2`1,
l: list[T] gets hu_list,
Rewriting using nth_remove, matching in -1,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.1.1 : 
;;; car(i!3`4)=hu(i!2`1+1), according to -2

{-1}  car(i!3`4) = nth(hu_list, 1 + i!2`1)
[-2]  i!4 < 1 + length(append(l!1, (: i!2`2 :)))
[-3]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-4]  i!3`1 = cons(n_init, l!1)
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] length(l!1) = i!2`1 - 1
[-11] i!2`1 <= i!1
[-12] nth(cons(n_init, append(l!1, (: i!2`2 :))), i!4) = n_init
[-13] 2 <= p
[-14] i!2`1 < p - 1
  |-------
[1]   car(i!3`4) = hu(1 + i!2`1)
[2]   i!2`1 = i!1
[3]   p = 2

Rerunning step: (inst -8 "1+i!2`1")
Instantiating the top quantifier in -8 with the terms: 
 1+i!2`1,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.1.1 : 
;;; car(i!3`4)=hu(i!2`1+1), according to -2

[-1]  car(i!3`4) = nth(hu_list, 1 + i!2`1)
[-2]  i!4 < 1 + length(append(l!1, (: i!2`2 :)))
[-3]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-4]  i!3`1 = cons(n_init, l!1)
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
{-8}  nth(hu_list, 1 + i!2`1) = hu(1 + i!2`1)
[-9]  i!1 < p - 1
[-10] length(l!1) = i!2`1 - 1
[-11] i!2`1 <= i!1
[-12] nth(cons(n_init, append(l!1, (: i!2`2 :))), i!4) = n_init
[-13] 2 <= p
[-14] i!2`1 < p - 1
  |-------
[1]   car(i!3`4) = hu(1 + i!2`1)
[2]   i!2`1 = i!1
[3]   p = 2

Rerunning step: (delete -2 -3 -4 -5 -6 -7 -9 -10 -11 -12 -13 -14 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.1.1 : 
;;; car(i!3`4)=hu(i!2`1+1), according to -2

[-1]  car(i!3`4) = nth(hu_list, 1 + i!2`1)
[-2]  nth(hu_list, 1 + i!2`1) = hu(1 + i!2`1)
  |-------
[1]   car(i!3`4) = hu(1 + i!2`1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_middle.1.2.1.2.1.6.1.1.1.

restrictmiddle_middle.1.2.1.2.1.6.1.1.2 (TCC):   

[-1]  i!4 < 1 + length(append(l!1, (: i!2`2 :)))
[-2]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = -1 - i!2`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!1 < p - 1
[-9]  length(l!1) = i!2`1 - 1
[-10] i!2`1 <= i!1
[-11] nth(cons(n_init, append(l!1, (: i!2`2 :))), i!4) = n_init
[-12] 2 <= p
[-13] i!2`1 < p - 1
  |-------
{1}   i!2`1 < length[Identity](append[Identity](i!3`3, i!3`4))
[2]   car(i!3`4) = hu(1 + i!2`1)
[3]   i!2`1 = i!1
[4]   p = 2

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets i!3`4,
l1: list[T] gets i!3`3,
Rewriting using length_append, matching in 1,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.1.2 : 
;;; car(i!3`4)=hu(i!2`1+1), according to -2

[-1]  i!4 < 1 + length(append(l!1, (: i!2`2 :)))
[-2]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = -1 - i!2`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!1 < p - 1
[-9]  length(l!1) = i!2`1 - 1
[-10] i!2`1 <= i!1
[-11] nth(cons(n_init, append(l!1, (: i!2`2 :))), i!4) = n_init
[-12] 2 <= p
[-13] i!2`1 < p - 1
  |-------
{1}   i!2`1 < length(i!3`3) + length(i!3`4)
[2]   car(i!3`4) = hu(1 + i!2`1)
[3]   i!2`1 = i!1
[4]   p = 2

Rerunning step: (delete -1 -2 -3 -6 -7 -8 -9 -10 -11 -12 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.1.2 : 
;;; car(i!3`4)=hu(i!2`1+1), according to -2

[-1]  length(i!3`3) = i!2`1
[-2]  length(i!3`4) = -1 - i!2`1 + p
[-3]  i!2`1 < p - 1
  |-------
[1]   i!2`1 < length(i!3`3) + length(i!3`4)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_middle.1.2.1.2.1.6.1.1.2.


This completes the proof of restrictmiddle_middle.1.2.1.2.1.6.1.1.

restrictmiddle_middle.1.2.1.2.1.6.1.2 : 
;;; car(i!3`4)=hu(i!2`1+1), according to -2

[-1]  i!4 < 1 + length(append(l!1, (: i!2`2 :)))
[-2]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = -1 - i!2`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!1 < p - 1
[-9]  length(l!1) = i!2`1 - 1
[-10] i!2`1 <= i!1
[-11] nth(cons(n_init, append(l!1, (: i!2`2 :))), i!4) = n_init
[-12] 2 <= p
[-13] i!2`1 < p - 1
  |-------
{1}   EXISTS (l: {x: list[Nonce] | length(x) = i!2`1}):
        conc(nlist(cons(n_init, append(l!1, (: i!2`2 :)))),
             ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))))
         = conc(nlist(cons(n_init, l)), ilist(remove(hu_list, i!2`1 + 1)))
[2]   i!2`1 = i!1
[3]   p = 2

Rerunning step: (inst 1 "append(l!1, (: i!2`2 :))")
Instantiating the top quantifier in 1 with the terms: 
 append(l!1, (: i!2`2 :)),
this yields  2 subgoals: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.1 : 
;;; car(i!3`4)=hu(i!2`1+1), according to -2

[-1]  i!4 < 1 + length(append(l!1, (: i!2`2 :)))
[-2]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = -1 - i!2`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!1 < p - 1
[-9]  length(l!1) = i!2`1 - 1
[-10] i!2`1 <= i!1
[-11] nth(cons(n_init, append(l!1, (: i!2`2 :))), i!4) = n_init
[-12] 2 <= p
[-13] i!2`1 < p - 1
  |-------
{1}   conc(nlist(cons(n_init, append(l!1, (: i!2`2 :)))),
           ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))))
       =
       conc(nlist(cons(n_init, append(l!1, (: i!2`2 :)))),
            ilist(remove(hu_list, i!2`1 + 1)))
[2]   i!2`1 = i!1
[3]   p = 2

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.1 : 
;;; car(i!3`4)=hu(i!2`1+1), according to -2

[-1]  i!4 < 1 + length(append(l!1, (: i!2`2 :)))
[-2]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = -1 - i!2`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!1 < p - 1
[-9]  length(l!1) = i!2`1 - 1
[-10] i!2`1 <= i!1
[-11] nth(cons(n_init, append(l!1, (: i!2`2 :))), i!4) = n_init
[-12] 2 <= p
[-13] i!2`1 < p - 1
  |-------
{1}   ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) =
       ilist(remove(hu_list, 1 + i!2`1))
[2]   i!2`1 = i!1
[3]   p = 2

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.1 : 
;;; car(i!3`4)=hu(i!2`1+1), according to -2

[-1]  i!4 < 1 + length(append(l!1, (: i!2`2 :)))
[-2]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = -1 - i!2`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!1 < p - 1
[-9]  length(l!1) = i!2`1 - 1
[-10] i!2`1 <= i!1
[-11] nth(cons(n_init, append(l!1, (: i!2`2 :))), i!4) = n_init
[-12] 2 <= p
[-13] i!2`1 < p - 1
  |-------
{1}   append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))) =
       remove(hu_list, 1 + i!2`1)
[2]   i!2`1 = i!1
[3]   p = 2

Rerunning step: (comment "establish a convenient truth")
Adding comment: establish a convenient truth
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.1 : 
;;; establish a convenient truth

[-1]  i!4 < 1 + length(append(l!1, (: i!2`2 :)))
[-2]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = -1 - i!2`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!1 < p - 1
[-9]  length(l!1) = i!2`1 - 1
[-10] i!2`1 <= i!1
[-11] nth(cons(n_init, append(l!1, (: i!2`2 :))), i!4) = n_init
[-12] 2 <= p
[-13] i!2`1 < p - 1
  |-------
[1]   append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))) =
       remove(hu_list, 1 + i!2`1)
[2]   i!2`1 = i!1
[3]   p = 2

Rerunning step: (case "length(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))))=p-1")
Case splitting on 
   length(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) = p - 1, 
this yields  2 subgoals: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.1.1 : 
;;; establish a convenient truth

{-1}  length(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) = p - 1
[-2]  i!4 < 1 + length(append(l!1, (: i!2`2 :)))
[-3]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-4]  i!3`1 = cons(n_init, l!1)
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] length(l!1) = i!2`1 - 1
[-11] i!2`1 <= i!1
[-12] nth(cons(n_init, append(l!1, (: i!2`2 :))), i!4) = n_init
[-13] 2 <= p
[-14] i!2`1 < p - 1
  |-------
[1]   append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))) =
       remove(hu_list, 1 + i!2`1)
[2]   i!2`1 = i!1
[3]   p = 2

Rerunning step: (rewrite "length_nth_equality[Identity]" 1)
Found matching substitution:
l2: list[Identity] gets remove(hu_list, 1 + i!2`1),
l1: list[Identity] gets append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))),
Rewriting using length_nth_equality[Identity], matching in 1,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.1.1.1 : 
;;; establish a convenient truth

[-1]  length(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) = p - 1
[-2]  i!4 < 1 + length(append(l!1, (: i!2`2 :)))
[-3]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-4]  i!3`1 = cons(n_init, l!1)
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] length(l!1) = i!2`1 - 1
[-11] i!2`1 <= i!1
[-12] nth(cons(n_init, append(l!1, (: i!2`2 :))), i!4) = n_init
[-13] 2 <= p
[-14] i!2`1 < p - 1
  |-------
{1}   length[Identity](append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) =
       length[Identity](remove(hu_list, 1 + i!2`1))
[2]   append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))) =
       remove(hu_list, 1 + i!2`1)
[3]   i!2`1 = i!1
[4]   p = 2

Rerunning step: (delete -2 -3 -4 -5 -6 -8 -9 -10 -11 -12 -13 -14 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.1.1.1 : 
;;; establish a convenient truth

[-1]  length(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) = p - 1
[-2]  (length(hu_list) = p)
  |-------
[1]   length[Identity](append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) =
       length[Identity](remove(hu_list, 1 + i!2`1))

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.1.1.1 : 
;;; establish a convenient truth

[-1]  length(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) = p - 1
[-2]  (length(hu_list) = p)
  |-------
{1}   p - 1 = length[Identity](remove(hu_list, 1 + i!2`1))

Rerunning step: (rewrite "length_remove" 1 :dir rl)
Found matching substitution:
i: below[length(c)] gets 1 + i!2`1,
c: (cons?[T]) gets hu_list,
length rewrites length(hu_list)
  to 0
Rewriting using length_remove, matching in 1,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.1.1.1 : 
;;; establish a convenient truth

[-1]  length(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) = p - 1
[-2]  (length(hu_list) = p)
  |-------
{1}   p - 1 = length[Identity](hu_list) - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_middle.1.2.1.2.1.6.1.2.1.1.1.

restrictmiddle_middle.1.2.1.2.1.6.1.2.1.1.2 : 
;;; establish a convenient truth

[-1]  length(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) = p - 1
[-2]  i!4 < 1 + length(append(l!1, (: i!2`2 :)))
[-3]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-4]  i!3`1 = cons(n_init, l!1)
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] length(l!1) = i!2`1 - 1
[-11] i!2`1 <= i!1
[-12] nth(cons(n_init, append(l!1, (: i!2`2 :))), i!4) = n_init
[-13] 2 <= p
[-14] i!2`1 < p - 1
  |-------
{1}   FORALL (i:
                below[length[Identity]
                          (append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))))]):
        nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i) =
         nth(remove(hu_list, 1 + i!2`1), i)
[2]   append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))) =
       remove(hu_list, 1 + i!2`1)
[3]   i!2`1 = i!1
[4]   p = 2

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.1.1.2 : 
;;; establish a convenient truth

{-1}  i!5 < length[Identity](append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))))
[-2]  length(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) = p - 1
[-3]  i!4 < 1 + length(append(l!1, (: i!2`2 :)))
[-4]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-5]  i!3`1 = cons(n_init, l!1)
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = -1 - i!2`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1 < p - 1
[-11] length(l!1) = i!2`1 - 1
[-12] i!2`1 <= i!1
[-13] nth(cons(n_init, append(l!1, (: i!2`2 :))), i!4) = n_init
[-14] 2 <= p
[-15] i!2`1 < p - 1
  |-------
{1}   nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i!5) =
       nth(remove(hu_list, 1 + i!2`1), i!5)
[2]   append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))) =
       remove(hu_list, 1 + i!2`1)
[3]   i!2`1 = i!1
[4]   p = 2

Rerunning step: (delete -3 -5 -10 -11 -12 -13 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.1.1.2 : 
;;; establish a convenient truth

[-1]  i!5 < length[Identity](append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))))
[-2]  length(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) = p - 1
[-3]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = -1 - i!2`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  2 <= p
[-9]  i!2`1 < p - 1
  |-------
[1]   nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i!5) =
       nth(remove(hu_list, 1 + i!2`1), i!5)

Rerunning step: (lemma "listprops[Identity].equality_nth"
                 ("l1" "append(i!3`3, i!3`4)" "l2"
                  "remove(hu_list, i!2`1)"))
Applying listprops[Identity].equality_nth where 
  l1 gets append(i!3`3, i!3`4),
  l2 gets remove(hu_list, i!2`1),
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.1.1.2 : 
;;; establish a convenient truth

{-1}  append(i!3`3, i!3`4) = remove(hu_list, i!2`1) IMPLIES
       FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
         nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-2]  i!5 < length[Identity](append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))))
[-3]  length(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) = p - 1
[-4]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  2 <= p
[-10] i!2`1 < p - 1
  |-------
[1]   nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i!5) =
       nth(remove(hu_list, 1 + i!2`1), i!5)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.1.1.2 : 
;;; establish a convenient truth

{-1}  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-2]  i!5 < length[Identity](append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))))
[-3]  length(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) = p - 1
[-4]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  2 <= p
[-10] i!2`1 < p - 1
  |-------
[1]   nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i!5) =
       nth(remove(hu_list, 1 + i!2`1), i!5)

Rerunning step: (lemma "listprops[Identity].nth_append"
                 ("l1" "i!3`3" "l2" "cons(hu(i!2`1), cdr(i!3`4))" "i"
                  "i!5"))
length rewrites 
  length[Identity](cons[Identity](hu(i!2`1), cdr[Identity](i!3`4)))
  to 1 + length(cdr[Identity](i!3`4))
Applying listprops[Identity].nth_append where 
  l1 gets i!3`3,
  l2 gets cons(hu(i!2`1), cdr(i!3`4)),
  i gets i!5,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.1.1.2.1 : 
;;; establish a convenient truth

{-1}  nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i!5) =
       IF i!5 < length[Identity](i!3`3) THEN nth(i!3`3, i!5)
       ELSE nth(cons(hu(i!2`1), cdr(i!3`4)), i!5 - length[Identity](i!3`3))
       ENDIF
[-2]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-3]  i!5 < length[Identity](append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))))
[-4]  length(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) = p - 1
[-5]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = -1 - i!2`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] 2 <= p
[-11] i!2`1 < p - 1
  |-------
[1]   nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i!5) =
       nth(remove(hu_list, 1 + i!2`1), i!5)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.1.1.2.1 : 
;;; establish a convenient truth

[-1]  nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i!5) =
       IF i!5 < length[Identity](i!3`3) THEN nth(i!3`3, i!5)
       ELSE nth(cons(hu(i!2`1), cdr(i!3`4)), i!5 - length[Identity](i!3`3))
       ENDIF
[-2]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-3]  i!5 < length[Identity](append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))))
[-4]  length(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) = p - 1
[-5]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = -1 - i!2`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] 2 <= p
[-11] i!2`1 < p - 1
  |-------
{1}   IF i!5 < length[Identity](i!3`3) THEN nth(i!3`3, i!5)
      ELSE nth(cons(hu(i!2`1), cdr(i!3`4)), i!5 - length[Identity](i!3`3))
      ENDIF
       = nth(remove(hu_list, 1 + i!2`1), i!5)

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.1.1.2.1 : 
;;; establish a convenient truth

[-1]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-2]  i!5 < length[Identity](append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))))
[-3]  length(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) = p - 1
[-4]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  2 <= p
[-10] i!2`1 < p - 1
  |-------
[1]   IF i!5 < length[Identity](i!3`3) THEN nth(i!3`3, i!5)
      ELSE nth(cons(hu(i!2`1), cdr(i!3`4)), i!5 - length[Identity](i!3`3))
      ENDIF
       = nth(remove(hu_list, 1 + i!2`1), i!5)

Rerunning step: (lemma "listprops[Identity].nth_remove"
                 ("l" "hu_list" "i" "1+i!2`1" "j" "i!5"))
Applying listprops[Identity].nth_remove where 
  l gets hu_list,
  i gets 1 + i!2`1,
  j gets i!5,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.1.1.2.1 : 
;;; establish a convenient truth

{-1}  nth(remove(hu_list, 1 + i!2`1), i!5) =
       IF i!5 < 1 + i!2`1 THEN nth(hu_list, i!5)
       ELSE nth(hu_list, i!5 + 1)
       ENDIF
[-2]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-3]  i!5 < length[Identity](append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))))
[-4]  length(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) = p - 1
[-5]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = -1 - i!2`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] 2 <= p
[-11] i!2`1 < p - 1
  |-------
[1]   IF i!5 < length[Identity](i!3`3) THEN nth(i!3`3, i!5)
      ELSE nth(cons(hu(i!2`1), cdr(i!3`4)), i!5 - length[Identity](i!3`3))
      ENDIF
       = nth(remove(hu_list, 1 + i!2`1), i!5)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.1.1.2.1 : 
;;; establish a convenient truth

[-1]  nth(remove(hu_list, 1 + i!2`1), i!5) =
       IF i!5 < 1 + i!2`1 THEN nth(hu_list, i!5)
       ELSE nth(hu_list, i!5 + 1)
       ENDIF
[-2]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-3]  i!5 < length[Identity](append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))))
[-4]  length(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) = p - 1
[-5]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = -1 - i!2`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] 2 <= p
[-11] i!2`1 < p - 1
  |-------
{1}   IF i!5 < length[Identity](i!3`3) THEN nth(i!3`3, i!5)
      ELSE nth(cons(hu(i!2`1), cdr(i!3`4)), i!5 - length[Identity](i!3`3))
      ENDIF
       =
       IF i!5 < 1 + i!2`1 THEN nth(hu_list, i!5)
       ELSE nth(hu_list, i!5 + 1)
       ENDIF

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.1.1.2.1 : 
;;; establish a convenient truth

[-1]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-2]  i!5 < length[Identity](append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))))
[-3]  length(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) = p - 1
[-4]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  2 <= p
[-10] i!2`1 < p - 1
  |-------
[1]   IF i!5 < length[Identity](i!3`3) THEN nth(i!3`3, i!5)
      ELSE nth(cons(hu(i!2`1), cdr(i!3`4)), i!5 - length[Identity](i!3`3))
      ENDIF
       =
       IF i!5 < 1 + i!2`1 THEN nth(hu_list, i!5)
       ELSE nth(hu_list, i!5 + 1)
       ENDIF

Rerunning step: (lemma "listprops[Identity].nth_append"
                 ("l1" "i!3`3" "l2" "i!3`4"))
Applying listprops[Identity].nth_append where 
  l1 gets i!3`3,
  l2 gets i!3`4,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.1.1.2.1 : 
;;; establish a convenient truth

{-1}  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-2]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-3]  i!5 < length[Identity](append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))))
[-4]  length(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) = p - 1
[-5]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = -1 - i!2`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] 2 <= p
[-11] i!2`1 < p - 1
  |-------
[1]   IF i!5 < length[Identity](i!3`3) THEN nth(i!3`3, i!5)
      ELSE nth(cons(hu(i!2`1), cdr(i!3`4)), i!5 - length[Identity](i!3`3))
      ENDIF
       =
       IF i!5 < 1 + i!2`1 THEN nth(hu_list, i!5)
       ELSE nth(hu_list, i!5 + 1)
       ENDIF

Rerunning step: (lemma "listprops[Identity].nth_remove"
                 ("l" "hu_list" "i" "i!2`1"))
Applying listprops[Identity].nth_remove where 
  l gets hu_list,
  i gets i!2`1,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.1.1.2.1 : 
;;; establish a convenient truth

{-1}  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-2]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-3]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-4]  i!5 < length[Identity](append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))))
[-5]  length(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) = p - 1
[-6]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-7]  length(i!3`3) = i!2`1
[-8]  length(i!3`4) = -1 - i!2`1 + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] 2 <= p
[-12] i!2`1 < p - 1
  |-------
[1]   IF i!5 < length[Identity](i!3`3) THEN nth(i!3`3, i!5)
      ELSE nth(cons(hu(i!2`1), cdr(i!3`4)), i!5 - length[Identity](i!3`3))
      ENDIF
       =
       IF i!5 < 1 + i!2`1 THEN nth(hu_list, i!5)
       ELSE nth(hu_list, i!5 + 1)
       ENDIF

Rerunning step: (grind :exclude ("append" "remove"))
nth rewrites nth(cdr(hu_list), j)
  to nth(cdr(cdr(hu_list)), j - 1)
nth rewrites nth(hu_list, 1 + j)
  to nth(cdr(cdr(hu_list)), j - 1)
nth rewrites nth(hu_list, 1 + i!5)
  to nth(cdr(hu_list), i!5)
nth rewrites nth(cdr(cdr(hu_list)), i!5 - 1)
  to nth(cdr(cdr(cdr(hu_list))), i!5 - 2)
nth rewrites nth(cdr(hu_list), i!5)
  to nth(cdr(cdr(cdr(hu_list))), i!5 - 2)
nth rewrites nth(remove(hu_list, i!2`1), i!5)
  to nth(cdr(remove(hu_list, i!2`1)), i!5 - 1)
nth rewrites nth(hu_list, i!5)
  to nth(cdr(hu_list), i!5 - 1)
nth rewrites nth(remove(hu_list, i!2`1), i!5)
  to nth(cdr(remove(hu_list, i!2`1)), i!5 - 1)
nth rewrites nth(cons(hu(i!2`1), cdr(i!3`4)), i!5 - i!2`1)
  to hu(i!2`1)
nth rewrites nth(cons(hu(i!2`1), cdr(i!3`4)), i!5 - i!2`1)
  to nth(cdr(i!3`4), -1 - i!2`1 + i!5)
nth rewrites nth(i!3`4, i!5 - i!2`1)
  to car(i!3`4)
nth rewrites nth(hu_list, i!2`1)
  to nth(cdr(hu_list), i!2`1 - 1)
nth rewrites nth(i!3`4, i!5 - i!2`1)
  to car(i!3`4)
nth rewrites nth(hu_list, i!2`1)
  to nth(cdr(hu_list), i!2`1 - 1)
nth rewrites nth(cdr(remove(hu_list, i!2`1)), i!5 - 1)
  to nth(cdr(cdr(remove(hu_list, i!2`1))), i!5 - 2)
nth rewrites nth(i!3`4, i!5 - i!2`1)
  to nth(cdr(i!3`4), -1 - i!2`1 + i!5)
nth rewrites nth(cdr(cdr(hu_list)), i!5 - 1)
  to nth(cdr(cdr(cdr(hu_list))), i!5 - 2)
nth rewrites nth(cdr(remove(hu_list, i!2`1)), i!5 - 1)
  to nth(cdr(cdr(remove(hu_list, i!2`1))), i!5 - 2)
nth rewrites nth(i!3`4, i!5 - i!2`1)
  to nth(cdr(i!3`4), -1 - i!2`1 + i!5)
nth rewrites nth(cdr(cdr(hu_list)), i!5 - 1)
  to nth(cdr(cdr(cdr(hu_list))), i!5 - 2)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_middle.1.2.1.2.1.6.1.2.1.1.2.1.

restrictmiddle_middle.1.2.1.2.1.6.1.2.1.1.2.2T (TCC):   

[-1]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-2]  i!5 < length[Identity](append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))))
[-3]  length(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) = p - 1
[-4]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  2 <= p
[-10] i!2`1 < p - 1
  |-------
{1}   i!5 < 1 + length(cdr[Identity](i!3`4)) + length[Identity](i!3`3)
[2]   nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i!5) =
       nth(remove(hu_list, 1 + i!2`1), i!5)

Rerunning step: (delete -1 -4 -7 -8 -9 -10 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.1.1.2.2T : 
;;; establish a convenient truth

[-1]  i!5 < length[Identity](append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))))
[-2]  length(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) = p - 1
[-3]  length(i!3`3) = i!2`1
[-4]  length(i!3`4) = -1 - i!2`1 + p
  |-------
[1]   i!5 < 1 + length(cdr[Identity](i!3`4)) + length[Identity](i!3`3)

Rerunning step: (rewrite "length_cdr")
Found matching substitution:
cons_l: (cons?[T]) gets i!3`4,
Rewriting using length_cdr, matching in *,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.1.1.2.2T : 
;;; establish a convenient truth

[-1]  i!5 < length[Identity](append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))))
[-2]  length(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) = p - 1
[-3]  length(i!3`3) = i!2`1
[-4]  length(i!3`4) = -1 - i!2`1 + p
  |-------
{1}   i!5 < 1 + (length(i!3`4) - 1) + length[Identity](i!3`3)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_middle.1.2.1.2.1.6.1.2.1.1.2.2T.


This completes the proof of restrictmiddle_middle.1.2.1.2.1.6.1.2.1.1.2.


This completes the proof of restrictmiddle_middle.1.2.1.2.1.6.1.2.1.1.

restrictmiddle_middle.1.2.1.2.1.6.1.2.1.2 : 
;;; establish a convenient truth

[-1]  i!4 < 1 + length(append(l!1, (: i!2`2 :)))
[-2]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = -1 - i!2`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!1 < p - 1
[-9]  length(l!1) = i!2`1 - 1
[-10] i!2`1 <= i!1
[-11] nth(cons(n_init, append(l!1, (: i!2`2 :))), i!4) = n_init
[-12] 2 <= p
[-13] i!2`1 < p - 1
  |-------
{1}   length(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) = p - 1
[2]   append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))) =
       remove(hu_list, 1 + i!2`1)
[3]   i!2`1 = i!1
[4]   p = 2

Rerunning step: (rewrite "length_append")
Found matching substitution:
l2: list[T] gets cons(hu(i!2`1), cdr(i!3`4)),
l1: list[T] gets i!3`3,
length rewrites length(cons(hu(i!2`1), cdr(i!3`4)))
  to 1 + length(cdr(i!3`4))
Rewriting using length_append, matching in *,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.1.2 : 
;;; establish a convenient truth

[-1]  i!4 < 1 + length(append(l!1, (: i!2`2 :)))
[-2]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = -1 - i!2`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!1 < p - 1
[-9]  length(l!1) = i!2`1 - 1
[-10] i!2`1 <= i!1
[-11] nth(cons(n_init, append(l!1, (: i!2`2 :))), i!4) = n_init
[-12] 2 <= p
[-13] i!2`1 < p - 1
  |-------
{1}   1 + length(cdr(i!3`4)) + length(i!3`3) = p - 1
[2]   append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))) =
       remove(hu_list, 1 + i!2`1)
[3]   i!2`1 = i!1
[4]   p = 2

Rerunning step: (delete -1 -2 -3 -6 -7 -8 -9 -10 -11 -12 -13 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.1.2 : 
;;; establish a convenient truth

[-1]  length(i!3`3) = i!2`1
[-2]  length(i!3`4) = -1 - i!2`1 + p
  |-------
[1]   1 + length(cdr(i!3`4)) + length(i!3`3) = p - 1

Rerunning step: (rewrite "length_cdr")
Found matching substitution:
cons_l: (cons?[T]) gets i!3`4,
Rewriting using length_cdr, matching in *,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.1.2 : 
;;; establish a convenient truth

[-1]  length(i!3`3) = i!2`1
[-2]  length(i!3`4) = -1 - i!2`1 + p
  |-------
{1}   1 + (length(i!3`4) - 1) + length(i!3`3) = p - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_middle.1.2.1.2.1.6.1.2.1.2.


This completes the proof of restrictmiddle_middle.1.2.1.2.1.6.1.2.1.

restrictmiddle_middle.1.2.1.2.1.6.1.2.2 (TCC):   

[-1]  i!4 < 1 + length(append(l!1, (: i!2`2 :)))
[-2]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = -1 - i!2`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!1 < p - 1
[-9]  length(l!1) = i!2`1 - 1
[-10] i!2`1 <= i!1
[-11] nth(cons(n_init, append(l!1, (: i!2`2 :))), i!4) = n_init
[-12] 2 <= p
[-13] i!2`1 < p - 1
  |-------
{1}   length[Nonce](append[Nonce](l!1, (: i!2`2 :))) = i!2`1
[2]   i!2`1 = i!1
[3]   p = 2

Rerunning step: (delete -1 -2 -3 -4 -5 -6 -7 -8 -10 -11 -12 -13 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.2 : 
;;; car(i!3`4)=hu(i!2`1+1), according to -2

[-1]  length(l!1) = i!2`1 - 1
  |-------
[1]   length[Nonce](append[Nonce](l!1, (: i!2`2 :))) = i!2`1

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets (: i!2`2 :),
l1: list[T] gets l!1,
length rewrites length((: :))
  to 0
length rewrites length((: i!2`2 :))
  to 1
Rewriting using length_append, matching in 1,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.1.2.2 : 
;;; car(i!3`4)=hu(i!2`1+1), according to -2

[-1]  length(l!1) = i!2`1 - 1
  |-------
{1}   1 + length(l!1) = i!2`1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_middle.1.2.1.2.1.6.1.2.2.


This completes the proof of restrictmiddle_middle.1.2.1.2.1.6.1.2.


This completes the proof of restrictmiddle_middle.1.2.1.2.1.6.1.

restrictmiddle_middle.1.2.1.2.1.6.2 : 
;;; establish some obvious equalities

[-1]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-2]  i!3`1 = cons(n_init, l!1)
[-3]  u!1 = hu(j!1)
[-4]  length(i!3`1) = i!2`1
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = P!1 - 1 - i!2`1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] length(l!1) = j!1 - 1
[-11] j!1 <= i!1
[-12] 2 <= P!1
[-13] i!2`1 < P!1 - 1
  |-------
{1}   P!1 = p AND j!1 = i!2`1
[2]   i!2`1 = i!1
[3]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[4]   P!1 = 2

Rerunning step: (replace -2 -4)
Replacing using formula -2,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.2 : 
;;; establish some obvious equalities

[-1]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-2]  i!3`1 = cons(n_init, l!1)
[-3]  u!1 = hu(j!1)
{-4}  length(cons(n_init, l!1)) = i!2`1
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = P!1 - 1 - i!2`1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] length(l!1) = j!1 - 1
[-11] j!1 <= i!1
[-12] 2 <= P!1
[-13] i!2`1 < P!1 - 1
  |-------
[1]   P!1 = p AND j!1 = i!2`1
[2]   i!2`1 = i!1
[3]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[4]   P!1 = 2

Rerunning step: (expand "length" -4)
Expanding the definition of length,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.2 : 
;;; establish some obvious equalities

[-1]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-2]  i!3`1 = cons(n_init, l!1)
[-3]  u!1 = hu(j!1)
{-4}  1 + length(l!1) = i!2`1
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = P!1 - 1 - i!2`1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] length(l!1) = j!1 - 1
[-11] j!1 <= i!1
[-12] 2 <= P!1
[-13] i!2`1 < P!1 - 1
  |-------
[1]   P!1 = p AND j!1 = i!2`1
[2]   i!2`1 = i!1
[3]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[4]   P!1 = 2

Rerunning step: (replace -10 -4)
Replacing using formula -10,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.2 : 
;;; establish some obvious equalities

[-1]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-2]  i!3`1 = cons(n_init, l!1)
[-3]  u!1 = hu(j!1)
{-4}  1 + (j!1 - 1) = i!2`1
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = P!1 - 1 - i!2`1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] length(l!1) = j!1 - 1
[-11] j!1 <= i!1
[-12] 2 <= P!1
[-13] i!2`1 < P!1 - 1
  |-------
[1]   P!1 = p AND j!1 = i!2`1
[2]   i!2`1 = i!1
[3]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[4]   P!1 = 2

Rerunning step: (lemma "listprops[Identity].equality_length"
                 ("l1" "append(i!3`3, i!3`4)" "l2"
                  "remove(hu_list, j!1)"))
Applying listprops[Identity].equality_length where 
  l1 gets append(i!3`3, i!3`4),
  l2 gets remove(hu_list, j!1),
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.2 : 
;;; establish some obvious equalities

{-1}  append(i!3`3, i!3`4) = remove(hu_list, j!1) IMPLIES
       length[Identity](append(i!3`3, i!3`4)) =
        length[Identity](remove(hu_list, j!1))
[-2]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  u!1 = hu(j!1)
[-5]  1 + (j!1 - 1) = i!2`1
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = P!1 - 1 - i!2`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1 < p - 1
[-11] length(l!1) = j!1 - 1
[-12] j!1 <= i!1
[-13] 2 <= P!1
[-14] i!2`1 < P!1 - 1
  |-------
[1]   P!1 = p AND j!1 = i!2`1
[2]   i!2`1 = i!1
[3]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[4]   P!1 = 2

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets i!3`4,
l1: list[T] gets i!3`3,
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.2 : 
;;; establish some obvious equalities

{-1}  append(i!3`3, i!3`4) = remove(hu_list, j!1) IMPLIES
       length(i!3`3) + length(i!3`4) =
        length[Identity](remove(hu_list, j!1))
[-2]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  u!1 = hu(j!1)
[-5]  1 + (j!1 - 1) = i!2`1
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = P!1 - 1 - i!2`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1 < p - 1
[-11] length(l!1) = j!1 - 1
[-12] j!1 <= i!1
[-13] 2 <= P!1
[-14] i!2`1 < P!1 - 1
  |-------
[1]   P!1 = p AND j!1 = i!2`1
[2]   i!2`1 = i!1
[3]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[4]   P!1 = 2

Rerunning step: (rewrite "length_remove" -1 :dir rl)
Found matching substitution:
i: below[length(c)] gets j!1,
c: (cons?[T]) gets hu_list,
length rewrites length(hu_list)
  to 0
Rewriting using length_remove, matching in -1,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.2 : 
;;; establish some obvious equalities

{-1}  append(i!3`3, i!3`4) = remove(hu_list, j!1) IMPLIES
       length(i!3`3) + length(i!3`4) = length[Identity](hu_list) - 1
[-2]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-3]  i!3`1 = cons(n_init, l!1)
[-4]  u!1 = hu(j!1)
[-5]  1 + (j!1 - 1) = i!2`1
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = P!1 - 1 - i!2`1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1 < p - 1
[-11] length(l!1) = j!1 - 1
[-12] j!1 <= i!1
[-13] 2 <= P!1
[-14] i!2`1 < P!1 - 1
  |-------
[1]   P!1 = p AND j!1 = i!2`1
[2]   i!2`1 = i!1
[3]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[4]   P!1 = 2

Rerunning step: (delete -3 -4 -9 -10 -11 -12 -13 -14 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.1.6.2 : 
;;; establish some obvious equalities

[-1]  append(i!3`3, i!3`4) = remove(hu_list, j!1) IMPLIES
       length(i!3`3) + length(i!3`4) = length[Identity](hu_list) - 1
[-2]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-3]  1 + (j!1 - 1) = i!2`1
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = P!1 - 1 - i!2`1
[-6]  (length(hu_list) = p)
  |-------
[1]   P!1 = p AND j!1 = i!2`1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_middle.1.2.1.2.1.6.2.


This completes the proof of restrictmiddle_middle.1.2.1.2.1.6.


This completes the proof of restrictmiddle_middle.1.2.1.2.1.

restrictmiddle_middle.1.2.1.2.2 : 
;;; first and foremost, let us prove that i!2`2 /= n_init

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
{1}   i!2`2 /= n_init
[2]   i!2`1 = i!1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND car(i!3`1) = n_init
[3]   rho_middle(i!1)
                (E(public(car(i!3`4)),
                   conc(nlist(append(i!3`1, (: i!2`2 :))),
                        ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[4]   P!1 = 2

Rerunning step: (delete -1 -2 -4 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.2 : 
;;; first and foremost, let us prove that i!2`2 /= n_init

[-1]  0 < i!2`1
  |-------
[1]   i!2`2 /= n_init

Rerunning step: (typepred "i!2`2")
Adding type constraints for  i!2`2,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.2 : 
;;; first and foremost, let us prove that i!2`2 /= n_init

{-1}  IRpart(P!1, u!1, i!2`1)(i!2`2)
[-2]  0 < i!2`1
  |-------
[1]   i!2`2 /= n_init

Rerunning step: (lemma "n_prop" ("P" "P!1" "u" "u!1" "r" "i!2`1"))
Applying n_prop where 
  P gets P!1,
  u gets u!1,
  r gets i!2`1,
this simplifies to: 
restrictmiddle_middle.1.2.1.2.2 : 
;;; first and foremost, let us prove that i!2`2 /= n_init

{-1}  (P!1 /= p OR i!2`1 /= 0) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, i!2`1)(n_init)
[-2]  IRpart(P!1, u!1, i!2`1)(i!2`2)
[-3]  0 < i!2`1
  |-------
[1]   i!2`2 /= n_init

Rerunning step: (grind)
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
/= rewrites i!2`2 /= n_init
  to TRUE
/= rewrites P!1 /= p
  to NOT (P!1 = p)
/= rewrites i!2`1 /= 0
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_middle.1.2.1.2.2.


This completes the proof of restrictmiddle_middle.1.2.1.2.


This completes the proof of restrictmiddle_middle.1.2.1.

restrictmiddle_middle.1.2.2 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
{1}   ((rec(u!1, nth(i!3`3, i!2`1 - 1),
            E(public(u!1),
              conc(ilist(append(i!3`3, i!3`4)),
                   nlist(cons(i!2`2, i!3`2)))))
         >>
         ((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
           Stop[event]))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (trans(u!1, car(i!3`4),
                     E(public(car(i!3`4)),
                       conc(nlist(append(i!3`1, (: i!2`2 :))),
                            ilist(append(i!3`3, cons(u!1, cdr(i!3`4))))))))
{3}   trans(u!1, car(i!3`4),
            E(public(car(i!3`4)),
              conc(nlist(append(i!3`1, (: i!2`2 :))),
                   ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
       >>
       ((rec(u!1, nth(i!3`3, i!2`1 - 1),
             E(public(u!1),
               conc(ilist(append(i!3`3, i!3`4)),
                    nlist(cons(i!2`2, i!3`2)))))
          >>
          ((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
            Stop[event]))
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   R_middle(i!1)
              (signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                              car(i!3`1))))
[5]   P!1 = 2

Rerunning step: (delete 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   ((rec(u!1, nth(i!3`3, i!2`1 - 1),
            E(public(u!1),
              conc(ilist(append(i!3`3, i!3`4)),
                   nlist(cons(i!2`2, i!3`2)))))
         >>
         ((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
           Stop[event]))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[2]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictmiddle_middle.1.2.2 :  

{-1}  rho_middle(i!1)
                (E(public(u!1),
                   conc(ilist(append(i!3`3, i!3`4)),
                        nlist(cons(i!2`2, i!3`2)))))
[-2]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
{1}   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (rec(u!1, nth(i!3`3, i!2`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(i!3`3, i!3`4)),
                          nlist(cons(i!2`2, i!3`2))))))
{3}   rec(u!1, nth(i!3`3, i!2`1 - 1),
          E(public(u!1),
            conc(ilist(append(i!3`3, i!3`4)), nlist(cons(i!2`2, i!3`2)))))
       >>
       (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
          Stop[event])
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(ilist(append(i!3`3, i!3`4)),
                        nlist(cons(i!2`2, i!3`2)))))
[-2]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
[1]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[2]   P!1 = 2

Rerunning step: (expand "LastMessage")
Expanding the definition of LastMessage,
this simplifies to: 
restrictmiddle_middle.1.2.2 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(ilist(append(i!3`3, i!3`4)),
                        nlist(cons(i!2`2, i!3`2)))))
[-2]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
{1}   ((IF i!2`1 = P!1 - 2
          THEN trans(u!1, car(i!3`4), E(public(car(i!3`4)), nlist(i!3`2)))
        ELSE trans(u!1, car(i!3`4),
                   E(public(car(i!3`4)),
                     conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                          nlist(i!3`2))))
        ENDIF
         >> Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[2]   P!1 = 2

Rerunning step: (lift-if)
Lifting IF-conditions to the top level,
this simplifies to: 
restrictmiddle_middle.1.2.2 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(ilist(append(i!3`3, i!3`4)),
                        nlist(cons(i!2`2, i!3`2)))))
[-2]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
{1}   IF i!2`1 = P!1 - 2
        THEN ((trans(u!1, car(i!3`4), E(public(car(i!3`4)), nlist(i!3`2)))
                >> Stop[event])
               # R_middle(i!1))
              |>
              LAMBDA (t: list[event]):
                every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))
                     (t)
                 =>
                 every(LAMBDA (e: event):
                         NOT rec?(e) => rho_middle(i!1)(msg(e)))
                      (t)
      ELSE ((trans(u!1, car(i!3`4),
                   E(public(car(i!3`4)),
                     conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                          nlist(i!3`2))))
              >> Stop[event])
             # R_middle(i!1))
            |>
            LAMBDA (t: list[event]):
              every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))
                   (t)
               =>
               every(LAMBDA (e: event):
                       NOT rec?(e) => rho_middle(i!1)(msg(e)))
                    (t)
      ENDIF
[2]   P!1 = 2

Rerunning step: (prop)
Applying propositional simplification,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.2.1 :  

{-1}  i!2`1 = P!1 - 2
[-2]  rho_middle(i!1)
                (E(public(u!1),
                   conc(ilist(append(i!3`3, i!3`4)),
                        nlist(cons(i!2`2, i!3`2)))))
[-3]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-4]  2 <= P!1
[-5]  0 < i!2`1
[-6]  i!2`1 < P!1 - 1
  |-------
{1}   ((trans(u!1, car(i!3`4), E(public(car(i!3`4)), nlist(i!3`2))) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[2]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.2.1.1 :  

[-1]  i!2`1 = P!1 - 2
[-2]  rho_middle(i!1)
                (E(public(u!1),
                   conc(ilist(append(i!3`3, i!3`4)),
                        nlist(cons(i!2`2, i!3`2)))))
[-3]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-4]  2 <= P!1
[-5]  0 < i!2`1
[-6]  i!2`1 < P!1 - 1
  |-------
{1}   rho_middle(i!1)(E(public(car(i!3`4)), nlist(i!3`2)))
{2}   R_middle(i!1)
              (trans(u!1, car(i!3`4), E(public(car(i!3`4)), nlist(i!3`2))))
{3}   trans(u!1, car(i!3`4), E(public(car(i!3`4)), nlist(i!3`2))) >>
       (Stop[event] # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   P!1 = 2

Rerunning step: (delete -3 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.1.1 :  

[-1]  i!2`1 = P!1 - 2
[-2]  rho_middle(i!1)
                (E(public(u!1),
                   conc(ilist(append(i!3`3, i!3`4)),
                        nlist(cons(i!2`2, i!3`2)))))
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
[1]   rho_middle(i!1)(E(public(car(i!3`4)), nlist(i!3`2)))
[2]   P!1 = 2

Rerunning step: (lemma "listprops[Nonce].elt_append2"
                 ("l1" "(: i!2`2:)" "l2" "i!3`2" "t" "n_init"))
Applying listprops[Nonce].elt_append2 where 
  l1 gets (: i!2`2 :),
  l2 gets i!3`2,
  t gets n_init,
this simplifies to: 
restrictmiddle_middle.1.2.2.1.1 :  

{-1}  elt(i!3`2, n_init) IMPLIES elt(append((: i!2`2 :), i!3`2), n_init)
[-2]  i!2`1 = P!1 - 2
[-3]  rho_middle(i!1)
                (E(public(u!1),
                   conc(ilist(append(i!3`3, i!3`4)),
                        nlist(cons(i!2`2, i!3`2)))))
[-4]  2 <= P!1
[-5]  0 < i!2`1
[-6]  i!2`1 < P!1 - 1
  |-------
[1]   rho_middle(i!1)(E(public(car(i!3`4)), nlist(i!3`2)))
[2]   P!1 = 2

Rerunning step: (grind :if-match nil :exclude "elt")
append rewrites append((: :), i!3`2)
  to i!3`2
append rewrites append((: i!2`2 :), i!3`2)
  to cons(i!2`2, i!3`2)
E rewrites E(public(car(i!3`4)), nlist(i!3`2))
  to code(public(car(i!3`4)), nlist(i!3`2))
rho_middle rewrites rho_middle(i!1)(nlist(i!3`2))
  to NOT elt(i!3`2, n_init)
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites rho_middle(i!1)(code(public(car(i!3`4)), nlist(i!3`2)))
  to NOT elt(i!3`2, n_init)
E rewrites 
  E(public(u!1),
    conc(ilist(append(i!3`3, i!3`4)), nlist(cons(i!2`2, i!3`2))))
  to code(public(u!1),
           conc(ilist(append(i!3`3, i!3`4)), nlist(cons(i!2`2, i!3`2))))
rho_middle rewrites rho_middle(i!1)(ilist(append(i!3`3, i!3`4)))
  to TRUE
rho_middle rewrites rho_middle(i!1)(nlist(cons(i!2`2, i!3`2)))
  to FALSE
rho_middle rewrites 
  rho_middle(i!1)
            (conc(ilist(append(i!3`3, i!3`4)), nlist(cons(i!2`2, i!3`2))))
  to FALSE
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites 
  rho_middle(i!1)
            (code(public(u!1),
                  conc(ilist(append(i!3`3, i!3`4)),
                       nlist(cons(i!2`2, i!3`2)))))
  to EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
        public(u!1) = public(hu(j)) AND
         EXISTS (l: {x: list[Nonce] | length(x) = j - 1}):
           conc(ilist(append(i!3`3, i!3`4)), nlist(cons(i!2`2, i!3`2))) =
            conc(nlist(cons(n_init, l)),
                 ilist(cons(car(hu_list), remove(cdr(hu_list), j - 1))))
E rewrites E(public(car(i!3`4)), nlist(i!3`2))
  to code(public(car(i!3`4)), nlist(i!3`2))
rho_middle rewrites rho_middle(i!1)(nlist(i!3`2))
  to TRUE
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites rho_middle(i!1)(code(public(car(i!3`4)), nlist(i!3`2)))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,
this simplifies to: 
restrictmiddle_middle.1.2.2.1.1 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
{-2}  length(l!1) = j!1 - 1
{-3}  0 < j!1
{-4}  j!1 <= i!1
{-5}  elt(cons(i!2`2, i!3`2), n_init)
{-6}  elt(i!3`2, n_init)
[-7]  i!2`1 = P!1 - 2
{-8}  public(u!1) = public(hu(j!1))
{-9}  conc(ilist(append(i!3`3, i!3`4)), nlist(cons(i!2`2, i!3`2))) =
       conc(nlist(cons(n_init, l!1)),
            ilist(cons(car(hu_list), remove(cdr(hu_list), j!1 - 1))))
[-10] 2 <= P!1
{-11} 0 < P!1 - 2
{-12} P!1 - 2 < P!1 - 1
  |-------
[1]   P!1 = 2

Rerunning step: (decompose-equality -9)
Applying decompose-equality,

This completes the proof of restrictmiddle_middle.1.2.2.1.1.

restrictmiddle_middle.1.2.2.1.2 :  

[-1]  i!2`1 = P!1 - 2
[-2]  rho_middle(i!1)
                (E(public(u!1),
                   conc(ilist(append(i!3`3, i!3`4)),
                        nlist(cons(i!2`2, i!3`2)))))
[-3]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-4]  2 <= P!1
[-5]  0 < i!2`1
[-6]  i!2`1 < P!1 - 1
  |-------
{1}   (Stop[event] # R_middle(i!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (trans(u!1, car(i!3`4), E(public(car(i!3`4)), nlist(i!3`2))))
{3}   trans(u!1, car(i!3`4), E(public(car(i!3`4)), nlist(i!3`2))) >>
       (Stop[event] # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   P!1 = 2

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.1.2 :  

  |-------
[1]   (Stop[event] # R_middle(i!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[2]   P!1 = 2

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictmiddle_middle.1.2.2.1.2.


This completes the proof of restrictmiddle_middle.1.2.2.1.

restrictmiddle_middle.1.2.2.2 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(ilist(append(i!3`3, i!3`4)),
                        nlist(cons(i!2`2, i!3`2)))))
[-2]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
{1}   i!2`1 = P!1 - 2
{2}   ((trans(u!1, car(i!3`4),
              E(public(car(i!3`4)),
                conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                     nlist(i!3`2))))
         >> Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.2.2.1 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(ilist(append(i!3`3, i!3`4)),
                        nlist(cons(i!2`2, i!3`2)))))
[-2]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
{1}   rho_middle(i!1)
                (E(public(car(i!3`4)),
                   conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                        nlist(i!3`2))))
{2}   R_middle(i!1)
              (trans(u!1, car(i!3`4),
                     E(public(car(i!3`4)),
                       conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                            nlist(i!3`2)))))
{3}   trans(u!1, car(i!3`4),
            E(public(car(i!3`4)),
              conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                   nlist(i!3`2))))
       >> (Stop[event] # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   i!2`1 = P!1 - 2
[5]   P!1 = 2

Rerunning step: (delete -2 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.1 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(ilist(append(i!3`3, i!3`4)),
                        nlist(cons(i!2`2, i!3`2)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   rho_middle(i!1)
                (E(public(car(i!3`4)),
                   conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                        nlist(i!3`2))))
[2]   i!2`1 = P!1 - 2
[3]   P!1 = 2

Rerunning step: (lemma "listprops[Nonce].elt_append2"
                 ("l1" "(: i!2`2:)" "l2" "i!3`2" "t" "n_init"))
Applying listprops[Nonce].elt_append2 where 
  l1 gets (: i!2`2 :),
  l2 gets i!3`2,
  t gets n_init,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.1 :  

{-1}  elt(i!3`2, n_init) IMPLIES elt(append((: i!2`2 :), i!3`2), n_init)
[-2]  rho_middle(i!1)
                (E(public(u!1),
                   conc(ilist(append(i!3`3, i!3`4)),
                        nlist(cons(i!2`2, i!3`2)))))
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
[1]   rho_middle(i!1)
                (E(public(car(i!3`4)),
                   conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                        nlist(i!3`2))))
[2]   i!2`1 = P!1 - 2
[3]   P!1 = 2

Rerunning step: (grind :if-match nil :exclude "elt")
append rewrites append((: :), i!3`2)
  to i!3`2
append rewrites append((: i!2`2 :), i!3`2)
  to cons(i!2`2, i!3`2)
E rewrites 
  E(public(car(i!3`4)),
    conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))), nlist(i!3`2)))
  to code(public(car(i!3`4)),
           conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))), nlist(i!3`2)))
rho_middle rewrites 
  rho_middle(i!1)(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))
  to TRUE
rho_middle rewrites rho_middle(i!1)(nlist(i!3`2))
  to NOT elt(i!3`2, n_init)
rho_middle rewrites 
  rho_middle(i!1)
            (conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                  nlist(i!3`2)))
  to NOT elt(i!3`2, n_init)
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites 
  rho_middle(i!1)
            (code(public(car(i!3`4)),
                  conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                       nlist(i!3`2))))
  to NOT elt(i!3`2, n_init) OR
       EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
         public(car(i!3`4)) = public(hu(j)) AND
          EXISTS (l: {x: list[Nonce] | length(x) = j - 1}):
            conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))), nlist(i!3`2))
             =
             conc(nlist(cons(n_init, l)),
                  ilist(cons(car(hu_list), remove(cdr(hu_list), j - 1))))
E rewrites 
  E(public(u!1),
    conc(ilist(append(i!3`3, i!3`4)), nlist(cons(i!2`2, i!3`2))))
  to code(public(u!1),
           conc(ilist(append(i!3`3, i!3`4)), nlist(cons(i!2`2, i!3`2))))
rho_middle rewrites rho_middle(i!1)(ilist(append(i!3`3, i!3`4)))
  to TRUE
rho_middle rewrites rho_middle(i!1)(nlist(cons(i!2`2, i!3`2)))
  to FALSE
rho_middle rewrites 
  rho_middle(i!1)
            (conc(ilist(append(i!3`3, i!3`4)), nlist(cons(i!2`2, i!3`2))))
  to FALSE
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites 
  rho_middle(i!1)
            (code(public(u!1),
                  conc(ilist(append(i!3`3, i!3`4)),
                       nlist(cons(i!2`2, i!3`2)))))
  to EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
        public(u!1) = public(hu(j)) AND
         EXISTS (l: {x: list[Nonce] | length(x) = j - 1}):
           conc(ilist(append(i!3`3, i!3`4)), nlist(cons(i!2`2, i!3`2))) =
            conc(nlist(cons(n_init, l)),
                 ilist(cons(car(hu_list), remove(cdr(hu_list), j - 1))))
E rewrites 
  E(public(car(i!3`4)),
    conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))), nlist(i!3`2)))
  to code(public(car(i!3`4)),
           conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))), nlist(i!3`2)))
rho_middle rewrites 
  rho_middle(i!1)(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))
  to TRUE
rho_middle rewrites rho_middle(i!1)(nlist(i!3`2))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)
            (conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                  nlist(i!3`2)))
  to TRUE
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites 
  rho_middle(i!1)
            (code(public(car(i!3`4)),
                  conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                       nlist(i!3`2))))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.1 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
{-2}  length(l!1) = j!1 - 1
{-3}  0 < j!1
{-4}  j!1 <= i!1
{-5}  elt(cons(i!2`2, i!3`2), n_init)
{-6}  elt(i!3`2, n_init)
{-7}  public(u!1) = public(hu(j!1))
{-8}  conc(ilist(append(i!3`3, i!3`4)), nlist(cons(i!2`2, i!3`2))) =
       conc(nlist(cons(n_init, l!1)),
            ilist(cons(car(hu_list), remove(cdr(hu_list), j!1 - 1))))
[-9]  2 <= P!1
[-10] 0 < i!2`1
[-11] i!2`1 < P!1 - 1
  |-------
{1}   EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
        public(car(i!3`4)) = public(hu(j)) AND
         EXISTS (l: {x: list[Nonce] | length(x) = j - 1}):
           conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))), nlist(i!3`2))
            =
            conc(nlist(cons(n_init, l)),
                 ilist(cons(car(hu_list), remove(cdr(hu_list), j - 1))))
[2]   i!2`1 = P!1 - 2
[3]   P!1 = 2

Rerunning step: (decompose-equality -8)
Applying decompose-equality,

This completes the proof of restrictmiddle_middle.1.2.2.2.1.

restrictmiddle_middle.1.2.2.2.2 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(ilist(append(i!3`3, i!3`4)),
                        nlist(cons(i!2`2, i!3`2)))))
[-2]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
{1}   (Stop[event] # R_middle(i!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (trans(u!1, car(i!3`4),
                     E(public(car(i!3`4)),
                       conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                            nlist(i!3`2)))))
{3}   trans(u!1, car(i!3`4),
            E(public(car(i!3`4)),
              conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                   nlist(i!3`2))))
       >> (Stop[event] # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   i!2`1 = P!1 - 2
[5]   P!1 = 2

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.2 :  

  |-------
[1]   (Stop[event] # R_middle(i!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[2]   i!2`1 = P!1 - 2
[3]   P!1 = 2

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictmiddle_middle.1.2.2.2.2.


This completes the proof of restrictmiddle_middle.1.2.2.2.


This completes the proof of restrictmiddle_middle.1.2.2.


This completes the proof of restrictmiddle_middle.1.2.


This completes the proof of restrictmiddle_middle.1.

restrictmiddle_middle.2 :  

[-1]  2 <= P!1
[-2]  0 < i!2`1
[-3]  i!2`1 < P!1 - 1
  |-------
{1}   cons?[Identity](i!3`4)
[2]   P!1 = 2
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!2`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!2`1},
                  {x: list[Identity] | length(x) = i!2`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!2`1}]):
        (rec(u!1, nth(i`3, i!2`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (signal(running(i!2`1, append(i`3, cons(u!1, i`4)), car(i`1))) >>
            (trans(u!1, car(i`4),
                   E(public(car(i`4)),
                     conc(nlist(append(i`1, (: i!2`2 :))),
                          ilist(append(i`3, cons(u!1, cdr(i`4)))))))
              >>
              (rec(u!1, nth(i`3, i!2`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(i`3, i`4)),
                          nlist(cons(i!2`2, i`2)))))
                >>
                ((LastMessage(P!1, i!2`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.2 :  

[-1]  2 <= P!1
[-2]  0 < i!2`1
[-3]  i!2`1 < P!1 - 1
  |-------
[1]   cons?[Identity](i!3`4)
[2]   P!1 = 2

Rerunning step: (nonemptylist "i!3`4")
Relating existence of a tail to a list's length,

This completes the proof of restrictmiddle_middle.2.

restrictmiddle_middle.3 :  

[-1]  2 <= P!1
[-2]  0 < i!2`1
[-3]  i!2`1 < P!1 - 1
  |-------
{1}   cons?[Nonce](i!3`1)
[2]   P!1 = 2
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!2`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!2`1},
                  {x: list[Identity] | length(x) = i!2`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!2`1}]):
        (rec(u!1, nth(i`3, i!2`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (signal(running(i!2`1, append(i`3, cons(u!1, i`4)), car(i`1))) >>
            (trans(u!1, car(i`4),
                   E(public(car(i`4)),
                     conc(nlist(append(i`1, (: i!2`2 :))),
                          ilist(append(i`3, cons(u!1, cdr(i`4)))))))
              >>
              (rec(u!1, nth(i`3, i!2`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(i`3, i`4)),
                          nlist(cons(i!2`2, i`2)))))
                >>
                ((LastMessage(P!1, i!2`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.3 :  

[-1]  2 <= P!1
[-2]  0 < i!2`1
[-3]  i!2`1 < P!1 - 1
  |-------
[1]   cons?[Nonce](i!3`1)
[2]   P!1 = 2

Rerunning step: (nonemptylist "i!3`1")
Relating existence of a tail to a list's length,

This completes the proof of restrictmiddle_middle.3.

restrictmiddle_middle.4 :  

[-1]  2 <= P!1
[-2]  0 < i!2`1
[-3]  i!2`1 < P!1 - 1
  |-------
{1}   i!2`1 - 1 < length[Identity](i!3`3)
[2]   P!1 = 2
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!2`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!2`1},
                  {x: list[Identity] | length(x) = i!2`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!2`1}]):
        (rec(u!1, nth(i`3, i!2`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (signal(running(i!2`1, append(i`3, cons(u!1, i`4)), car(i`1))) >>
            (trans(u!1, car(i`4),
                   E(public(car(i`4)),
                     conc(nlist(append(i`1, (: i!2`2 :))),
                          ilist(append(i`3, cons(u!1, cdr(i`4)))))))
              >>
              (rec(u!1, nth(i`3, i!2`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(i`3, i`4)),
                          nlist(cons(i!2`2, i`2)))))
                >>
                ((LastMessage(P!1, i!2`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.4 :  

[-1]  2 <= P!1
[-2]  0 < i!2`1
[-3]  i!2`1 < P!1 - 1
  |-------
[1]   i!2`1 - 1 < length[Identity](i!3`3)

Rerunning step: (nonemptylist "i!3`3")
Relating existence of a tail to a list's length,

This completes the proof of restrictmiddle_middle.4.

restrictmiddle_middle.5 :  

[-1]  2 <= P!1
[-2]  0 < i!2`1
[-3]  i!2`1 < P!1 - 1
  |-------
{1}   FORALL (nl1: {x: list[Nonce] | length[Nonce](x) = i!2`1},
              nl2: {x: list[Nonce] | length[Nonce](x) = P!1 - 1 - i!2`1},
              il1: {x: list[Identity] | length[Identity](x) = i!2`1},
              il2:
                {x: list[Identity] |
                   length[Identity](x) = P!1 - 1 - i!2`1}):
        cons?[Identity](il2)
[2]   P!1 = 2
[3]   Choice! (nl1: {x: list[Nonce] | length(x) = i!2`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!2`1},
               il1: {x: list[Identity] | length(x) = i!2`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!2`1}):
        (rec(u!1, nth(il1, i!2`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (signal(running(i!2`1, append(il1, cons(u!1, il2)), car(nl1))) >>
            (trans(u!1, car(il2),
                   E(public(car(il2)),
                     conc(nlist(append(nl1, (: i!2`2 :))),
                          ilist(append(il1, cons(u!1, cdr(il2)))))))
              >>
              (rec(u!1, nth(il1, i!2`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(il1, il2)),
                          nlist(cons(i!2`2, nl2)))))
                >>
                ((LastMessage(P!1, i!2`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.5 :  

[-1]  2 <= P!1
[-2]  0 < i!2`1
[-3]  i!2`1 < P!1 - 1
  |-------
[1]   FORALL (nl1: {x: list[Nonce] | length[Nonce](x) = i!2`1},
              nl2: {x: list[Nonce] | length[Nonce](x) = P!1 - 1 - i!2`1},
              il1: {x: list[Identity] | length[Identity](x) = i!2`1},
              il2:
                {x: list[Identity] |
                   length[Identity](x) = P!1 - 1 - i!2`1}):
        cons?[Identity](il2)

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictmiddle_middle.5 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl1!1)
{-2}  length(nl1!1) = i!2`1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
{-4}  length(nl2!1) = P!1 - 1 - i!2`1
{-5}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (il1!1)
{-6}  length(il1!1) = i!2`1
{-7}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (il2!1)
{-8}  length(il2!1) = P!1 - 1 - i!2`1
[-9]  2 <= P!1
[-10] 0 < i!2`1
[-11] i!2`1 < P!1 - 1
  |-------
{1}   cons?[Identity](il2!1)

Rerunning step: (delete -1 -2 -3 -4 -5 -6 -7)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.5 :  

[-1]  length(il2!1) = P!1 - 1 - i!2`1
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   cons?[Identity](il2!1)

Rerunning step: (nonemptylist "il2!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictmiddle_middle.5.

restrictmiddle_middle.6 :  

[-1]  2 <= P!1
[-2]  0 < i!2`1
[-3]  i!2`1 < P!1 - 1
  |-------
{1}   FORALL (nl1: {x: list[Nonce] | length[Nonce](x) = i!2`1},
              nl2: {x: list[Nonce] | length[Nonce](x) = P!1 - 1 - i!2`1},
              il1: {x: list[Identity] | length[Identity](x) = i!2`1},
              il2:
                {x: list[Identity] |
                   length[Identity](x) = P!1 - 1 - i!2`1}):
        cons?[Nonce](nl1)
[2]   P!1 = 2
[3]   Choice! (nl1: {x: list[Nonce] | length(x) = i!2`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!2`1},
               il1: {x: list[Identity] | length(x) = i!2`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!2`1}):
        (rec(u!1, nth(il1, i!2`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (signal(running(i!2`1, append(il1, cons(u!1, il2)), car(nl1))) >>
            (trans(u!1, car(il2),
                   E(public(car(il2)),
                     conc(nlist(append(nl1, (: i!2`2 :))),
                          ilist(append(il1, cons(u!1, cdr(il2)))))))
              >>
              (rec(u!1, nth(il1, i!2`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(il1, il2)),
                          nlist(cons(i!2`2, nl2)))))
                >>
                ((LastMessage(P!1, i!2`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.6 :  

[-1]  2 <= P!1
[-2]  0 < i!2`1
[-3]  i!2`1 < P!1 - 1
  |-------
[1]   FORALL (nl1: {x: list[Nonce] | length[Nonce](x) = i!2`1},
              nl2: {x: list[Nonce] | length[Nonce](x) = P!1 - 1 - i!2`1},
              il1: {x: list[Identity] | length[Identity](x) = i!2`1},
              il2:
                {x: list[Identity] |
                   length[Identity](x) = P!1 - 1 - i!2`1}):
        cons?[Nonce](nl1)

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictmiddle_middle.6 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl1!1)
{-2}  length(nl1!1) = i!2`1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl2!1)
{-4}  length(nl2!1) = P!1 - 1 - i!2`1
{-5}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (il1!1)
{-6}  length(il1!1) = i!2`1
{-7}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (il2!1)
{-8}  length(il2!1) = P!1 - 1 - i!2`1
[-9]  2 <= P!1
[-10] 0 < i!2`1
[-11] i!2`1 < P!1 - 1
  |-------
{1}   cons?[Nonce](nl1!1)

Rerunning step: (delete -1 -3 -4 -5 -6 -7 -8)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.6 :  

[-1]  length(nl1!1) = i!2`1
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   cons?[Nonce](nl1!1)

Rerunning step: (nonemptylist "nl1!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictmiddle_middle.6.

Q.E.D.


Run time  = 12.65 secs.
Real time = 14.36 secs.
nil
pvs(47): 
Installing rewrite rule sets.singleton_rew (all instances)
restrictmiddle_last :  

  |-------
{1}   FORALL (P: nat_from_2, i: nat_1_to(p), u: Identity):
        ((Interleave! (nnP: Nonces(P, u, P - 1)): UROLE_LAST(P, u, nnP)) #
          R_middle(i))
         |> RankUser(rho_middle(i))

Rerunning step: (auto-rewrite-theory "sets")
Rewriting relative to the theory: sets,
this simplifies to: 
restrictmiddle_last :  

  |-------
[1]   FORALL (P: nat_from_2, i: nat_1_to(p), u: Identity):
        ((Interleave! (nnP: Nonces(P, u, P - 1)): UROLE_LAST(P, u, nnP)) #
          R_middle(i))
         |> RankUser(rho_middle(i))

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictmiddle_last :  

  |-------
{1}   ((Interleave! (nnP: Nonces(P!1, u!1, P!1 - 1)):
          UROLE_LAST(P!1, u!1, nnP))
        # R_middle(i!1))
       |> RankUser(rho_middle(i!1))

Rerunning step: (expand "RankUser")
Expanding the definition of RankUser,
this simplifies to: 
restrictmiddle_last :  

  |-------
{1}   ((Interleave! (nnP: Nonces(P!1, u!1, P!1 - 1)):
          UROLE_LAST(P!1, u!1, nnP))
        # R_middle(i!1))
       |>
       LAMBDA (tr: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(tr)
          =>
          every(LAMBDA (e: event):
                  complement(rec?)(e) => rho_middle(i!1)(msg(e)))
               (tr)

Rerunning step: (interleaving2)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
Applying interleaving rule,
this simplifies to: 
restrictmiddle_last :  

  |-------
{1}   UROLE_LAST(P!1, u!1, i!2) # R_middle(i!1) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (expand "UROLE_LAST")
Expanding the definition of UROLE_LAST,
this simplifies to: 
restrictmiddle_last :  

  |-------
{1}   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (signal(running(P!1 - 1, append(il, (: u!1 :)), car(nl))) >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(nlist(append(nl, (: i!2 :))),
                          ilist(append(cdr(il), (: u!1 :))))))
              >>
              (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
                >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (typepred "P!1")
Adding type constraints for  P!1,
this simplifies to: 
restrictmiddle_last :  

{-1}  2 <= P!1
  |-------
[1]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (signal(running(P!1 - 1, append(il, (: u!1 :)), car(nl))) >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(nlist(append(nl, (: i!2 :))),
                          ilist(append(cdr(il), (: u!1 :))))))
              >>
              (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
                >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (choice3)
Applying choice rule,
this yields  8 subgoals: 
restrictmiddle_last.1 :  

[-1]  2 <= P!1
  |-------
{1}   (rec(u!1, nth(i!3`2, P!1 - 2),
           E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
        >>
        (signal(running(P!1 - 1, append(i!3`2, (: u!1 :)), car(i!3`1))) >>
          (trans(u!1, car(i!3`2),
                 E(public(car(i!3`2)),
                   conc(nlist(append(i!3`1, (: i!2 :))),
                        ilist(append(cdr(i!3`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i!3`2, P!1 - 2),
                 E(public(u!1), nlist((: i!2 :))))
              >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictmiddle_last.1 :  

{-1}  rho_middle(i!1)(E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
{1}   ((signal(running(P!1 - 1, append(i!3`2, (: u!1 :)), car(i!3`1))) >>
         (trans(u!1, car(i!3`2),
                E(public(car(i!3`2)),
                  conc(nlist(append(i!3`1, (: i!2 :))),
                       ilist(append(cdr(i!3`2), (: u!1 :))))))
           >>
           (rec(u!1, nth(i!3`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
             >> Stop[event])))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (rec(u!1, nth(i!3`2, P!1 - 2),
                   E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2)))))
{3}   rec(u!1, nth(i!3`2, P!1 - 2),
          E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
       >>
       ((signal(running(P!1 - 1, append(i!3`2, (: u!1 :)), car(i!3`1))) >>
          (trans(u!1, car(i!3`2),
                 E(public(car(i!3`2)),
                   conc(nlist(append(i!3`1, (: i!2 :))),
                        ilist(append(cdr(i!3`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i!3`2, P!1 - 2),
                 E(public(u!1), nlist((: i!2 :))))
              >> Stop[event])))
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1 :  

[-1]  rho_middle(i!1)(E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
[1]   ((signal(running(P!1 - 1, append(i!3`2, (: u!1 :)), car(i!3`1))) >>
         (trans(u!1, car(i!3`2),
                E(public(car(i!3`2)),
                  conc(nlist(append(i!3`1, (: i!2 :))),
                       ilist(append(cdr(i!3`2), (: u!1 :))))))
           >>
           (rec(u!1, nth(i!3`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
             >> Stop[event])))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictmiddle_last.1.1 :  

[-1]  rho_middle(i!1)(E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
{1}   rho_middle(i!1)
                (running(P!1 - 1, append(i!3`2, (: u!1 :)), car(i!3`1)))
{2}   R_middle(i!1)
              (signal(running(P!1 - 1, append(i!3`2, (: u!1 :)),
                              car(i!3`1))))
{3}   signal(running(P!1 - 1, append(i!3`2, (: u!1 :)), car(i!3`1))) >>
       ((trans(u!1, car(i!3`2),
               E(public(car(i!3`2)),
                 conc(nlist(append(i!3`1, (: i!2 :))),
                      ilist(append(cdr(i!3`2), (: u!1 :))))))
          >>
          (rec(u!1, nth(i!3`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
            >> Stop[event]))
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.1 :  

  |-------
[1]   rho_middle(i!1)
                (running(P!1 - 1, append(i!3`2, (: u!1 :)), car(i!3`1)))

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
restrictmiddle_last.1.1 :  

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictmiddle_last.1.1.

restrictmiddle_last.1.2 :  

[-1]  rho_middle(i!1)(E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
{1}   ((trans(u!1, car(i!3`2),
              E(public(car(i!3`2)),
                conc(nlist(append(i!3`1, (: i!2 :))),
                     ilist(append(cdr(i!3`2), (: u!1 :))))))
         >>
         (rec(u!1, nth(i!3`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
           >> Stop[event]))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (signal(running(P!1 - 1, append(i!3`2, (: u!1 :)),
                              car(i!3`1))))
{3}   signal(running(P!1 - 1, append(i!3`2, (: u!1 :)), car(i!3`1))) >>
       ((trans(u!1, car(i!3`2),
               E(public(car(i!3`2)),
                 conc(nlist(append(i!3`1, (: i!2 :))),
                      ilist(append(cdr(i!3`2), (: u!1 :))))))
          >>
          (rec(u!1, nth(i!3`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
            >> Stop[event]))
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.2 :  

[-1]  rho_middle(i!1)(E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
[1]   ((trans(u!1, car(i!3`2),
              E(public(car(i!3`2)),
                conc(nlist(append(i!3`1, (: i!2 :))),
                     ilist(append(cdr(i!3`2), (: u!1 :))))))
         >>
         (rec(u!1, nth(i!3`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
           >> Stop[event]))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictmiddle_last.1.2.1 :  

[-1]  rho_middle(i!1)(E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
{1}   rho_middle(i!1)
                (E(public(car(i!3`2)),
                   conc(nlist(append(i!3`1, (: i!2 :))),
                        ilist(append(cdr(i!3`2), (: u!1 :))))))
{2}   R_middle(i!1)
              (trans(u!1, car(i!3`2),
                     E(public(car(i!3`2)),
                       conc(nlist(append(i!3`1, (: i!2 :))),
                            ilist(append(cdr(i!3`2), (: u!1 :)))))))
{3}   trans(u!1, car(i!3`2),
            E(public(car(i!3`2)),
              conc(nlist(append(i!3`1, (: i!2 :))),
                   ilist(append(cdr(i!3`2), (: u!1 :))))))
       >>
       ((rec(u!1, nth(i!3`2, P!1 - 2), E(public(u!1), nlist((: i!2 :)))) >>
          Stop[event])
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.2.1 :  

[-1]  rho_middle(i!1)(E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (E(public(car(i!3`2)),
                   conc(nlist(append(i!3`1, (: i!2 :))),
                        ilist(append(cdr(i!3`2), (: u!1 :))))))

Rerunning step: (comment "first, let's establish that i!2 /= n_init")
Adding comment: first, let's establish that i!2 /= n_init
this simplifies to: 
restrictmiddle_last.1.2.1 : 
;;; first, let's establish that i!2 /= n_init

[-1]  rho_middle(i!1)(E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (E(public(car(i!3`2)),
                   conc(nlist(append(i!3`1, (: i!2 :))),
                        ilist(append(cdr(i!3`2), (: u!1 :))))))

Rerunning step: (case "i!2 /= n_init")
Case splitting on 
   i!2 /= n_init, 
this yields  2 subgoals: 
restrictmiddle_last.1.2.1.1 : 
;;; first, let's establish that i!2 /= n_init

{-1}  i!2 /= n_init
[-2]  rho_middle(i!1)(E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
[-3]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (E(public(car(i!3`2)),
                   conc(nlist(append(i!3`1, (: i!2 :))),
                        ilist(append(cdr(i!3`2), (: u!1 :))))))

Rerunning step: (expand "rho_middle" -2)
Expanding the definition of rho_middle,
this simplifies to: 
restrictmiddle_last.1.2.1.1 : 
;;; first, let's establish that i!2 /= n_init

[-1]  i!2 /= n_init
{-2}  CASES E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2)))
        OF nonce(z): z /= n_init,
           nlist(z): NOT elt(z, n_init),
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i)),
           conc(z1, z2): rho_middle(i!1)(z1) AND rho_middle(i!1)(z2),
           commit(z1, z2, z3): z1 /= 0 OR z2 /= hu_list OR z3 /= n_init,
           code(z1, z2):
             rho_middle(i!1)(z2) OR
              EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
                z1 = public(hu(j)) AND
                 EXISTS (l: {x: list[Nonce] | length(x) = j - 1}):
                   z2 =
                    conc(nlist(cons(n_init, l)), ilist(remove(hu_list, j)))
        ELSE TRUE
        ENDCASES
[-3]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (E(public(car(i!3`2)),
                   conc(nlist(append(i!3`1, (: i!2 :))),
                        ilist(append(cdr(i!3`2), (: u!1 :))))))

Rerunning step: (grind :exclude ("rho_middle" "remove"))
/= rewrites i!2 /= n_init
  to NOT (i!2 = n_init)
E rewrites 
  E(public(car(i!3`2)),
    conc(nlist(append(i!3`1, (: i!2 :))),
         ilist(append(cdr(i!3`2), (: u!1 :)))))
  to code(public(car(i!3`2)),
           conc(nlist(append(i!3`1, (: i!2 :))),
                ilist(append(cdr(i!3`2), (: u!1 :)))))
E rewrites E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2)))
  to code(public(u!1), conc(nlist(i!3`1), ilist(i!3`2)))
Trying repeated skolemization, instantiation, and if-lifting,
this yields  2 subgoals: 
restrictmiddle_last.1.2.1.1.1 : 
;;; first, let's establish that i!2 /= n_init

{-1}  rho_middle(i!1)(conc(nlist(i!3`1), ilist(i!3`2)))
[-2]  2 <= P!1
  |-------
{1}   (i!2 = n_init)
{2}   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(nlist(append(i!3`1, (: i!2 :))),
                           ilist(append(cdr(i!3`2), (: u!1 :))))))

Rerunning step: (comment "due to -1 (and i!2 /= n_init), 2 will be satisfied")
Adding comment: due to -1 (and i!2 /= n_init), 2 will be satisfied
this simplifies to: 
restrictmiddle_last.1.2.1.1.1 : 
;;; due to -1 (and i!2 /= n_init), 2 will be satisfied

[-1]  rho_middle(i!1)(conc(nlist(i!3`1), ilist(i!3`2)))
[-2]  2 <= P!1
  |-------
[1]   (i!2 = n_init)
[2]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(nlist(append(i!3`1, (: i!2 :))),
                           ilist(append(cdr(i!3`2), (: u!1 :))))))

Rerunning step: (lemma "listprops[Nonce].elt_append3"
                 ("l1" "i!3`1" "l2" "(: i!2 :)" "t" "n_init"))
Applying listprops[Nonce].elt_append3 where 
  l1 gets i!3`1,
  l2 gets (: i!2 :),
  t gets n_init,
this simplifies to: 
restrictmiddle_last.1.2.1.1.1 : 
;;; due to -1 (and i!2 /= n_init), 2 will be satisfied

{-1}  elt(append(i!3`1, (: i!2 :)), n_init) IMPLIES
       elt(i!3`1, n_init) OR elt((: i!2 :), n_init)
[-2]  rho_middle(i!1)(conc(nlist(i!3`1), ilist(i!3`2)))
[-3]  2 <= P!1
  |-------
[1]   (i!2 = n_init)
[2]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(nlist(append(i!3`1, (: i!2 :))),
                           ilist(append(cdr(i!3`2), (: u!1 :))))))

Rerunning step: (lemma "listprops[Nonce].elt_singleton"
                 ("t1" "i!2" "t2" "n_init"))
Applying listprops[Nonce].elt_singleton where 
  t1 gets i!2,
  t2 gets n_init,
this simplifies to: 
restrictmiddle_last.1.2.1.1.1 : 
;;; due to -1 (and i!2 /= n_init), 2 will be satisfied

{-1}  elt((: i!2 :), n_init) IFF i!2 = n_init
[-2]  elt(append(i!3`1, (: i!2 :)), n_init) IMPLIES
       elt(i!3`1, n_init) OR elt((: i!2 :), n_init)
[-3]  rho_middle(i!1)(conc(nlist(i!3`1), ilist(i!3`2)))
[-4]  2 <= P!1
  |-------
[1]   (i!2 = n_init)
[2]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(nlist(append(i!3`1, (: i!2 :))),
                           ilist(append(cdr(i!3`2), (: u!1 :))))))

Rerunning step: (grind :exclude "elt")
rho_middle rewrites rho_middle(i!1)(nlist(append(i!3`1, (: i!2 :))))
  to NOT elt(append(i!3`1, (: i!2 :)), n_init)
rho_middle rewrites rho_middle(i!1)(ilist(append(cdr(i!3`2), (: u!1 :))))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)
            (conc(nlist(append(i!3`1, (: i!2 :))),
                  ilist(append(cdr(i!3`2), (: u!1 :)))))
  to NOT elt(append(i!3`1, (: i!2 :)), n_init)
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites 
  rho_middle(i!1)
            (code(public(car(i!3`2)),
                  conc(nlist(append(i!3`1, (: i!2 :))),
                       ilist(append(cdr(i!3`2), (: u!1 :))))))
  to NOT elt(append(i!3`1, (: i!2 :)), n_init) OR
       EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
         public(car(i!3`2)) = public(hu(j)) AND
          EXISTS (l: {x: list[Nonce] | length(x) = j - 1}):
            conc(nlist(append(i!3`1, (: i!2 :))),
                 ilist(append(cdr(i!3`2), (: u!1 :))))
             =
             conc(nlist(cons(n_init, l)),
                  ilist(cons(car(hu_list), remove(cdr(hu_list), j - 1))))
rho_middle rewrites rho_middle(i!1)(nlist(i!3`1))
  to FALSE
rho_middle rewrites rho_middle(i!1)(ilist(i!3`2))
  to TRUE
rho_middle rewrites rho_middle(i!1)(conc(nlist(i!3`1), ilist(i!3`2)))
  to FALSE
rho_middle rewrites rho_middle(i!1)(nlist(append(i!3`1, (: i!2 :))))
  to TRUE
rho_middle rewrites rho_middle(i!1)(ilist(append(cdr(i!3`2), (: u!1 :))))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)
            (conc(nlist(append(i!3`1, (: i!2 :))),
                  ilist(append(cdr(i!3`2), (: u!1 :)))))
  to TRUE
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites 
  rho_middle(i!1)
            (code(public(car(i!3`2)),
                  conc(nlist(append(i!3`1, (: i!2 :))),
                       ilist(append(cdr(i!3`2), (: u!1 :))))))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_last.1.2.1.1.1.

restrictmiddle_last.1.2.1.1.2 : 
;;; first, let's establish that i!2 /= n_init

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
{-2}  length(l!1) = j!1 - 1
{-3}  0 < j!1
{-4}  j!1 <= i!1
{-5}  public(u!1) = public(hu(j!1))
{-6}  conc(nlist(i!3`1), ilist(i!3`2)) =
       conc(nlist(cons(n_init, l!1)), ilist(remove(hu_list, j!1)))
[-7]  2 <= P!1
  |-------
{1}   (i!2 = n_init)
{2}   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(nlist(append(i!3`1, (: i!2 :))),
                           ilist(append(cdr(i!3`2), (: u!1 :))))))

Rerunning step: (comment "in this case, the received message is in rho because it contains n_init and is 'escaped' in rho ")
Adding comment: in this case, the received message is in rho because it contains n_init and is 'escaped' in rho 
this simplifies to: 
restrictmiddle_last.1.2.1.1.2 : 
;;; in this case, the received message is in rho because it contains n_init and is 'escaped' in rho 

[-1]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
[-2]  length(l!1) = j!1 - 1
[-3]  0 < j!1
[-4]  j!1 <= i!1
[-5]  public(u!1) = public(hu(j!1))
[-6]  conc(nlist(i!3`1), ilist(i!3`2)) =
       conc(nlist(cons(n_init, l!1)), ilist(remove(hu_list, j!1)))
[-7]  2 <= P!1
  |-------
[1]   (i!2 = n_init)
[2]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(nlist(append(i!3`1, (: i!2 :))),
                           ilist(append(cdr(i!3`2), (: u!1 :))))))

Rerunning step: (comment "this cannot be the case for the last user (p-1), so there must be a contradiction in the assumptions")
Adding comment: this cannot be the case for the last user (p-1), so there must be a contradiction in the assumptions
this simplifies to: 
restrictmiddle_last.1.2.1.1.2 : 
;;; this cannot be the case for the last user (p-1), so there must be a contradiction in the assumptions

[-1]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
[-2]  length(l!1) = j!1 - 1
[-3]  0 < j!1
[-4]  j!1 <= i!1
[-5]  public(u!1) = public(hu(j!1))
[-6]  conc(nlist(i!3`1), ilist(i!3`2)) =
       conc(nlist(cons(n_init, l!1)), ilist(remove(hu_list, j!1)))
[-7]  2 <= P!1
  |-------
[1]   (i!2 = n_init)
[2]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(nlist(append(i!3`1, (: i!2 :))),
                           ilist(append(cdr(i!3`2), (: u!1 :))))))

Rerunning step: (typepred "i!3`1" "i!3`2" "hu_list" "i!1")
Adding type constraints for  i!3`1, i!3`2, hu_list, i!1,
this simplifies to: 
restrictmiddle_last.1.2.1.1.2 : 
;;; this cannot be the case for the last user (p-1), so there must be a contradiction in the assumptions

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`1)
{-2}  length(i!3`1) = P!1 - 1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`2)
{-4}  length(i!3`2) = P!1 - 1
{-5}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-6}  (length(hu_list) = p)
{-7}  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
{-8}  0 < i!1
{-9}  i!1 < p - 1
[-10] every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
[-11] length(l!1) = j!1 - 1
[-12] 0 < j!1
[-13] j!1 <= i!1
[-14] public(u!1) = public(hu(j!1))
[-15] conc(nlist(i!3`1), ilist(i!3`2)) =
       conc(nlist(cons(n_init, l!1)), ilist(remove(hu_list, j!1)))
[-16] 2 <= P!1
  |-------
[1]   (i!2 = n_init)
[2]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(nlist(append(i!3`1, (: i!2 :))),
                           ilist(append(cdr(i!3`2), (: u!1 :))))))

Rerunning step: (delete -1 -3 -5 -7 -8 -10 -12 -14 -16 +)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.2.1.1.2 : 
;;; this cannot be the case for the last user (p-1), so there must be a contradiction in the assumptions

[-1]  length(i!3`1) = P!1 - 1
[-2]  length(i!3`2) = P!1 - 1
[-3]  (length(hu_list) = p)
[-4]  i!1 < p - 1
[-5]  length(l!1) = j!1 - 1
[-6]  j!1 <= i!1
[-7]  conc(nlist(i!3`1), ilist(i!3`2)) =
       conc(nlist(cons(n_init, l!1)), ilist(remove(hu_list, j!1)))
  |-------

Rerunning step: (comment "the contradiction lies in -6")
Adding comment: the contradiction lies in -6
this simplifies to: 
restrictmiddle_last.1.2.1.1.2 : 
;;; the contradiction lies in -6

[-1]  length(i!3`1) = P!1 - 1
[-2]  length(i!3`2) = P!1 - 1
[-3]  (length(hu_list) = p)
[-4]  i!1 < p - 1
[-5]  length(l!1) = j!1 - 1
[-6]  j!1 <= i!1
[-7]  conc(nlist(i!3`1), ilist(i!3`2)) =
       conc(nlist(cons(n_init, l!1)), ilist(remove(hu_list, j!1)))
  |-------

Rerunning step: (case "P!1=p AND j!1=P!1-1")
Case splitting on 
   P!1 = p AND j!1 = P!1 - 1, 
this yields  2 subgoals: 
restrictmiddle_last.1.2.1.1.2.1 : 
;;; the contradiction lies in -6

{-1}  P!1 = p AND j!1 = P!1 - 1
[-2]  length(i!3`1) = P!1 - 1
[-3]  length(i!3`2) = P!1 - 1
[-4]  (length(hu_list) = p)
[-5]  i!1 < p - 1
[-6]  length(l!1) = j!1 - 1
[-7]  j!1 <= i!1
[-8]  conc(nlist(i!3`1), ilist(i!3`2)) =
       conc(nlist(cons(n_init, l!1)), ilist(remove(hu_list, j!1)))
  |-------

Rerunning step: (delete -2 -3 -4 -6 -8)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.2.1.1.2.1 : 
;;; the contradiction lies in -6

[-1]  P!1 = p AND j!1 = P!1 - 1
[-2]  i!1 < p - 1
[-3]  j!1 <= i!1
  |-------

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_last.1.2.1.1.2.1.

restrictmiddle_last.1.2.1.1.2.2 : 
;;; the contradiction lies in -6

[-1]  length(i!3`1) = P!1 - 1
[-2]  length(i!3`2) = P!1 - 1
[-3]  (length(hu_list) = p)
[-4]  i!1 < p - 1
[-5]  length(l!1) = j!1 - 1
[-6]  j!1 <= i!1
[-7]  conc(nlist(i!3`1), ilist(i!3`2)) =
       conc(nlist(cons(n_init, l!1)), ilist(remove(hu_list, j!1)))
  |-------
{1}   P!1 = p AND j!1 = P!1 - 1

Rerunning step: (decompose-equality -7)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_last.1.2.1.1.2.2 : 
;;; the contradiction lies in -6

{-1}  nlist(i!3`1) = nlist(cons(n_init, l!1))
{-2}  ilist(i!3`2) = ilist(remove(hu_list, j!1))
[-3]  length(i!3`1) = P!1 - 1
[-4]  length(i!3`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  i!1 < p - 1
[-7]  length(l!1) = j!1 - 1
[-8]  j!1 <= i!1
  |-------
[1]   P!1 = p AND j!1 = P!1 - 1

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_last.1.2.1.1.2.2 : 
;;; the contradiction lies in -6

{-1}  i!3`1 = cons(n_init, l!1)
[-2]  ilist(i!3`2) = ilist(remove(hu_list, j!1))
[-3]  length(i!3`1) = P!1 - 1
[-4]  length(i!3`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  i!1 < p - 1
[-7]  length(l!1) = j!1 - 1
[-8]  j!1 <= i!1
  |-------
[1]   P!1 = p AND j!1 = P!1 - 1

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_last.1.2.1.1.2.2 : 
;;; the contradiction lies in -6

{-1}  i!3`2 = remove(hu_list, j!1)
[-2]  i!3`1 = cons(n_init, l!1)
[-3]  length(i!3`1) = P!1 - 1
[-4]  length(i!3`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  i!1 < p - 1
[-7]  length(l!1) = j!1 - 1
[-8]  j!1 <= i!1
  |-------
[1]   P!1 = p AND j!1 = P!1 - 1

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
restrictmiddle_last.1.2.1.1.2.2.1 : 
;;; the contradiction lies in -6

[-1]  i!3`2 = remove(hu_list, j!1)
[-2]  i!3`1 = cons(n_init, l!1)
[-3]  length(i!3`1) = P!1 - 1
[-4]  length(i!3`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  i!1 < p - 1
[-7]  length(l!1) = j!1 - 1
[-8]  j!1 <= i!1
  |-------
{1}   P!1 = p

Rerunning step: (delete -2 -3 -6 -7 -8)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.2.1.1.2.2.1 : 
;;; the contradiction lies in -6

[-1]  i!3`2 = remove(hu_list, j!1)
[-2]  length(i!3`2) = P!1 - 1
[-3]  (length(hu_list) = p)
  |-------
[1]   P!1 = p

Rerunning step: (replace -1 -2)
Replacing using formula -1,
this simplifies to: 
restrictmiddle_last.1.2.1.1.2.2.1 : 
;;; the contradiction lies in -6

[-1]  i!3`2 = remove(hu_list, j!1)
{-2}  length(remove(hu_list, j!1)) = P!1 - 1
[-3]  (length(hu_list) = p)
  |-------
[1]   P!1 = p

Rerunning step: (rewrite "length_remove" -2 ("c" "hu_list" "i" "j!1")
                 :dir rl)
Found matching substitution:
c: (cons?[T]) gets hu_list,
i: below[length(c)] gets j!1,
length rewrites length(hu_list)
  to 0
Rewriting using length_remove, matching in -2 where
  c gets hu_list,
  i gets j!1,
this simplifies to: 
restrictmiddle_last.1.2.1.1.2.2.1 : 
;;; the contradiction lies in -6

[-1]  i!3`2 = remove(hu_list, j!1)
{-2}  length[Identity](hu_list) - 1 = P!1 - 1
[-3]  (length(hu_list) = p)
  |-------
[1]   P!1 = p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_last.1.2.1.1.2.2.1.

restrictmiddle_last.1.2.1.1.2.2.2 : 
;;; the contradiction lies in -6

[-1]  i!3`2 = remove(hu_list, j!1)
[-2]  i!3`1 = cons(n_init, l!1)
[-3]  length(i!3`1) = P!1 - 1
[-4]  length(i!3`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  i!1 < p - 1
[-7]  length(l!1) = j!1 - 1
[-8]  j!1 <= i!1
  |-------
{1}   j!1 = P!1 - 1

Rerunning step: (delete -1 -4 -5 -6 -8)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.2.1.1.2.2.2 : 
;;; the contradiction lies in -6

[-1]  i!3`1 = cons(n_init, l!1)
[-2]  length(i!3`1) = P!1 - 1
[-3]  length(l!1) = j!1 - 1
  |-------
[1]   j!1 = P!1 - 1

Rerunning step: (replace -1 -2)
Replacing using formula -1,
this simplifies to: 
restrictmiddle_last.1.2.1.1.2.2.2 : 
;;; the contradiction lies in -6

[-1]  i!3`1 = cons(n_init, l!1)
{-2}  length(cons(n_init, l!1)) = P!1 - 1
[-3]  length(l!1) = j!1 - 1
  |-------
[1]   j!1 = P!1 - 1

Rerunning step: (expand "length" -2)
Expanding the definition of length,
this simplifies to: 
restrictmiddle_last.1.2.1.1.2.2.2 : 
;;; the contradiction lies in -6

[-1]  i!3`1 = cons(n_init, l!1)
{-2}  1 + length(l!1) = P!1 - 1
[-3]  length(l!1) = j!1 - 1
  |-------
[1]   j!1 = P!1 - 1

Rerunning step: (replace -3 -2)
Replacing using formula -3,
this simplifies to: 
restrictmiddle_last.1.2.1.1.2.2.2 : 
;;; the contradiction lies in -6

[-1]  i!3`1 = cons(n_init, l!1)
{-2}  1 + (j!1 - 1) = P!1 - 1
[-3]  length(l!1) = j!1 - 1
  |-------
[1]   j!1 = P!1 - 1

Rerunning step: (simplify -2)
Simplifying with decision procedures,
this simplifies to: 
restrictmiddle_last.1.2.1.1.2.2.2 : 
;;; the contradiction lies in -6

[-1]  i!3`1 = cons(n_init, l!1)
{-2}  j!1 = P!1 - 1
[-3]  length(l!1) = j!1 - 1
  |-------
[1]   j!1 = P!1 - 1

which is trivially true.

This completes the proof of restrictmiddle_last.1.2.1.1.2.2.2.


This completes the proof of restrictmiddle_last.1.2.1.1.2.2.


This completes the proof of restrictmiddle_last.1.2.1.1.2.


This completes the proof of restrictmiddle_last.1.2.1.1.

restrictmiddle_last.1.2.1.2 : 
;;; first, let's establish that i!2 /= n_init

[-1]  rho_middle(i!1)(E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
{1}   i!2 /= n_init
[2]   rho_middle(i!1)
                (E(public(car(i!3`2)),
                   conc(nlist(append(i!3`1, (: i!2 :))),
                        ilist(append(cdr(i!3`2), (: u!1 :))))))

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.2.1.2 : 
;;; first, let's establish that i!2 /= n_init

  |-------
[1]   i!2 /= n_init

Rerunning step: (typepred "i!2")
Adding type constraints for  i!2,
this simplifies to: 
restrictmiddle_last.1.2.1.2 : 
;;; first, let's establish that i!2 /= n_init

{-1}  IRpart(P!1, u!1, P!1 - 1)(i!2)
  |-------
[1]   i!2 /= n_init

Rerunning step: (lemma "n_prop" ("P" "P!1" "u" "u!1" "r" "P!1-1"))
Applying n_prop where 
  P gets P!1,
  u gets u!1,
  r gets P!1 - 1,
this simplifies to: 
restrictmiddle_last.1.2.1.2 : 
;;; first, let's establish that i!2 /= n_init

{-1}  (P!1 /= p OR P!1 - 1 /= 0) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce]
               (P!1, u!1, P!1 - 1)(n_init)
[-2]  IRpart(P!1, u!1, P!1 - 1)(i!2)
  |-------
[1]   i!2 /= n_init

Rerunning step: (grind)
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
/= rewrites i!2 /= n_init
  to TRUE
/= rewrites P!1 /= p
  to NOT (P!1 = p)
/= rewrites P!1 - 1 /= 0
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_last.1.2.1.2.


This completes the proof of restrictmiddle_last.1.2.1.

restrictmiddle_last.1.2.2 :  

[-1]  rho_middle(i!1)(E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
{1}   ((rec(u!1, nth(i!3`2, P!1 - 2), E(public(u!1), nlist((: i!2 :)))) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (trans(u!1, car(i!3`2),
                     E(public(car(i!3`2)),
                       conc(nlist(append(i!3`1, (: i!2 :))),
                            ilist(append(cdr(i!3`2), (: u!1 :)))))))
{3}   trans(u!1, car(i!3`2),
            E(public(car(i!3`2)),
              conc(nlist(append(i!3`1, (: i!2 :))),
                   ilist(append(cdr(i!3`2), (: u!1 :))))))
       >>
       ((rec(u!1, nth(i!3`2, P!1 - 2), E(public(u!1), nlist((: i!2 :)))) >>
          Stop[event])
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.2.2 :  

[-1]  rho_middle(i!1)(E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
[1]   ((rec(u!1, nth(i!3`2, P!1 - 2), E(public(u!1), nlist((: i!2 :)))) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictmiddle_last.1.2.2 :  

{-1}  rho_middle(i!1)(E(public(u!1), nlist((: i!2 :))))
[-2]  rho_middle(i!1)(E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
[-3]  2 <= P!1
  |-------
{1}   (Stop[event] # R_middle(i!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (rec(u!1, nth(i!3`2, P!1 - 2),
                   E(public(u!1), nlist((: i!2 :)))))
{3}   rec(u!1, nth(i!3`2, P!1 - 2), E(public(u!1), nlist((: i!2 :)))) >>
       (Stop[event] # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.2.2 :  

[-1]  rho_middle(i!1)(E(public(u!1), nlist((: i!2 :))))
[-2]  rho_middle(i!1)(E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
[-3]  2 <= P!1
  |-------
[1]   (Stop[event] # R_middle(i!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictmiddle_last.1.2.2.


This completes the proof of restrictmiddle_last.1.2.


This completes the proof of restrictmiddle_last.1.

restrictmiddle_last.2 :  

[-1]  2 <= P!1
  |-------
{1}   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!2 :))
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (signal(running(P!1 - 1, append(i`2, (: u!1 :)), car(i`1))) >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(nlist(append(i`1, (: i!2 :))),
                          ilist(append(cdr(i`2), (: u!1 :))))))
              >>
              (rec(u!1, nth(i`2, P!1 - 2),
                   E(public(u!1), nlist((: i!2 :))))
                >> Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.2 :  

  |-------
[1]   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!2 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!2 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_last.2.

restrictmiddle_last.3 :  

[-1]  2 <= P!1
  |-------
{1}   cons?[Identity](i!3`2)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (signal(running(P!1 - 1, append(i`2, (: u!1 :)), car(i`1))) >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(nlist(append(i`1, (: i!2 :))),
                          ilist(append(cdr(i`2), (: u!1 :))))))
              >>
              (rec(u!1, nth(i`2, P!1 - 2),
                   E(public(u!1), nlist((: i!2 :))))
                >> Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.3 :  

  |-------
[1]   cons?[Identity](i!3`2)

Rerunning step: (nonemptylist "i!3`2")
Relating existence of a tail to a list's length,

This completes the proof of restrictmiddle_last.3.

restrictmiddle_last.4 :  

[-1]  2 <= P!1
  |-------
{1}   cons?[Nonce](i!3`1)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (signal(running(P!1 - 1, append(i`2, (: u!1 :)), car(i`1))) >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(nlist(append(i`1, (: i!2 :))),
                          ilist(append(cdr(i`2), (: u!1 :))))))
              >>
              (rec(u!1, nth(i`2, P!1 - 2),
                   E(public(u!1), nlist((: i!2 :))))
                >> Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.4 :  

  |-------
[1]   cons?[Nonce](i!3`1)

Rerunning step: (nonemptylist "i!3`1")
Relating existence of a tail to a list's length,

This completes the proof of restrictmiddle_last.4.

restrictmiddle_last.5 :  

[-1]  2 <= P!1
  |-------
{1}   P!1 - 2 < length[Identity](i!3`2)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (signal(running(P!1 - 1, append(i`2, (: u!1 :)), car(i`1))) >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(nlist(append(i`1, (: i!2 :))),
                          ilist(append(cdr(i`2), (: u!1 :))))))
              >>
              (rec(u!1, nth(i`2, P!1 - 2),
                   E(public(u!1), nlist((: i!2 :))))
                >> Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (typepred "i!3`2")
Adding type constraints for  i!3`2,
this simplifies to: 
restrictmiddle_last.5 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`2)
{-2}  length(i!3`2) = P!1 - 1
[-3]  2 <= P!1
  |-------
[1]   P!1 - 2 < length[Identity](i!3`2)
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (signal(running(P!1 - 1, append(i`2, (: u!1 :)), car(i`1))) >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(nlist(append(i`1, (: i!2 :))),
                          ilist(append(cdr(i`2), (: u!1 :))))))
              >>
              (rec(u!1, nth(i`2, P!1 - 2),
                   E(public(u!1), nlist((: i!2 :))))
                >> Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -3 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.5 :  

[-1]  length(i!3`2) = P!1 - 1
  |-------
[1]   P!1 - 2 < length[Identity](i!3`2)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_last.5.

restrictmiddle_last.6 :  

[-1]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!2 :))
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (signal(running(P!1 - 1, append(il, (: u!1 :)), car(nl))) >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(nlist(append(nl, (: i!2 :))),
                          ilist(append(cdr(il), (: u!1 :))))))
              >>
              (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
                >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -1 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.6 :  

  |-------
[1]   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!2 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!2 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_last.6.

restrictmiddle_last.7 :  

[-1]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        cons?[Identity](il)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (signal(running(P!1 - 1, append(il, (: u!1 :)), car(nl))) >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(nlist(append(nl, (: i!2 :))),
                          ilist(append(cdr(il), (: u!1 :))))))
              >>
              (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
                >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.7 :  

[-1]  2 <= P!1
  |-------
[1]   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        cons?[Identity](il)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictmiddle_last.7 :  

[-1]  2 <= P!1
  |-------
{1}   cons?[Identity](il!1)

Rerunning step: (nonemptylist "il!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictmiddle_last.7.

restrictmiddle_last.8 :  

[-1]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        cons?[Nonce](nl)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (signal(running(P!1 - 1, append(il, (: u!1 :)), car(nl))) >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(nlist(append(nl, (: i!2 :))),
                          ilist(append(cdr(il), (: u!1 :))))))
              >>
              (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
                >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.8 :  

  |-------
[1]   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        cons?[Nonce](nl)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictmiddle_last.8 :  

  |-------
{1}   cons?[Nonce](nl!1)

Rerunning step: (nonemptylist "nl!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictmiddle_last.8.

Q.E.D.


Run time  = 2.00 secs.
Real time = 2.93 secs.
nil
pvs(52): 
Installing rewrite rule sets.singleton_rew (all instances)
authentication_middle :  

  |-------
{1}   FORALL (i: nat_1_to(p)): network(USER) |> auth(T, R_middle(i))

Rerunning step: (auto-rewrite-theory "sets")
Rewriting relative to the theory: sets,
this simplifies to: 
authentication_middle :  

  |-------
[1]   FORALL (i: nat_1_to(p)): network(USER) |> auth(T, R_middle(i))

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle :  

  |-------
{1}   network(USER) |> auth(T, R_middle(i!1))

Rerunning step: (rewrite "authentication_by_rank" +
                 ("rho" "rho_middle(i!1)"))
Found matching substitution:
R: setof[event] gets R_middle(i!1),
T: setof[event] gets T,
users: [Identity -> process[event]] gets USER,
rho: setof[Message] gets rho_middle(i!1),
member rewrites member(x, INIT)
  to INIT(x)
member rewrites member(x, rho_middle(i!1))
  to rho_middle(i!1)(x)
subset? rewrites subset?(INIT, rho_middle(i!1))
  to FORALL (x: Message): INIT(x) => rho_middle(i!1)(x)
member rewrites member(x, S)
  to S(x)
member rewrites member(x, rho_middle(i!1))
  to rho_middle(i!1)(x)
subset? rewrites subset?(S, rho_middle(i!1))
  to FORALL (x: Message): S(x) => rho_middle(i!1)(x)
Rewriting using authentication_by_rank, matching in + where
  rho gets rho_middle(i!1),
this yields  4 subgoals: 
authentication_middle.1 :  

  |-------
{1}   FORALL (x: Message): INIT(x) => rho_middle(i!1)(x)
[2]   network(USER) |> auth(T, R_middle(i!1))

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_middle.1 :  

  |-------
[1]   FORALL (x: Message): INIT(x) => rho_middle(i!1)(x)

Rerunning step: (comment "intruder's initial knowledge is in rho")
Adding comment: intruder's initial knowledge is in rho
this simplifies to: 
authentication_middle.1 : 
;;; intruder's initial knowledge is in rho

  |-------
[1]   FORALL (x: Message): INIT(x) => rho_middle(i!1)(x)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.1 : 
;;; intruder's initial knowledge is in rho

  |-------
{1}   INIT(x!1) => rho_middle(i!1)(x!1)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_middle.1 : 
;;; intruder's initial knowledge is in rho

{-1}  INIT(x!1)
  |-------
{1}   rho_middle(i!1)(x!1)

Rerunning step: (expand "INIT")
Expanding the definition of INIT,
this simplifies to: 
authentication_middle.1 : 
;;; intruder's initial knowledge is in rho

{-1}  CASES x!1
        OF user(z): TRUE,
           nonce(z): z /= n_init,
           public(z): TRUE,
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i))
        ELSE FALSE
        ENDCASES
  |-------
[1]   rho_middle(i!1)(x!1)

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.1 : 
;;; intruder's initial knowledge is in rho

[-1]  CASES x!1
        OF user(z): TRUE,
           nonce(z): z /= n_init,
           public(z): TRUE,
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i))
        ELSE FALSE
        ENDCASES
  |-------
{1}   CASES x!1
        OF nonce(z): z /= n_init,
           nlist(z): NOT elt(z, n_init),
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i)),
           conc(z1, z2): rho_middle(i!1)(z1) AND rho_middle(i!1)(z2),
           commit(z1, z2, z3): z1 /= 0 OR z2 /= hu_list OR z3 /= n_init,
           code(z1, z2):
             rho_middle(i!1)(z2) OR
              EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
                z1 = public(hu(j)) AND
                 EXISTS (l: {x: list[Nonce] | length(x) = j - 1}):
                   z2 =
                    conc(nlist(cons(n_init, l)), ilist(remove(hu_list, j)))
        ELSE TRUE
        ENDCASES

Rerunning step: (smash)
Repeatedly simplifying with BDDs, decision procedures, rewriting,
and if-lifting,

This completes the proof of authentication_middle.1.

authentication_middle.2 :  

  |-------
{1}   FORALL (S: setof[Message]), (m: Message):
        (FORALL (x: Message): S(x) => rho_middle(i!1)(x)) AND (S |- m)
         IMPLIES rho_middle(i!1)(m)
[2]   network(USER) |> auth(T, R_middle(i!1))

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2 :  

  |-------
[1]   FORALL (S: setof[Message]), (m: Message):
        (FORALL (x: Message): S(x) => rho_middle(i!1)(x)) AND (S |- m)
         IMPLIES rho_middle(i!1)(m)

Rerunning step: (comment "from of a set of messages in rho, no message not in rho can be generated")
Adding comment: from of a set of messages in rho, no message not in rho can be generated
this simplifies to: 
authentication_middle.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   FORALL (S: setof[Message]), (m: Message):
        (FORALL (x: Message): S(x) => rho_middle(i!1)(x)) AND (S |- m)
         IMPLIES rho_middle(i!1)(m)

Rerunning step: (expand "|-")
Expanding the definition of |-,
this simplifies to: 
authentication_middle.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   FORALL (S: setof[Message]), (m: Message):
        (FORALL (x: Message): S(x) => rho_middle(i!1)(x)) AND Gen(S, m)
         IMPLIES rho_middle(i!1)(m)

Rerunning step: (rule-induct "Gen")
Applying rule (co)induction over Gen,
this simplifies to: 
authentication_middle.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   FORALL (m: Message):
        (     S!1(m)
          OR (EXISTS m1, m2:
                rho_middle(i!1)(m1) AND
                 rho_middle(i!1)(m2) AND m = conc(m1, m2))
          OR (EXISTS m1: rho_middle(i!1)(conc(m1, m)))
          OR (EXISTS m2: rho_middle(i!1)(conc(m, m2)))
          OR (EXISTS (n: Nonce):
                rho_middle(i!1)(nonce(n)) AND m = nlist((: n :)))
          OR (EXISTS (n: Nonce):
                rho_middle(i!1)(nlist((: n :))) AND m = nonce(n))
          OR (EXISTS (nl1, nl2: list[Nonce]):
                rho_middle(i!1)(nlist(nl1)) AND
                 rho_middle(i!1)(nlist(nl2)) AND
                  m = nlist(append(nl1, nl2)))
          OR (EXISTS (nl, nl1, nl2: list[Nonce]):
                rho_middle(i!1)(nlist(nl)) AND
                 nl = append(nl1, nl2) AND m = nlist(nl1))
          OR (EXISTS (nl, nl1, nl2: list[Nonce]):
                rho_middle(i!1)(nlist(nl)) AND
                 nl = append(nl1, nl2) AND m = nlist(nl2))
          OR (EXISTS (i: Identity):
                rho_middle(i!1)(user(i)) AND m = ilist((: i :)))
          OR (EXISTS (i: Identity):
                rho_middle(i!1)(ilist((: i :))) AND m = user(i))
          OR (EXISTS (il1, il2: list[Identity]):
                rho_middle(i!1)(ilist(il1)) AND
                 rho_middle(i!1)(ilist(il2)) AND
                  m = ilist(append(il1, il2)))
          OR (EXISTS (il, il1, il2: list[Identity]):
                rho_middle(i!1)(ilist(il)) AND
                 il = append(il1, il2) AND m = ilist(il1))
          OR (EXISTS (il, il1, il2: list[Identity]):
                rho_middle(i!1)(ilist(il)) AND
                 il = append(il1, il2) AND m = ilist(il2))
          OR EXISTS m1, k:
               rho_middle(i!1)(m1) AND rho_middle(i!1)(k) AND m = E(k, m1))
         IMPLIES rho_middle(i!1)(m)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   (     S!1(m!2)
        OR (EXISTS m1, m2:
              rho_middle(i!1)(m1) AND
               rho_middle(i!1)(m2) AND m!2 = conc(m1, m2))
        OR (EXISTS m1: rho_middle(i!1)(conc(m1, m!2)))
        OR (EXISTS m2: rho_middle(i!1)(conc(m!2, m2)))
        OR (EXISTS (n: Nonce):
              rho_middle(i!1)(nonce(n)) AND m!2 = nlist((: n :)))
        OR (EXISTS (n: Nonce):
              rho_middle(i!1)(nlist((: n :))) AND m!2 = nonce(n))
        OR (EXISTS (nl1, nl2: list[Nonce]):
              rho_middle(i!1)(nlist(nl1)) AND
               rho_middle(i!1)(nlist(nl2)) AND
                m!2 = nlist(append(nl1, nl2)))
        OR (EXISTS (nl, nl1, nl2: list[Nonce]):
              rho_middle(i!1)(nlist(nl)) AND
               nl = append(nl1, nl2) AND m!2 = nlist(nl1))
        OR (EXISTS (nl, nl1, nl2: list[Nonce]):
              rho_middle(i!1)(nlist(nl)) AND
               nl = append(nl1, nl2) AND m!2 = nlist(nl2))
        OR (EXISTS (i: Identity):
              rho_middle(i!1)(user(i)) AND m!2 = ilist((: i :)))
        OR (EXISTS (i: Identity):
              rho_middle(i!1)(ilist((: i :))) AND m!2 = user(i))
        OR (EXISTS (il1, il2: list[Identity]):
              rho_middle(i!1)(ilist(il1)) AND
               rho_middle(i!1)(ilist(il2)) AND
                m!2 = ilist(append(il1, il2)))
        OR (EXISTS (il, il1, il2: list[Identity]):
              rho_middle(i!1)(ilist(il)) AND
               il = append(il1, il2) AND m!2 = ilist(il1))
        OR (EXISTS (il, il1, il2: list[Identity]):
              rho_middle(i!1)(ilist(il)) AND
               il = append(il1, il2) AND m!2 = ilist(il2))
        OR EXISTS m1, k:
             rho_middle(i!1)(m1) AND rho_middle(i!1)(k) AND m!2 = E(k, m1))
       IMPLIES rho_middle(i!1)(m!2)

Rerunning step: (smash)
Repeatedly simplifying with BDDs, decision procedures, rewriting,
and if-lifting,
this yields  15 subgoals: 
authentication_middle.2.1 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  S!1(m!2)
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (inst -2 "m!2")
Instantiating the top quantifier in -2 with the terms: 
 m!2,
this simplifies to: 
authentication_middle.2.1 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  S!1(m!2)
{-2}  S!1(m!2) => rho_middle(i!1)(m!2)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_middle.2.1.

authentication_middle.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS m1, m2:
        rho_middle(i!1)(m1) AND rho_middle(i!1)(m2) AND m!2 = conc(m1, m2)
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS m1, m2:
        rho_middle(i!1)(m1) AND rho_middle(i!1)(m2) AND m!2 = conc(m1, m2)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(m1!1) AND
       rho_middle(i!1)(m2!1) AND m!2 = conc(m1!1, m2!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_middle.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(m1!1)
{-2}  rho_middle(i!1)(m2!1)
{-3}  m!2 = conc(m1!1, m2!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_middle.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(m1!1)
[-2]  rho_middle(i!1)(m2!1)
[-3]  m!2 = conc(m1!1, m2!1)
  |-------
{1}   rho_middle(i!1)(conc(m1!1, m2!1))

Rerunning step: (expand "rho_middle" 1)
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(m1!1)
[-2]  rho_middle(i!1)(m2!1)
[-3]  m!2 = conc(m1!1, m2!1)
  |-------
{1}   rho_middle(i!1)(m1!1) AND rho_middle(i!1)(m2!1)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_middle.2.2.

authentication_middle.2.3 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS m1: rho_middle(i!1)(conc(m1, m!2))
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.3 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS m1: rho_middle(i!1)(conc(m1, m!2))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.3 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(conc(m1!1, m!2))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (expand "rho_middle" -1)
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.3 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  FALSE
  |-------
[1]   rho_middle(i!1)(m!2)

which is trivially true.

This completes the proof of authentication_middle.2.3.

authentication_middle.2.4 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS m2: rho_middle(i!1)(conc(m!2, m2))
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.4 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS m2: rho_middle(i!1)(conc(m!2, m2))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.4 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(conc(m!2, m2!1))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (expand "rho_middle" -1)
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.4 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  FALSE
  |-------
[1]   rho_middle(i!1)(m!2)

which is trivially true.

This completes the proof of authentication_middle.2.4.

authentication_middle.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (n: Nonce): rho_middle(i!1)(nonce(n)) AND m!2 = nlist((: n :))
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (n: Nonce): rho_middle(i!1)(nonce(n)) AND m!2 = nlist((: n :))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(nonce(n!1)) AND m!2 = nlist((: n!1 :))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_middle.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(nonce(n!1))
{-2}  m!2 = nlist((: n!1 :))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (expand "rho_middle" -1)
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  n!1 /= n_init
[-2]  m!2 = nlist((: n!1 :))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
authentication_middle.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  n!1 /= n_init
[-2]  m!2 = nlist((: n!1 :))
  |-------
{1}   rho_middle(i!1)(nlist((: n!1 :)))

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  n!1 /= n_init
[-2]  m!2 = nlist((: n!1 :))
{-3}  elt((: n!1 :), n_init)
  |-------

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  n!1 /= n_init
[-2]  elt((: n!1 :), n_init)
  |-------

Rerunning step: (grind)
/= rewrites n!1 /= n_init
  to NOT (n!1 = n_init)
elt rewrites elt((: n!1 :), n_init)
  to EXISTS (i: below[length((: n!1 :))]): nth((: n!1 :), i) = n_init
length rewrites length((: :))
  to 0
length rewrites length((: n!1 :))
  to 1
nth rewrites nth((: n!1 :), i!2)
  to n!1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_middle.2.5.

authentication_middle.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (n: Nonce): rho_middle(i!1)(nlist((: n :))) AND m!2 = nonce(n)
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (n: Nonce): rho_middle(i!1)(nlist((: n :))) AND m!2 = nonce(n)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(nlist((: n!1 :))) AND m!2 = nonce(n!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_middle.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(nlist((: n!1 :)))
{-2}  m!2 = nonce(n!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
authentication_middle.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(nlist((: n!1 :)))
[-2]  m!2 = nonce(n!1)
  |-------
{1}   rho_middle(i!1)(nonce(n!1))

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(nlist((: n!1 :)))
  |-------
[1]   rho_middle(i!1)(nonce(n!1))

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   elt((: n!1 :), n_init)
{2}   n!1 /= n_init

Rerunning step: (expand "elt")
Expanding the definition of elt,
this simplifies to: 
authentication_middle.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   EXISTS (i: below[length((: n!1 :))]): nth((: n!1 :), i) = n_init
[2]   n!1 /= n_init

Rerunning step: (inst 1 "0")
Instantiating the top quantifier in 1 with the terms: 
 0,
this yields  2 subgoals: 
authentication_middle.2.6.1 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   nth((: n!1 :), 0) = n_init
[2]   n!1 /= n_init

Rerunning step: (grind :exclude 2)
nth rewrites nth((: n!1 :), 0)
  to n!1
/= rewrites n!1 /= n_init
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_middle.2.6.1.

authentication_middle.2.6.2 (TCC):   

  |-------
{1}   0 < length[Nonce]((: n!1 :))
[2]   n!1 /= n_init

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.6.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   0 < length[Nonce]((: n!1 :))

Rerunning step: (grind)
length rewrites length((: :))
  to 0
length rewrites length[Nonce]((: n!1 :))
  to 1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_middle.2.6.2.


This completes the proof of authentication_middle.2.6.

authentication_middle.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (nl1, nl2: list[Nonce]):
        rho_middle(i!1)(nlist(nl1)) AND
         rho_middle(i!1)(nlist(nl2)) AND m!2 = nlist(append(nl1, nl2))
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (nl1, nl2: list[Nonce]):
        rho_middle(i!1)(nlist(nl1)) AND
         rho_middle(i!1)(nlist(nl2)) AND m!2 = nlist(append(nl1, nl2))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(nlist(nl1!1)) AND
       rho_middle(i!1)(nlist(nl2!1)) AND m!2 = nlist(append(nl1!1, nl2!1))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_middle.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(nlist(nl1!1))
{-2}  rho_middle(i!1)(nlist(nl2!1))
{-3}  m!2 = nlist(append(nl1!1, nl2!1))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_middle.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(nlist(nl1!1))
[-2]  rho_middle(i!1)(nlist(nl2!1))
[-3]  m!2 = nlist(append(nl1!1, nl2!1))
  |-------
{1}   rho_middle(i!1)(nlist(append(nl1!1, nl2!1)))

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(nlist(nl1!1))
[-2]  rho_middle(i!1)(nlist(nl2!1))
  |-------
[1]   rho_middle(i!1)(nlist(append(nl1!1, nl2!1)))

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(append(nl1!1, nl2!1), n_init)
  |-------
{1}   elt(nl1!1, n_init)
{2}   elt(nl2!1, n_init)

Rerunning step: (lemma "listprops[Nonce].elt_append3"
                 ("l1" "nl1!1" "l2" "nl2!1" "t" "n_init"))
Applying listprops[Nonce].elt_append3 where 
  l1 gets nl1!1,
  l2 gets nl2!1,
  t gets n_init,
this simplifies to: 
authentication_middle.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(append(nl1!1, nl2!1), n_init) IMPLIES
       elt(nl1!1, n_init) OR elt(nl2!1, n_init)
[-2]  elt(append(nl1!1, nl2!1), n_init)
  |-------
[1]   elt(nl1!1, n_init)
[2]   elt(nl2!1, n_init)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_middle.2.7.

authentication_middle.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (nl, nl1, nl2: list[Nonce]):
        rho_middle(i!1)(nlist(nl)) AND
         nl = append(nl1, nl2) AND m!2 = nlist(nl1)
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (nl, nl1, nl2: list[Nonce]):
        rho_middle(i!1)(nlist(nl)) AND
         nl = append(nl1, nl2) AND m!2 = nlist(nl1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(nlist(nl!1)) AND
       nl!1 = append(nl1!1, nl2!1) AND m!2 = nlist(nl1!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_middle.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(nlist(nl!1))
{-2}  nl!1 = append(nl1!1, nl2!1)
{-3}  m!2 = nlist(nl1!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_middle.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(nlist(nl!1))
[-2]  nl!1 = append(nl1!1, nl2!1)
[-3]  m!2 = nlist(nl1!1)
  |-------
{1}   rho_middle(i!1)(nlist(nl1!1))

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(nlist(nl!1))
[-2]  nl!1 = append(nl1!1, nl2!1)
  |-------
[1]   rho_middle(i!1)(nlist(nl1!1))

Rerunning step: (replace -2 -1)
Replacing using formula -2,
this simplifies to: 
authentication_middle.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(nlist(append(nl1!1, nl2!1)))
[-2]  nl!1 = append(nl1!1, nl2!1)
  |-------
[1]   rho_middle(i!1)(nlist(nl1!1))

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(nlist(append(nl1!1, nl2!1)))
  |-------
[1]   rho_middle(i!1)(nlist(nl1!1))

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(nl1!1, n_init)
  |-------
{1}   elt(append(nl1!1, nl2!1), n_init)

Rerunning step: (lemma "listprops[Nonce].elt_append1"
                 ("l1" "nl1!1" "l2" "nl2!1" "t" "n_init"))
Applying listprops[Nonce].elt_append1 where 
  l1 gets nl1!1,
  l2 gets nl2!1,
  t gets n_init,
this simplifies to: 
authentication_middle.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(nl1!1, n_init) IMPLIES elt(append(nl1!1, nl2!1), n_init)
[-2]  elt(nl1!1, n_init)
  |-------
[1]   elt(append(nl1!1, nl2!1), n_init)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_middle.2.8.

authentication_middle.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (nl, nl1, nl2: list[Nonce]):
        rho_middle(i!1)(nlist(nl)) AND
         nl = append(nl1, nl2) AND m!2 = nlist(nl2)
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (nl, nl1, nl2: list[Nonce]):
        rho_middle(i!1)(nlist(nl)) AND
         nl = append(nl1, nl2) AND m!2 = nlist(nl2)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(nlist(nl!1)) AND
       nl!1 = append(nl1!1, nl2!1) AND m!2 = nlist(nl2!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_middle.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(nlist(nl!1))
{-2}  nl!1 = append(nl1!1, nl2!1)
{-3}  m!2 = nlist(nl2!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_middle.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(nlist(nl!1))
[-2]  nl!1 = append(nl1!1, nl2!1)
[-3]  m!2 = nlist(nl2!1)
  |-------
{1}   rho_middle(i!1)(nlist(nl2!1))

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(nlist(nl!1))
[-2]  nl!1 = append(nl1!1, nl2!1)
  |-------
[1]   rho_middle(i!1)(nlist(nl2!1))

Rerunning step: (replace -2 -1)
Replacing using formula -2,
this simplifies to: 
authentication_middle.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(nlist(append(nl1!1, nl2!1)))
[-2]  nl!1 = append(nl1!1, nl2!1)
  |-------
[1]   rho_middle(i!1)(nlist(nl2!1))

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(nlist(append(nl1!1, nl2!1)))
  |-------
[1]   rho_middle(i!1)(nlist(nl2!1))

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(nl2!1, n_init)
  |-------
{1}   elt(append(nl1!1, nl2!1), n_init)

Rerunning step: (lemma "listprops[Nonce].elt_append2"
                 ("l1" "nl1!1" "l2" "nl2!1" "t" "n_init"))
Applying listprops[Nonce].elt_append2 where 
  l1 gets nl1!1,
  l2 gets nl2!1,
  t gets n_init,
this simplifies to: 
authentication_middle.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(nl2!1, n_init) IMPLIES elt(append(nl1!1, nl2!1), n_init)
[-2]  elt(nl2!1, n_init)
  |-------
[1]   elt(append(nl1!1, nl2!1), n_init)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_middle.2.9.

authentication_middle.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (i: Identity):
        rho_middle(i!1)(user(i)) AND m!2 = ilist((: i :))
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (i: Identity):
        rho_middle(i!1)(user(i)) AND m!2 = ilist((: i :))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(user(i!2)) AND m!2 = ilist((: i!2 :))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_middle.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(user(i!2))
{-2}  m!2 = ilist((: i!2 :))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
authentication_middle.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(user(i!2))
[-2]  m!2 = ilist((: i!2 :))
  |-------
{1}   rho_middle(i!1)(ilist((: i!2 :)))

Rerunning step: (delete -1 -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   rho_middle(i!1)(ilist((: i!2 :)))

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_middle.2.10.

authentication_middle.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (i: Identity):
        rho_middle(i!1)(ilist((: i :))) AND m!2 = user(i)
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (i: Identity):
        rho_middle(i!1)(ilist((: i :))) AND m!2 = user(i)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(ilist((: i!2 :))) AND m!2 = user(i!2)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_middle.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(ilist((: i!2 :)))
{-2}  m!2 = user(i!2)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
authentication_middle.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(ilist((: i!2 :)))
[-2]  m!2 = user(i!2)
  |-------
{1}   rho_middle(i!1)(user(i!2))

Rerunning step: (delete -1 -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   rho_middle(i!1)(user(i!2))

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_middle.2.11.

authentication_middle.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (il1, il2: list[Identity]):
        rho_middle(i!1)(ilist(il1)) AND
         rho_middle(i!1)(ilist(il2)) AND m!2 = ilist(append(il1, il2))
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (il1, il2: list[Identity]):
        rho_middle(i!1)(ilist(il1)) AND
         rho_middle(i!1)(ilist(il2)) AND m!2 = ilist(append(il1, il2))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(ilist(il1!1)) AND
       rho_middle(i!1)(ilist(il2!1)) AND m!2 = ilist(append(il1!1, il2!1))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_middle.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(ilist(il1!1))
{-2}  rho_middle(i!1)(ilist(il2!1))
{-3}  m!2 = ilist(append(il1!1, il2!1))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_middle.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(ilist(il1!1))
[-2]  rho_middle(i!1)(ilist(il2!1))
[-3]  m!2 = ilist(append(il1!1, il2!1))
  |-------
{1}   rho_middle(i!1)(ilist(append(il1!1, il2!1)))

Rerunning step: (delete -1 -2 -3)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   rho_middle(i!1)(ilist(append(il1!1, il2!1)))

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_middle.2.12.

authentication_middle.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (il, il1, il2: list[Identity]):
        rho_middle(i!1)(ilist(il)) AND
         il = append(il1, il2) AND m!2 = ilist(il1)
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (il, il1, il2: list[Identity]):
        rho_middle(i!1)(ilist(il)) AND
         il = append(il1, il2) AND m!2 = ilist(il1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(ilist(il!1)) AND
       il!1 = append(il1!1, il2!1) AND m!2 = ilist(il1!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_middle.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(ilist(il!1))
{-2}  il!1 = append(il1!1, il2!1)
{-3}  m!2 = ilist(il1!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_middle.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(ilist(il!1))
[-2]  il!1 = append(il1!1, il2!1)
[-3]  m!2 = ilist(il1!1)
  |-------
{1}   rho_middle(i!1)(ilist(il1!1))

Rerunning step: (delete -1 -2 -3)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   rho_middle(i!1)(ilist(il1!1))

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_middle.2.13.

authentication_middle.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (il, il1, il2: list[Identity]):
        rho_middle(i!1)(ilist(il)) AND
         il = append(il1, il2) AND m!2 = ilist(il2)
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (il, il1, il2: list[Identity]):
        rho_middle(i!1)(ilist(il)) AND
         il = append(il1, il2) AND m!2 = ilist(il2)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(ilist(il!1)) AND
       il!1 = append(il1!1, il2!1) AND m!2 = ilist(il2!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_middle.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(ilist(il!1))
{-2}  il!1 = append(il1!1, il2!1)
{-3}  m!2 = ilist(il2!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_middle.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(ilist(il!1))
[-2]  il!1 = append(il1!1, il2!1)
[-3]  m!2 = ilist(il2!1)
  |-------
{1}   rho_middle(i!1)(ilist(il2!1))

Rerunning step: (delete -1 -2 -3)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   rho_middle(i!1)(ilist(il2!1))

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_middle.2.14.

authentication_middle.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS m1, k:
        rho_middle(i!1)(m1) AND rho_middle(i!1)(k) AND m!2 = E(k, m1)
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS m1, k:
        rho_middle(i!1)(m1) AND rho_middle(i!1)(k) AND m!2 = E(k, m1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(m1!1) AND rho_middle(i!1)(k!1) AND m!2 = E(k!1, m1!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_middle.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(m1!1)
{-2}  rho_middle(i!1)(k!1)
{-3}  m!2 = E(k!1, m1!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_middle.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(m1!1)
[-2]  rho_middle(i!1)(k!1)
[-3]  m!2 = E(k!1, m1!1)
  |-------
{1}   rho_middle(i!1)(E(k!1, m1!1))

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(m1!1)
[-2]  rho_middle(i!1)(k!1)
  |-------
[1]   rho_middle(i!1)(E(k!1, m1!1))

Rerunning step: (typepred "k!1")
Adding type constraints for  k!1,
this simplifies to: 
authentication_middle.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  public?(k!1) OR secret?(k!1)
[-2]  rho_middle(i!1)(m1!1)
[-3]  rho_middle(i!1)(k!1)
  |-------
[1]   rho_middle(i!1)(E(k!1, m1!1))

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
authentication_middle.2.15.1 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  public?(k!1)
[-2]  rho_middle(i!1)(m1!1)
[-3]  rho_middle(i!1)(k!1)
  |-------
[1]   rho_middle(i!1)(E(k!1, m1!1))

Rerunning step: (grind)
rho_middle rewrites rho_middle(i!1)(k!1)
  to TRUE
E rewrites E(k!1, m1!1)
  to CASES m1!1
        OF code(k1, m1):
             CASES k1
               OF public(i):
                    IF k!1 = secret(i) THEN m1 ELSE code(k!1, m1!1) ENDIF,
                  secret(i):
                    IF k!1 = public(i) THEN m1 ELSE code(k!1, m1!1) ENDIF
               ENDCASES
        ELSE code(k!1, m1!1)
        ENDCASES
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites rho_middle(i!1)(code(k!1, m1!1))
  to TRUE
rho_middle rewrites rho_middle(i!1)(public(x_secret(x_code(m1!1))))
  to TRUE
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites rho_middle(i!1)(m1!1)
  to FALSE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_middle.2.15.1.

authentication_middle.2.15.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  secret?(k!1)
[-2]  rho_middle(i!1)(m1!1)
[-3]  rho_middle(i!1)(k!1)
  |-------
[1]   rho_middle(i!1)(E(k!1, m1!1))

Rerunning step: (expand "rho_middle" -3)
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.15.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  secret?(k!1)
[-2]  rho_middle(i!1)(m1!1)
{-3}  CASES k!1
        OF nonce(z): z /= n_init,
           nlist(z): NOT elt(z, n_init),
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i)),
           conc(z1, z2): rho_middle(i!1)(z1) AND rho_middle(i!1)(z2),
           commit(z1, z2, z3): z1 /= 0 OR z2 /= hu_list OR z3 /= n_init,
           code(z1, z2):
             rho_middle(i!1)(z2) OR
              EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
                z1 = public(hu(j)) AND
                 EXISTS (l: {x: list[Nonce] | length(x) = j - 1}):
                   z2 =
                    conc(nlist(cons(n_init, l)), ilist(remove(hu_list, j)))
        ELSE TRUE
        ENDCASES
  |-------
[1]   rho_middle(i!1)(E(k!1, m1!1))

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
authentication_middle.2.15.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  secret?(k!1)
[-2]  rho_middle(i!1)(m1!1)
  |-------
{1}   EXISTS (i: nat_to_p): x_secret(k!1) = hu(i)
[2]   rho_middle(i!1)(E(k!1, m1!1))

Rerunning step: (lazy-grind)
E rewrites E(k!1, m1!1)
  to CASES m1!1
        OF code(k1, m1):
             CASES k1
               OF public(i):
                    IF k!1 = secret(i) THEN m1 ELSE code(k!1, m1!1) ENDIF,
                  secret(i):
                    IF k!1 = public(i) THEN m1 ELSE code(k!1, m1!1) ENDIF
               ENDCASES
        ELSE code(k!1, m1!1)
        ENDCASES
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites rho_middle(i!1)(code(k!1, m1!1))
  to TRUE
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites rho_middle(i!1)(m1!1)
  to EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
        x_code(m1!1) = public(hu(j)) AND
         EXISTS (l: {x: list[Nonce] | length(x) = j - 1}):
           y_code(m1!1) =
            conc(nlist(cons(n_init, l)),
                 ilist(cons(car(hu_list), remove(cdr(hu_list), j - 1))))
elt rewrites elt(cons(n_init, l!1), n_init)
  to EXISTS (i: below[length(cons(n_init, l!1))]):
        nth(cons(n_init, l!1), i) = n_init
rho_middle rewrites rho_middle(i!1)(nlist(cons(n_init, l!1)))
  to NOT EXISTS (i: below[length(cons(n_init, l!1))]):
            nth(cons(n_init, l!1), i) = n_init
rho_middle rewrites 
  rho_middle(i!1)(ilist(cons(car(hu_list), remove(cdr(hu_list), j!1 - 1))))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)
            (conc(nlist(cons(n_init, l!1)),
                  ilist(cons(car(hu_list), remove(cdr(hu_list), j!1 - 1)))))
  to NOT EXISTS (i: below[length(cons(n_init, l!1))]):
            nth(cons(n_init, l!1), i) = n_init
length rewrites length(cons(n_init, l!1))
  to 1 + length(l!1)
By skolemization, if-lifting, simplification and instantiation,

This completes the proof of authentication_middle.2.15.2.


This completes the proof of authentication_middle.2.15.


This completes the proof of authentication_middle.2.

authentication_middle.3 :  

  |-------
{1}   FORALL (i: Identity):
        USER(i) # R_middle(i!1) |> RankUser(rho_middle(i!1))
[2]   network(USER) |> auth(T, R_middle(i!1))

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_middle.3 :  

  |-------
[1]   FORALL (i: Identity):
        USER(i) # R_middle(i!1) |> RankUser(rho_middle(i!1))

Rerunning step: (comment "users maintain the rank function")
Adding comment: users maintain the rank function
this simplifies to: 
authentication_middle.3 : 
;;; users maintain the rank function

  |-------
[1]   FORALL (i: Identity):
        USER(i) # R_middle(i!1) |> RankUser(rho_middle(i!1))

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.3 : 
;;; users maintain the rank function

  |-------
{1}   USER(i!2) # R_middle(i!1) |> RankUser(rho_middle(i!1))

Rerunning step: (expand "USER")
Expanding the definition of USER,
this simplifies to: 
authentication_middle.3 : 
;;; users maintain the rank function

  |-------
{1}   (Interleave! (P: nat_from_2):
         (Interleave! (nn0: Nonces(P, i!2, 0)): UROLE_INIT(P, i!2, nn0)) //
          (Interleave! (nnP: Nonces(P, i!2, P - 1)):
             UROLE_LAST(P, i!2, nnP))
          //
          IF P = 2 THEN Stop[event]
          ELSE (Interleave! (j: nat_1_to(P), nnJ: Nonces(P, i!2, j)):
                  UROLE_MIDDLE(P, j, i!2, nnJ))
          ENDIF)
       # R_middle(i!1)
       |> RankUser(rho_middle(i!1))

Rerunning step: (expand "RankUser")
Expanding the definition of RankUser,
this simplifies to: 
authentication_middle.3 : 
;;; users maintain the rank function

  |-------
{1}   (Interleave! (P: nat_from_2):
         (Interleave! (nn0: Nonces(P, i!2, 0)): UROLE_INIT(P, i!2, nn0)) //
          (Interleave! (nnP: Nonces(P, i!2, P - 1)):
             UROLE_LAST(P, i!2, nnP))
          //
          IF P = 2 THEN Stop[event]
          ELSE (Interleave! (j: nat_1_to(P), nnJ: Nonces(P, i!2, j)):
                  UROLE_MIDDLE(P, j, i!2, nnJ))
          ENDIF)
       # R_middle(i!1)
       |>
       LAMBDA (tr: list[event]):
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (tr)
          IMPLIES
          every(LAMBDA (e: event):
                  complement(rec?)(e) IMPLIES rho_middle(i!1)(msg(e)))
               (tr)

Rerunning step: (interleaving2)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
Applying interleaving rule,
this simplifies to: 
authentication_middle.3 : 
;;; users maintain the rank function

  |-------
{1}   (Interleave! (nn0: Nonces(i!3, i!2, 0)): UROLE_INIT(i!3, i!2, nn0))
       //
       (Interleave! (nnP: Nonces(i!3, i!2, i!3 - 1)):
          UROLE_LAST(i!3, i!2, nnP))
       //
       IF i!3 = 2 THEN Stop[event]
       ELSE (Interleave! (j: nat_1_to(i!3), nnJ: Nonces(i!3, i!2, j)):
               UROLE_MIDDLE(i!3, j, i!2, nnJ))
       ENDIF
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (t)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (interleaving)
Applying interleaving rule,
this yields  2 subgoals: 
authentication_middle.3.1 : 
;;; users maintain the rank function

  |-------
{1}   (((Interleave! (nn0: Nonces(i!3, i!2, 0)): UROLE_INIT(i!3, i!2, nn0))
         //
         (Interleave! (nnP: Nonces(i!3, i!2, i!3 - 1)):
            UROLE_LAST(i!3, i!2, nnP))
         # R_middle(i!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                (t))

Rerunning step: (interleaving)
Applying interleaving rule,
this yields  2 subgoals: 
authentication_middle.3.1.1 : 
;;; users maintain the rank function

  |-------
{1}   (((Interleave! (nn0: Nonces(i!3, i!2, 0)): UROLE_INIT(i!3, i!2, nn0))
         # R_middle(i!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                (t))

Rerunning step: (lemma "restrictmiddle_init"
                 ("P" "i!3" "u" "i!2" "i" "i!1"))
Applying restrictmiddle_init where 
  P gets i!3,
  u gets i!2,
  i gets i!1,
this simplifies to: 
authentication_middle.3.1.1 : 
;;; users maintain the rank function

{-1}  ((Interleave! (nn0: Nonces(i!3, i!2, 0)): UROLE_INIT(i!3, i!2, nn0))
        # R_middle(i!1))
       |> RankUser(rho_middle(i!1))
  |-------
[1]   (((Interleave! (nn0: Nonces(i!3, i!2, 0)): UROLE_INIT(i!3, i!2, nn0))
         # R_middle(i!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                (t))

Rerunning step: (grind :exclude ("rho_middle" "UROLE_INIT"))
Interleave rewrites 
  (Interleave! (nn0: Nonces(i!3, i!2, 0)): UROLE_INIT(i!3, i!2, nn0))
  to Par(emptyset)
         (LAMBDA (nn0: Nonces(i!3, i!2, 0)): UROLE_INIT(i!3, i!2, nn0))
# rewrites 
  (Par(emptyset)
      (LAMBDA (nn0: Nonces(i!3, i!2, 0)): UROLE_INIT(i!3, i!2, nn0))
    # R_middle(i!1))
  to Par(R_middle(i!1))
         (Par(emptyset)
             (LAMBDA (nn0: Nonces(i!3, i!2, 0)):
                UROLE_INIT(i!3, i!2, nn0)),
          Stop)
Par rewrites 
  Par(R_middle(i!1))
     (Par(emptyset)
         (LAMBDA (nn0: Nonces(i!3, i!2, 0)): UROLE_INIT(i!3, i!2, nn0)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nn0: Nonces(i!3, i!2, 0)):
                       UROLE_INIT(i!3, i!2, nn0)))),
             (t2: (Stop)):
        prod(R_middle(i!1))(t1, t2, x)
member rewrites 
  member(x,
         Par(R_middle(i!1))
            (Par(emptyset)
                (LAMBDA (nn0: Nonces(i!3, i!2, 0)):
                   UROLE_INIT(i!3, i!2, nn0)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nn0: Nonces(i!3, i!2, 0)):
                       UROLE_INIT(i!3, i!2, nn0)))),
             (t2: (Stop)):
        prod(R_middle(i!1))(t1, t2, x)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
RankUser rewrites RankUser(rho_middle(i!1))(x)
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))(x)
       IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
            (x)
member rewrites member(x, RankUser(rho_middle(i!1)))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))(x)
       IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
            (x)
subset? rewrites 
  subset?(Par(R_middle(i!1))
             (Par(emptyset)
                 (LAMBDA (nn0: Nonces(i!3, i!2, 0)):
                    UROLE_INIT(i!3, i!2, nn0)),
              Stop),
          RankUser(rho_middle(i!1)))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nn0: Nonces(i!3, i!2, 0)):
                          UROLE_INIT(i!3, i!2, nn0)))),
                (t2: (Stop)):
           prod(R_middle(i!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (x)
          IMPLIES
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (x)
|> rewrites 
  Par(R_middle(i!1))
     (Par(emptyset)
         (LAMBDA (nn0: Nonces(i!3, i!2, 0)): UROLE_INIT(i!3, i!2, nn0)),
      Stop)
   |> RankUser(rho_middle(i!1))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nn0: Nonces(i!3, i!2, 0)):
                          UROLE_INIT(i!3, i!2, nn0)))),
                (t2: (Stop)):
           prod(R_middle(i!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (x)
          IMPLIES
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (x)
Par rewrites 
  Par(R_middle(i!1))
     (Par(emptyset)
         (LAMBDA (nn0: Nonces(i!3, i!2, 0)): UROLE_INIT(i!3, i!2, nn0)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nn0: Nonces(i!3, i!2, 0)):
                       UROLE_INIT(i!3, i!2, nn0)))),
             (t2: (Stop)):
        prod(R_middle(i!1))(t1, t2, x)
member rewrites 
  member(x,
         Par(R_middle(i!1))
            (Par(emptyset)
                (LAMBDA (nn0: Nonces(i!3, i!2, 0)):
                   UROLE_INIT(i!3, i!2, nn0)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nn0: Nonces(i!3, i!2, 0)):
                       UROLE_INIT(i!3, i!2, nn0)))),
             (t2: (Stop)):
        prod(R_middle(i!1))(t1, t2, x)
member rewrites 
  member(x,
         LAMBDA (t: list[event]):
           every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                (t)
            =>
            every(LAMBDA (e: event):
                    NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                 (t))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))(x)
       =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
            (x)
subset? rewrites 
  subset?(Par(R_middle(i!1))
             (Par(emptyset)
                 (LAMBDA (nn0: Nonces(i!3, i!2, 0)):
                    UROLE_INIT(i!3, i!2, nn0)),
              Stop),
          LAMBDA (t: list[event]):
            every(LAMBDA (e: event):
                    rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                 (t)
             =>
             every(LAMBDA (e: event):
                     NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                  (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nn0: Nonces(i!3, i!2, 0)):
                          UROLE_INIT(i!3, i!2, nn0)))),
                (t2: (Stop)):
           prod(R_middle(i!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (x)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (x)
|> rewrites 
  (Par(R_middle(i!1))
      (Par(emptyset)
          (LAMBDA (nn0: Nonces(i!3, i!2, 0)): UROLE_INIT(i!3, i!2, nn0)),
       Stop)
    |>
    LAMBDA (t: list[event]):
      every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))(t)
       =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
            (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nn0: Nonces(i!3, i!2, 0)):
                          UROLE_INIT(i!3, i!2, nn0)))),
                (t2: (Stop)):
           prod(R_middle(i!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (x)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (x)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_middle.3.1.1.

authentication_middle.3.1.2 : 
;;; users maintain the rank function

  |-------
{1}   (((Interleave! (nnP: Nonces(i!3, i!2, i!3 - 1)):
           UROLE_LAST(i!3, i!2, nnP))
         # R_middle(i!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                (t))

Rerunning step: (lemma "restrictmiddle_last"
                 ("P" "i!3" "u" "i!2" "i" "i!1"))
Applying restrictmiddle_last where 
  P gets i!3,
  u gets i!2,
  i gets i!1,
this simplifies to: 
authentication_middle.3.1.2 : 
;;; users maintain the rank function

{-1}  ((Interleave! (nnP: Nonces(i!3, i!2, i!3 - 1)):
          UROLE_LAST(i!3, i!2, nnP))
        # R_middle(i!1))
       |> RankUser(rho_middle(i!1))
  |-------
[1]   (((Interleave! (nnP: Nonces(i!3, i!2, i!3 - 1)):
           UROLE_LAST(i!3, i!2, nnP))
         # R_middle(i!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                (t))

Rerunning step: (grind :exclude ("rho_middle" "UROLE_LAST"))
Interleave rewrites 
  (Interleave! (nnP: Nonces(i!3, i!2, i!3 - 1)): UROLE_LAST(i!3, i!2, nnP))
  to Par(emptyset)
         (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
            UROLE_LAST(i!3, i!2, nnP))
# rewrites 
  (Par(emptyset)
      (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)): UROLE_LAST(i!3, i!2, nnP))
    # R_middle(i!1))
  to Par(R_middle(i!1))
         (Par(emptyset)
             (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
                UROLE_LAST(i!3, i!2, nnP)),
          Stop)
Par rewrites 
  Par(R_middle(i!1))
     (Par(emptyset)
         (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
            UROLE_LAST(i!3, i!2, nnP)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
                       UROLE_LAST(i!3, i!2, nnP)))),
             (t2: (Stop)):
        prod(R_middle(i!1))(t1, t2, x)
member rewrites 
  member(x,
         Par(R_middle(i!1))
            (Par(emptyset)
                (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
                   UROLE_LAST(i!3, i!2, nnP)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
                       UROLE_LAST(i!3, i!2, nnP)))),
             (t2: (Stop)):
        prod(R_middle(i!1))(t1, t2, x)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
RankUser rewrites RankUser(rho_middle(i!1))(x)
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))(x)
       IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
            (x)
member rewrites member(x, RankUser(rho_middle(i!1)))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))(x)
       IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
            (x)
subset? rewrites 
  subset?(Par(R_middle(i!1))
             (Par(emptyset)
                 (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
                    UROLE_LAST(i!3, i!2, nnP)),
              Stop),
          RankUser(rho_middle(i!1)))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
                          UROLE_LAST(i!3, i!2, nnP)))),
                (t2: (Stop)):
           prod(R_middle(i!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (x)
          IMPLIES
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (x)
|> rewrites 
  Par(R_middle(i!1))
     (Par(emptyset)
         (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
            UROLE_LAST(i!3, i!2, nnP)),
      Stop)
   |> RankUser(rho_middle(i!1))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
                          UROLE_LAST(i!3, i!2, nnP)))),
                (t2: (Stop)):
           prod(R_middle(i!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (x)
          IMPLIES
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (x)
Par rewrites 
  Par(R_middle(i!1))
     (Par(emptyset)
         (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
            UROLE_LAST(i!3, i!2, nnP)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
                       UROLE_LAST(i!3, i!2, nnP)))),
             (t2: (Stop)):
        prod(R_middle(i!1))(t1, t2, x)
member rewrites 
  member(x,
         Par(R_middle(i!1))
            (Par(emptyset)
                (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
                   UROLE_LAST(i!3, i!2, nnP)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
                       UROLE_LAST(i!3, i!2, nnP)))),
             (t2: (Stop)):
        prod(R_middle(i!1))(t1, t2, x)
member rewrites 
  member(x,
         LAMBDA (t: list[event]):
           every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                (t)
            =>
            every(LAMBDA (e: event):
                    NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                 (t))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))(x)
       =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
            (x)
subset? rewrites 
  subset?(Par(R_middle(i!1))
             (Par(emptyset)
                 (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
                    UROLE_LAST(i!3, i!2, nnP)),
              Stop),
          LAMBDA (t: list[event]):
            every(LAMBDA (e: event):
                    rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                 (t)
             =>
             every(LAMBDA (e: event):
                     NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                  (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
                          UROLE_LAST(i!3, i!2, nnP)))),
                (t2: (Stop)):
           prod(R_middle(i!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (x)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (x)
|> rewrites 
  (Par(R_middle(i!1))
      (Par(emptyset)
          (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
             UROLE_LAST(i!3, i!2, nnP)),
       Stop)
    |>
    LAMBDA (t: list[event]):
      every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))(t)
       =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
            (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
                          UROLE_LAST(i!3, i!2, nnP)))),
                (t2: (Stop)):
           prod(R_middle(i!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (x)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (x)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_middle.3.1.2.


This completes the proof of authentication_middle.3.1.

authentication_middle.3.2 : 
;;; users maintain the rank function

  |-------
{1}   ((IF i!3 = 2 THEN Stop[event]
        ELSE (Interleave! (j: nat_1_to(i!3), nnJ: Nonces(i!3, i!2, j)):
                UROLE_MIDDLE(i!3, j, i!2, nnJ))
        ENDIF
         # R_middle(i!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                (t))

Rerunning step: (lift-if)
Lifting IF-conditions to the top level,
this simplifies to: 
authentication_middle.3.2 : 
;;; users maintain the rank function

  |-------
{1}   IF i!3 = 2
        THEN ((Stop[event] # R_middle(i!1)) |>
               LAMBDA (t: list[event]):
                 every(LAMBDA (e: event):
                         rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                      (t)
                  =>
                  every(LAMBDA (e: event):
                          NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                       (t))
      ELSE (((Interleave! (j: nat_1_to(i!3), nnJ: Nonces(i!3, i!2, j)):
                UROLE_MIDDLE(i!3, j, i!2, nnJ))
              # R_middle(i!1))
             |>
             LAMBDA (t: list[event]):
               every(LAMBDA (e: event):
                       rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                    (t)
                =>
                every(LAMBDA (e: event):
                        NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                     (t))
      ENDIF

Rerunning step: (prop)
Applying propositional simplification,
this yields  2 subgoals: 
authentication_middle.3.2.1 : 
;;; users maintain the rank function

{-1}  i!3 = 2
  |-------
{1}   ((Stop[event] # R_middle(i!1)) |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                (t))

Rerunning step: (stop)
Applying stop rule,

This completes the proof of authentication_middle.3.2.1.

authentication_middle.3.2.2 : 
;;; users maintain the rank function

  |-------
{1}   i!3 = 2
{2}   (((Interleave! (j: nat_1_to(i!3), nnJ: Nonces(i!3, i!2, j)):
           UROLE_MIDDLE(i!3, j, i!2, nnJ))
         # R_middle(i!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                (t))

Rerunning step: (lemma "restrictmiddle_middle"
                 ("P" "i!3" "u" "i!2" "i" "i!1"))
Applying restrictmiddle_middle where 
  P gets i!3,
  u gets i!2,
  i gets i!1,
this simplifies to: 
authentication_middle.3.2.2 : 
;;; users maintain the rank function

{-1}  i!3 /= 2 =>
       (((Interleave! (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
            UROLE_MIDDLE(i!3, k, i!2, nnK))
          # R_middle(i!1))
         |> RankUser(rho_middle(i!1)))
  |-------
[1]   i!3 = 2
[2]   (((Interleave! (j: nat_1_to(i!3), nnJ: Nonces(i!3, i!2, j)):
           UROLE_MIDDLE(i!3, j, i!2, nnJ))
         # R_middle(i!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                (t))

Rerunning step: (grind :exclude ("rho_middle" "UROLE_MIDDLE"))
Interleave rewrites 
  (Interleave! (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
     UROLE_MIDDLE(i!3, k, i!2, nnK))
  to Par(emptyset)
         (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
            UROLE_MIDDLE(i!3, k, i!2, nnK))
# rewrites 
  (Par(emptyset)
      (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
         UROLE_MIDDLE(i!3, k, i!2, nnK))
    # R_middle(i!1))
  to Par(R_middle(i!1))
         (Par(emptyset)
             (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
                UROLE_MIDDLE(i!3, k, i!2, nnK)),
          Stop)
Par rewrites 
  Par(R_middle(i!1))
     (Par(emptyset)
         (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
            UROLE_MIDDLE(i!3, k, i!2, nnK)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
                       UROLE_MIDDLE(i!3, k, i!2, nnK)))),
             (t2: (Stop)):
        prod(R_middle(i!1))(t1, t2, x)
member rewrites 
  member(x,
         Par(R_middle(i!1))
            (Par(emptyset)
                (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
                   UROLE_MIDDLE(i!3, k, i!2, nnK)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
                       UROLE_MIDDLE(i!3, k, i!2, nnK)))),
             (t2: (Stop)):
        prod(R_middle(i!1))(t1, t2, x)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
RankUser rewrites RankUser(rho_middle(i!1))(x)
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))(x)
       IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
            (x)
member rewrites member(x, RankUser(rho_middle(i!1)))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))(x)
       IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
            (x)
subset? rewrites 
  subset?(Par(R_middle(i!1))
             (Par(emptyset)
                 (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
                    UROLE_MIDDLE(i!3, k, i!2, nnK)),
              Stop),
          RankUser(rho_middle(i!1)))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (k: nat_1_to(i!3),
                                nnK: Nonces(i!3, i!2, k)):
                          UROLE_MIDDLE(i!3, k, i!2, nnK)))),
                (t2: (Stop)):
           prod(R_middle(i!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (x)
          IMPLIES
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (x)
|> rewrites 
  (Par(R_middle(i!1))
      (Par(emptyset)
          (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
             UROLE_MIDDLE(i!3, k, i!2, nnK)),
       Stop)
    |> RankUser(rho_middle(i!1)))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (k: nat_1_to(i!3),
                                nnK: Nonces(i!3, i!2, k)):
                          UROLE_MIDDLE(i!3, k, i!2, nnK)))),
                (t2: (Stop)):
           prod(R_middle(i!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (x)
          IMPLIES
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (x)
Par rewrites 
  Par(R_middle(i!1))
     (Par(emptyset)
         (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
            UROLE_MIDDLE(i!3, k, i!2, nnK)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
                       UROLE_MIDDLE(i!3, k, i!2, nnK)))),
             (t2: (Stop)):
        prod(R_middle(i!1))(t1, t2, x)
member rewrites 
  member(x,
         Par(R_middle(i!1))
            (Par(emptyset)
                (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
                   UROLE_MIDDLE(i!3, k, i!2, nnK)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
                       UROLE_MIDDLE(i!3, k, i!2, nnK)))),
             (t2: (Stop)):
        prod(R_middle(i!1))(t1, t2, x)
member rewrites 
  member(x,
         LAMBDA (t: list[event]):
           every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                (t)
            =>
            every(LAMBDA (e: event):
                    NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                 (t))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))(x)
       =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
            (x)
subset? rewrites 
  subset?(Par(R_middle(i!1))
             (Par(emptyset)
                 (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
                    UROLE_MIDDLE(i!3, k, i!2, nnK)),
              Stop),
          LAMBDA (t: list[event]):
            every(LAMBDA (e: event):
                    rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                 (t)
             =>
             every(LAMBDA (e: event):
                     NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                  (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (k: nat_1_to(i!3),
                                nnK: Nonces(i!3, i!2, k)):
                          UROLE_MIDDLE(i!3, k, i!2, nnK)))),
                (t2: (Stop)):
           prod(R_middle(i!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (x)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (x)
|> rewrites 
  (Par(R_middle(i!1))
      (Par(emptyset)
          (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
             UROLE_MIDDLE(i!3, k, i!2, nnK)),
       Stop)
    |>
    LAMBDA (t: list[event]):
      every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))(t)
       =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
            (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (k: nat_1_to(i!3),
                                nnK: Nonces(i!3, i!2, k)):
                          UROLE_MIDDLE(i!3, k, i!2, nnK)))),
                (t2: (Stop)):
           prod(R_middle(i!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (x)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (x)
/= rewrites i!3 /= 2
  to NOT (i!3 = 2)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_middle.3.2.2.


This completes the proof of authentication_middle.3.2.


This completes the proof of authentication_middle.3.

authentication_middle.4 :  

  |-------
{1}   FORALL (e: (T)): NOT rho_middle(i!1)(msg(e))
[2]   network(USER) |> auth(T, R_middle(i!1))

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_middle.4 :  

  |-------
[1]   FORALL (e: (T)): NOT rho_middle(i!1)(msg(e))

Rerunning step: (comment "T is not in rho")
Adding comment: T is not in rho
this simplifies to: 
authentication_middle.4 : 
;;; T is not in rho

  |-------
[1]   FORALL (e: (T)): NOT rho_middle(i!1)(msg(e))

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
authentication_middle.4 : 
;;; T is not in rho

{-1}  T(e!1)
{-2}  rho_middle(i!1)(msg(e!1))
  |-------

Rerunning step: (expand "T")
Expanding the definition of T,
this simplifies to: 
authentication_middle.4 : 
;;; T is not in rho

{-1}  e!1 = signal(commit(0, hu_list, n_init))
[-2]  rho_middle(i!1)(msg(e!1))
  |-------

Rerunning step: (replace -1 -2)
Replacing using formula -1,
this simplifies to: 
authentication_middle.4 : 
;;; T is not in rho

[-1]  e!1 = signal(commit(0, hu_list, n_init))
{-2}  rho_middle(i!1)(msg(signal(commit(0, hu_list, n_init))))
  |-------

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
authentication_middle.4 : 
;;; T is not in rho

[-1]  rho_middle(i!1)(msg(signal(commit(0, hu_list, n_init))))
  |-------

Rerunning step: (grind)
rho_middle rewrites rho_middle(i!1)(commit(0, hu_list, n_init))
  to FALSE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_middle.4.

Q.E.D.


Run time  = 3.86 secs.
Real time = 4.86 secs.
nil
pvs(57): 
Installing rewrite rule sets.singleton_rew (all instances)
restrictlast_init :  

  |-------
{1}   FORALL (P: nat_from_2, u: Identity):
        ((Interleave! (nn0: Nonces(P, u, 0)): UROLE_INIT(P, u, nn0)) #
          R_last)
         |> RankUser(rho_last)

Rerunning step: (auto-rewrite-theory "sets")
Rewriting relative to the theory: sets,
this simplifies to: 
restrictlast_init :  

  |-------
[1]   FORALL (P: nat_from_2, u: Identity):
        ((Interleave! (nn0: Nonces(P, u, 0)): UROLE_INIT(P, u, nn0)) #
          R_last)
         |> RankUser(rho_last)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictlast_init :  

  |-------
{1}   ((Interleave! (nn0: Nonces(P!1, u!1, 0)): UROLE_INIT(P!1, u!1, nn0))
        # R_last)
       |> RankUser(rho_last)

Rerunning step: (expand "RankUser")
Expanding the definition of RankUser,
this simplifies to: 
restrictlast_init :  

  |-------
{1}   ((Interleave! (nn0: Nonces(P!1, u!1, 0)): UROLE_INIT(P!1, u!1, nn0))
        # R_last)
       |>
       LAMBDA (tr: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(tr) =>
          every(LAMBDA (e: event): complement(rec?)(e) => rho_last(msg(e)))
               (tr)

Rerunning step: (interleaving2)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
Applying interleaving rule,
this simplifies to: 
restrictlast_init :  

  |-------
{1}   UROLE_INIT(P!1, u!1, i!1) # R_last |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (expand "UROLE_INIT")
Expanding the definition of UROLE_INIT,
this simplifies to: 
restrictlast_init :  

  |-------
{1}   IF i!1 = n_init
        THEN Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
                      il:
                        {x: list[Identity] |
                           (length(x) = P!1 - 1) AND
                            FORALL (i: below[P!1 - 1]):
                              nth(x, i) = hu(1 + i)}):
               (trans(u!1, car(il),
                      E(public(car(il)),
                        conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
                 >>
                 (rec(u!1, nth(il, P!1 - 2),
                      E(public(u!1),
                        conc(nlist(cons(i!1, nl)), ilist(il))))
                   >>
                   (trans(u!1, car(il),
                          E(public(car(il)),
                            conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                     >>
                     (signal(commit(0, cons(u!1, il), i!1)) >>
                       Stop[event]))))
      ELSE Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
                    il: {x: list[Identity] | length(x) = P!1 - 1}):
             (trans(u!1, car(il),
                    E(public(car(il)),
                      conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
               >>
               (rec(u!1, nth(il, P!1 - 2),
                    E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
                 >>
                 (trans(u!1, car(il),
                        E(public(car(il)),
                          conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                   >>
                   (signal(commit(0, cons(u!1, il), i!1)) >>
                     Stop[event]))))
      ENDIF
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (lift-if)
Lifting IF-conditions to the top level,
this simplifies to: 
restrictlast_init :  

  |-------
{1}   IF i!1 = n_init
        THEN Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
                      il:
                        {x: list[Identity] |
                           (length(x) = P!1 - 1) AND
                            FORALL (i: below[P!1 - 1]):
                              nth(x, i) = hu(1 + i)}):
               (trans(u!1, car(il),
                      E(public(car(il)),
                        conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
                 >>
                 (rec(u!1, nth(il, P!1 - 2),
                      E(public(u!1),
                        conc(nlist(cons(i!1, nl)), ilist(il))))
                   >>
                   (trans(u!1, car(il),
                          E(public(car(il)),
                            conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                     >>
                     (signal(commit(0, cons(u!1, il), i!1)) >>
                       Stop[event]))))
              # R_last
              |>
              LAMBDA (t: list[event]):
                every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
                 every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))
                      (t)
      ELSE Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
                    il: {x: list[Identity] | length(x) = P!1 - 1}):
             (trans(u!1, car(il),
                    E(public(car(il)),
                      conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
               >>
               (rec(u!1, nth(il, P!1 - 2),
                    E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
                 >>
                 (trans(u!1, car(il),
                        E(public(car(il)),
                          conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                   >>
                   (signal(commit(0, cons(u!1, il), i!1)) >>
                     Stop[event]))))
            # R_last
            |>
            LAMBDA (t: list[event]):
              every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
               every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
      ENDIF

Rerunning step: (prop)
Applying propositional simplification,
this yields  2 subgoals: 
restrictlast_init.1 :  

{-1}  i!1 = n_init
  |-------
{1}   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1) AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
              >> (signal(commit(0, cons(u!1, il), i!1)) >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (typepred "p")
Adding type constraints for  p,
this simplifies to: 
restrictlast_init.1 :  

{-1}  2 <= p
[-2]  i!1 = n_init
  |-------
[1]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1) AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
              >> (signal(commit(0, cons(u!1, il), i!1)) >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (choice3)
Applying choice rule,
this yields  12 subgoals: 
restrictlast_init.1.1 :  

[-1]  2 <= p
[-2]  i!1 = n_init
  |-------
{1}   (trans(u!1, car(i!2`2),
             E(public(car(i!2`2)),
               conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))
        >>
        (rec(u!1, nth(i!2`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
          >>
          (trans(u!1, car(i!2`2),
                 E(public(car(i!2`2)),
                   conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
            >> (signal(commit(0, cons(u!1, i!2`2), i!1)) >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (comment "establish obvious equalities")
Adding comment: establish obvious equalities
this simplifies to: 
restrictlast_init.1.1 : 
;;; establish obvious equalities

[-1]  2 <= p
[-2]  i!1 = n_init
  |-------
[1]   (trans(u!1, car(i!2`2),
             E(public(car(i!2`2)),
               conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))
        >>
        (rec(u!1, nth(i!2`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
          >>
          (trans(u!1, car(i!2`2),
                 E(public(car(i!2`2)),
                   conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
            >> (signal(commit(0, cons(u!1, i!2`2), i!1)) >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (case "u!1 = hu(0) AND p = P!1")
Case splitting on 
   u!1 = hu(0) AND p = P!1, 
this yields  3 subgoals: 
restrictlast_init.1.1.1 : 
;;; establish obvious equalities

{-1}  u!1 = hu(0) AND p = P!1
[-2]  2 <= p
[-3]  i!1 = n_init
  |-------
[1]   (trans(u!1, car(i!2`2),
             E(public(car(i!2`2)),
               conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))
        >>
        (rec(u!1, nth(i!2`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
          >>
          (trans(u!1, car(i!2`2),
                 E(public(car(i!2`2)),
                   conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
            >> (signal(commit(0, cons(u!1, i!2`2), i!1)) >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictlast_init.1.1.1 : 
;;; establish obvious equalities

{-1}  u!1 = hu(0)
{-2}  p = P!1
[-3]  2 <= p
[-4]  i!1 = n_init
  |-------
[1]   (trans(u!1, car(i!2`2),
             E(public(car(i!2`2)),
               conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))
        >>
        (rec(u!1, nth(i!2`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
          >>
          (trans(u!1, car(i!2`2),
                 E(public(car(i!2`2)),
                   conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
            >> (signal(commit(0, cons(u!1, i!2`2), i!1)) >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictlast_init.1.1.1 : 
;;; establish obvious equalities

[-1]  u!1 = hu(0)
[-2]  p = P!1
[-3]  2 <= p
[-4]  i!1 = n_init
  |-------
{1}   (trans(hu(0), car(i!2`2),
             E(public(car(i!2`2)),
               conc(nlist((: i!1 :)), ilist(cons(hu(0), cdr(i!2`2))))))
        >>
        (rec(hu(0), nth(i!2`2, P!1 - 2),
             E(public(hu(0)), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
          >>
          (trans(hu(0), car(i!2`2),
                 E(public(car(i!2`2)),
                   conc(ilist(cons(hu(0), cdr(i!2`2))), nlist(i!2`1))))
            >>
            (signal(commit(0, cons(hu(0), i!2`2), i!1)) >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (replace -2 1 rl)
Replacing using formula -2,
this simplifies to: 
restrictlast_init.1.1.1 : 
;;; establish obvious equalities

[-1]  u!1 = hu(0)
[-2]  p = P!1
[-3]  2 <= p
[-4]  i!1 = n_init
  |-------
{1}   (trans(hu(0), car(i!2`2),
             E(public(car(i!2`2)),
               conc(nlist((: i!1 :)), ilist(cons(hu(0), cdr(i!2`2))))))
        >>
        (rec(hu(0), nth(i!2`2, p - 2),
             E(public(hu(0)), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
          >>
          (trans(hu(0), car(i!2`2),
                 E(public(car(i!2`2)),
                   conc(ilist(cons(hu(0), cdr(i!2`2))), nlist(i!2`1))))
            >>
            (signal(commit(0, cons(hu(0), i!2`2), i!1)) >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (replace -4 1)
Replacing using formula -4,
this simplifies to: 
restrictlast_init.1.1.1 : 
;;; establish obvious equalities

[-1]  u!1 = hu(0)
[-2]  p = P!1
[-3]  2 <= p
[-4]  i!1 = n_init
  |-------
{1}   (trans(hu(0), car(i!2`2),
             E(public(car(i!2`2)),
               conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!2`2))))))
        >>
        (rec(hu(0), nth(i!2`2, p - 2),
             E(public(hu(0)),
               conc(nlist(cons(n_init, i!2`1)), ilist(i!2`2))))
          >>
          (trans(hu(0), car(i!2`2),
                 E(public(car(i!2`2)),
                   conc(ilist(cons(hu(0), cdr(i!2`2))), nlist(i!2`1))))
            >>
            (signal(commit(0, cons(hu(0), i!2`2), n_init)) >>
              Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete -1 -4)
Deleting some formulas,
this simplifies to: 
restrictlast_init.1.1.1 : 
;;; establish obvious equalities

[-1]  p = P!1
[-2]  2 <= p
  |-------
[1]   (trans(hu(0), car(i!2`2),
             E(public(car(i!2`2)),
               conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!2`2))))))
        >>
        (rec(hu(0), nth(i!2`2, p - 2),
             E(public(hu(0)),
               conc(nlist(cons(n_init, i!2`1)), ilist(i!2`2))))
          >>
          (trans(hu(0), car(i!2`2),
                 E(public(car(i!2`2)),
                   conc(ilist(cons(hu(0), cdr(i!2`2))), nlist(i!2`1))))
            >>
            (signal(commit(0, cons(hu(0), i!2`2), n_init)) >>
              Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictlast_init.1.1.1.1 : 
;;; establish obvious equalities

[-1]  p = P!1
[-2]  2 <= p
  |-------
{1}   rho_last(E(public(car(i!2`2)),
                 conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!2`2))))))
{2}   R_last(trans(hu(0), car(i!2`2),
                   E(public(car(i!2`2)),
                     conc(nlist((: n_init :)),
                          ilist(cons(hu(0), cdr(i!2`2)))))))
{3}   trans(hu(0), car(i!2`2),
            E(public(car(i!2`2)),
              conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!2`2))))))
       >>
       ((rec(hu(0), nth(i!2`2, p - 2),
             E(public(hu(0)),
               conc(nlist(cons(n_init, i!2`1)), ilist(i!2`2))))
          >>
          (trans(hu(0), car(i!2`2),
                 E(public(car(i!2`2)),
                   conc(ilist(cons(hu(0), cdr(i!2`2))), nlist(i!2`1))))
            >>
            (signal(commit(0, cons(hu(0), i!2`2), n_init)) >>
              Stop[event])))
         # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_init.1.1.1.1 : 
;;; establish obvious equalities

[-1]  p = P!1
[-2]  2 <= p
  |-------
[1]   rho_last(E(public(car(i!2`2)),
                 conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!2`2))))))

Rerunning step: (grind :if-match nil)
E rewrites 
  E(public(car(i!2`2)),
    conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!2`2)))))
  to code(public(car(i!2`2)),
           conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!2`2)))))
elt rewrites elt((: n_init :), n_init)
  to EXISTS (i: below[length((: n_init :))]): nth((: n_init :), i) = n_init
rho_last rewrites rho_last(nlist((: n_init :)))
  to NOT EXISTS (i: below[length((: n_init :))]):
            nth((: n_init :), i) = n_init
rho_last rewrites rho_last(ilist(cons(hu(0), cdr(i!2`2))))
  to TRUE
rho_last rewrites 
  rho_last(conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!2`2)))))
  to NOT EXISTS (i: below[length((: n_init :))]):
            nth((: n_init :), i) = n_init
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_last rewrites 
  rho_last(code(public(car(i!2`2)),
                conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!2`2))))))
  to NOT EXISTS (i: below[length((: n_init :))]):
            nth((: n_init :), i) = n_init
       OR
       EXISTS (i: {x: nat | 0 < x AND x < p}):
         public(car(i!2`2)) = public(hu(i)) AND
          EXISTS (l: {x: list[Nonce] | length(x) = i - 1}):
            conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!2`2)))) =
             conc(nlist(cons(n_init, l)),
                  ilist(cons(car(hu_list), remove(cdr(hu_list), i - 1))))
length rewrites length((: :))
  to 0
length rewrites length((: n_init :))
  to 1
nth rewrites nth((: n_init :), i!3)
  to n_init
Trying repeated skolemization, instantiation, and if-lifting,
this simplifies to: 
restrictlast_init.1.1.1.1 : 
;;; establish obvious equalities

{-1}  i!3 < 1
[-2]  p = P!1
{-3}  2 <= P!1
  |-------
{1}   EXISTS (i: {x: nat | 0 < x AND x < p}):
        public(car(i!2`2)) = public(hu(i)) AND
         EXISTS (l: {x: list[Nonce] | length(x) = i - 1}):
           conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!2`2)))) =
            conc(nlist(cons(n_init, l)),
                 ilist(cons(car(hu_list), remove(cdr(hu_list), i - 1))))

Rerunning step: (comment "hu(0) sends a message (that is `escaped' in rho) to hu(1)")
Adding comment: hu(0) sends a message (that is `escaped' in rho) to hu(1)
this simplifies to: 
restrictlast_init.1.1.1.1 : 
;;; hu(0) sends a message (that is `escaped' in rho) to hu(1)

[-1]  i!3 < 1
[-2]  p = P!1
[-3]  2 <= P!1
  |-------
[1]   EXISTS (i: {x: nat | 0 < x AND x < p}):
        public(car(i!2`2)) = public(hu(i)) AND
         EXISTS (l: {x: list[Nonce] | length(x) = i - 1}):
           conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!2`2)))) =
            conc(nlist(cons(n_init, l)),
                 ilist(cons(car(hu_list), remove(cdr(hu_list), i - 1))))

Rerunning step: (inst 1 "1")
Instantiating the top quantifier in 1 with the terms: 
 1,
this simplifies to: 
restrictlast_init.1.1.1.1 : 
;;; hu(0) sends a message (that is `escaped' in rho) to hu(1)

[-1]  i!3 < 1
[-2]  p = P!1
[-3]  2 <= P!1
  |-------
{1}   public(car(i!2`2)) = public(hu(1)) AND
       EXISTS (l: {x: list[Nonce] | length(x) = 0}):
         conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!2`2)))) =
          conc(nlist(cons(n_init, l)),
               ilist(cons(car(hu_list), remove(cdr(hu_list), 1 - 1))))

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
restrictlast_init.1.1.1.1.1 : 
;;; hu(0) sends a message (that is `escaped' in rho) to hu(1)

[-1]  i!3 < 1
[-2]  p = P!1
[-3]  2 <= P!1
  |-------
{1}   public(car(i!2`2)) = public(hu(1))

Rerunning step: (comment "prove that the intended recipient is 1")
Adding comment: prove that the intended recipient is 1
this simplifies to: 
restrictlast_init.1.1.1.1.1 : 
;;; prove that the intended recipient is 1

[-1]  i!3 < 1
[-2]  p = P!1
[-3]  2 <= P!1
  |-------
[1]   public(car(i!2`2)) = public(hu(1))

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictlast_init.1.1.1.1.1 : 
;;; prove that the intended recipient is 1

[-1]  i!3 < 1
[-2]  p = P!1
[-3]  2 <= P!1
  |-------
{1}   car(i!2`2) = hu(1)

Rerunning step: (typepred "i!2`2")
Adding type constraints for  i!2`2,
this simplifies to: 
restrictlast_init.1.1.1.1.1 : 
;;; prove that the intended recipient is 1

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`2)
{-2}  (length(i!2`2) = P!1 - 1)
{-3}  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(1 + i)
[-4]  i!3 < 1
[-5]  p = P!1
[-6]  2 <= P!1
  |-------
[1]   car(i!2`2) = hu(1)

Rerunning step: (delete -1 -2 -4 -5 -6)
Deleting some formulas,
this simplifies to: 
restrictlast_init.1.1.1.1.1 : 
;;; prove that the intended recipient is 1

[-1]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(1 + i)
  |-------
[1]   car(i!2`2) = hu(1)

Rerunning step: (inst -1 "0")
Instantiating the top quantifier in -1 with the terms: 
 0,
this simplifies to: 
restrictlast_init.1.1.1.1.1 : 
;;; prove that the intended recipient is 1

{-1}  nth(i!2`2, 0) = hu(1 + 0)
  |-------
[1]   car(i!2`2) = hu(1)

Rerunning step: (grind)
nth rewrites nth(i!2`2, 0)
  to car(i!2`2)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictlast_init.1.1.1.1.1.

restrictlast_init.1.1.1.1.2 : 
;;; hu(0) sends a message (that is `escaped' in rho) to hu(1)

[-1]  i!3 < 1
[-2]  p = P!1
[-3]  2 <= P!1
  |-------
{1}   EXISTS (l: {x: list[Nonce] | length(x) = 0}):
        conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!2`2)))) =
         conc(nlist(cons(n_init, l)),
              ilist(cons(car(hu_list), remove(cdr(hu_list), 1 - 1))))

Rerunning step: (comment "prove that the message has the right structure")
Adding comment: prove that the message has the right structure
this simplifies to: 
restrictlast_init.1.1.1.1.2 : 
;;; prove that the message has the right structure

[-1]  i!3 < 1
[-2]  p = P!1
[-3]  2 <= P!1
  |-------
[1]   EXISTS (l: {x: list[Nonce] | length(x) = 0}):
        conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!2`2)))) =
         conc(nlist(cons(n_init, l)),
              ilist(cons(car(hu_list), remove(cdr(hu_list), 1 - 1))))

Rerunning step: (inst 1 "null")
length rewrites length[Nonce](null[Nonce])
  to 0
Instantiating the top quantifier in 1 with the terms: 
 null,
this simplifies to: 
restrictlast_init.1.1.1.1.2 : 
;;; prove that the message has the right structure

[-1]  i!3 < 1
[-2]  p = P!1
[-3]  2 <= P!1
  |-------
{1}   conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!2`2)))) =
       conc(nlist(cons(n_init, null)),
            ilist(cons(car(hu_list), remove(cdr(hu_list), 1 - 1))))

Rerunning step: (decompose-equality 1)
remove rewrites remove(cdr(hu_list), 0)
  to cdr(cdr(hu_list))
Applying decompose-equality,
this simplifies to: 
restrictlast_init.1.1.1.1.2 : 
;;; prove that the message has the right structure

[-1]  i!3 < 1
[-2]  p = P!1
[-3]  2 <= P!1
  |-------
{1}   ilist(cons(hu(0), cdr(i!2`2))) =
       ilist(cons(car(hu_list), cdr(cdr(hu_list))))

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictlast_init.1.1.1.1.2 : 
;;; prove that the message has the right structure

[-1]  i!3 < 1
[-2]  p = P!1
[-3]  2 <= P!1
  |-------
{1}   cons(hu(0), cdr(i!2`2)) = cons(car(hu_list), cdr(cdr(hu_list)))

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this yields  2 subgoals: 
restrictlast_init.1.1.1.1.2.1 : 
;;; prove that the message has the right structure

[-1]  i!3 < 1
[-2]  p = P!1
[-3]  2 <= P!1
  |-------
{1}   hu(0) = car(hu_list)

Rerunning step: (typepred "hu_list")
Adding type constraints for  hu_list,
this simplifies to: 
restrictlast_init.1.1.1.1.2.1 : 
;;; prove that the message has the right structure

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-2}  (length(hu_list) = p)
{-3}  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-4]  i!3 < 1
[-5]  p = P!1
[-6]  2 <= P!1
  |-------
[1]   hu(0) = car(hu_list)

Rerunning step: (delete -1 -2 -4 -5 -6)
Deleting some formulas,
this simplifies to: 
restrictlast_init.1.1.1.1.2.1 : 
;;; prove that the message has the right structure

[-1]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
  |-------
[1]   hu(0) = car(hu_list)

Rerunning step: (inst -1 "0")
Instantiating the top quantifier in -1 with the terms: 
 0,
this simplifies to: 
restrictlast_init.1.1.1.1.2.1 : 
;;; prove that the message has the right structure

{-1}  nth(hu_list, 0) = hu(0)
  |-------
[1]   hu(0) = car(hu_list)

Rerunning step: (grind)
nth rewrites nth(hu_list, 0)
  to car(hu_list)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictlast_init.1.1.1.1.2.1.

restrictlast_init.1.1.1.1.2.2 : 
;;; prove that the message has the right structure

[-1]  i!3 < 1
[-2]  p = P!1
[-3]  2 <= P!1
  |-------
{1}   cdr(i!2`2) = cdr(cdr(hu_list))

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictlast_init.1.1.1.1.2.2 : 
;;; prove that the message has the right structure

[-1]  p = P!1
[-2]  2 <= P!1
  |-------
[1]   cdr(i!2`2) = cdr(cdr(hu_list))

Rerunning step: (comment "prove that the two lists are equal by showing that their lengths and elements are equal")
Adding comment: prove that the two lists are equal by showing that their lengths and elements are equal
this simplifies to: 
restrictlast_init.1.1.1.1.2.2 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  p = P!1
[-2]  2 <= P!1
  |-------
[1]   cdr(i!2`2) = cdr(cdr(hu_list))

Rerunning step: (typepred "i!2`2" "hu_list")
Adding type constraints for  i!2`2, hu_list,
this simplifies to: 
restrictlast_init.1.1.1.1.2.2 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`2)
{-2}  (length(i!2`2) = P!1 - 1)
{-3}  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(1 + i)
{-4}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-5}  (length(hu_list) = p)
{-6}  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  p = P!1
[-8]  2 <= P!1
  |-------
[1]   cdr(i!2`2) = cdr(cdr(hu_list))

Rerunning step: (delete -1 -4)
Deleting some formulas,
this simplifies to: 
restrictlast_init.1.1.1.1.2.2 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  (length(i!2`2) = P!1 - 1)
[-2]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(1 + i)
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  p = P!1
[-6]  2 <= P!1
  |-------
[1]   cdr(i!2`2) = cdr(cdr(hu_list))

Rerunning step: (rewrite "length_nth_equality[Identity]")
Found matching substitution:
l2: list[Identity] gets cdr(cdr(hu_list)),
l1: list[Identity] gets cdr(i!2`2),
Rewriting using length_nth_equality[Identity], matching in *,
this yields  2 subgoals: 
restrictlast_init.1.1.1.1.2.2.1 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  (length(i!2`2) = P!1 - 1)
[-2]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(1 + i)
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  p = P!1
[-6]  2 <= P!1
  |-------
{1}   length[Identity](cdr(i!2`2)) = length[Identity](cdr(cdr(hu_list)))
[2]   cdr(i!2`2) = cdr(cdr(hu_list))

Rerunning step: (delete -2 -4 -6 2)
Deleting some formulas,
this simplifies to: 
restrictlast_init.1.1.1.1.2.2.1 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  (length(i!2`2) = P!1 - 1)
[-2]  (length(hu_list) = p)
[-3]  p = P!1
  |-------
[1]   length[Identity](cdr(i!2`2)) = length[Identity](cdr(cdr(hu_list)))

Rerunning step: (rewrite "length_cdr")
Found matching substitution:
cons_l: (cons?[T]) gets i!2`2,
Rewriting using length_cdr, matching in *,
this simplifies to: 
restrictlast_init.1.1.1.1.2.2.1 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  (length(i!2`2) = P!1 - 1)
[-2]  (length(hu_list) = p)
[-3]  p = P!1
  |-------
{1}   length(i!2`2) - 1 = length[Identity](cdr(cdr(hu_list)))

Rerunning step: (rewrite "length_cdr")
Found matching substitution:
cons_l: (cons?[T]) gets cdr(hu_list),
Rewriting using length_cdr, matching in *,
this simplifies to: 
restrictlast_init.1.1.1.1.2.2.1 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  (length(i!2`2) = P!1 - 1)
[-2]  (length(hu_list) = p)
[-3]  p = P!1
  |-------
{1}   length(i!2`2) - 1 = length(cdr(hu_list)) - 1

Rerunning step: (rewrite "length_cdr")
Found matching substitution:
cons_l: (cons?[T]) gets hu_list,
Rewriting using length_cdr, matching in *,
this simplifies to: 
restrictlast_init.1.1.1.1.2.2.1 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  (length(i!2`2) = P!1 - 1)
[-2]  (length(hu_list) = p)
[-3]  p = P!1
  |-------
{1}   length(i!2`2) - 1 = length(hu_list) - 1 - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_init.1.1.1.1.2.2.1.

restrictlast_init.1.1.1.1.2.2.2 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  (length(i!2`2) = P!1 - 1)
[-2]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(1 + i)
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  p = P!1
[-6]  2 <= P!1
  |-------
{1}   FORALL (i: below[length[Identity](cdr(i!2`2))]):
        nth(cdr(i!2`2), i) = nth(cdr(cdr(hu_list)), i)
[2]   cdr(i!2`2) = cdr(cdr(hu_list))

Rerunning step: (delete -3 -6 2)
Deleting some formulas,
this simplifies to: 
restrictlast_init.1.1.1.1.2.2.2 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  (length(i!2`2) = P!1 - 1)
[-2]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(1 + i)
[-3]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-4]  p = P!1
  |-------
[1]   FORALL (i: below[length[Identity](cdr(i!2`2))]):
        nth(cdr(i!2`2), i) = nth(cdr(cdr(hu_list)), i)

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictlast_init.1.1.1.1.2.2.2 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

{-1}  i!4 < length[Identity](cdr(i!2`2))
[-2]  (length(i!2`2) = P!1 - 1)
[-3]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(1 + i)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  p = P!1
  |-------
{1}   nth(cdr(i!2`2), i!4) = nth(cdr(cdr(hu_list)), i!4)

Rerunning step: (inst -3 "i!4+1")
Instantiating the top quantifier in -3 with the terms: 
 i!4+1,
this yields  2 subgoals: 
restrictlast_init.1.1.1.1.2.2.2.1 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  i!4 < length[Identity](cdr(i!2`2))
[-2]  (length(i!2`2) = P!1 - 1)
{-3}  nth(i!2`2, i!4 + 1) = hu(1 + (i!4 + 1))
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  p = P!1
  |-------
[1]   nth(cdr(i!2`2), i!4) = nth(cdr(cdr(hu_list)), i!4)

Rerunning step: (inst -4 "i!4+2")
Instantiating the top quantifier in -4 with the terms: 
 i!4+2,
this yields  2 subgoals: 
restrictlast_init.1.1.1.1.2.2.2.1.1 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  i!4 < length[Identity](cdr(i!2`2))
[-2]  (length(i!2`2) = P!1 - 1)
[-3]  nth(i!2`2, i!4 + 1) = hu(1 + (i!4 + 1))
{-4}  nth(hu_list, i!4 + 2) = hu(i!4 + 2)
[-5]  p = P!1
  |-------
[1]   nth(cdr(i!2`2), i!4) = nth(cdr(cdr(hu_list)), i!4)

Rerunning step: (delete -1 -2)
Deleting some formulas,
this simplifies to: 
restrictlast_init.1.1.1.1.2.2.2.1.1 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  nth(i!2`2, i!4 + 1) = hu(1 + (i!4 + 1))
[-2]  nth(hu_list, i!4 + 2) = hu(i!4 + 2)
[-3]  p = P!1
  |-------
[1]   nth(cdr(i!2`2), i!4) = nth(cdr(cdr(hu_list)), i!4)

Rerunning step: (grind)
nth rewrites nth(i!2`2, 1 + i!4)
  to nth(cdr(i!2`2), i!4)
nth rewrites nth(cdr(hu_list), 1 + i!4)
  to nth(cdr(cdr(hu_list)), i!4)
nth rewrites nth(hu_list, 2 + i!4)
  to nth(cdr(cdr(hu_list)), i!4)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictlast_init.1.1.1.1.2.2.2.1.1.

restrictlast_init.1.1.1.1.2.2.2.1.2 (TCC):   

[-1]  i!4 < length[Identity](cdr(i!2`2))
[-2]  (length(i!2`2) = P!1 - 1)
[-3]  nth(i!2`2, i!4 + 1) = hu(1 + (i!4 + 1))
[-4]  p = P!1
  |-------
{1}   2 + i!4 < p
[2]   nth(cdr(i!2`2), i!4) = nth(cdr(cdr(hu_list)), i!4)

Rerunning step: (delete -3 2)
Deleting some formulas,
this simplifies to: 
restrictlast_init.1.1.1.1.2.2.2.1.2 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  i!4 < length[Identity](cdr(i!2`2))
[-2]  (length(i!2`2) = P!1 - 1)
[-3]  p = P!1
  |-------
[1]   2 + i!4 < p

Rerunning step: (rewrite "length_cdr")
Found matching substitution:
cons_l: (cons?[T]) gets i!2`2,
Rewriting using length_cdr, matching in *,
this simplifies to: 
restrictlast_init.1.1.1.1.2.2.2.1.2 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

{-1}  i!4 < length(i!2`2) - 1
[-2]  (length(i!2`2) = P!1 - 1)
[-3]  p = P!1
  |-------
[1]   2 + i!4 < p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_init.1.1.1.1.2.2.2.1.2.


This completes the proof of restrictlast_init.1.1.1.1.2.2.2.1.

restrictlast_init.1.1.1.1.2.2.2.2 (TCC):   

[-1]  i!4 < length[Identity](cdr(i!2`2))
[-2]  (length(i!2`2) = P!1 - 1)
[-3]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-4]  p = P!1
  |-------
{1}   1 + i!4 < P!1 - 1
[2]   nth(cdr(i!2`2), i!4) = nth(cdr(cdr(hu_list)), i!4)

Rerunning step: (delete -3 2)
Deleting some formulas,
this simplifies to: 
restrictlast_init.1.1.1.1.2.2.2.2 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

[-1]  i!4 < length[Identity](cdr(i!2`2))
[-2]  (length(i!2`2) = P!1 - 1)
[-3]  p = P!1
  |-------
[1]   1 + i!4 < P!1 - 1

Rerunning step: (rewrite "length_cdr")
Found matching substitution:
cons_l: (cons?[T]) gets i!2`2,
Rewriting using length_cdr, matching in *,
this simplifies to: 
restrictlast_init.1.1.1.1.2.2.2.2 : 
;;; prove that the two lists are equal by showing that their lengths and elements are equal

{-1}  i!4 < length(i!2`2) - 1
[-2]  (length(i!2`2) = P!1 - 1)
[-3]  p = P!1
  |-------
[1]   1 + i!4 < P!1 - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_init.1.1.1.1.2.2.2.2.


This completes the proof of restrictlast_init.1.1.1.1.2.2.2.


This completes the proof of restrictlast_init.1.1.1.1.2.2.


This completes the proof of restrictlast_init.1.1.1.1.2.


This completes the proof of restrictlast_init.1.1.1.1.

restrictlast_init.1.1.1.2 : 
;;; establish obvious equalities

[-1]  p = P!1
[-2]  2 <= p
  |-------
{1}   ((rec(hu(0), nth(i!2`2, p - 2),
            E(public(hu(0)),
              conc(nlist(cons(n_init, i!2`1)), ilist(i!2`2))))
         >>
         (trans(hu(0), car(i!2`2),
                E(public(car(i!2`2)),
                  conc(ilist(cons(hu(0), cdr(i!2`2))), nlist(i!2`1))))
           >>
           (signal(commit(0, cons(hu(0), i!2`2), n_init)) >> Stop[event])))
        # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
{2}   R_last(trans(hu(0), car(i!2`2),
                   E(public(car(i!2`2)),
                     conc(nlist((: n_init :)),
                          ilist(cons(hu(0), cdr(i!2`2)))))))
{3}   trans(hu(0), car(i!2`2),
            E(public(car(i!2`2)),
              conc(nlist((: n_init :)), ilist(cons(hu(0), cdr(i!2`2))))))
       >>
       ((rec(hu(0), nth(i!2`2, p - 2),
             E(public(hu(0)),
               conc(nlist(cons(n_init, i!2`1)), ilist(i!2`2))))
          >>
          (trans(hu(0), car(i!2`2),
                 E(public(car(i!2`2)),
                   conc(ilist(cons(hu(0), cdr(i!2`2))), nlist(i!2`1))))
            >>
            (signal(commit(0, cons(hu(0), i!2`2), n_init)) >>
              Stop[event])))
         # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_init.1.1.1.2 : 
;;; establish obvious equalities

[-1]  p = P!1
[-2]  2 <= p
  |-------
[1]   ((rec(hu(0), nth(i!2`2, p - 2),
            E(public(hu(0)),
              conc(nlist(cons(n_init, i!2`1)), ilist(i!2`2))))
         >>
         (trans(hu(0), car(i!2`2),
                E(public(car(i!2`2)),
                  conc(ilist(cons(hu(0), cdr(i!2`2))), nlist(i!2`1))))
           >>
           (signal(commit(0, cons(hu(0), i!2`2), n_init)) >> Stop[event])))
        # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictlast_init.1.1.1.2 : 
;;; establish obvious equalities

{-1}  rho_last(E(public(hu(0)),
                 conc(nlist(cons(n_init, i!2`1)), ilist(i!2`2))))
[-2]  p = P!1
[-3]  2 <= p
  |-------
{1}   ((trans(hu(0), car(i!2`2),
              E(public(car(i!2`2)),
                conc(ilist(cons(hu(0), cdr(i!2`2))), nlist(i!2`1))))
         >> (signal(commit(0, cons(hu(0), i!2`2), n_init)) >> Stop[event]))
        # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
{2}   R_last(rec(hu(0), nth(i!2`2, p - 2),
                 E(public(hu(0)),
                   conc(nlist(cons(n_init, i!2`1)), ilist(i!2`2)))))
{3}   rec(hu(0), nth(i!2`2, p - 2),
          E(public(hu(0)), conc(nlist(cons(n_init, i!2`1)), ilist(i!2`2))))
       >>
       ((trans(hu(0), car(i!2`2),
               E(public(car(i!2`2)),
                 conc(ilist(cons(hu(0), cdr(i!2`2))), nlist(i!2`1))))
          >>
          (signal(commit(0, cons(hu(0), i!2`2), n_init)) >> Stop[event]))
         # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete -2 -3 +)
Deleting some formulas,
this simplifies to: 
restrictlast_init.1.1.1.2 : 
;;; establish obvious equalities

[-1]  rho_last(E(public(hu(0)),
                 conc(nlist(cons(n_init, i!2`1)), ilist(i!2`2))))
  |-------

Rerunning step: (comment "-1 evaluates to false")
Adding comment: -1 evaluates to false
this simplifies to: 
restrictlast_init.1.1.1.2 : 
;;; -1 evaluates to false

[-1]  rho_last(E(public(hu(0)),
                 conc(nlist(cons(n_init, i!2`1)), ilist(i!2`2))))
  |-------

Rerunning step: (grind :if-match nil)
E rewrites E(public(hu(0)), conc(nlist(cons(n_init, i!2`1)), ilist(i!2`2)))
  to code(public(hu(0)), conc(nlist(cons(n_init, i!2`1)), ilist(i!2`2)))
elt rewrites elt(cons(n_init, i!2`1), n_init)
  to EXISTS (i: below[length(cons(n_init, i!2`1))]):
        nth(cons(n_init, i!2`1), i) = n_init
rho_last rewrites rho_last(nlist(cons(n_init, i!2`1)))
  to NOT EXISTS (i: below[length(cons(n_init, i!2`1))]):
            nth(cons(n_init, i!2`1), i) = n_init
rho_last rewrites rho_last(ilist(i!2`2))
  to TRUE
rho_last rewrites rho_last(conc(nlist(cons(n_init, i!2`1)), ilist(i!2`2)))
  to NOT EXISTS (i: below[length(cons(n_init, i!2`1))]):
            nth(cons(n_init, i!2`1), i) = n_init
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_last rewrites 
  rho_last(code(public(hu(0)),
                conc(nlist(cons(n_init, i!2`1)), ilist(i!2`2))))
  to NOT EXISTS (i: below[length(cons(n_init, i!2`1))]):
            nth(cons(n_init, i!2`1), i) = n_init
       OR
       EXISTS (i: {x: nat | 0 < x AND x < p}):
         public(hu(0)) = public(hu(i)) AND
          EXISTS (l: {x: list[Nonce] | length(x) = i - 1}):
            conc(nlist(cons(n_init, i!2`1)), ilist(i!2`2)) =
             conc(nlist(cons(n_init, l)),
                  ilist(cons(car(hu_list), remove(cdr(hu_list), i - 1))))
Trying repeated skolemization, instantiation, and if-lifting,
this yields  2 subgoals: 
restrictlast_init.1.1.1.2.1 : 
;;; -1 evaluates to false

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
{-2}  length(l!1) = i!3 - 1
{-3}  0 < i!3
{-4}  i!3 < p
{-5}  public(hu(0)) = public(hu(i!3))
{-6}  conc(nlist(cons(n_init, i!2`1)), ilist(i!2`2)) =
       conc(nlist(cons(n_init, l!1)),
            ilist(cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))))
  |-------

Rerunning step: (comment "contradiction in terms -3 and -5")
Adding comment: contradiction in terms -3 and -5
this simplifies to: 
restrictlast_init.1.1.1.2.1 : 
;;; contradiction in terms -3 and -5

[-1]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
[-2]  length(l!1) = i!3 - 1
[-3]  0 < i!3
[-4]  i!3 < p
[-5]  public(hu(0)) = public(hu(i!3))
[-6]  conc(nlist(cons(n_init, i!2`1)), ilist(i!2`2)) =
       conc(nlist(cons(n_init, l!1)),
            ilist(cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))))
  |-------

Rerunning step: (delete -1 -2 -4 -6)
Deleting some formulas,
this simplifies to: 
restrictlast_init.1.1.1.2.1 : 
;;; contradiction in terms -3 and -5

[-1]  0 < i!3
[-2]  public(hu(0)) = public(hu(i!3))
  |-------

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictlast_init.1.1.1.2.1 : 
;;; contradiction in terms -3 and -5

{-1}  hu(0) = hu(i!3)
[-2]  0 < i!3
  |-------

Rerunning step: (typepred "hu")
Adding type constraints for  hu,
this simplifies to: 
restrictlast_init.1.1.1.2.1 : 
;;; contradiction in terms -3 and -5

{-1}  FORALL (i, j: nat_to_p): i /= j IMPLIES hu(i) /= hu(j)
[-2]  hu(0) = hu(i!3)
[-3]  0 < i!3
  |-------

Rerunning step: (inst -1 "0" "i!3")
Instantiating the top quantifier in -1 with the terms: 
 0, i!3,
this simplifies to: 
restrictlast_init.1.1.1.2.1 : 
;;; contradiction in terms -3 and -5

{-1}  0 /= i!3 IMPLIES hu(0) /= hu(i!3)
[-2]  hu(0) = hu(i!3)
[-3]  0 < i!3
  |-------

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_init.1.1.1.2.1.

restrictlast_init.1.1.1.2.2 : 
;;; -1 evaluates to false

  |-------
{1}   EXISTS (i: below[length(cons(n_init, i!2`1))]):
        nth(cons(n_init, i!2`1), i) = n_init

Rerunning step: (comment "consequent 1 was a negated antecedent")
Adding comment: consequent 1 was a negated antecedent
this simplifies to: 
restrictlast_init.1.1.1.2.2 : 
;;; consequent 1 was a negated antecedent

  |-------
[1]   EXISTS (i: below[length(cons(n_init, i!2`1))]):
        nth(cons(n_init, i!2`1), i) = n_init

Rerunning step: (inst 1 "0")
length rewrites length[Nonce](cons[Nonce](n_init, i!2`1))
  to 1 + length(i!2`1)
Instantiating the top quantifier in 1 with the terms: 
 0,
this simplifies to: 
restrictlast_init.1.1.1.2.2 : 
;;; consequent 1 was a negated antecedent

  |-------
{1}   nth(cons(n_init, i!2`1), 0) = n_init

Rerunning step: (expand "nth")
Expanding the definition of nth,
this simplifies to: 
restrictlast_init.1.1.1.2.2 : 
;;; consequent 1 was a negated antecedent

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictlast_init.1.1.1.2.2.


This completes the proof of restrictlast_init.1.1.1.2.


This completes the proof of restrictlast_init.1.1.1.

restrictlast_init.1.1.2 : 
;;; establish obvious equalities

[-1]  2 <= p
[-2]  i!1 = n_init
  |-------
{1}   u!1 = hu(0) AND p = P!1
[2]   (trans(u!1, car(i!2`2),
             E(public(car(i!2`2)),
               conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))
        >>
        (rec(u!1, nth(i!2`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
          >>
          (trans(u!1, car(i!2`2),
                 E(public(car(i!2`2)),
                   conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
            >> (signal(commit(0, cons(u!1, i!2`2), i!1)) >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete -1 2)
Deleting some formulas,
this simplifies to: 
restrictlast_init.1.1.2 : 
;;; establish obvious equalities

[-1]  i!1 = n_init
  |-------
[1]   u!1 = hu(0) AND p = P!1

Rerunning step: (typepred "i!1")
Adding type constraints for  i!1,
this simplifies to: 
restrictlast_init.1.1.2 : 
;;; establish obvious equalities

{-1}  IRpart(P!1, u!1, 0)(i!1)
[-2]  i!1 = n_init
  |-------
[1]   u!1 = hu(0) AND p = P!1

Rerunning step: (lemma "n_orig" ("P" "P!1" "u" "u!1"))
Applying n_orig where 
  P gets P!1,
  u gets u!1,
this simplifies to: 
restrictlast_init.1.1.2 : 
;;; establish obvious equalities

{-1}  IRpart(P!1, u!1, 0)(n_init) => (P!1 = p AND u!1 = hu(0))
[-2]  IRpart(P!1, u!1, 0)(i!1)
[-3]  i!1 = n_init
  |-------
[1]   u!1 = hu(0) AND p = P!1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_init.1.1.2.

restrictlast_init.1.1.3T (TCC):   

[-1]  2 <= p
[-2]  i!1 = n_init
  |-------
{1}   0 < p
[2]   (trans(u!1, car(i!2`2),
             E(public(car(i!2`2)),
               conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))
        >>
        (rec(u!1, nth(i!2`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
          >>
          (trans(u!1, car(i!2`2),
                 E(public(car(i!2`2)),
                   conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
            >> (signal(commit(0, cons(u!1, i!2`2), i!1)) >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete -2 2)
Deleting some formulas,
this simplifies to: 
restrictlast_init.1.1.3T : 
;;; establish obvious equalities

[-1]  2 <= p
  |-------
[1]   0 < p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_init.1.1.3T.


This completes the proof of restrictlast_init.1.1.

restrictlast_init.1.2 :  

[-1]  2 <= p
[-2]  i!1 = n_init
  |-------
{1}   P!1 - 2 < length[Identity](i!2`2)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     (length(x) = P!1 - 1) AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, i`1)), ilist(i`2))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
              >> (signal(commit(0, cons(u!1, i`2), i!1)) >> Stop[event]))))
         # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (typepred "i!2`2")
Adding type constraints for  i!2`2,
this simplifies to: 
restrictlast_init.1.2 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`2)
{-2}  (length(i!2`2) = P!1 - 1)
{-3}  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(1 + i)
[-4]  2 <= p
[-5]  i!1 = n_init
  |-------
[1]   P!1 - 2 < length[Identity](i!2`2)
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     (length(x) = P!1 - 1) AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, i`1)), ilist(i`2))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
              >> (signal(commit(0, cons(u!1, i`2), i!1)) >> Stop[event]))))
         # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete -1 -3 -4 -5 2)
Deleting some formulas,
this simplifies to: 
restrictlast_init.1.2 :  

[-1]  (length(i!2`2) = P!1 - 1)
  |-------
[1]   P!1 - 2 < length[Identity](i!2`2)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_init.1.2.

restrictlast_init.1.3 :  

[-1]  2 <= p
[-2]  i!1 = n_init
  |-------
{1}   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!1 :))
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     (length(x) = P!1 - 1) AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, i`1)), ilist(i`2))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
              >> (signal(commit(0, cons(u!1, i`2), i!1)) >> Stop[event]))))
         # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictlast_init.1.3 :  

  |-------
[1]   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!1 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!1 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictlast_init.1.3.

restrictlast_init.1.4 :  

[-1]  2 <= p
[-2]  i!1 = n_init
  |-------
{1}   cons?[Identity](i!2`2)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     (length(x) = P!1 - 1) AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, i`1)), ilist(i`2))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
              >> (signal(commit(0, cons(u!1, i`2), i!1)) >> Stop[event]))))
         # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
restrictlast_init.1.4 :  

[-1]  2 <= p
[-2]  i!1 = n_init
  |-------
[1]   cons?[Identity](i!2`2)

Rerunning step: (nonemptylist "i!2`2")
Relating existence of a tail to a list's length,

This completes the proof of restrictlast_init.1.4.

restrictlast_init.1.5 :  

[-1]  2 <= p
[-2]  i!1 = n_init
  |-------
{1}   (length(x!1) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     (length(x) = P!1 - 1) AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, i`1)), ilist(i`2))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
              >> (signal(commit(0, cons(u!1, i`2), i!1)) >> Stop[event]))))
         # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete -1 2)
Deleting some formulas,
this simplifies to: 
restrictlast_init.1.5 :  

[-1]  i!1 = n_init
  |-------
[1]   (length(x!1) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p

Rerunning step: (typepred "i!1")
Adding type constraints for  i!1,
this simplifies to: 
restrictlast_init.1.5 :  

{-1}  IRpart(P!1, u!1, 0)(i!1)
[-2]  i!1 = n_init
  |-------
[1]   (length(x!1) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p

Rerunning step: (lemma "n_orig" ("P" "P!1" "u" "u!1"))
Applying n_orig where 
  P gets P!1,
  u gets u!1,
this simplifies to: 
restrictlast_init.1.5 :  

{-1}  IRpart(P!1, u!1, 0)(n_init) => (P!1 = p AND u!1 = hu(0))
[-2]  IRpart(P!1, u!1, 0)(i!1)
[-3]  i!1 = n_init
  |-------
[1]   (length(x!1) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_init.1.5.

restrictlast_init.1.6 :  

[-1]  2 <= p
[-2]  i!1 = n_init
  |-------
{1}   (length(x!1) = P!1 - 1) IMPLIES
       FORALL (i: below[P!1 - 1]): i < length[Identity](x!1)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     (length(x) = P!1 - 1) AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, i`1)), ilist(i`2))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
              >> (signal(commit(0, cons(u!1, i`2), i!1)) >> Stop[event]))))
         # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictlast_init.1.6 :  

  |-------
[1]   (length(x!1) = P!1 - 1) IMPLIES
       FORALL (i: below[P!1 - 1]): i < length[Identity](x!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_init.1.6.

restrictlast_init.1.7 :  

[-1]  2 <= p
[-2]  i!1 = n_init
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il:
                {x: list[Identity] |
                   (length[Identity](x) = P!1 - 1) AND
                    FORALL (i: below[P!1 - 1]):
                      nth[Identity](x, i) = hu(1 + i)}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!1 :))
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1) AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
              >> (signal(commit(0, cons(u!1, il), i!1)) >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictlast_init.1.7 :  

  |-------
[1]   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il:
                {x: list[Identity] |
                   (length[Identity](x) = P!1 - 1) AND
                    FORALL (i: below[P!1 - 1]):
                      nth[Identity](x, i) = hu(1 + i)}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!1 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!1 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictlast_init.1.7.

restrictlast_init.1.8 :  

[-1]  2 <= p
[-2]  i!1 = n_init
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il:
                {x: list[Identity] |
                   (length[Identity](x) = P!1 - 1) AND
                    FORALL (i: below[P!1 - 1]):
                      nth[Identity](x, i) = hu(1 + i)}):
        cons?[Identity](il)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1) AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
              >> (signal(commit(0, cons(u!1, il), i!1)) >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (skolem-typepred 1)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictlast_init.1.8 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl!1)
{-2}  length(nl!1) = P!1 - 1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (il!1)
{-4}  (length(il!1) = P!1 - 1)
{-5}  FORALL (i: below[P!1 - 1]): nth(il!1, i) = hu(1 + i)
[-6]  2 <= p
[-7]  i!1 = n_init
  |-------
{1}   cons?[Identity](il!1)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1) AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
              >> (signal(commit(0, cons(u!1, il), i!1)) >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete -1 -2 -3 -5 -6 -7 2)
Deleting some formulas,
this simplifies to: 
restrictlast_init.1.8 :  

[-1]  (length(il!1) = P!1 - 1)
  |-------
[1]   cons?[Identity](il!1)

Rerunning step: (nonemptylist "il!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictlast_init.1.8.

restrictlast_init.1.9 :  

[-1]  2 <= p
[-2]  i!1 = n_init
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              x: list[Identity]):
        (length(x) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1) AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
              >> (signal(commit(0, cons(u!1, il), i!1)) >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete -1 2)
Deleting some formulas,
this simplifies to: 
restrictlast_init.1.9 :  

[-1]  i!1 = n_init
  |-------
[1]   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              x: list[Identity]):
        (length(x) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictlast_init.1.9 :  

[-1]  i!1 = n_init
  |-------
{1}   (length(x!1) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p

Rerunning step: (typepred "i!1")
Adding type constraints for  i!1,
this simplifies to: 
restrictlast_init.1.9 :  

{-1}  IRpart(P!1, u!1, 0)(i!1)
[-2]  i!1 = n_init
  |-------
[1]   (length(x!1) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p

Rerunning step: (lemma "n_orig" ("P" "P!1" "u" "u!1"))
Applying n_orig where 
  P gets P!1,
  u gets u!1,
this simplifies to: 
restrictlast_init.1.9 :  

{-1}  IRpart(P!1, u!1, 0)(n_init) => (P!1 = p AND u!1 = hu(0))
[-2]  IRpart(P!1, u!1, 0)(i!1)
[-3]  i!1 = n_init
  |-------
[1]   (length(x!1) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_init.1.9.

restrictlast_init.1.10 :  

[-1]  2 <= p
[-2]  i!1 = n_init
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              x: list[Identity]):
        (length(x) = P!1 - 1) IMPLIES
         FORALL (i: below[P!1 - 1]): i < length[Identity](x)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1) AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
              >> (signal(commit(0, cons(u!1, il), i!1)) >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictlast_init.1.10 :  

  |-------
[1]   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              x: list[Identity]):
        (length(x) = P!1 - 1) IMPLIES
         FORALL (i: below[P!1 - 1]): i < length[Identity](x)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictlast_init.1.10 :  

  |-------
{1}   (length(x!1) = P!1 - 1) IMPLIES
       FORALL (i: below[P!1 - 1]): i < length[Identity](x!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_init.1.10.

restrictlast_init.1.11 :  

[-1]  2 <= p
[-2]  i!1 = n_init
  |-------
{1}   FORALL (x: list[Identity]):
        (length(x) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1) AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
              >> (signal(commit(0, cons(u!1, il), i!1)) >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete -1 2)
Deleting some formulas,
this simplifies to: 
restrictlast_init.1.11 :  

[-1]  i!1 = n_init
  |-------
[1]   FORALL (x: list[Identity]):
        (length(x) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictlast_init.1.11 :  

[-1]  i!1 = n_init
  |-------
{1}   (length(x!1) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p

Rerunning step: (typepred i!1)
Adding type constraints for  i!1,
this simplifies to: 
restrictlast_init.1.11 :  

{-1}  IRpart(P!1, u!1, 0)(i!1)
[-2]  i!1 = n_init
  |-------
[1]   (length(x!1) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p

Rerunning step: (lemma "n_orig" ("P" "P!1" "u" "u!1"))
Applying n_orig where 
  P gets P!1,
  u gets u!1,
this simplifies to: 
restrictlast_init.1.11 :  

{-1}  IRpart(P!1, u!1, 0)(n_init) => (P!1 = p AND u!1 = hu(0))
[-2]  IRpart(P!1, u!1, 0)(i!1)
[-3]  i!1 = n_init
  |-------
[1]   (length(x!1) = P!1 - 1) IMPLIES FORALL (i: below[P!1 - 1]): 1 + i < p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_init.1.11.

restrictlast_init.1.12 :  

[-1]  2 <= p
[-2]  i!1 = n_init
  |-------
{1}   FORALL (x: list[Identity]):
        (length(x) = P!1 - 1) IMPLIES
         FORALL (i: below[P!1 - 1]): i < length[Identity](x)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    (length(x) = P!1 - 1) AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(1 + i)}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
              >> (signal(commit(0, cons(u!1, il), i!1)) >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictlast_init.1.12 :  

  |-------
[1]   FORALL (x: list[Identity]):
        (length(x) = P!1 - 1) IMPLIES
         FORALL (i: below[P!1 - 1]): i < length[Identity](x)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictlast_init.1.12 :  

  |-------
{1}   (length(x!1) = P!1 - 1) IMPLIES
       FORALL (i: below[P!1 - 1]): i < length[Identity](x!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_init.1.12.


This completes the proof of restrictlast_init.1.

restrictlast_init.2 :  

  |-------
{1}   i!1 = n_init
{2}   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
              >> (signal(commit(0, cons(u!1, il), i!1)) >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (typepred "P!1")
Adding type constraints for  P!1,
this simplifies to: 
restrictlast_init.2 :  

{-1}  2 <= P!1
  |-------
[1]   i!1 = n_init
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
              >> (signal(commit(0, cons(u!1, il), i!1)) >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (choice3)
Applying choice rule,
this yields  6 subgoals: 
restrictlast_init.2.1 :  

[-1]  2 <= P!1
  |-------
[1]   i!1 = n_init
{2}   (trans(u!1, car(i!2`2),
             E(public(car(i!2`2)),
               conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))
        >>
        (rec(u!1, nth(i!2`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
          >>
          (trans(u!1, car(i!2`2),
                 E(public(car(i!2`2)),
                   conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
            >> (signal(commit(0, cons(u!1, i!2`2), i!1)) >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictlast_init.2.1.1 :  

[-1]  2 <= P!1
  |-------
{1}   rho_last(E(public(car(i!2`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))
{2}   R_last(trans(u!1, car(i!2`2),
                   E(public(car(i!2`2)),
                     conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2)))))))
{3}   trans(u!1, car(i!2`2),
            E(public(car(i!2`2)),
              conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))
       >>
       ((rec(u!1, nth(i!2`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
          >>
          (trans(u!1, car(i!2`2),
                 E(public(car(i!2`2)),
                   conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
            >> (signal(commit(0, cons(u!1, i!2`2), i!1)) >> Stop[event])))
         # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[4]   i!1 = n_init

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_init.2.1.1 :  

[-1]  2 <= P!1
  |-------
[1]   rho_last(E(public(car(i!2`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))
[2]   i!1 = n_init

Rerunning step: (grind)
E rewrites 
  E(public(car(i!2`2)),
    conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2)))))
  to code(public(car(i!2`2)),
           conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2)))))
elt rewrites elt((: i!1 :), n_init)
  to EXISTS (i: below[length((: i!1 :))]): nth((: i!1 :), i) = n_init
rho_last rewrites rho_last(nlist((: i!1 :)))
  to NOT EXISTS (i: below[length((: i!1 :))]): nth((: i!1 :), i) = n_init
rho_last rewrites rho_last(ilist(cons(u!1, cdr(i!2`2))))
  to TRUE
rho_last rewrites 
  rho_last(conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2)))))
  to NOT EXISTS (i: below[length((: i!1 :))]): nth((: i!1 :), i) = n_init
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_last rewrites 
  rho_last(code(public(car(i!2`2)),
                conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))
  to NOT EXISTS (i: below[length((: i!1 :))]): nth((: i!1 :), i) = n_init
       OR
       EXISTS (i: {x: nat | 0 < x AND x < p}):
         public(car(i!2`2)) = public(hu(i)) AND
          EXISTS (l: {x: list[Nonce] | length(x) = i - 1}):
            conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2)))) =
             conc(nlist(cons(n_init, l)),
                  ilist(cons(car(hu_list), remove(cdr(hu_list), i - 1))))

length rewrites length((: :))
  to 0
length rewrites length((: i!1 :))
  to 1
nth rewrites nth((: i!1 :), i!3)
  to i!1
length rewrites length((: :))
  to 0
length rewrites length((: i!1 :))
  to 1
nth rewrites nth((: i!1 :), i!3)
  to i!1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictlast_init.2.1.1.

restrictlast_init.2.1.2 :  

[-1]  2 <= P!1
  |-------
{1}   ((rec(u!1, nth(i!2`2, P!1 - 2),
            E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
         >>
         (trans(u!1, car(i!2`2),
                E(public(car(i!2`2)),
                  conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
           >> (signal(commit(0, cons(u!1, i!2`2), i!1)) >> Stop[event])))
        # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
{2}   R_last(trans(u!1, car(i!2`2),
                   E(public(car(i!2`2)),
                     conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2)))))))
{3}   trans(u!1, car(i!2`2),
            E(public(car(i!2`2)),
              conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))
       >>
       ((rec(u!1, nth(i!2`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
          >>
          (trans(u!1, car(i!2`2),
                 E(public(car(i!2`2)),
                   conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
            >> (signal(commit(0, cons(u!1, i!2`2), i!1)) >> Stop[event])))
         # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[4]   i!1 = n_init

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_init.2.1.2 :  

[-1]  2 <= P!1
  |-------
[1]   ((rec(u!1, nth(i!2`2, P!1 - 2),
            E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
         >>
         (trans(u!1, car(i!2`2),
                E(public(car(i!2`2)),
                  conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
           >> (signal(commit(0, cons(u!1, i!2`2), i!1)) >> Stop[event])))
        # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[2]   i!1 = n_init

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictlast_init.2.1.2 :  

{-1}  rho_last(E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
{1}   ((trans(u!1, car(i!2`2),
              E(public(car(i!2`2)),
                conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
         >> (signal(commit(0, cons(u!1, i!2`2), i!1)) >> Stop[event]))
        # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
{2}   R_last(rec(u!1, nth(i!2`2, P!1 - 2),
                 E(public(u!1),
                   conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)))))
{3}   rec(u!1, nth(i!2`2, P!1 - 2),
          E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
       >>
       ((trans(u!1, car(i!2`2),
               E(public(car(i!2`2)),
                 conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
          >> (signal(commit(0, cons(u!1, i!2`2), i!1)) >> Stop[event]))
         # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[4]   i!1 = n_init

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_init.2.1.2 :  

[-1]  rho_last(E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   ((trans(u!1, car(i!2`2),
              E(public(car(i!2`2)),
                conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
         >> (signal(commit(0, cons(u!1, i!2`2), i!1)) >> Stop[event]))
        # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[2]   i!1 = n_init

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictlast_init.2.1.2.1 :  

[-1]  rho_last(E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
{1}   rho_last(E(public(car(i!2`2)),
                 conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
{2}   R_last(trans(u!1, car(i!2`2),
                   E(public(car(i!2`2)),
                     conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1)))))
{3}   trans(u!1, car(i!2`2),
            E(public(car(i!2`2)),
              conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
       >>
       ((signal(commit(0, cons(u!1, i!2`2), i!1)) >> Stop[event]) # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[4]   i!1 = n_init

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_init.2.1.2.1 :  

[-1]  rho_last(E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   rho_last(E(public(car(i!2`2)),
                 conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
[2]   i!1 = n_init

Rerunning step: (expand "rho_last" -1)
Expanding the definition of rho_last,
this simplifies to: 
restrictlast_init.2.1.2.1 :  

{-1}  CASES E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)))
        OF nonce(z): z /= n_init,
           nlist(z): NOT elt(z, n_init),
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i)),
           conc(z1, z2): rho_last(z1) AND rho_last(z2),
           commit(z1, z2, z3): z1 /= 0 OR z2 /= hu_list OR z3 /= n_init,
           code(z1, z2):
             rho_last(z2) OR
              (EXISTS (i: {x: nat | 0 < x AND x < p}):
                 z1 = public(hu(i)) AND
                  (EXISTS (l: {x: list[Nonce] | length(x) = i - 1}):
                     z2 =
                      conc(nlist(cons(n_init, l)),
                           ilist(remove(hu_list, i)))))
        ELSE TRUE
        ENDCASES
[-2]  2 <= P!1
  |-------
[1]   rho_last(E(public(car(i!2`2)),
                 conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
[2]   i!1 = n_init

Rerunning step: (grind :exclude "rho_last")
E rewrites 
  E(public(car(i!2`2)), conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1)))
  to code(public(car(i!2`2)),
           conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1)))
E rewrites E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)))
  to code(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)))
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
Trying repeated skolemization, instantiation, and if-lifting,
this yields  2 subgoals: 
restrictlast_init.2.1.2.1.1 :  

{-1}  rho_last(conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)))
[-2]  2 <= P!1
  |-------
{1}   rho_last(code(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
[2]   i!1 = n_init

Rerunning step: (comment "-1 means that nonce n_init is not in the nlist")
Adding comment: -1 means that nonce n_init is not in the nlist
this simplifies to: 
restrictlast_init.2.1.2.1.1 : 
;;; -1 means that nonce n_init is not in the nlist

[-1]  rho_last(conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)))
[-2]  2 <= P!1
  |-------
[1]   rho_last(code(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
[2]   i!1 = n_init

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
restrictlast_init.2.1.2.1.1 : 
;;; -1 means that nonce n_init is not in the nlist

[-1]  rho_last(conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)))
  |-------
[1]   rho_last(code(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
[2]   i!1 = n_init

Rerunning step: (expand "rho_last" -1)
Expanding the definition of rho_last,
this simplifies to: 
restrictlast_init.2.1.2.1.1 : 
;;; -1 means that nonce n_init is not in the nlist

{-1}  rho_last(nlist(cons(i!1, i!2`1))) AND rho_last(ilist(i!2`2))
  |-------
[1]   rho_last(code(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
[2]   i!1 = n_init

Rerunning step: (lemma "listprops[Nonce].elt_append2"
                 ("l1" "(: i!1 :)" "l2" "i!2`1" "t" "n_init"))
Applying listprops[Nonce].elt_append2 where 
  l1 gets (: i!1 :),
  l2 gets i!2`1,
  t gets n_init,
this simplifies to: 
restrictlast_init.2.1.2.1.1 : 
;;; -1 means that nonce n_init is not in the nlist

{-1}  elt(i!2`1, n_init) IMPLIES elt(append((: i!1 :), i!2`1), n_init)
[-2]  rho_last(nlist(cons(i!1, i!2`1))) AND rho_last(ilist(i!2`2))
  |-------
[1]   rho_last(code(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
[2]   i!1 = n_init

Rerunning step: (grind :exclude "elt")
append rewrites append((: :), i!2`1)
  to i!2`1
append rewrites append((: i!1 :), i!2`1)
  to cons(i!1, i!2`1)
rho_last rewrites rho_last(ilist(cons(u!1, cdr(i!2`2))))
  to TRUE
rho_last rewrites rho_last(nlist(i!2`1))
  to NOT elt(i!2`1, n_init)
rho_last rewrites rho_last(conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1)))
  to NOT elt(i!2`1, n_init)
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_last rewrites 
  rho_last(code(public(car(i!2`2)),
                conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
  to NOT elt(i!2`1, n_init) OR
       EXISTS (i: {x: nat | 0 < x AND x < p}):
         public(car(i!2`2)) = public(hu(i)) AND
          EXISTS (l: {x: list[Nonce] | length(x) = i - 1}):
            conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1)) =
             conc(nlist(cons(n_init, l)),
                  ilist(cons(car(hu_list), remove(cdr(hu_list), i - 1))))
rho_last rewrites rho_last(nlist(cons(i!1, i!2`1)))
  to FALSE
rho_last rewrites rho_last(ilist(cons(u!1, cdr(i!2`2))))
  to TRUE
rho_last rewrites rho_last(nlist(i!2`1))
  to TRUE
rho_last rewrites rho_last(conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1)))
  to TRUE
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_last rewrites 
  rho_last(code(public(car(i!2`2)),
                conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictlast_init.2.1.2.1.1.

restrictlast_init.2.1.2.1.2 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
{-2}  length(l!1) = i!3 - 1
{-3}  0 < i!3
{-4}  i!3 < p
{-5}  public(u!1) = public(hu(i!3))
{-6}  conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)) =
       conc(nlist(cons(n_init, l!1)),
            ilist(cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))))
[-7]  2 <= P!1
  |-------
{1}   rho_last(code(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
[2]   i!1 = n_init

Rerunning step: (comment "i!1 = n_init is provable from -6")
Adding comment: i!1 = n_init is provable from -6
this simplifies to: 
restrictlast_init.2.1.2.1.2 : 
;;; i!1 = n_init is provable from -6

[-1]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
[-2]  length(l!1) = i!3 - 1
[-3]  0 < i!3
[-4]  i!3 < p
[-5]  public(u!1) = public(hu(i!3))
[-6]  conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)) =
       conc(nlist(cons(n_init, l!1)),
            ilist(cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))))
[-7]  2 <= P!1
  |-------
[1]   rho_last(code(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
[2]   i!1 = n_init

Rerunning step: (mdecompose-equality -6)
Decomposing equalities,

This completes the proof of restrictlast_init.2.1.2.1.2.


This completes the proof of restrictlast_init.2.1.2.1.

restrictlast_init.2.1.2.2 :  

[-1]  rho_last(E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
{1}   ((signal(commit(0, cons(u!1, i!2`2), i!1)) >> Stop[event]) # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
{2}   R_last(trans(u!1, car(i!2`2),
                   E(public(car(i!2`2)),
                     conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1)))))
{3}   trans(u!1, car(i!2`2),
            E(public(car(i!2`2)),
              conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
       >>
       ((signal(commit(0, cons(u!1, i!2`2), i!1)) >> Stop[event]) # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[4]   i!1 = n_init

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_init.2.1.2.2 :  

[-1]  rho_last(E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   ((signal(commit(0, cons(u!1, i!2`2), i!1)) >> Stop[event]) # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[2]   i!1 = n_init

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictlast_init.2.1.2.2.1 :  

[-1]  rho_last(E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
{1}   rho_last(commit(0, cons(u!1, i!2`2), i!1))
{2}   R_last(signal(commit(0, cons(u!1, i!2`2), i!1)))
{3}   signal(commit(0, cons(u!1, i!2`2), i!1)) >> (Stop[event] # R_last) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[4]   i!1 = n_init

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_init.2.1.2.2.1 :  

[-1]  rho_last(E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   rho_last(commit(0, cons(u!1, i!2`2), i!1))
[2]   i!1 = n_init

Rerunning step: (comment "1 and 2 are mutually exclusive")
Adding comment: 1 and 2 are mutually exclusive
this simplifies to: 
restrictlast_init.2.1.2.2.1 : 
;;; 1 and 2 are mutually exclusive

[-1]  rho_last(E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   rho_last(commit(0, cons(u!1, i!2`2), i!1))
[2]   i!1 = n_init

Rerunning step: (grind)
/= rewrites cons(u!1, i!2`2) /= hu_list
  to NOT (cons(u!1, i!2`2) = hu_list)
rho_last rewrites rho_last(commit(0, cons(u!1, i!2`2), i!1))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictlast_init.2.1.2.2.1.

restrictlast_init.2.1.2.2.2 :  

[-1]  rho_last(E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
{1}   (Stop[event] # R_last) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
{2}   R_last(signal(commit(0, cons(u!1, i!2`2), i!1)))
{3}   signal(commit(0, cons(u!1, i!2`2), i!1)) >> (Stop[event] # R_last) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[4]   i!1 = n_init

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_init.2.1.2.2.2 :  

[-1]  rho_last(E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   (Stop[event] # R_last) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[2]   i!1 = n_init

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictlast_init.2.1.2.2.2.


This completes the proof of restrictlast_init.2.1.2.2.


This completes the proof of restrictlast_init.2.1.2.


This completes the proof of restrictlast_init.2.1.

restrictlast_init.2.2 :  

[-1]  2 <= P!1
  |-------
{1}   P!1 - 2 < length[Identity](i!2`2)
[2]   i!1 = n_init
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, i`1)), ilist(i`2))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
              >> (signal(commit(0, cons(u!1, i`2), i!1)) >> Stop[event]))))
         # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_init.2.2 :  

  |-------
[1]   P!1 - 2 < length[Identity](i!2`2)

Rerunning step: (typepred "i!2`2")
Adding type constraints for  i!2`2,
this simplifies to: 
restrictlast_init.2.2 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`2)
{-2}  length(i!2`2) = P!1 - 1
  |-------
[1]   P!1 - 2 < length[Identity](i!2`2)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_init.2.2.

restrictlast_init.2.3 :  

[-1]  2 <= P!1
  |-------
{1}   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!1 :))
[2]   i!1 = n_init
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, i`1)), ilist(i`2))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
              >> (signal(commit(0, cons(u!1, i`2), i!1)) >> Stop[event]))))
         # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_init.2.3 :  

  |-------
[1]   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!1 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!1 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictlast_init.2.3.

restrictlast_init.2.4 :  

[-1]  2 <= P!1
  |-------
{1}   cons?[Identity](i!2`2)
[2]   i!1 = n_init
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, i`1)), ilist(i`2))))
            >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
              >> (signal(commit(0, cons(u!1, i`2), i!1)) >> Stop[event]))))
         # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_init.2.4 :  

  |-------
[1]   cons?[Identity](i!2`2)

Rerunning step: (nonemptylist "i!2`2")
Relating existence of a tail to a list's length,

This completes the proof of restrictlast_init.2.4.

restrictlast_init.2.5 :  

[-1]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!1 :))
[2]   i!1 = n_init
[3]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
              >> (signal(commit(0, cons(u!1, il), i!1)) >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_init.2.5 :  

  |-------
[1]   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!1 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!1 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictlast_init.2.5.

restrictlast_init.2.6 :  

[-1]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        cons?[Identity](il)
[2]   i!1 = n_init
[3]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
              >> (signal(commit(0, cons(u!1, il), i!1)) >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_init.2.6 :  

  |-------
[1]   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        cons?[Identity](il)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictlast_init.2.6 :  

  |-------
{1}   cons?[Identity](il!1)

Rerunning step: (nonemptylist "il!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictlast_init.2.6.


This completes the proof of restrictlast_init.2.

Q.E.D.


Run time  = 2.47 secs.
Real time = 6.38 secs.
nil
pvs(62): 
Installing rewrite rule sets.singleton_rew (all instances)
restrictlast_middle :  

  |-------
{1}   FORALL (P: nat_from_2, u: Identity):
        P /= 2 =>
         (((Interleave! (k: nat_1_to(P), nnK: Nonces(P, u, k)):
              UROLE_MIDDLE(P, k, u, nnK))
            # R_last)
           |> RankUser(rho_last))

Rerunning step: (auto-rewrite-theory "sets")
Rewriting relative to the theory: sets,
this simplifies to: 
restrictlast_middle :  

  |-------
[1]   FORALL (P: nat_from_2, u: Identity):
        P /= 2 =>
         (((Interleave! (k: nat_1_to(P), nnK: Nonces(P, u, k)):
              UROLE_MIDDLE(P, k, u, nnK))
            # R_last)
           |> RankUser(rho_last))

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictlast_middle :  

  |-------
{1}   P!1 /= 2 =>
       (((Interleave! (k: nat_1_to(P!1), nnK: Nonces(P!1, u!1, k)):
            UROLE_MIDDLE(P!1, k, u!1, nnK))
          # R_last)
         |> RankUser(rho_last))

Rerunning step: (expand "RankUser")
Expanding the definition of RankUser,
this simplifies to: 
restrictlast_middle :  

  |-------
{1}   P!1 /= 2 =>
       (((Interleave! (k: nat_1_to(P!1), nnK: Nonces(P!1, u!1, k)):
            UROLE_MIDDLE(P!1, k, u!1, nnK))
          # R_last)
         |>
         LAMBDA (tr: list[event]):
           every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(tr) =>
            every(LAMBDA (e: event):
                    complement(rec?)(e) => rho_last(msg(e)))
                 (tr))

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictlast_middle :  

  |-------
{1}   P!1 = 2
{2}   (((Interleave! (k: nat_1_to(P!1), nnK: Nonces(P!1, u!1, k)):
           UROLE_MIDDLE(P!1, k, u!1, nnK))
         # R_last)
        |>
        LAMBDA (tr: list[event]):
          every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(tr) =>
           every(LAMBDA (e: event): complement(rec?)(e) => rho_last(msg(e)))
                (tr))

Rerunning step: (auto-rewrite "USER_TCC2")
Installing rewrite rule gnsl_init.USER_TCC2
Installing automatic rewrites from: 
  USER_TCC2
this simplifies to: 
restrictlast_middle :  

  |-------
[1]   P!1 = 2
[2]   (((Interleave! (k: nat_1_to(P!1), nnK: Nonces(P!1, u!1, k)):
           UROLE_MIDDLE(P!1, k, u!1, nnK))
         # R_last)
        |>
        LAMBDA (tr: list[event]):
          every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(tr) =>
           every(LAMBDA (e: event): complement(rec?)(e) => rho_last(msg(e)))
                (tr))

Rerunning step: (interleaving2)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
USER_TCC2 rewrites EXISTS (x: [k: nat_1_to(P!1), Nonces(P!1, u!1, k)]): TRUE
  to TRUE
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
USER_TCC2 rewrites EXISTS (x: [k: nat_1_to(P!1), Nonces(P!1, u!1, k)]): TRUE
  to TRUE
Applying interleaving rule,
this simplifies to: 
restrictlast_middle :  

  |-------
[1]   P!1 = 2
{2}   UROLE_MIDDLE(P!1, i!1`1, u!1, i!1`2) # R_last |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (typepred "P!1" "i!1`1")
Adding type constraints for  P!1, i!1`1,
this simplifies to: 
restrictlast_middle :  

{-1}  2 <= P!1
{-2}  0 < i!1`1
{-3}  i!1`1 < P!1 - 1
  |-------
[1]   P!1 = 2
[2]   UROLE_MIDDLE(P!1, i!1`1, u!1, i!1`2) # R_last |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (expand "UROLE_MIDDLE")
Expanding the definition of UROLE_MIDDLE,
this simplifies to: 
restrictlast_middle :  

[-1]  2 <= P!1
[-2]  0 < i!1`1
[-3]  i!1`1 < P!1 - 1
  |-------
[1]   P!1 = 2
{2}   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1: {x: list[Identity] | length(x) = i!1`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (signal(running(i!1`1, append(il1, cons(u!1, il2)), car(nl1))) >>
            (trans(u!1, car(il2),
                   E(public(car(il2)),
                     conc(nlist(append(nl1, (: i!1`2 :))),
                          ilist(append(il1, cons(u!1, cdr(il2)))))))
              >>
              (rec(u!1, nth(il1, i!1`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(il1, il2)),
                          nlist(cons(i!1`2, nl2)))))
                >>
                ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (choice3)
Applying choice rule,
this yields  6 subgoals: 
restrictlast_middle.1 :  

[-1]  2 <= P!1
[-2]  0 < i!1`1
[-3]  i!1`1 < P!1 - 1
  |-------
[1]   P!1 = 2
{2}   (rec(u!1, nth(i!2`3, i!1`1 - 1),
           E(public(u!1), conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
        >>
        (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                        car(i!2`1)))
          >>
          (trans(u!1, car(i!2`4),
                 E(public(car(i!2`4)),
                   conc(nlist(append(i!2`1, (: i!1`2 :))),
                        ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
            >>
            (rec(u!1, nth(i!2`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i!2`3, i!2`4)),
                        nlist(cons(i!1`2, i!2`2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4))
                >> Stop[event])))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictlast_middle.1 :  

{-1}  rho_last(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
{1}   ((signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)), car(i!2`1)))
         >>
         (trans(u!1, car(i!2`4),
                E(public(car(i!2`4)),
                  conc(nlist(append(i!2`1, (: i!1`2 :))),
                       ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
           >>
           (rec(u!1, nth(i!2`3, i!1`1 - 1),
                E(public(u!1),
                  conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2)))))
             >>
             ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
               Stop[event]))))
        # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
{2}   R_last(rec(u!1, nth(i!2`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))))
{3}   rec(u!1, nth(i!2`3, i!1`1 - 1),
          E(public(u!1), conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
       >>
       ((signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                        car(i!2`1)))
          >>
          (trans(u!1, car(i!2`4),
                 E(public(car(i!2`4)),
                   conc(nlist(append(i!2`1, (: i!1`2 :))),
                        ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
            >>
            (rec(u!1, nth(i!2`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i!2`3, i!2`4)),
                        nlist(cons(i!1`2, i!2`2)))))
              >>
              ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4))
                >> Stop[event]))))
         # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[4]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1 :  

[-1]  rho_last(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
[1]   ((signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)), car(i!2`1)))
         >>
         (trans(u!1, car(i!2`4),
                E(public(car(i!2`4)),
                  conc(nlist(append(i!2`1, (: i!1`2 :))),
                       ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
           >>
           (rec(u!1, nth(i!2`3, i!1`1 - 1),
                E(public(u!1),
                  conc(ilist(append(i!2`3, i!2`4)),
                       nlist(cons(i!1`2, i!2`2)))))
             >>
             ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
               Stop[event]))))
        # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[2]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictlast_middle.1.1 :  

[-1]  rho_last(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
{1}   rho_last(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)), car(i!2`1)))
{2}   R_last(signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                            car(i!2`1))))
{3}   signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)), car(i!2`1)))
       >>
       ((trans(u!1, car(i!2`4),
               E(public(car(i!2`4)),
                 conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
          >>
          (rec(u!1, nth(i!2`3, i!1`1 - 1),
               E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
            >>
            ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
              Stop[event])))
         # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[4]   P!1 = 2

Rerunning step: (delete - 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.1 :  

  |-------
[1]   rho_last(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)), car(i!2`1)))

Rerunning step: (expand "rho_last")
Expanding the definition of rho_last,
this simplifies to: 
restrictlast_middle.1.1 :  

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictlast_middle.1.1.

restrictlast_middle.1.2 :  

[-1]  rho_last(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
{1}   ((trans(u!1, car(i!2`4),
              E(public(car(i!2`4)),
                conc(nlist(append(i!2`1, (: i!1`2 :))),
                     ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
         >>
         (rec(u!1, nth(i!2`3, i!1`1 - 1),
              E(public(u!1),
                conc(ilist(append(i!2`3, i!2`4)),
                     nlist(cons(i!1`2, i!2`2)))))
           >>
           ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
             Stop[event])))
        # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
{2}   R_last(signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                            car(i!2`1))))
{3}   signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)), car(i!2`1)))
       >>
       ((trans(u!1, car(i!2`4),
               E(public(car(i!2`4)),
                 conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
          >>
          (rec(u!1, nth(i!2`3, i!1`1 - 1),
               E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
            >>
            ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
              Stop[event])))
         # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[4]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.2 :  

[-1]  rho_last(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
[1]   ((trans(u!1, car(i!2`4),
              E(public(car(i!2`4)),
                conc(nlist(append(i!2`1, (: i!1`2 :))),
                     ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
         >>
         (rec(u!1, nth(i!2`3, i!1`1 - 1),
              E(public(u!1),
                conc(ilist(append(i!2`3, i!2`4)),
                     nlist(cons(i!1`2, i!2`2)))))
           >>
           ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
             Stop[event])))
        # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[2]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictlast_middle.1.2.1 :  

[-1]  rho_last(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
{1}   rho_last(E(public(car(i!2`4)),
                 conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
{2}   R_last(trans(u!1, car(i!2`4),
                   E(public(car(i!2`4)),
                     conc(nlist(append(i!2`1, (: i!1`2 :))),
                          ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))))
{3}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(nlist(append(i!2`1, (: i!1`2 :))),
                   ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
       >>
       ((rec(u!1, nth(i!2`3, i!1`1 - 1),
             E(public(u!1),
               conc(ilist(append(i!2`3, i!2`4)),
                    nlist(cons(i!1`2, i!2`2)))))
          >>
          ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
            Stop[event]))
         # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[4]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.2.1 :  

[-1]  rho_last(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
[1]   rho_last(E(public(car(i!2`4)),
                 conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   P!1 = 2

Rerunning step: (comment "let us make explicit that i!1`2 /= n_init")
Adding comment: let us make explicit that i!1`2 /= n_init
this simplifies to: 
restrictlast_middle.1.2.1 : 
;;; let us make explicit that i!1`2 /= n_init

[-1]  rho_last(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
[1]   rho_last(E(public(car(i!2`4)),
                 conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   P!1 = 2

Rerunning step: (case "i!1`2 /= n_init")
Case splitting on 
   i!1`2 /= n_init, 
this yields  2 subgoals: 
restrictlast_middle.1.2.1.1 : 
;;; let us make explicit that i!1`2 /= n_init

{-1}  i!1`2 /= n_init
[-2]  rho_last(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
[1]   rho_last(E(public(car(i!2`4)),
                 conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   P!1 = 2

Rerunning step: (expand "rho_last" -2)
Expanding the definition of rho_last,
this simplifies to: 
restrictlast_middle.1.2.1.1 : 
;;; let us make explicit that i!1`2 /= n_init

[-1]  i!1`2 /= n_init
{-2}  CASES E(public(u!1), conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
        OF nonce(z): z /= n_init,
           nlist(z): NOT elt(z, n_init),
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i)),
           conc(z1, z2): rho_last(z1) AND rho_last(z2),
           commit(z1, z2, z3): z1 /= 0 OR z2 /= hu_list OR z3 /= n_init,
           code(z1, z2):
             rho_last(z2) OR
              (EXISTS (i: {x: nat | 0 < x AND x < p}):
                 z1 = public(hu(i)) AND
                  (EXISTS (l: {x: list[Nonce] | length(x) = i - 1}):
                     z2 =
                      conc(nlist(cons(n_init, l)),
                           ilist(remove(hu_list, i)))))
        ELSE TRUE
        ENDCASES
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
[1]   rho_last(E(public(car(i!2`4)),
                 conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   P!1 = 2

Rerunning step: (stop-rewrite "remove")
Turned off sets.removeError: listprops.remove is not an auto-rewrite
Turning off automatic rewriting for: 
   remove,
this simplifies to: 
restrictlast_middle.1.2.1.1 : 
;;; let us make explicit that i!1`2 /= n_init

[-1]  i!1`2 /= n_init
[-2]  CASES E(public(u!1), conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
        OF nonce(z): z /= n_init,
           nlist(z): NOT elt(z, n_init),
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i)),
           conc(z1, z2): rho_last(z1) AND rho_last(z2),
           commit(z1, z2, z3): z1 /= 0 OR z2 /= hu_list OR z3 /= n_init,
           code(z1, z2):
             rho_last(z2) OR
              (EXISTS (i: {x: nat | 0 < x AND x < p}):
                 z1 = public(hu(i)) AND
                  (EXISTS (l: {x: list[Nonce] | length(x) = i - 1}):
                     z2 =
                      conc(nlist(cons(n_init, l)),
                           ilist(remove(hu_list, i)))))
        ELSE TRUE
        ENDCASES
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
[1]   rho_last(E(public(car(i!2`4)),
                 conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   P!1 = 2

Rerunning step: (grind :exclude ("rho_last" "remove"))
/= rewrites i!1`2 /= n_init
  to NOT (i!1`2 = n_init)
E rewrites 
  E(public(car(i!2`4)),
    conc(nlist(append(i!2`1, (: i!1`2 :))),
         ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))
  to code(public(car(i!2`4)),
           conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))
E rewrites E(public(u!1), conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
  to code(public(u!1), conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
Trying repeated skolemization, instantiation, and if-lifting,
this yields  2 subgoals: 
restrictlast_middle.1.2.1.1.1 : 
;;; let us make explicit that i!1`2 /= n_init

{-1}  rho_last(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
{1}   (i!1`2 = n_init)
{2}   rho_last(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   P!1 = 2

Rerunning step: (delete -2 -3 -4 3)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.2.1.1.1 : 
;;; let us make explicit that i!1`2 /= n_init

[-1]  rho_last(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
  |-------
[1]   (i!1`2 = n_init)
[2]   rho_last(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))

Rerunning step: (comment "due to -1 (and i!1`2 /= n_init), 2 will be satisfied")
Adding comment: due to -1 (and i!1`2 /= n_init), 2 will be satisfied
this simplifies to: 
restrictlast_middle.1.2.1.1.1 : 
;;; due to -1 (and i!1`2 /= n_init), 2 will be satisfied

[-1]  rho_last(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
  |-------
[1]   (i!1`2 = n_init)
[2]   rho_last(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))

Rerunning step: (lemma "listprops[Nonce].elt_append3"
                 ("l1" "i!2`1" "l2" "(: i!1`2 :)" "t" "n_init"))
Applying listprops[Nonce].elt_append3 where 
  l1 gets i!2`1,
  l2 gets (: i!1`2 :),
  t gets n_init,
this simplifies to: 
restrictlast_middle.1.2.1.1.1 : 
;;; due to -1 (and i!1`2 /= n_init), 2 will be satisfied

{-1}  elt(append(i!2`1, (: i!1`2 :)), n_init) IMPLIES
       elt(i!2`1, n_init) OR elt((: i!1`2 :), n_init)
[-2]  rho_last(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
  |-------
[1]   (i!1`2 = n_init)
[2]   rho_last(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))

Rerunning step: (lemma "listprops[Nonce].elt_singleton"
                 ("t1" "i!1`2" "t2" "n_init"))
Applying listprops[Nonce].elt_singleton where 
  t1 gets i!1`2,
  t2 gets n_init,
this simplifies to: 
restrictlast_middle.1.2.1.1.1 : 
;;; due to -1 (and i!1`2 /= n_init), 2 will be satisfied

{-1}  elt((: i!1`2 :), n_init) IFF i!1`2 = n_init
[-2]  elt(append(i!2`1, (: i!1`2 :)), n_init) IMPLIES
       elt(i!2`1, n_init) OR elt((: i!1`2 :), n_init)
[-3]  rho_last(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
  |-------
[1]   (i!1`2 = n_init)
[2]   rho_last(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))

Rerunning step: (grind :exclude "elt")
rho_last rewrites rho_last(nlist(append(i!2`1, (: i!1`2 :))))
  to NOT elt(append(i!2`1, (: i!1`2 :)), n_init)
rho_last rewrites rho_last(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
  to TRUE
rho_last rewrites 
  rho_last(conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))
  to NOT elt(append(i!2`1, (: i!1`2 :)), n_init)
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_last rewrites 
  rho_last(code(public(car(i!2`4)),
                conc(nlist(append(i!2`1, (: i!1`2 :))),
                     ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
  to NOT elt(append(i!2`1, (: i!1`2 :)), n_init) OR
       EXISTS (i: {x: nat | 0 < x AND x < p}):
         public(car(i!2`4)) = public(hu(i)) AND
          EXISTS (l: {x: list[Nonce] | length(x) = i - 1}):
            conc(nlist(append(i!2`1, (: i!1`2 :))),
                 ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
             =
             conc(nlist(cons(n_init, l)),
                  ilist(cons(car(hu_list), remove(cdr(hu_list), i - 1))))
rho_last rewrites rho_last(nlist(i!2`1))
  to FALSE
rho_last rewrites rho_last(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_last rewrites rho_last(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
  to FALSE
rho_last rewrites rho_last(nlist(append(i!2`1, (: i!1`2 :))))
  to TRUE
rho_last rewrites rho_last(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
  to TRUE
rho_last rewrites 
  rho_last(conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))
  to TRUE
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_last rewrites 
  rho_last(code(public(car(i!2`4)),
                conc(nlist(append(i!2`1, (: i!1`2 :))),
                     ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictlast_middle.1.2.1.1.1.

restrictlast_middle.1.2.1.1.2 : 
;;; let us make explicit that i!1`2 /= n_init

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
{-2}  length(l!1) = i!3 - 1
{-3}  0 < i!3
{-4}  i!3 < p
{-5}  public(u!1) = public(hu(i!3))
{-6}  conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
       conc(nlist(cons(n_init, l!1)), ilist(remove(hu_list, i!3)))
[-7]  2 <= P!1
[-8]  0 < i!1`1
[-9]  i!1`1 < P!1 - 1
  |-------
{1}   (i!1`2 = n_init)
{2}   rho_last(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   P!1 = 2

Rerunning step: (comment "this is the case of the run under consideration, so 2 must be proven by showing the parameters satisfy the EXISTS quantor in rho_last")
Adding comment: this is the case of the run under consideration, so 2 must be proven by showing the parameters satisfy the EXISTS quantor in rho_last
this simplifies to: 
restrictlast_middle.1.2.1.1.2 : 
;;; this is the case of the run under consideration, so 2 must be proven by showing the parameters satisfy the EXISTS quantor in rho_last

[-1]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
[-2]  length(l!1) = i!3 - 1
[-3]  0 < i!3
[-4]  i!3 < p
[-5]  public(u!1) = public(hu(i!3))
[-6]  conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
       conc(nlist(cons(n_init, l!1)), ilist(remove(hu_list, i!3)))
[-7]  2 <= P!1
[-8]  0 < i!1`1
[-9]  i!1`1 < P!1 - 1
  |-------
[1]   (i!1`2 = n_init)
[2]   rho_last(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   P!1 = 2

Rerunning step: (decompose-equality -5)
Applying decompose-equality,
this simplifies to: 
restrictlast_middle.1.2.1.1.2 : 
;;; this is the case of the run under consideration, so 2 must be proven by showing the parameters satisfy the EXISTS quantor in rho_last

{-1}  u!1 = hu(i!3)
[-2]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
[-3]  length(l!1) = i!3 - 1
[-4]  0 < i!3
[-5]  i!3 < p
[-6]  conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
       conc(nlist(cons(n_init, l!1)), ilist(remove(hu_list, i!3)))
[-7]  2 <= P!1
[-8]  0 < i!1`1
[-9]  i!1`1 < P!1 - 1
  |-------
[1]   (i!1`2 = n_init)
[2]   rho_last(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   P!1 = 2

Rerunning step: (decompose-equality -6)
Applying decompose-equality,
this simplifies to: 
restrictlast_middle.1.2.1.1.2 : 
;;; this is the case of the run under consideration, so 2 must be proven by showing the parameters satisfy the EXISTS quantor in rho_last

{-1}  nlist(i!2`1) = nlist(cons(n_init, l!1))
{-2}  ilist(append(i!2`3, i!2`4)) = ilist(remove(hu_list, i!3))
[-3]  u!1 = hu(i!3)
[-4]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
[-5]  length(l!1) = i!3 - 1
[-6]  0 < i!3
[-7]  i!3 < p
[-8]  2 <= P!1
[-9]  0 < i!1`1
[-10] i!1`1 < P!1 - 1
  |-------
[1]   (i!1`2 = n_init)
[2]   rho_last(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   P!1 = 2

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictlast_middle.1.2.1.1.2 : 
;;; this is the case of the run under consideration, so 2 must be proven by showing the parameters satisfy the EXISTS quantor in rho_last

{-1}  i!2`1 = cons(n_init, l!1)
[-2]  ilist(append(i!2`3, i!2`4)) = ilist(remove(hu_list, i!3))
[-3]  u!1 = hu(i!3)
[-4]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
[-5]  length(l!1) = i!3 - 1
[-6]  0 < i!3
[-7]  i!3 < p
[-8]  2 <= P!1
[-9]  0 < i!1`1
[-10] i!1`1 < P!1 - 1
  |-------
[1]   (i!1`2 = n_init)
[2]   rho_last(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   P!1 = 2

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictlast_middle.1.2.1.1.2 : 
;;; this is the case of the run under consideration, so 2 must be proven by showing the parameters satisfy the EXISTS quantor in rho_last

{-1}  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-2]  i!2`1 = cons(n_init, l!1)
[-3]  u!1 = hu(i!3)
[-4]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
[-5]  length(l!1) = i!3 - 1
[-6]  0 < i!3
[-7]  i!3 < p
[-8]  2 <= P!1
[-9]  0 < i!1`1
[-10] i!1`1 < P!1 - 1
  |-------
[1]   (i!1`2 = n_init)
[2]   rho_last(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   P!1 = 2

Rerunning step: (typepred "i!2`1" "i!2`3" "i!2`4" "p" "hu_list")
Adding type constraints for  i!2`1, i!2`3, i!2`4, p, hu_list,
this simplifies to: 
restrictlast_middle.1.2.1.1.2 : 
;;; this is the case of the run under consideration, so 2 must be proven by showing the parameters satisfy the EXISTS quantor in rho_last

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`1)
{-2}  length(i!2`1) = i!1`1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`3)
{-4}  length(i!2`3) = i!1`1
{-5}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`4)
{-6}  length(i!2`4) = P!1 - 1 - i!1`1
{-7}  2 <= p
{-8}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-9}  (length(hu_list) = p)
{-10} FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-12] i!2`1 = cons(n_init, l!1)
[-13] u!1 = hu(i!3)
[-14] every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
[-15] length(l!1) = i!3 - 1
[-16] 0 < i!3
[-17] i!3 < p
[-18] 2 <= P!1
[-19] 0 < i!1`1
[-20] i!1`1 < P!1 - 1
  |-------
[1]   (i!1`2 = n_init)
[2]   rho_last(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   P!1 = 2

Rerunning step: (delete -1 -3 -5 -8 -14)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.2.1.1.2 : 
;;; this is the case of the run under consideration, so 2 must be proven by showing the parameters satisfy the EXISTS quantor in rho_last

[-1]  length(i!2`1) = i!1`1
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  2 <= p
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-8]  i!2`1 = cons(n_init, l!1)
[-9]  u!1 = hu(i!3)
[-10] length(l!1) = i!3 - 1
[-11] 0 < i!3
[-12] i!3 < p
[-13] 2 <= P!1
[-14] 0 < i!1`1
[-15] i!1`1 < P!1 - 1
  |-------
[1]   (i!1`2 = n_init)
[2]   rho_last(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   P!1 = 2

Rerunning step: (comment "derive value of i!3 from lists l!1 and i!2`1 and make explicit that P!1 = p")
Adding comment: derive value of i!3 from lists l!1 and i!2`1 and make explicit that P!1 = p
this simplifies to: 
restrictlast_middle.1.2.1.1.2 : 
;;; derive value of i!3 from lists l!1 and i!2`1 and make explicit that P!1 = p

[-1]  length(i!2`1) = i!1`1
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  2 <= p
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-8]  i!2`1 = cons(n_init, l!1)
[-9]  u!1 = hu(i!3)
[-10] length(l!1) = i!3 - 1
[-11] 0 < i!3
[-12] i!3 < p
[-13] 2 <= P!1
[-14] 0 < i!1`1
[-15] i!1`1 < P!1 - 1
  |-------
[1]   (i!1`2 = n_init)
[2]   rho_last(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   P!1 = 2

Rerunning step: (case "i!3=i!1`1 AND P!1=p")
Case splitting on 
   i!3 = i!1`1 AND P!1 = p, 
this yields  2 subgoals: 
restrictlast_middle.1.2.1.1.2.1 : 
;;; derive value of i!3 from lists l!1 and i!2`1 and make explicit that P!1 = p

{-1}  i!3 = i!1`1 AND P!1 = p
[-2]  length(i!2`1) = i!1`1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  2 <= p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-9]  i!2`1 = cons(n_init, l!1)
[-10] u!1 = hu(i!3)
[-11] length(l!1) = i!3 - 1
[-12] 0 < i!3
[-13] i!3 < p
[-14] 2 <= P!1
[-15] 0 < i!1`1
[-16] i!1`1 < P!1 - 1
  |-------
[1]   (i!1`2 = n_init)
[2]   rho_last(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   P!1 = 2

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1 : 
;;; derive value of i!3 from lists l!1 and i!2`1 and make explicit that P!1 = p

{-1}  i!3 = i!1`1
{-2}  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  2 <= p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-10] i!2`1 = cons(n_init, l!1)
[-11] u!1 = hu(i!3)
[-12] length(l!1) = i!3 - 1
[-13] 0 < i!3
[-14] i!3 < p
[-15] 2 <= P!1
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
  |-------
[1]   (i!1`2 = n_init)
[2]   rho_last(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   P!1 = 2

Rerunning step: (replace* -1)
Repeatedly applying the replace rule,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1 : 
;;; derive value of i!3 from lists l!1 and i!2`1 and make explicit that P!1 = p

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = P!1 - 1 - i!1`1
[-6]  2 <= p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
{-9}  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] i!2`1 = cons(n_init, l!1)
{-11} u!1 = hu(i!1`1)
{-12} length(l!1) = i!1`1 - 1
{-13} 0 < i!1`1
{-14} i!1`1 < p
[-15] 2 <= P!1
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
  |-------
[1]   (i!1`2 = n_init)
[2]   rho_last(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   P!1 = 2

Rerunning step: (replace* -2)
Repeatedly applying the replace rule,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1 : 
;;; derive value of i!3 from lists l!1 and i!2`1 and make explicit that P!1 = p

[-1]  i!3 = i!1`1
[-2]  P!1 = p
[-3]  length(i!2`1) = i!1`1
[-4]  length(i!2`3) = i!1`1
{-5}  length(i!2`4) = p - 1 - i!1`1
[-6]  2 <= p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] i!2`1 = cons(n_init, l!1)
[-11] u!1 = hu(i!1`1)
[-12] length(l!1) = i!1`1 - 1
[-13] 0 < i!1`1
[-14] i!1`1 < p
{-15} 2 <= p
[-16] 0 < i!1`1
{-17} i!1`1 < p - 1
  |-------
[1]   (i!1`2 = n_init)
[2]   rho_last(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
{3}   p = 2

Rerunning step: (delete -1 -2 -6 -13 -14)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1 : 
;;; derive value of i!3 from lists l!1 and i!2`1 and make explicit that P!1 = p

[-1]  length(i!2`1) = i!1`1
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = p - 1 - i!1`1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-7]  i!2`1 = cons(n_init, l!1)
[-8]  u!1 = hu(i!1`1)
[-9]  length(l!1) = i!1`1 - 1
[-10] 2 <= p
[-11] 0 < i!1`1
[-12] i!1`1 < p - 1
  |-------
[1]   (i!1`2 = n_init)
[2]   rho_last(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   p = 2

Rerunning step: (comment "let PVS simplify matters by grinding")
Adding comment: let PVS simplify matters by grinding
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1 : 
;;; let PVS simplify matters by grinding

[-1]  length(i!2`1) = i!1`1
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = p - 1 - i!1`1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-7]  i!2`1 = cons(n_init, l!1)
[-8]  u!1 = hu(i!1`1)
[-9]  length(l!1) = i!1`1 - 1
[-10] 2 <= p
[-11] 0 < i!1`1
[-12] i!1`1 < p - 1
  |-------
[1]   (i!1`2 = n_init)
[2]   rho_last(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   p = 2

Rerunning step: (grind :if-match nil :exclude ("elt" "remove"))
append rewrites append(i!2`1, (: i!1`2 :))
  to cons(car(i!2`1), append(cdr(i!2`1), (: i!1`2 :)))
rho_last rewrites 
  rho_last(nlist(cons(car(i!2`1), append(cdr(i!2`1), (: i!1`2 :)))))
  to NOT elt(cons(car(i!2`1), append(cdr(i!2`1), (: i!1`2 :))), n_init)
rho_last rewrites rho_last(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
  to TRUE
rho_last rewrites 
  rho_last(conc(nlist(cons(car(i!2`1), append(cdr(i!2`1), (: i!1`2 :)))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))
  to NOT elt(cons(car(i!2`1), append(cdr(i!2`1), (: i!1`2 :))), n_init)
rho_last rewrites 
  rho_last(code(public(car(i!2`4)),
                conc(nlist(cons(car(i!2`1),
                                append(cdr(i!2`1), (: i!1`2 :)))),
                     ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
  to NOT elt(cons(car(i!2`1), append(cdr(i!2`1), (: i!1`2 :))), n_init) OR
       EXISTS (i: {x: nat | 0 < x AND x < p}):
         public(car(i!2`4)) = public(hu(i)) AND
          EXISTS (l: {x: list[Nonce] | length(x) = i - 1}):
            conc(nlist(cons(car(i!2`1), append(cdr(i!2`1), (: i!1`2 :)))),
                 ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
             = conc(nlist(cons(n_init, l)), ilist(remove(hu_list, i)))
length rewrites length(cons(n_init, l!1))
  to 1 + length(l!1)
Trying repeated skolemization, instantiation, and if-lifting,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1 : 
;;; let PVS simplify matters by grinding

[-1]  length(i!2`3) = i!1`1
{-2}  length(i!2`4) = -1 - i!1`1 + p
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-6]  i!2`1 = cons(n_init, l!1)
[-7]  u!1 = hu(i!1`1)
[-8]  length(l!1) = i!1`1 - 1
{-9}  elt(cons(n_init, append(l!1, (: i!1`2 :))), n_init)
[-10] 2 <= p
[-11] 0 < i!1`1
[-12] i!1`1 < p - 1
  |-------
[1]   (i!1`2 = n_init)
{2}   EXISTS (i: {x: nat | 0 < x AND x < p}):
        public(car(i!2`4)) = public(hu(i)) AND
         EXISTS (l: {x: list[Nonce] | length(x) = i - 1}):
           conc(nlist(cons(n_init, append(l!1, (: i!1`2 :)))),
                ilist(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4)))))
            = conc(nlist(cons(n_init, l)), ilist(remove(hu_list, i)))
[3]   p = 2

Rerunning step: (comment "since the current agent is hu(i!1`1) [-7], car(i!2`4) must be hu(i!1`1+1)")
Adding comment: since the current agent is hu(i!1`1) [-7], car(i!2`4) must be hu(i!1`1+1)
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1 : 
;;; since the current agent is hu(i!1`1) [-7], car(i!2`4) must be hu(i!1`1+1)

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-6]  i!2`1 = cons(n_init, l!1)
[-7]  u!1 = hu(i!1`1)
[-8]  length(l!1) = i!1`1 - 1
[-9]  elt(cons(n_init, append(l!1, (: i!1`2 :))), n_init)
[-10] 2 <= p
[-11] 0 < i!1`1
[-12] i!1`1 < p - 1
  |-------
[1]   (i!1`2 = n_init)
[2]   EXISTS (i: {x: nat | 0 < x AND x < p}):
        public(car(i!2`4)) = public(hu(i)) AND
         EXISTS (l: {x: list[Nonce] | length(x) = i - 1}):
           conc(nlist(cons(n_init, append(l!1, (: i!1`2 :)))),
                ilist(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4)))))
            = conc(nlist(cons(n_init, l)), ilist(remove(hu_list, i)))
[3]   p = 2

Rerunning step: (inst 2 "i!1`1+1")
Instantiating the top quantifier in 2 with the terms: 
 i!1`1+1,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1 : 
;;; since the current agent is hu(i!1`1) [-7], car(i!2`4) must be hu(i!1`1+1)

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-6]  i!2`1 = cons(n_init, l!1)
[-7]  u!1 = hu(i!1`1)
[-8]  length(l!1) = i!1`1 - 1
[-9]  elt(cons(n_init, append(l!1, (: i!1`2 :))), n_init)
[-10] 2 <= p
[-11] 0 < i!1`1
[-12] i!1`1 < p - 1
  |-------
[1]   (i!1`2 = n_init)
{2}   public(car(i!2`4)) = public(hu(i!1`1 + 1)) AND
       EXISTS (l: {x: list[Nonce] | length(x) = i!1`1}):
         conc(nlist(cons(n_init, append(l!1, (: i!1`2 :)))),
              ilist(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4)))))
          = conc(nlist(cons(n_init, l)), ilist(remove(hu_list, i!1`1 + 1)))
[3]   p = 2

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
restrictlast_middle.1.2.1.1.2.1.1 : 
;;; since the current agent is hu(i!1`1) [-7], car(i!2`4) must be hu(i!1`1+1)

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-6]  i!2`1 = cons(n_init, l!1)
[-7]  u!1 = hu(i!1`1)
[-8]  length(l!1) = i!1`1 - 1
[-9]  elt(cons(n_init, append(l!1, (: i!1`2 :))), n_init)
[-10] 2 <= p
[-11] 0 < i!1`1
[-12] i!1`1 < p - 1
  |-------
{1}   public(car(i!2`4)) = public(hu(i!1`1 + 1))
[2]   (i!1`2 = n_init)
[3]   p = 2

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.1 : 
;;; since the current agent is hu(i!1`1) [-7], car(i!2`4) must be hu(i!1`1+1)

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-6]  i!2`1 = cons(n_init, l!1)
[-7]  u!1 = hu(i!1`1)
[-8]  length(l!1) = i!1`1 - 1
[-9]  elt(cons(n_init, append(l!1, (: i!1`2 :))), n_init)
[-10] 2 <= p
[-11] 0 < i!1`1
[-12] i!1`1 < p - 1
  |-------
{1}   car(i!2`4) = hu(1 + i!1`1)
[2]   (i!1`2 = n_init)
[3]   p = 2

Rerunning step: (delete -6 -7 -8 -9 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.1 : 
;;; since the current agent is hu(i!1`1) [-7], car(i!2`4) must be hu(i!1`1+1)

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-6]  2 <= p
[-7]  0 < i!1`1
[-8]  i!1`1 < p - 1
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)

Rerunning step: (comment "now retrieve element i!1`1 from both lists in -5")
Adding comment: now retrieve element i!1`1 from both lists in -5
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.1 : 
;;; now retrieve element i!1`1 from both lists in -5

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-6]  2 <= p
[-7]  0 < i!1`1
[-8]  i!1`1 < p - 1
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)

Rerunning step: (lemma "equality_nth[Identity]"
                 ("l1" "append(i!2`3, i!2`4)" "l2"
                  "remove(hu_list, i!1`1)"))
Applying equality_nth[Identity] where 
  l1 gets append(i!2`3, i!2`4),
  l2 gets remove(hu_list, i!1`1),
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.1 : 
;;; now retrieve element i!1`1 from both lists in -5

{-1}  append(i!2`3, i!2`4) = remove(hu_list, i!1`1) IMPLIES
       FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
         nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = -1 - i!1`1 + p
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-7]  2 <= p
[-8]  0 < i!1`1
[-9]  i!1`1 < p - 1
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.1 : 
;;; now retrieve element i!1`1 from both lists in -5

{-1}  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = -1 - i!1`1 + p
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-7]  2 <= p
[-8]  0 < i!1`1
[-9]  i!1`1 < p - 1
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)

Rerunning step: (inst -1 "i!1`1")
Instantiating the top quantifier in -1 with the terms: 
 i!1`1,
this yields  2 subgoals: 
restrictlast_middle.1.2.1.1.2.1.1.1 : 
;;; now retrieve element i!1`1 from both lists in -5

{-1}  nth(append(i!2`3, i!2`4), i!1`1) = nth(remove(hu_list, i!1`1), i!1`1)
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = -1 - i!1`1 + p
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-7]  2 <= p
[-8]  0 < i!1`1
[-9]  i!1`1 < p - 1
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)

Rerunning step: (rewrite "nth_append" -1)
Found matching substitution:
i: below[length(l1) + length(l2)] gets i!1`1,
l2: list[T] gets i!2`4,
l1: list[T] gets i!2`3,
nth rewrites nth(i!2`4, i!1`1 - length[Identity](i!2`3))
  to car(i!2`4)
Rewriting using nth_append, matching in -1,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.1.1 : 
;;; now retrieve element i!1`1 from both lists in -5

{-1}  car(i!2`4) = nth(remove(hu_list, i!1`1), i!1`1)
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = -1 - i!1`1 + p
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-7]  2 <= p
[-8]  0 < i!1`1
[-9]  i!1`1 < p - 1
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)

Rerunning step: (lemma "listprops[Identity].nth_remove"
                 ("l" "hu_list" "i" "i!1`1" "j" "i!1`1"))
Applying listprops[Identity].nth_remove where 
  l gets hu_list,
  i gets i!1`1,
  j gets i!1`1,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.1.1 : 
;;; now retrieve element i!1`1 from both lists in -5

{-1}  nth(remove(hu_list, i!1`1), i!1`1) =
       IF i!1`1 < i!1`1 THEN nth(hu_list, i!1`1)
       ELSE nth(hu_list, i!1`1 + 1)
       ENDIF
[-2]  car(i!2`4) = nth(remove(hu_list, i!1`1), i!1`1)
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = -1 - i!1`1 + p
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  2 <= p
[-9]  0 < i!1`1
[-10] i!1`1 < p - 1
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)

Rerunning step: (replace -1 -2)
Replacing using formula -1,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.1.1 : 
;;; now retrieve element i!1`1 from both lists in -5

[-1]  nth(remove(hu_list, i!1`1), i!1`1) =
       IF i!1`1 < i!1`1 THEN nth(hu_list, i!1`1)
       ELSE nth(hu_list, i!1`1 + 1)
       ENDIF
{-2}  car(i!2`4) =
       IF i!1`1 < i!1`1 THEN nth(hu_list, i!1`1)
       ELSE nth(hu_list, i!1`1 + 1)
       ENDIF
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = -1 - i!1`1 + p
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  2 <= p
[-9]  0 < i!1`1
[-10] i!1`1 < p - 1
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.1.1 : 
;;; now retrieve element i!1`1 from both lists in -5

[-1]  car(i!2`4) =
       IF i!1`1 < i!1`1 THEN nth(hu_list, i!1`1)
       ELSE nth(hu_list, i!1`1 + 1)
       ENDIF
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = -1 - i!1`1 + p
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-7]  2 <= p
[-8]  0 < i!1`1
[-9]  i!1`1 < p - 1
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)

Rerunning step: (inst -5 "i!1`1+1")
Instantiating the top quantifier in -5 with the terms: 
 i!1`1+1,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.1.1 : 
;;; now retrieve element i!1`1 from both lists in -5

[-1]  car(i!2`4) =
       IF i!1`1 < i!1`1 THEN nth(hu_list, i!1`1)
       ELSE nth(hu_list, i!1`1 + 1)
       ENDIF
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = -1 - i!1`1 + p
[-4]  (length(hu_list) = p)
{-5}  nth(hu_list, i!1`1 + 1) = hu(i!1`1 + 1)
[-6]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-7]  2 <= p
[-8]  0 < i!1`1
[-9]  i!1`1 < p - 1
  |-------
[1]   car(i!2`4) = hu(1 + i!1`1)

Rerunning step: (ground)
nth rewrites nth(cdr(hu_list), i!1`1)
  to nth(cdr(cdr(hu_list)), i!1`1 - 1)
nth rewrites nth(hu_list, 1 + i!1`1)
  to nth(cdr(cdr(hu_list)), i!1`1 - 1)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_middle.1.2.1.1.2.1.1.1.

restrictlast_middle.1.2.1.1.2.1.1.2 (TCC):   

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-6]  2 <= p
[-7]  0 < i!1`1
[-8]  i!1`1 < p - 1
  |-------
{1}   i!1`1 < length[Identity](append[Identity](i!2`3, i!2`4))
[2]   car(i!2`4) = hu(1 + i!1`1)

Rerunning step: (delete -3 -4 -5 -6 -7 2)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.1.2 : 
;;; now retrieve element i!1`1 from both lists in -5

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  i!1`1 < p - 1
  |-------
[1]   i!1`1 < length[Identity](append[Identity](i!2`3, i!2`4))

Rerunning step: (rewrite "length_append")
Found matching substitution:
l2: list[T] gets i!2`4,
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in *,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.1.2 : 
;;; now retrieve element i!1`1 from both lists in -5

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  i!1`1 < p - 1
  |-------
{1}   i!1`1 < length(i!2`3) + length(i!2`4)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_middle.1.2.1.1.2.1.1.2.


This completes the proof of restrictlast_middle.1.2.1.1.2.1.1.

restrictlast_middle.1.2.1.1.2.1.2 : 
;;; since the current agent is hu(i!1`1) [-7], car(i!2`4) must be hu(i!1`1+1)

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-6]  i!2`1 = cons(n_init, l!1)
[-7]  u!1 = hu(i!1`1)
[-8]  length(l!1) = i!1`1 - 1
[-9]  elt(cons(n_init, append(l!1, (: i!1`2 :))), n_init)
[-10] 2 <= p
[-11] 0 < i!1`1
[-12] i!1`1 < p - 1
  |-------
{1}   EXISTS (l: {x: list[Nonce] | length(x) = i!1`1}):
        conc(nlist(cons(n_init, append(l!1, (: i!1`2 :)))),
             ilist(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4)))))
         = conc(nlist(cons(n_init, l)), ilist(remove(hu_list, i!1`1 + 1)))
[2]   (i!1`2 = n_init)
[3]   p = 2

Rerunning step: (comment "the choice for instantiation is obvious: append(l!1, (: i!1`2 :))")
Adding comment: the choice for instantiation is obvious: append(l!1, (: i!1`2 :))
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2 : 
;;; the choice for instantiation is obvious: append(l!1, (: i!1`2 :))

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-6]  i!2`1 = cons(n_init, l!1)
[-7]  u!1 = hu(i!1`1)
[-8]  length(l!1) = i!1`1 - 1
[-9]  elt(cons(n_init, append(l!1, (: i!1`2 :))), n_init)
[-10] 2 <= p
[-11] 0 < i!1`1
[-12] i!1`1 < p - 1
  |-------
[1]   EXISTS (l: {x: list[Nonce] | length(x) = i!1`1}):
        conc(nlist(cons(n_init, append(l!1, (: i!1`2 :)))),
             ilist(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4)))))
         = conc(nlist(cons(n_init, l)), ilist(remove(hu_list, i!1`1 + 1)))
[2]   (i!1`2 = n_init)
[3]   p = 2

Rerunning step: (inst 1 "append(l!1, (: i!1`2 :))")
Instantiating the top quantifier in 1 with the terms: 
 append(l!1, (: i!1`2 :)),
this yields  2 subgoals: 
restrictlast_middle.1.2.1.1.2.1.2.1 : 
;;; the choice for instantiation is obvious: append(l!1, (: i!1`2 :))

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-6]  i!2`1 = cons(n_init, l!1)
[-7]  u!1 = hu(i!1`1)
[-8]  length(l!1) = i!1`1 - 1
[-9]  elt(cons(n_init, append(l!1, (: i!1`2 :))), n_init)
[-10] 2 <= p
[-11] 0 < i!1`1
[-12] i!1`1 < p - 1
  |-------
{1}   conc(nlist(cons(n_init, append(l!1, (: i!1`2 :)))),
           ilist(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4)))))
       =
       conc(nlist(cons(n_init, append(l!1, (: i!1`2 :)))),
            ilist(remove(hu_list, i!1`1 + 1)))
[2]   (i!1`2 = n_init)
[3]   p = 2

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.1 : 
;;; the choice for instantiation is obvious: append(l!1, (: i!1`2 :))

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-6]  i!2`1 = cons(n_init, l!1)
[-7]  u!1 = hu(i!1`1)
[-8]  length(l!1) = i!1`1 - 1
[-9]  elt(cons(n_init, append(l!1, (: i!1`2 :))), n_init)
[-10] 2 <= p
[-11] 0 < i!1`1
[-12] i!1`1 < p - 1
  |-------
{1}   ilist(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4)))) =
       ilist(remove(hu_list, 1 + i!1`1))
[2]   (i!1`2 = n_init)
[3]   p = 2

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.1 : 
;;; the choice for instantiation is obvious: append(l!1, (: i!1`2 :))

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-6]  i!2`1 = cons(n_init, l!1)
[-7]  u!1 = hu(i!1`1)
[-8]  length(l!1) = i!1`1 - 1
[-9]  elt(cons(n_init, append(l!1, (: i!1`2 :))), n_init)
[-10] 2 <= p
[-11] 0 < i!1`1
[-12] i!1`1 < p - 1
  |-------
{1}   append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))) =
       remove(hu_list, 1 + i!1`1)
[2]   (i!1`2 = n_init)
[3]   p = 2

Rerunning step: (delete -6 -7 -8 -9 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.1 : 
;;; the choice for instantiation is obvious: append(l!1, (: i!1`2 :))

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-6]  2 <= p
[-7]  0 < i!1`1
[-8]  i!1`1 < p - 1
  |-------
[1]   append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))) =
       remove(hu_list, 1 + i!1`1)

Rerunning step: (comment "prove equality of lists by proving equality of lengths and elements")
Adding comment: prove equality of lists by proving equality of lengths and elements
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.1 : 
;;; prove equality of lists by proving equality of lengths and elements

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-6]  2 <= p
[-7]  0 < i!1`1
[-8]  i!1`1 < p - 1
  |-------
[1]   append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))) =
       remove(hu_list, 1 + i!1`1)

Rerunning step: (rewrite "length_nth_equality[Identity]")
Found matching substitution:
l2: list[Identity] gets remove(hu_list, 1 + i!1`1),
l1: list[Identity] gets append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))),
Rewriting using length_nth_equality[Identity], matching in *,
this yields  2 subgoals: 
restrictlast_middle.1.2.1.1.2.1.2.1.1 : 
;;; prove equality of lists by proving equality of lengths and elements

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-6]  2 <= p
[-7]  0 < i!1`1
[-8]  i!1`1 < p - 1
  |-------
{1}   length[Identity](append(i!2`3, cons(hu(i!1`1), cdr(i!2`4)))) =
       length[Identity](remove(hu_list, 1 + i!1`1))
[2]   append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))) =
       remove(hu_list, 1 + i!1`1)

Rerunning step: (delete -4 -5 -6 -7 -8 2)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.1.1 : 
;;; prove equality of lists by proving equality of lengths and elements

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  (length(hu_list) = p)
  |-------
[1]   length[Identity](append(i!2`3, cons(hu(i!1`1), cdr(i!2`4)))) =
       length[Identity](remove(hu_list, 1 + i!1`1))

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets cons(hu(i!1`1), cdr(i!2`4)),
l1: list[T] gets i!2`3,
length rewrites length(cons(hu(i!1`1), cdr(i!2`4)))
  to 1 + length(cdr(i!2`4))
Rewriting using length_append, matching in 1,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.1.1 : 
;;; prove equality of lists by proving equality of lengths and elements

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  (length(hu_list) = p)
  |-------
{1}   1 + length(cdr(i!2`4)) + length(i!2`3) =
       length[Identity](remove(hu_list, 1 + i!1`1))

Rerunning step: (rewrite "length_cdr" 1)
Found matching substitution:
cons_l: (cons?[T]) gets i!2`4,
Rewriting using length_cdr, matching in 1,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.1.1 : 
;;; prove equality of lists by proving equality of lengths and elements

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  (length(hu_list) = p)
  |-------
{1}   1 + (length(i!2`4) - 1) + length(i!2`3) =
       length[Identity](remove(hu_list, 1 + i!1`1))

Rerunning step: (rewrite "length_remove" 1 :dir rl)
Found matching substitution:
i: below[length(c)] gets 1 + i!1`1,
c: (cons?[T]) gets hu_list,
length rewrites length(hu_list)
  to 0
Rewriting using length_remove, matching in 1,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.1.1 : 
;;; prove equality of lists by proving equality of lengths and elements

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  (length(hu_list) = p)
  |-------
{1}   1 + (length(i!2`4) - 1) + length(i!2`3) =
       length[Identity](hu_list) - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_middle.1.2.1.1.2.1.2.1.1.

restrictlast_middle.1.2.1.1.2.1.2.1.2 : 
;;; prove equality of lists by proving equality of lengths and elements

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-6]  2 <= p
[-7]  0 < i!1`1
[-8]  i!1`1 < p - 1
  |-------
{1}   FORALL (i:
                below[length[Identity]
                          (append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))))]):
        nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i) =
         nth(remove(hu_list, 1 + i!1`1), i)
[2]   append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))) =
       remove(hu_list, 1 + i!1`1)

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.1.2 : 
;;; prove equality of lists by proving equality of lengths and elements

{-1}  i!4 < length[Identity](append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))))
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = -1 - i!1`1 + p
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-7]  2 <= p
[-8]  0 < i!1`1
[-9]  i!1`1 < p - 1
  |-------
{1}   nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i!4) =
       nth(remove(hu_list, 1 + i!1`1), i!4)
[2]   append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))) =
       remove(hu_list, 1 + i!1`1)

Rerunning step: (comment "use equality in -6 and use properties of nth distributed over remove and append")
Adding comment: use equality in -6 and use properties of nth distributed over remove and append
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.1.2 : 
;;; use equality in -6 and use properties of nth distributed over remove and append

[-1]  i!4 < length[Identity](append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))))
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = -1 - i!1`1 + p
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-7]  2 <= p
[-8]  0 < i!1`1
[-9]  i!1`1 < p - 1
  |-------
[1]   nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i!4) =
       nth(remove(hu_list, 1 + i!1`1), i!4)
[2]   append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))) =
       remove(hu_list, 1 + i!1`1)

Rerunning step: (comment "first, simplify -1")
Adding comment: first, simplify -1
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.1.2 : 
;;; first, simplify -1

[-1]  i!4 < length[Identity](append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))))
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = -1 - i!1`1 + p
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-7]  2 <= p
[-8]  0 < i!1`1
[-9]  i!1`1 < p - 1
  |-------
[1]   nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i!4) =
       nth(remove(hu_list, 1 + i!1`1), i!4)
[2]   append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))) =
       remove(hu_list, 1 + i!1`1)

Rerunning step: (case "i!4<p-1")
Case splitting on 
   i!4 < p - 1, 
this yields  2 subgoals: 
restrictlast_middle.1.2.1.1.2.1.2.1.2.1 : 
;;; first, simplify -1

{-1}  i!4 < p - 1
[-2]  i!4 < length[Identity](append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))))
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = -1 - i!1`1 + p
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  2 <= p
[-9]  0 < i!1`1
[-10] i!1`1 < p - 1
  |-------
[1]   nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i!4) =
       nth(remove(hu_list, 1 + i!1`1), i!4)
[2]   append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))) =
       remove(hu_list, 1 + i!1`1)

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.1.2.1 : 
;;; first, simplify -1

[-1]  i!4 < p - 1
[-2]  i!4 < length[Identity](append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))))
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = -1 - i!1`1 + p
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  2 <= p
[-9]  0 < i!1`1
[-10] i!1`1 < p - 1
  |-------
[1]   nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i!4) =
       nth(remove(hu_list, 1 + i!1`1), i!4)

Rerunning step: (lemma "listprops[Identity].equality_nth"
                 ("l1" "append(i!2`3, i!2`4)" "l2"
                  "remove(hu_list, i!1`1)"))
Applying listprops[Identity].equality_nth where 
  l1 gets append(i!2`3, i!2`4),
  l2 gets remove(hu_list, i!1`1),
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.1.2.1 : 
;;; first, simplify -1

{-1}  append(i!2`3, i!2`4) = remove(hu_list, i!1`1) IMPLIES
       FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
         nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-2]  i!4 < p - 1
[-3]  i!4 < length[Identity](append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))))
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = -1 - i!1`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  2 <= p
[-10] 0 < i!1`1
[-11] i!1`1 < p - 1
  |-------
[1]   nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i!4) =
       nth(remove(hu_list, 1 + i!1`1), i!4)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.1.2.1 : 
;;; first, simplify -1

{-1}  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-2]  i!4 < p - 1
[-3]  i!4 < length[Identity](append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))))
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = -1 - i!1`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  2 <= p
[-10] 0 < i!1`1
[-11] i!1`1 < p - 1
  |-------
[1]   nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i!4) =
       nth(remove(hu_list, 1 + i!1`1), i!4)

Rerunning step: (lemma "listprops[Identity].nth_append"
                 ("l1" "i!2`3" "l2" "cons(hu(i!1`1), cdr(i!2`4))" "i"
                  "i!4"))
length rewrites 
  length[Identity](cons[Identity](hu(i!1`1), cdr[Identity](i!2`4)))
  to 1 + length(cdr[Identity](i!2`4))
Applying listprops[Identity].nth_append where 
  l1 gets i!2`3,
  l2 gets cons(hu(i!1`1), cdr(i!2`4)),
  i gets i!4,
this yields  2 subgoals: 
restrictlast_middle.1.2.1.1.2.1.2.1.2.1.1 : 
;;; first, simplify -1

{-1}  nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i!4) =
       IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
       ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
       ENDIF
[-2]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-3]  i!4 < p - 1
[-4]  i!4 < length[Identity](append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))))
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] 2 <= p
[-11] 0 < i!1`1
[-12] i!1`1 < p - 1
  |-------
[1]   nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i!4) =
       nth(remove(hu_list, 1 + i!1`1), i!4)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.1.2.1.1 : 
;;; first, simplify -1

[-1]  nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i!4) =
       IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
       ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
       ENDIF
[-2]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-3]  i!4 < p - 1
[-4]  i!4 < length[Identity](append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))))
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] 2 <= p
[-11] 0 < i!1`1
[-12] i!1`1 < p - 1
  |-------
{1}   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, 1 + i!1`1), i!4)

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.1.2.1.1 : 
;;; first, simplify -1

[-1]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-2]  i!4 < p - 1
[-3]  i!4 < length[Identity](append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))))
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = -1 - i!1`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  2 <= p
[-10] 0 < i!1`1
[-11] i!1`1 < p - 1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, 1 + i!1`1), i!4)

Rerunning step: (lemma "listprops[Identity].nth_remove"
                 ("l" "hu_list" "i" "i!1`1+1" "j" "i!4"))
Applying listprops[Identity].nth_remove where 
  l gets hu_list,
  i gets i!1`1 + 1,
  j gets i!4,
this yields  2 subgoals: 
restrictlast_middle.1.2.1.1.2.1.2.1.2.1.1.1 : 
;;; first, simplify -1

{-1}  nth(remove(hu_list, i!1`1 + 1), i!4) =
       IF i!4 < i!1`1 + 1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF
[-2]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-3]  i!4 < p - 1
[-4]  i!4 < length[Identity](append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))))
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] 2 <= p
[-11] 0 < i!1`1
[-12] i!1`1 < p - 1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, 1 + i!1`1), i!4)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.1.2.1.1.1 : 
;;; first, simplify -1

[-1]  nth(remove(hu_list, i!1`1 + 1), i!4) =
       IF i!4 < i!1`1 + 1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF
[-2]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-3]  i!4 < p - 1
[-4]  i!4 < length[Identity](append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))))
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] 2 <= p
[-11] 0 < i!1`1
[-12] i!1`1 < p - 1
  |-------
{1}   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < i!1`1 + 1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.1.2.1.1.1 : 
;;; first, simplify -1

[-1]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-2]  i!4 < p - 1
[-3]  i!4 < length[Identity](append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))))
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = -1 - i!1`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  2 <= p
[-10] 0 < i!1`1
[-11] i!1`1 < p - 1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < i!1`1 + 1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (comment "use the equality in -7 (or -1) to prove 1")
Adding comment: use the equality in -7 (or -1) to prove 1
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.1.2.1.1.1 : 
;;; use the equality in -7 (or -1) to prove 1

[-1]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-2]  i!4 < p - 1
[-3]  i!4 < length[Identity](append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))))
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = -1 - i!1`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  2 <= p
[-10] 0 < i!1`1
[-11] i!1`1 < p - 1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < i!1`1 + 1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (lemma "listprops[Identity].nth_append"
                 ("l1" "i!2`3" "l2" "i!2`4"))
Applying listprops[Identity].nth_append where 
  l1 gets i!2`3,
  l2 gets i!2`4,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.1.2.1.1.1 : 
;;; use the equality in -7 (or -1) to prove 1

{-1}  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < length[Identity](i!2`3) THEN nth(i!2`3, i)
         ELSE nth(i!2`4, i - length[Identity](i!2`3))
         ENDIF
[-2]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-3]  i!4 < p - 1
[-4]  i!4 < length[Identity](append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))))
[-5]  length(i!2`3) = i!1`1
[-6]  length(i!2`4) = -1 - i!1`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-10] 2 <= p
[-11] 0 < i!1`1
[-12] i!1`1 < p - 1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < i!1`1 + 1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (lemma "listprops[Identity].nth_remove"
                 ("l" "hu_list" "i" "i!1`1"))
Applying listprops[Identity].nth_remove where 
  l gets hu_list,
  i gets i!1`1,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.1.2.1.1.1 : 
;;; use the equality in -7 (or -1) to prove 1

{-1}  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!1`1), j) =
         IF j < i!1`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-2]  FORALL (i: below[length[Identity](i!2`3) + length[Identity](i!2`4)]):
        nth(append(i!2`3, i!2`4), i) =
         IF i < length[Identity](i!2`3) THEN nth(i!2`3, i)
         ELSE nth(i!2`4, i - length[Identity](i!2`3))
         ENDIF
[-3]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-4]  i!4 < p - 1
[-5]  i!4 < length[Identity](append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))))
[-6]  length(i!2`3) = i!1`1
[-7]  length(i!2`4) = -1 - i!1`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-11] 2 <= p
[-12] 0 < i!1`1
[-13] i!1`1 < p - 1
  |-------
[1]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       =
       IF i!4 < i!1`1 + 1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (grind :exclude ("append" "remove"))
nth rewrites nth(cdr(hu_list), j)
  to nth(cdr(cdr(hu_list)), j - 1)
nth rewrites nth(hu_list, 1 + j)
  to nth(cdr(cdr(hu_list)), j - 1)
nth rewrites nth(hu_list, 1 + i!4)
  to nth(cdr(hu_list), i!4)
nth rewrites nth(cdr(cdr(hu_list)), i!4 - 1)
  to nth(cdr(cdr(cdr(hu_list))), i!4 - 2)
nth rewrites nth(cdr(hu_list), i!4)
  to nth(cdr(cdr(cdr(hu_list))), i!4 - 2)
nth rewrites nth(remove(hu_list, i!1`1), i!4)
  to nth(cdr(remove(hu_list, i!1`1)), i!4 - 1)
nth rewrites nth(hu_list, i!4)
  to nth(cdr(hu_list), i!4 - 1)
nth rewrites nth(remove(hu_list, i!1`1), i!4)
  to nth(cdr(remove(hu_list, i!1`1)), i!4 - 1)
nth rewrites nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - i!1`1)
  to hu(i!1`1)
nth rewrites nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - i!1`1)
  to nth(cdr(i!2`4), -1 - i!1`1 + i!4)
nth rewrites nth(i!2`4, i!4 - i!1`1)
  to car(i!2`4)
nth rewrites nth(hu_list, i!1`1)
  to nth(cdr(hu_list), i!1`1 - 1)
nth rewrites nth(i!2`4, i!4 - i!1`1)
  to car(i!2`4)
nth rewrites nth(hu_list, i!1`1)
  to nth(cdr(hu_list), i!1`1 - 1)
nth rewrites nth(cdr(remove(hu_list, i!1`1)), i!4 - 1)
  to nth(cdr(cdr(remove(hu_list, i!1`1))), i!4 - 2)
nth rewrites nth(i!2`4, i!4 - i!1`1)
  to nth(cdr(i!2`4), -1 - i!1`1 + i!4)
nth rewrites nth(cdr(cdr(hu_list)), i!4 - 1)
  to nth(cdr(cdr(cdr(hu_list))), i!4 - 2)
nth rewrites nth(cdr(remove(hu_list, i!1`1)), i!4 - 1)
  to nth(cdr(cdr(remove(hu_list, i!1`1))), i!4 - 2)
nth rewrites nth(i!2`4, i!4 - i!1`1)
  to nth(cdr(i!2`4), -1 - i!1`1 + i!4)
nth rewrites nth(cdr(cdr(hu_list)), i!4 - 1)
  to nth(cdr(cdr(cdr(hu_list))), i!4 - 2)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictlast_middle.1.2.1.1.2.1.2.1.2.1.1.1.

restrictlast_middle.1.2.1.1.2.1.2.1.2.1.1.2T (TCC):   

[-1]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-2]  i!4 < p - 1
[-3]  i!4 < length[Identity](append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))))
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = -1 - i!1`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  2 <= p
[-10] 0 < i!1`1
[-11] i!1`1 < p - 1
  |-------
{1}   i!4 < length[Identity](hu_list) - 1
[2]   IF i!4 < length[Identity](i!2`3) THEN nth(i!2`3, i!4)
      ELSE nth(cons(hu(i!1`1), cdr(i!2`4)), i!4 - length[Identity](i!2`3))
      ENDIF
       = nth(remove(hu_list, 1 + i!1`1), i!4)

Rerunning step: (delete -1 -3 -4 -5 -7 -8 -9 -10 -11 2)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.1.2.1.1.2T : 
;;; first, simplify -1

[-1]  i!4 < p - 1
[-2]  (length(hu_list) = p)
  |-------
[1]   i!4 < length[Identity](hu_list) - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_middle.1.2.1.1.2.1.2.1.2.1.1.2T.


This completes the proof of restrictlast_middle.1.2.1.1.2.1.2.1.2.1.1.

restrictlast_middle.1.2.1.1.2.1.2.1.2.1.2T (TCC):   

[-1]  FORALL (i: below[length[Identity](append(i!2`3, i!2`4))]):
        nth(append(i!2`3, i!2`4), i) = nth(remove(hu_list, i!1`1), i)
[-2]  i!4 < p - 1
[-3]  i!4 < length[Identity](append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))))
[-4]  length(i!2`3) = i!1`1
[-5]  length(i!2`4) = -1 - i!1`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-9]  2 <= p
[-10] 0 < i!1`1
[-11] i!1`1 < p - 1
  |-------
{1}   i!4 < 1 + length(cdr[Identity](i!2`4)) + length[Identity](i!2`3)
[2]   nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i!4) =
       nth(remove(hu_list, 1 + i!1`1), i!4)

Rerunning step: (delete -1 -2 -4 -5 -6 -7 -8 -9 -10 -11 2)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.1.2.1.2T : 
;;; first, simplify -1

[-1]  i!4 < length[Identity](append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))))
  |-------
[1]   i!4 < 1 + length(cdr[Identity](i!2`4)) + length[Identity](i!2`3)

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets cons(hu(i!1`1), cdr(i!2`4)),
l1: list[T] gets i!2`3,
length rewrites length(cons(hu(i!1`1), cdr(i!2`4)))
  to 1 + length(cdr(i!2`4))
Rewriting using length_append, matching in -1,

This completes the proof of restrictlast_middle.1.2.1.1.2.1.2.1.2.1.2T.


This completes the proof of restrictlast_middle.1.2.1.1.2.1.2.1.2.1.

restrictlast_middle.1.2.1.1.2.1.2.1.2.2 : 
;;; first, simplify -1

[-1]  i!4 < length[Identity](append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))))
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = -1 - i!1`1 + p
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-7]  2 <= p
[-8]  0 < i!1`1
[-9]  i!1`1 < p - 1
  |-------
{1}   i!4 < p - 1
[2]   nth(append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))), i!4) =
       nth(remove(hu_list, 1 + i!1`1), i!4)
[3]   append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))) =
       remove(hu_list, 1 + i!1`1)

Rerunning step: (delete -4 -5 -6 -7 -8 -9 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.1.2.2 : 
;;; first, simplify -1

[-1]  i!4 < length[Identity](append(i!2`3, cons(hu(i!1`1), cdr(i!2`4))))
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = -1 - i!1`1 + p
  |-------
[1]   i!4 < p - 1

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets cons(hu(i!1`1), cdr(i!2`4)),
l1: list[T] gets i!2`3,
length rewrites length(cons(hu(i!1`1), cdr(i!2`4)))
  to 1 + length(cdr(i!2`4))
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.1.2.2 : 
;;; first, simplify -1

{-1}  i!4 < 1 + length(cdr(i!2`4)) + length(i!2`3)
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = -1 - i!1`1 + p
  |-------
[1]   i!4 < p - 1

Rerunning step: (rewrite "length_cdr" -1)
Found matching substitution:
cons_l: (cons?[T]) gets i!2`4,
Rewriting using length_cdr, matching in -1,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.1.2.2 : 
;;; first, simplify -1

{-1}  i!4 < 1 + (length(i!2`4) - 1) + length(i!2`3)
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = -1 - i!1`1 + p
  |-------
[1]   i!4 < p - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_middle.1.2.1.1.2.1.2.1.2.2.


This completes the proof of restrictlast_middle.1.2.1.1.2.1.2.1.2.


This completes the proof of restrictlast_middle.1.2.1.1.2.1.2.1.

restrictlast_middle.1.2.1.1.2.1.2.2 (TCC):   

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = -1 - i!1`1 + p
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-6]  i!2`1 = cons(n_init, l!1)
[-7]  u!1 = hu(i!1`1)
[-8]  length(l!1) = i!1`1 - 1
[-9]  elt(cons(n_init, append(l!1, (: i!1`2 :))), n_init)
[-10] 2 <= p
[-11] 0 < i!1`1
[-12] i!1`1 < p - 1
  |-------
{1}   length[Nonce](append[Nonce](l!1, (: i!1`2 :))) = i!1`1
[2]   (i!1`2 = n_init)
[3]   p = 2

Rerunning step: (delete -1 -2 -3 -4 -5 -6 -7 -9 -10 -11 -12 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.2 : 
;;; the choice for instantiation is obvious: append(l!1, (: i!1`2 :))

[-1]  length(l!1) = i!1`1 - 1
  |-------
[1]   length[Nonce](append[Nonce](l!1, (: i!1`2 :))) = i!1`1

Rerunning step: (rewrite "length_append")
Found matching substitution:
l2: list[T] gets (: i!1`2 :),
l1: list[T] gets l!1,
length rewrites length((: :))
  to 0
length rewrites length((: i!1`2 :))
  to 1
Rewriting using length_append, matching in *,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.1.2.2 : 
;;; the choice for instantiation is obvious: append(l!1, (: i!1`2 :))

[-1]  length(l!1) = i!1`1 - 1
  |-------
{1}   1 + length(l!1) = i!1`1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_middle.1.2.1.1.2.1.2.2.


This completes the proof of restrictlast_middle.1.2.1.1.2.1.2.


This completes the proof of restrictlast_middle.1.2.1.1.2.1.

restrictlast_middle.1.2.1.1.2.2 : 
;;; derive value of i!3 from lists l!1 and i!2`1 and make explicit that P!1 = p

[-1]  length(i!2`1) = i!1`1
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  2 <= p
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-8]  i!2`1 = cons(n_init, l!1)
[-9]  u!1 = hu(i!3)
[-10] length(l!1) = i!3 - 1
[-11] 0 < i!3
[-12] i!3 < p
[-13] 2 <= P!1
[-14] 0 < i!1`1
[-15] i!1`1 < P!1 - 1
  |-------
{1}   i!3 = i!1`1 AND P!1 = p
[2]   (i!1`2 = n_init)
[3]   rho_last(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[4]   P!1 = 2

Rerunning step: (replace -8 -1)
Replacing using formula -8,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.2 : 
;;; derive value of i!3 from lists l!1 and i!2`1 and make explicit that P!1 = p

{-1}  length(cons(n_init, l!1)) = i!1`1
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  2 <= p
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-8]  i!2`1 = cons(n_init, l!1)
[-9]  u!1 = hu(i!3)
[-10] length(l!1) = i!3 - 1
[-11] 0 < i!3
[-12] i!3 < p
[-13] 2 <= P!1
[-14] 0 < i!1`1
[-15] i!1`1 < P!1 - 1
  |-------
[1]   i!3 = i!1`1 AND P!1 = p
[2]   (i!1`2 = n_init)
[3]   rho_last(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[4]   P!1 = 2

Rerunning step: (expand "length" -1)
Expanding the definition of length,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.2 : 
;;; derive value of i!3 from lists l!1 and i!2`1 and make explicit that P!1 = p

{-1}  1 + length(l!1) = i!1`1
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  2 <= p
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-8]  i!2`1 = cons(n_init, l!1)
[-9]  u!1 = hu(i!3)
[-10] length(l!1) = i!3 - 1
[-11] 0 < i!3
[-12] i!3 < p
[-13] 2 <= P!1
[-14] 0 < i!1`1
[-15] i!1`1 < P!1 - 1
  |-------
[1]   i!3 = i!1`1 AND P!1 = p
[2]   (i!1`2 = n_init)
[3]   rho_last(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[4]   P!1 = 2

Rerunning step: (replace -10 -1)
Replacing using formula -10,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.2 : 
;;; derive value of i!3 from lists l!1 and i!2`1 and make explicit that P!1 = p

{-1}  1 + (i!3 - 1) = i!1`1
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  2 <= p
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-8]  i!2`1 = cons(n_init, l!1)
[-9]  u!1 = hu(i!3)
[-10] length(l!1) = i!3 - 1
[-11] 0 < i!3
[-12] i!3 < p
[-13] 2 <= P!1
[-14] 0 < i!1`1
[-15] i!1`1 < P!1 - 1
  |-------
[1]   i!3 = i!1`1 AND P!1 = p
[2]   (i!1`2 = n_init)
[3]   rho_last(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[4]   P!1 = 2

Rerunning step: (simplify -1)
Simplifying with decision procedures,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.2 : 
;;; derive value of i!3 from lists l!1 and i!2`1 and make explicit that P!1 = p

{-1}  i!3 = i!1`1
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  2 <= p
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  append(i!2`3, i!2`4) = remove(hu_list, i!3)
[-8]  i!2`1 = cons(n_init, l!1)
[-9]  u!1 = hu(i!3)
[-10] length(l!1) = i!3 - 1
[-11] 0 < i!3
[-12] i!3 < p
[-13] 2 <= P!1
[-14] 0 < i!1`1
[-15] i!1`1 < P!1 - 1
  |-------
[1]   i!3 = i!1`1 AND P!1 = p
[2]   (i!1`2 = n_init)
[3]   rho_last(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[4]   P!1 = 2

Rerunning step: (replace* -1)
Repeatedly applying the replace rule,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.2 : 
;;; derive value of i!3 from lists l!1 and i!2`1 and make explicit that P!1 = p

[-1]  i!3 = i!1`1
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  2 <= p
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
{-7}  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
[-8]  i!2`1 = cons(n_init, l!1)
{-9}  u!1 = hu(i!1`1)
{-10} length(l!1) = i!1`1 - 1
{-11} 0 < i!1`1
{-12} i!1`1 < p
[-13] 2 <= P!1
[-14] 0 < i!1`1
[-15] i!1`1 < P!1 - 1
  |-------
{1}   P!1 = p
[2]   (i!1`2 = n_init)
[3]   rho_last(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[4]   P!1 = 2

Rerunning step: (delete -1 -4 -6 -8 -9 -10 -11 -12 -13 -14 -15 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.2 : 
;;; derive value of i!3 from lists l!1 and i!2`1 and make explicit that P!1 = p

[-1]  length(i!2`3) = i!1`1
[-2]  length(i!2`4) = P!1 - 1 - i!1`1
[-3]  (length(hu_list) = p)
[-4]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
  |-------
[1]   P!1 = p

Rerunning step: (lemma "listprops[Identity].equality_length"
                 ("l1" "append(i!2`3, i!2`4)" "l2"
                  "remove(hu_list, i!1`1)"))
Applying listprops[Identity].equality_length where 
  l1 gets append(i!2`3, i!2`4),
  l2 gets remove(hu_list, i!1`1),
this simplifies to: 
restrictlast_middle.1.2.1.1.2.2 : 
;;; derive value of i!3 from lists l!1 and i!2`1 and make explicit that P!1 = p

{-1}  append(i!2`3, i!2`4) = remove(hu_list, i!1`1) IMPLIES
       length[Identity](append(i!2`3, i!2`4)) =
        length[Identity](remove(hu_list, i!1`1))
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  (length(hu_list) = p)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
  |-------
[1]   P!1 = p

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.2 : 
;;; derive value of i!3 from lists l!1 and i!2`1 and make explicit that P!1 = p

{-1}  length[Identity](append(i!2`3, i!2`4)) =
       length[Identity](remove(hu_list, i!1`1))
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  (length(hu_list) = p)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
  |-------
[1]   P!1 = p

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets i!2`4,
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.2 : 
;;; derive value of i!3 from lists l!1 and i!2`1 and make explicit that P!1 = p

{-1}  length(i!2`3) + length(i!2`4) =
       length[Identity](remove(hu_list, i!1`1))
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  (length(hu_list) = p)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
  |-------
[1]   P!1 = p

Rerunning step: (lemma "length_remove" ("c" "hu_list" "i" "i!1`1"))
Using instance
  listprops[Identity].length_remove
Applying length_remove where 
  c gets hu_list,
  i gets i!1`1,
this yields  2 subgoals: 
restrictlast_middle.1.2.1.1.2.2.1 : 
;;; derive value of i!3 from lists l!1 and i!2`1 and make explicit that P!1 = p

{-1}  length[Identity](hu_list) - 1 =
       length[Identity](remove(hu_list, i!1`1))
[-2]  length(i!2`3) + length(i!2`4) =
       length[Identity](remove(hu_list, i!1`1))
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  (length(hu_list) = p)
[-6]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
  |-------
[1]   P!1 = p

Rerunning step: (replace -1 -2 rl)
Replacing using formula -1,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.2.1 : 
;;; derive value of i!3 from lists l!1 and i!2`1 and make explicit that P!1 = p

[-1]  length[Identity](hu_list) - 1 =
       length[Identity](remove(hu_list, i!1`1))
{-2}  length(i!2`3) + length(i!2`4) = length[Identity](hu_list) - 1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  (length(hu_list) = p)
[-6]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
  |-------
[1]   P!1 = p

Rerunning step: (delete -1 -6)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.2.1 : 
;;; derive value of i!3 from lists l!1 and i!2`1 and make explicit that P!1 = p

[-1]  length(i!2`3) + length(i!2`4) = length[Identity](hu_list) - 1
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  (length(hu_list) = p)
  |-------
[1]   P!1 = p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_middle.1.2.1.1.2.2.1.

restrictlast_middle.1.2.1.1.2.2.2T (TCC):   

[-1]  length(i!2`3) + length(i!2`4) =
       length[Identity](remove(hu_list, i!1`1))
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  (length(hu_list) = p)
[-5]  append(i!2`3, i!2`4) = remove(hu_list, i!1`1)
  |-------
{1}   cons?[Identity](hu_list)
[2]   P!1 = p

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.2.1.1.2.2.2T : 
;;; derive value of i!3 from lists l!1 and i!2`1 and make explicit that P!1 = p

  |-------
[1]   cons?[Identity](hu_list)

Rerunning step: (lemma "cons_hu_list")
Applying cons_hu_list 
this simplifies to: 
restrictlast_middle.1.2.1.1.2.2.2T : 
;;; derive value of i!3 from lists l!1 and i!2`1 and make explicit that P!1 = p

{-1}  cons?(hu_list) AND length(hu_list) = p
  |-------
[1]   cons?[Identity](hu_list)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_middle.1.2.1.1.2.2.2T.


This completes the proof of restrictlast_middle.1.2.1.1.2.2.


This completes the proof of restrictlast_middle.1.2.1.1.2.


This completes the proof of restrictlast_middle.1.2.1.1.

restrictlast_middle.1.2.1.2 : 
;;; let us make explicit that i!1`2 /= n_init

[-1]  rho_last(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
{1}   i!1`2 /= n_init
[2]   rho_last(E(public(car(i!2`4)),
                 conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[3]   P!1 = 2

Rerunning step: (delete -1 -2 -4 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.2.1.2 : 
;;; let us make explicit that i!1`2 /= n_init

[-1]  0 < i!1`1
  |-------
[1]   i!1`2 /= n_init

Rerunning step: (typepred "i!1`2")
Adding type constraints for  i!1`2,
this simplifies to: 
restrictlast_middle.1.2.1.2 : 
;;; let us make explicit that i!1`2 /= n_init

{-1}  IRpart(P!1, u!1, i!1`1)(i!1`2)
[-2]  0 < i!1`1
  |-------
[1]   i!1`2 /= n_init

Rerunning step: (lemma "n_prop" ("P" "P!1" "u" "u!1" "r" "i!1`1"))
Applying n_prop where 
  P gets P!1,
  u gets u!1,
  r gets i!1`1,
this simplifies to: 
restrictlast_middle.1.2.1.2 : 
;;; let us make explicit that i!1`2 /= n_init

{-1}  (P!1 /= p OR i!1`1 /= 0) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, i!1`1)(n_init)
[-2]  IRpart(P!1, u!1, i!1`1)(i!1`2)
[-3]  0 < i!1`1
  |-------
[1]   i!1`2 /= n_init

Rerunning step: (grind)
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
/= rewrites i!1`2 /= n_init
  to TRUE
/= rewrites P!1 /= p
  to NOT (P!1 = p)
/= rewrites i!1`1 /= 0
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictlast_middle.1.2.1.2.


This completes the proof of restrictlast_middle.1.2.1.

restrictlast_middle.1.2.2 :  

[-1]  rho_last(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
{1}   ((rec(u!1, nth(i!2`3, i!1`1 - 1),
            E(public(u!1),
              conc(ilist(append(i!2`3, i!2`4)),
                   nlist(cons(i!1`2, i!2`2)))))
         >>
         ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
           Stop[event]))
        # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
{2}   R_last(trans(u!1, car(i!2`4),
                   E(public(car(i!2`4)),
                     conc(nlist(append(i!2`1, (: i!1`2 :))),
                          ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))))
{3}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(nlist(append(i!2`1, (: i!1`2 :))),
                   ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
       >>
       ((rec(u!1, nth(i!2`3, i!1`1 - 1),
             E(public(u!1),
               conc(ilist(append(i!2`3, i!2`4)),
                    nlist(cons(i!1`2, i!2`2)))))
          >>
          ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
            Stop[event]))
         # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[4]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.2.2 :  

[-1]  rho_last(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
[1]   ((rec(u!1, nth(i!2`3, i!1`1 - 1),
            E(public(u!1),
              conc(ilist(append(i!2`3, i!2`4)),
                   nlist(cons(i!1`2, i!2`2)))))
         >>
         ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
           Stop[event]))
        # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[2]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictlast_middle.1.2.2 :  

{-1}  rho_last(E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
[-2]  rho_last(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
{1}   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
{2}   R_last(rec(u!1, nth(i!2`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i!2`3, i!2`4)),
                        nlist(cons(i!1`2, i!2`2))))))
{3}   rec(u!1, nth(i!2`3, i!1`1 - 1),
          E(public(u!1),
            conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2)))))
       >>
       (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
          Stop[event])
         # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[4]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.2.2 :  

[-1]  rho_last(E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
[-2]  rho_last(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[2]   P!1 = 2

Rerunning step: (expand "LastMessage")
Expanding the definition of LastMessage,
this simplifies to: 
restrictlast_middle.1.2.2 :  

[-1]  rho_last(E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
[-2]  rho_last(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
{1}   ((IF i!1`1 = P!1 - 2
          THEN trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2)))
        ELSE trans(u!1, car(i!2`4),
                   E(public(car(i!2`4)),
                     conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                          nlist(i!2`2))))
        ENDIF
         >> Stop[event])
        # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[2]   P!1 = 2

Rerunning step: (lift-if)
Lifting IF-conditions to the top level,
this simplifies to: 
restrictlast_middle.1.2.2 :  

[-1]  rho_last(E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
[-2]  rho_last(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
{1}   IF i!1`1 = P!1 - 2
        THEN ((trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2)))
                >> Stop[event])
               # R_last)
              |>
              LAMBDA (t: list[event]):
                every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
                 every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))
                      (t)
      ELSE ((trans(u!1, car(i!2`4),
                   E(public(car(i!2`4)),
                     conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                          nlist(i!2`2))))
              >> Stop[event])
             # R_last)
            |>
            LAMBDA (t: list[event]):
              every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
               every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
      ENDIF
[2]   P!1 = 2

Rerunning step: (prop)
Applying propositional simplification,
this yields  2 subgoals: 
restrictlast_middle.1.2.2.1 :  

{-1}  i!1`1 = P!1 - 2
[-2]  rho_last(E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
[-3]  rho_last(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-4]  2 <= P!1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
  |-------
{1}   ((trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))) >>
         Stop[event])
        # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[2]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictlast_middle.1.2.2.1.1 :  

[-1]  i!1`1 = P!1 - 2
[-2]  rho_last(E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
[-3]  rho_last(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-4]  2 <= P!1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
  |-------
{1}   rho_last(E(public(car(i!2`4)), nlist(i!2`2)))
{2}   R_last(trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))))
{3}   trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))) >>
       (Stop[event] # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[4]   P!1 = 2

Rerunning step: (delete -3 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.2.2.1.1 :  

[-1]  i!1`1 = P!1 - 2
[-2]  rho_last(E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
[1]   rho_last(E(public(car(i!2`4)), nlist(i!2`2)))
[2]   P!1 = 2

Rerunning step: (lemma "listprops[Nonce].elt_append2"
                 ("l1" "(: i!1`2:)" "l2" "i!2`2" "t" "n_init"))
Applying listprops[Nonce].elt_append2 where 
  l1 gets (: i!1`2 :),
  l2 gets i!2`2,
  t gets n_init,
this simplifies to: 
restrictlast_middle.1.2.2.1.1 :  

{-1}  elt(i!2`2, n_init) IMPLIES elt(append((: i!1`2 :), i!2`2), n_init)
[-2]  i!1`1 = P!1 - 2
[-3]  rho_last(E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
[-4]  2 <= P!1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
  |-------
[1]   rho_last(E(public(car(i!2`4)), nlist(i!2`2)))
[2]   P!1 = 2

Rerunning step: (grind :if-match nil :exclude "elt")
append rewrites append((: :), i!2`2)
  to i!2`2
append rewrites append((: i!1`2 :), i!2`2)
  to cons(i!1`2, i!2`2)
E rewrites E(public(car(i!2`4)), nlist(i!2`2))
  to code(public(car(i!2`4)), nlist(i!2`2))
rho_last rewrites rho_last(nlist(i!2`2))
  to NOT elt(i!2`2, n_init)
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_last rewrites rho_last(code(public(car(i!2`4)), nlist(i!2`2)))
  to NOT elt(i!2`2, n_init)
E rewrites 
  E(public(u!1),
    conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
  to code(public(u!1),
           conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
rho_last rewrites rho_last(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_last rewrites rho_last(nlist(cons(i!1`2, i!2`2)))
  to FALSE
rho_last rewrites 
  rho_last(conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
  to FALSE
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_last rewrites 
  rho_last(code(public(u!1),
                conc(ilist(append(i!2`3, i!2`4)),
                     nlist(cons(i!1`2, i!2`2)))))
  to EXISTS (i: {x: nat | 0 < x AND x < p}):
        public(u!1) = public(hu(i)) AND
         EXISTS (l: {x: list[Nonce] | length(x) = i - 1}):
           conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
            conc(nlist(cons(n_init, l)),
                 ilist(cons(car(hu_list), remove(cdr(hu_list), i - 1))))
E rewrites E(public(car(i!2`4)), nlist(i!2`2))
  to code(public(car(i!2`4)), nlist(i!2`2))
rho_last rewrites rho_last(nlist(i!2`2))
  to TRUE
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_last rewrites rho_last(code(public(car(i!2`4)), nlist(i!2`2)))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,
this simplifies to: 
restrictlast_middle.1.2.2.1.1 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
{-2}  length(l!1) = i!3 - 1
{-3}  0 < i!3
{-4}  i!3 < p
{-5}  elt(cons(i!1`2, i!2`2), n_init)
{-6}  elt(i!2`2, n_init)
[-7]  i!1`1 = P!1 - 2
{-8}  public(u!1) = public(hu(i!3))
{-9}  conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
       conc(nlist(cons(n_init, l!1)),
            ilist(cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))))
[-10] 2 <= P!1
{-11} 0 < P!1 - 2
{-12} P!1 - 2 < P!1 - 1
  |-------
[1]   P!1 = 2

Rerunning step: (decompose-equality -9)
Applying decompose-equality,

This completes the proof of restrictlast_middle.1.2.2.1.1.

restrictlast_middle.1.2.2.1.2 :  

[-1]  i!1`1 = P!1 - 2
[-2]  rho_last(E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
[-3]  rho_last(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-4]  2 <= P!1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
  |-------
{1}   (Stop[event] # R_last) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
{2}   R_last(trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))))
{3}   trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))) >>
       (Stop[event] # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[4]   P!1 = 2

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.2.2.1.2 :  

  |-------
[1]   (Stop[event] # R_last) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[2]   P!1 = 2

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictlast_middle.1.2.2.1.2.


This completes the proof of restrictlast_middle.1.2.2.1.

restrictlast_middle.1.2.2.2 :  

[-1]  rho_last(E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
[-2]  rho_last(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
{1}   i!1`1 = P!1 - 2
{2}   ((trans(u!1, car(i!2`4),
              E(public(car(i!2`4)),
                conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                     nlist(i!2`2))))
         >> Stop[event])
        # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[3]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictlast_middle.1.2.2.2.1 :  

[-1]  rho_last(E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
[-2]  rho_last(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
{1}   rho_last(E(public(car(i!2`4)),
                 conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                      nlist(i!2`2))))
{2}   R_last(trans(u!1, car(i!2`4),
                   E(public(car(i!2`4)),
                     conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                          nlist(i!2`2)))))
{3}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                   nlist(i!2`2))))
       >> (Stop[event] # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[4]   i!1`1 = P!1 - 2
[5]   P!1 = 2

Rerunning step: (delete -2 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.2.2.2.1 :  

[-1]  rho_last(E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
[1]   rho_last(E(public(car(i!2`4)),
                 conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                      nlist(i!2`2))))
[2]   i!1`1 = P!1 - 2
[3]   P!1 = 2

Rerunning step: (lemma "listprops[Nonce].elt_append2"
                 ("l1" "(: i!1`2:)" "l2" "i!2`2" "t" "n_init"))
Applying listprops[Nonce].elt_append2 where 
  l1 gets (: i!1`2 :),
  l2 gets i!2`2,
  t gets n_init,
this simplifies to: 
restrictlast_middle.1.2.2.2.1 :  

{-1}  elt(i!2`2, n_init) IMPLIES elt(append((: i!1`2 :), i!2`2), n_init)
[-2]  rho_last(E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
[1]   rho_last(E(public(car(i!2`4)),
                 conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                      nlist(i!2`2))))
[2]   i!1`1 = P!1 - 2
[3]   P!1 = 2

Rerunning step: (grind :if-match nil :exclude "elt")
append rewrites append((: :), i!2`2)
  to i!2`2
append rewrites append((: i!1`2 :), i!2`2)
  to cons(i!1`2, i!2`2)
E rewrites 
  E(public(car(i!2`4)),
    conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)))
  to code(public(car(i!2`4)),
           conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)))
rho_last rewrites rho_last(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
  to TRUE
rho_last rewrites rho_last(nlist(i!2`2))
  to NOT elt(i!2`2, n_init)
rho_last rewrites 
  rho_last(conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)))
  to NOT elt(i!2`2, n_init)
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_last rewrites 
  rho_last(code(public(car(i!2`4)),
                conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                     nlist(i!2`2))))
  to NOT elt(i!2`2, n_init) OR
       EXISTS (i: {x: nat | 0 < x AND x < p}):
         public(car(i!2`4)) = public(hu(i)) AND
          EXISTS (l: {x: list[Nonce] | length(x) = i - 1}):
            conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2))
             =
             conc(nlist(cons(n_init, l)),
                  ilist(cons(car(hu_list), remove(cdr(hu_list), i - 1))))
E rewrites 
  E(public(u!1),
    conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
  to code(public(u!1),
           conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
rho_last rewrites rho_last(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_last rewrites rho_last(nlist(cons(i!1`2, i!2`2)))
  to FALSE
rho_last rewrites 
  rho_last(conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
  to FALSE
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_last rewrites 
  rho_last(code(public(u!1),
                conc(ilist(append(i!2`3, i!2`4)),
                     nlist(cons(i!1`2, i!2`2)))))
  to EXISTS (i: {x: nat | 0 < x AND x < p}):
        public(u!1) = public(hu(i)) AND
         EXISTS (l: {x: list[Nonce] | length(x) = i - 1}):
           conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
            conc(nlist(cons(n_init, l)),
                 ilist(cons(car(hu_list), remove(cdr(hu_list), i - 1))))
E rewrites 
  E(public(car(i!2`4)),
    conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)))
  to code(public(car(i!2`4)),
           conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)))
rho_last rewrites rho_last(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
  to TRUE
rho_last rewrites rho_last(nlist(i!2`2))
  to TRUE
rho_last rewrites 
  rho_last(conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)))
  to TRUE
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_last rewrites 
  rho_last(code(public(car(i!2`4)),
                conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                     nlist(i!2`2))))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,
this simplifies to: 
restrictlast_middle.1.2.2.2.1 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
{-2}  length(l!1) = i!3 - 1
{-3}  0 < i!3
{-4}  i!3 < p
{-5}  elt(cons(i!1`2, i!2`2), n_init)
{-6}  elt(i!2`2, n_init)
{-7}  public(u!1) = public(hu(i!3))
{-8}  conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
       conc(nlist(cons(n_init, l!1)),
            ilist(cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))))
[-9]  2 <= P!1
[-10] 0 < i!1`1
[-11] i!1`1 < P!1 - 1
  |-------
{1}   EXISTS (i: {x: nat | 0 < x AND x < p}):
        public(car(i!2`4)) = public(hu(i)) AND
         EXISTS (l: {x: list[Nonce] | length(x) = i - 1}):
           conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2))
            =
            conc(nlist(cons(n_init, l)),
                 ilist(cons(car(hu_list), remove(cdr(hu_list), i - 1))))
[2]   i!1`1 = P!1 - 2
[3]   P!1 = 2

Rerunning step: (decompose-equality -8)
Applying decompose-equality,

This completes the proof of restrictlast_middle.1.2.2.2.1.

restrictlast_middle.1.2.2.2.2 :  

[-1]  rho_last(E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
[-2]  rho_last(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
{1}   (Stop[event] # R_last) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
{2}   R_last(trans(u!1, car(i!2`4),
                   E(public(car(i!2`4)),
                     conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                          nlist(i!2`2)))))
{3}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                   nlist(i!2`2))))
       >> (Stop[event] # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[4]   i!1`1 = P!1 - 2
[5]   P!1 = 2

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.1.2.2.2.2 :  

  |-------
[1]   (Stop[event] # R_last) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[2]   i!1`1 = P!1 - 2
[3]   P!1 = 2

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictlast_middle.1.2.2.2.2.


This completes the proof of restrictlast_middle.1.2.2.2.


This completes the proof of restrictlast_middle.1.2.2.


This completes the proof of restrictlast_middle.1.2.


This completes the proof of restrictlast_middle.1.

restrictlast_middle.2 :  

[-1]  2 <= P!1
[-2]  0 < i!1`1
[-3]  i!1`1 < P!1 - 1
  |-------
{1}   cons?[Identity](i!2`4)
[2]   P!1 = 2
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (signal(running(i!1`1, append(i`3, cons(u!1, i`4)), car(i`1))) >>
            (trans(u!1, car(i`4),
                   E(public(car(i`4)),
                     conc(nlist(append(i`1, (: i!1`2 :))),
                          ilist(append(i`3, cons(u!1, cdr(i`4)))))))
              >>
              (rec(u!1, nth(i`3, i!1`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(i`3, i`4)),
                          nlist(cons(i!1`2, i`2)))))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.2 :  

  |-------
[1]   cons?[Identity](i!2`4)

Rerunning step: (nonemptylist "i!2`4")
Relating existence of a tail to a list's length,

This completes the proof of restrictlast_middle.2.

restrictlast_middle.3 :  

[-1]  2 <= P!1
[-2]  0 < i!1`1
[-3]  i!1`1 < P!1 - 1
  |-------
{1}   cons?[Nonce](i!2`1)
[2]   P!1 = 2
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (signal(running(i!1`1, append(i`3, cons(u!1, i`4)), car(i`1))) >>
            (trans(u!1, car(i`4),
                   E(public(car(i`4)),
                     conc(nlist(append(i`1, (: i!1`2 :))),
                          ilist(append(i`3, cons(u!1, cdr(i`4)))))))
              >>
              (rec(u!1, nth(i`3, i!1`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(i`3, i`4)),
                          nlist(cons(i!1`2, i`2)))))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.3 :  

  |-------
[1]   cons?[Nonce](i!2`1)

Rerunning step: (nonemptylist "i!2`1")
Relating existence of a tail to a list's length,

This completes the proof of restrictlast_middle.3.

restrictlast_middle.4 :  

[-1]  2 <= P!1
[-2]  0 < i!1`1
[-3]  i!1`1 < P!1 - 1
  |-------
{1}   i!1`1 - 1 < length[Identity](i!2`3)
[2]   P!1 = 2
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (signal(running(i!1`1, append(i`3, cons(u!1, i`4)), car(i`1))) >>
            (trans(u!1, car(i`4),
                   E(public(car(i`4)),
                     conc(nlist(append(i`1, (: i!1`2 :))),
                          ilist(append(i`3, cons(u!1, cdr(i`4)))))))
              >>
              (rec(u!1, nth(i`3, i!1`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(i`3, i`4)),
                          nlist(cons(i!1`2, i`2)))))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (typepred "i!2`3")
Adding type constraints for  i!2`3,
this simplifies to: 
restrictlast_middle.4 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`3)
{-2}  length(i!2`3) = i!1`1
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
[1]   i!1`1 - 1 < length[Identity](i!2`3)
[2]   P!1 = 2
[3]   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (signal(running(i!1`1, append(i`3, cons(u!1, i`4)), car(i`1))) >>
            (trans(u!1, car(i`4),
                   E(public(car(i`4)),
                     conc(nlist(append(i`1, (: i!1`2 :))),
                          ilist(append(i`3, cons(u!1, cdr(i`4)))))))
              >>
              (rec(u!1, nth(i`3, i!1`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(i`3, i`4)),
                          nlist(cons(i!1`2, i`2)))))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete -1 -3 -4 -5 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.4 :  

[-1]  length(i!2`3) = i!1`1
  |-------
[1]   i!1`1 - 1 < length[Identity](i!2`3)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_middle.4.

restrictlast_middle.5 :  

[-1]  2 <= P!1
[-2]  0 < i!1`1
[-3]  i!1`1 < P!1 - 1
  |-------
{1}   FORALL (nl1: {x: list[Nonce] | length[Nonce](x) = i!1`1},
              nl2: {x: list[Nonce] | length[Nonce](x) = P!1 - 1 - i!1`1},
              il1: {x: list[Identity] | length[Identity](x) = i!1`1},
              il2:
                {x: list[Identity] |
                   length[Identity](x) = P!1 - 1 - i!1`1}):
        cons?[Identity](il2)
[2]   P!1 = 2
[3]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1: {x: list[Identity] | length(x) = i!1`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (signal(running(i!1`1, append(il1, cons(u!1, il2)), car(nl1))) >>
            (trans(u!1, car(il2),
                   E(public(car(il2)),
                     conc(nlist(append(nl1, (: i!1`2 :))),
                          ilist(append(il1, cons(u!1, cdr(il2)))))))
              >>
              (rec(u!1, nth(il1, i!1`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(il1, il2)),
                          nlist(cons(i!1`2, nl2)))))
                >>
                ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictlast_middle.5 :  

[-1]  2 <= P!1
[-2]  0 < i!1`1
[-3]  i!1`1 < P!1 - 1
  |-------
{1}   cons?[Identity](il2!1)
[2]   P!1 = 2
[3]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1: {x: list[Identity] | length(x) = i!1`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (signal(running(i!1`1, append(il1, cons(u!1, il2)), car(nl1))) >>
            (trans(u!1, car(il2),
                   E(public(car(il2)),
                     conc(nlist(append(nl1, (: i!1`2 :))),
                          ilist(append(il1, cons(u!1, cdr(il2)))))))
              >>
              (rec(u!1, nth(il1, i!1`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(il1, il2)),
                          nlist(cons(i!1`2, nl2)))))
                >>
                ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.5 :  

  |-------
[1]   cons?[Identity](il2!1)

Rerunning step: (nonemptylist "il2!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictlast_middle.5.

restrictlast_middle.6 :  

[-1]  2 <= P!1
[-2]  0 < i!1`1
[-3]  i!1`1 < P!1 - 1
  |-------
{1}   FORALL (nl1: {x: list[Nonce] | length[Nonce](x) = i!1`1},
              nl2: {x: list[Nonce] | length[Nonce](x) = P!1 - 1 - i!1`1},
              il1: {x: list[Identity] | length[Identity](x) = i!1`1},
              il2:
                {x: list[Identity] |
                   length[Identity](x) = P!1 - 1 - i!1`1}):
        cons?[Nonce](nl1)
[2]   P!1 = 2
[3]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1: {x: list[Identity] | length(x) = i!1`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (signal(running(i!1`1, append(il1, cons(u!1, il2)), car(nl1))) >>
            (trans(u!1, car(il2),
                   E(public(car(il2)),
                     conc(nlist(append(nl1, (: i!1`2 :))),
                          ilist(append(il1, cons(u!1, cdr(il2)))))))
              >>
              (rec(u!1, nth(il1, i!1`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(il1, il2)),
                          nlist(cons(i!1`2, nl2)))))
                >>
                ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictlast_middle.6 :  

[-1]  2 <= P!1
[-2]  0 < i!1`1
[-3]  i!1`1 < P!1 - 1
  |-------
{1}   cons?[Nonce](nl1!1)
[2]   P!1 = 2
[3]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1: {x: list[Identity] | length(x) = i!1`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (signal(running(i!1`1, append(il1, cons(u!1, il2)), car(nl1))) >>
            (trans(u!1, car(il2),
                   E(public(car(il2)),
                     conc(nlist(append(nl1, (: i!1`2 :))),
                          ilist(append(il1, cons(u!1, cdr(il2)))))))
              >>
              (rec(u!1, nth(il1, i!1`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(il1, il2)),
                          nlist(cons(i!1`2, nl2)))))
                >>
                ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_middle.6 :  

  |-------
[1]   cons?[Nonce](nl1!1)

Rerunning step: (nonemptylist "nl1!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictlast_middle.6.

Q.E.D.


Run time  = 7.49 secs.
Real time = 8.70 secs.
nil
pvs(67): 
Installing rewrite rule sets.singleton_rew (all instances)
restrictlast_last :  

  |-------
{1}   FORALL (P: nat_from_2, u: Identity):
        ((Interleave! (nnP: Nonces(P, u, P - 1)): UROLE_LAST(P, u, nnP)) #
          R_last)
         |> RankUser(rho_last)

Rerunning step: (auto-rewrite-theory "sets")
Rewriting relative to the theory: sets,
this simplifies to: 
restrictlast_last :  

  |-------
[1]   FORALL (P: nat_from_2, u: Identity):
        ((Interleave! (nnP: Nonces(P, u, P - 1)): UROLE_LAST(P, u, nnP)) #
          R_last)
         |> RankUser(rho_last)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictlast_last :  

  |-------
{1}   ((Interleave! (nnP: Nonces(P!1, u!1, P!1 - 1)):
          UROLE_LAST(P!1, u!1, nnP))
        # R_last)
       |> RankUser(rho_last)

Rerunning step: (expand "RankUser")
Expanding the definition of RankUser,
this simplifies to: 
restrictlast_last :  

  |-------
{1}   ((Interleave! (nnP: Nonces(P!1, u!1, P!1 - 1)):
          UROLE_LAST(P!1, u!1, nnP))
        # R_last)
       |>
       LAMBDA (tr: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(tr) =>
          every(LAMBDA (e: event): complement(rec?)(e) => rho_last(msg(e)))
               (tr)

Rerunning step: (interleaving2)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
Applying interleaving rule,
this simplifies to: 
restrictlast_last :  

  |-------
{1}   UROLE_LAST(P!1, u!1, i!1) # R_last |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (expand "UROLE_LAST")
Expanding the definition of UROLE_LAST,
this simplifies to: 
restrictlast_last :  

  |-------
{1}   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (signal(running(P!1 - 1, append(il, (: u!1 :)), car(nl))) >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(nlist(append(nl, (: i!1 :))),
                          ilist(append(cdr(il), (: u!1 :))))))
              >>
              (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (typepred "P!1")
Adding type constraints for  P!1,
this simplifies to: 
restrictlast_last :  

{-1}  2 <= P!1
  |-------
[1]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (signal(running(P!1 - 1, append(il, (: u!1 :)), car(nl))) >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(nlist(append(nl, (: i!1 :))),
                          ilist(append(cdr(il), (: u!1 :))))))
              >>
              (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (choice3)
Applying choice rule,
this yields  8 subgoals: 
restrictlast_last.1 :  

[-1]  2 <= P!1
  |-------
{1}   (rec(u!1, nth(i!2`2, P!1 - 2),
           E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
        >>
        (signal(running(P!1 - 1, append(i!2`2, (: u!1 :)), car(i!2`1))) >>
          (trans(u!1, car(i!2`2),
                 E(public(car(i!2`2)),
                   conc(nlist(append(i!2`1, (: i!1 :))),
                        ilist(append(cdr(i!2`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i!2`2, P!1 - 2),
                 E(public(u!1), nlist((: i!1 :))))
              >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictlast_last.1 :  

{-1}  rho_last(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
{1}   ((signal(running(P!1 - 1, append(i!2`2, (: u!1 :)), car(i!2`1))) >>
         (trans(u!1, car(i!2`2),
                E(public(car(i!2`2)),
                  conc(nlist(append(i!2`1, (: i!1 :))),
                       ilist(append(cdr(i!2`2), (: u!1 :))))))
           >>
           (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
             >> Stop[event])))
        # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
{2}   R_last(rec(u!1, nth(i!2`2, P!1 - 2),
                 E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2)))))
{3}   rec(u!1, nth(i!2`2, P!1 - 2),
          E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
       >>
       ((signal(running(P!1 - 1, append(i!2`2, (: u!1 :)), car(i!2`1))) >>
          (trans(u!1, car(i!2`2),
                 E(public(car(i!2`2)),
                   conc(nlist(append(i!2`1, (: i!1 :))),
                        ilist(append(cdr(i!2`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i!2`2, P!1 - 2),
                 E(public(u!1), nlist((: i!1 :))))
              >> Stop[event])))
         # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1 :  

[-1]  rho_last(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   ((signal(running(P!1 - 1, append(i!2`2, (: u!1 :)), car(i!2`1))) >>
         (trans(u!1, car(i!2`2),
                E(public(car(i!2`2)),
                  conc(nlist(append(i!2`1, (: i!1 :))),
                       ilist(append(cdr(i!2`2), (: u!1 :))))))
           >>
           (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
             >> Stop[event])))
        # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictlast_last.1.1 :  

[-1]  rho_last(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
{1}   rho_last(running(P!1 - 1, append(i!2`2, (: u!1 :)), car(i!2`1)))
{2}   R_last(signal(running(P!1 - 1, append(i!2`2, (: u!1 :)), car(i!2`1))))
{3}   signal(running(P!1 - 1, append(i!2`2, (: u!1 :)), car(i!2`1))) >>
       ((trans(u!1, car(i!2`2),
               E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :))))))
          >>
          (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
            >> Stop[event]))
         # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.1 :  

  |-------
[1]   rho_last(running(P!1 - 1, append(i!2`2, (: u!1 :)), car(i!2`1)))

Rerunning step: (expand "rho_last")
Expanding the definition of rho_last,
this simplifies to: 
restrictlast_last.1.1 :  

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictlast_last.1.1.

restrictlast_last.1.2 :  

[-1]  rho_last(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
{1}   ((trans(u!1, car(i!2`2),
              E(public(car(i!2`2)),
                conc(nlist(append(i!2`1, (: i!1 :))),
                     ilist(append(cdr(i!2`2), (: u!1 :))))))
         >>
         (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
           >> Stop[event]))
        # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
{2}   R_last(signal(running(P!1 - 1, append(i!2`2, (: u!1 :)), car(i!2`1))))
{3}   signal(running(P!1 - 1, append(i!2`2, (: u!1 :)), car(i!2`1))) >>
       ((trans(u!1, car(i!2`2),
               E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :))))))
          >>
          (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
            >> Stop[event]))
         # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete 3)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2 :  

[-1]  rho_last(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   ((trans(u!1, car(i!2`2),
              E(public(car(i!2`2)),
                conc(nlist(append(i!2`1, (: i!1 :))),
                     ilist(append(cdr(i!2`2), (: u!1 :))))))
         >>
         (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
           >> Stop[event]))
        # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[2]   R_last(signal(running(P!1 - 1, append(i!2`2, (: u!1 :)), car(i!2`1))))

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictlast_last.1.2.1 :  

[-1]  rho_last(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
{1}   rho_last(E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :))))))
{2}   R_last(trans(u!1, car(i!2`2),
                   E(public(car(i!2`2)),
                     conc(nlist(append(i!2`1, (: i!1 :))),
                          ilist(append(cdr(i!2`2), (: u!1 :)))))))
{3}   trans(u!1, car(i!2`2),
            E(public(car(i!2`2)),
              conc(nlist(append(i!2`1, (: i!1 :))),
                   ilist(append(cdr(i!2`2), (: u!1 :))))))
       >>
       ((rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :)))) >>
          Stop[event])
         # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[4]   R_last(signal(running(P!1 - 1, append(i!2`2, (: u!1 :)), car(i!2`1))))

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.1 :  

[-1]  rho_last(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   rho_last(E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :))))))
[2]   R_last(signal(running(P!1 - 1, append(i!2`2, (: u!1 :)), car(i!2`1))))

Rerunning step: (expand "R_last")
Expanding the definition of R_last,
this simplifies to: 
restrictlast_last.1.2.1 :  

[-1]  rho_last(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   rho_last(E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :))))))
{2}   signal(running(P!1 - 1, append(i!2`2, (: u!1 :)), car(i!2`1))) =
       signal(running(p - 1, hu_list, n_init))

Rerunning step: (comment "either the process is blocked on 2, or 1 is satisfied")
Adding comment: either the process is blocked on 2, or 1 is satisfied
this simplifies to: 
restrictlast_last.1.2.1 : 
;;; either the process is blocked on 2, or 1 is satisfied

[-1]  rho_last(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   rho_last(E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :))))))
[2]   signal(running(P!1 - 1, append(i!2`2, (: u!1 :)), car(i!2`1))) =
       signal(running(p - 1, hu_list, n_init))

Rerunning step: (case "append(i!2`2, (: u!1 :)) = hu_list AND car(i!2`1) = n_init AND P!1 = p")
Case splitting on 
   append(i!2`2, (: u!1 :)) = hu_list AND
    car(i!2`1) = n_init AND P!1 = p, 
this yields  2 subgoals: 
restrictlast_last.1.2.1.1 : 
;;; either the process is blocked on 2, or 1 is satisfied

{-1}  append(i!2`2, (: u!1 :)) = hu_list AND car(i!2`1) = n_init AND P!1 = p
[-2]  rho_last(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-3]  2 <= P!1
  |-------
[1]   rho_last(E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :))))))
[2]   signal(running(P!1 - 1, append(i!2`2, (: u!1 :)), car(i!2`1))) =
       signal(running(p - 1, hu_list, n_init))

Rerunning step: (delete -2 -3 1)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.1.1 : 
;;; either the process is blocked on 2, or 1 is satisfied

[-1]  append(i!2`2, (: u!1 :)) = hu_list AND car(i!2`1) = n_init AND P!1 = p
  |-------
[1]   signal(running(P!1 - 1, append(i!2`2, (: u!1 :)), car(i!2`1))) =
       signal(running(p - 1, hu_list, n_init))

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_last.1.2.1.1.

restrictlast_last.1.2.1.2 : 
;;; either the process is blocked on 2, or 1 is satisfied

[-1]  rho_last(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
{1}   append(i!2`2, (: u!1 :)) = hu_list AND car(i!2`1) = n_init AND P!1 = p
[2]   rho_last(E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :))))))
[3]   signal(running(P!1 - 1, append(i!2`2, (: u!1 :)), car(i!2`1))) =
       signal(running(p - 1, hu_list, n_init))

Rerunning step: (delete 3)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.1.2 : 
;;; either the process is blocked on 2, or 1 is satisfied

[-1]  rho_last(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   append(i!2`2, (: u!1 :)) = hu_list AND car(i!2`1) = n_init AND P!1 = p
[2]   rho_last(E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (comment "first and foremost, let us prove that i!1 /= n_init")
Adding comment: first and foremost, let us prove that i!1 /= n_init
this simplifies to: 
restrictlast_last.1.2.1.2 : 
;;; first and foremost, let us prove that i!1 /= n_init

[-1]  rho_last(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   append(i!2`2, (: u!1 :)) = hu_list AND car(i!2`1) = n_init AND P!1 = p
[2]   rho_last(E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (case "i!1 /= n_init")
Case splitting on 
   i!1 /= n_init, 
this yields  2 subgoals: 
restrictlast_last.1.2.1.2.1 : 
;;; first and foremost, let us prove that i!1 /= n_init

{-1}  i!1 /= n_init
[-2]  rho_last(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-3]  2 <= P!1
  |-------
[1]   append(i!2`2, (: u!1 :)) = hu_list AND car(i!2`1) = n_init AND P!1 = p
[2]   rho_last(E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (expand "rho_last" -2)
Expanding the definition of rho_last,
this simplifies to: 
restrictlast_last.1.2.1.2.1 : 
;;; first and foremost, let us prove that i!1 /= n_init

[-1]  i!1 /= n_init
{-2}  CASES E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2)))
        OF nonce(z): z /= n_init,
           nlist(z): NOT elt(z, n_init),
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i)),
           conc(z1, z2): rho_last(z1) AND rho_last(z2),
           commit(z1, z2, z3): z1 /= 0 OR z2 /= hu_list OR z3 /= n_init,
           code(z1, z2):
             rho_last(z2) OR
              (EXISTS (i: {x: nat | 0 < x AND x < p}):
                 z1 = public(hu(i)) AND
                  (EXISTS (l: {x: list[Nonce] | length(x) = i - 1}):
                     z2 =
                      conc(nlist(cons(n_init, l)),
                           ilist(remove(hu_list, i)))))
        ELSE TRUE
        ENDCASES
[-3]  2 <= P!1
  |-------
[1]   append(i!2`2, (: u!1 :)) = hu_list AND car(i!2`1) = n_init AND P!1 = p
[2]   rho_last(E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (grind :exclude "rho_last")
/= rewrites i!1 /= n_init
  to NOT (i!1 = n_init)
E rewrites 
  E(public(car(i!2`2)),
    conc(nlist(append(i!2`1, (: i!1 :))),
         ilist(append(cdr(i!2`2), (: u!1 :)))))
  to code(public(car(i!2`2)),
           conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :)))))
E rewrites E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2)))
  to code(public(u!1), conc(nlist(i!2`1), ilist(i!2`2)))
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
/= rewrites i!1 /= n_init
  to NOT (i!1 = n_init)
E rewrites 
  E(public(car(i!2`2)),
    conc(nlist(append(i!2`1, (: i!1 :))),
         ilist(append(cdr(i!2`2), (: u!1 :)))))
  to code(public(car(i!2`2)),
           conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :)))))
E rewrites E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2)))
  to code(public(u!1), conc(nlist(i!2`1), ilist(i!2`2)))
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
/= rewrites i!1 /= n_init
  to NOT (i!1 = n_init)
E rewrites 
  E(public(car(i!2`2)),
    conc(nlist(append(i!2`1, (: i!1 :))),
         ilist(append(cdr(i!2`2), (: u!1 :)))))
  to code(public(car(i!2`2)),
           conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :)))))
E rewrites E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2)))
  to code(public(u!1), conc(nlist(i!2`1), ilist(i!2`2)))
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
Trying repeated skolemization, instantiation, and if-lifting,
this yields  6 subgoals: 
restrictlast_last.1.2.1.2.1.1 : 
;;; first and foremost, let us prove that i!1 /= n_init

{-1}  rho_last(conc(nlist(i!2`1), ilist(i!2`2)))
[-2]  2 <= P!1
  |-------
{1}   (i!1 = n_init)
{2}   P!1 = p
{3}   rho_last(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (comment "due to -1 (and i!1 /= n_init), 3 will be satisfied")
Adding comment: due to -1 (and i!1 /= n_init), 3 will be satisfied
this simplifies to: 
restrictlast_last.1.2.1.2.1.1 : 
;;; due to -1 (and i!1 /= n_init), 3 will be satisfied

[-1]  rho_last(conc(nlist(i!2`1), ilist(i!2`2)))
[-2]  2 <= P!1
  |-------
[1]   (i!1 = n_init)
[2]   P!1 = p
[3]   rho_last(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.1.2.1.1 : 
;;; due to -1 (and i!1 /= n_init), 3 will be satisfied

[-1]  rho_last(conc(nlist(i!2`1), ilist(i!2`2)))
[-2]  2 <= P!1
  |-------
[1]   (i!1 = n_init)
[2]   rho_last(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (lemma "listprops[Nonce].elt_append3"
                 ("l1" "i!2`1" "l2" "(: i!1 :)" "t" "n_init"))
Applying listprops[Nonce].elt_append3 where 
  l1 gets i!2`1,
  l2 gets (: i!1 :),
  t gets n_init,
this simplifies to: 
restrictlast_last.1.2.1.2.1.1 : 
;;; due to -1 (and i!1 /= n_init), 3 will be satisfied

{-1}  elt(append(i!2`1, (: i!1 :)), n_init) IMPLIES
       elt(i!2`1, n_init) OR elt((: i!1 :), n_init)
[-2]  rho_last(conc(nlist(i!2`1), ilist(i!2`2)))
[-3]  2 <= P!1
  |-------
[1]   (i!1 = n_init)
[2]   rho_last(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (lemma "listprops[Nonce].elt_singleton"
                 ("t1" "i!1" "t2" "n_init"))
Applying listprops[Nonce].elt_singleton where 
  t1 gets i!1,
  t2 gets n_init,
this simplifies to: 
restrictlast_last.1.2.1.2.1.1 : 
;;; due to -1 (and i!1 /= n_init), 3 will be satisfied

{-1}  elt((: i!1 :), n_init) IFF i!1 = n_init
[-2]  elt(append(i!2`1, (: i!1 :)), n_init) IMPLIES
       elt(i!2`1, n_init) OR elt((: i!1 :), n_init)
[-3]  rho_last(conc(nlist(i!2`1), ilist(i!2`2)))
[-4]  2 <= P!1
  |-------
[1]   (i!1 = n_init)
[2]   rho_last(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (grind :exclude "elt")
rho_last rewrites rho_last(nlist(append(i!2`1, (: i!1 :))))
  to NOT elt(append(i!2`1, (: i!1 :)), n_init)
rho_last rewrites rho_last(ilist(append(cdr(i!2`2), (: u!1 :))))
  to TRUE
rho_last rewrites 
  rho_last(conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :)))))
  to NOT elt(append(i!2`1, (: i!1 :)), n_init)
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_last rewrites 
  rho_last(code(public(car(i!2`2)),
                conc(nlist(append(i!2`1, (: i!1 :))),
                     ilist(append(cdr(i!2`2), (: u!1 :))))))
  to NOT elt(append(i!2`1, (: i!1 :)), n_init) OR
       EXISTS (i: {x: nat | 0 < x AND x < p}):
         public(car(i!2`2)) = public(hu(i)) AND
          EXISTS (l: {x: list[Nonce] | length(x) = i - 1}):
            conc(nlist(append(i!2`1, (: i!1 :))),
                 ilist(append(cdr(i!2`2), (: u!1 :))))
             =
             conc(nlist(cons(n_init, l)),
                  ilist(cons(car(hu_list), remove(cdr(hu_list), i - 1))))
rho_last rewrites rho_last(nlist(i!2`1))
  to FALSE
rho_last rewrites rho_last(ilist(i!2`2))
  to TRUE
rho_last rewrites rho_last(conc(nlist(i!2`1), ilist(i!2`2)))
  to FALSE
rho_last rewrites rho_last(nlist(append(i!2`1, (: i!1 :))))
  to TRUE
rho_last rewrites rho_last(ilist(append(cdr(i!2`2), (: u!1 :))))
  to TRUE
rho_last rewrites 
  rho_last(conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :)))))
  to TRUE
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_last rewrites 
  rho_last(code(public(car(i!2`2)),
                conc(nlist(append(i!2`1, (: i!1 :))),
                     ilist(append(cdr(i!2`2), (: u!1 :))))))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictlast_last.1.2.1.2.1.1.

restrictlast_last.1.2.1.2.1.2 : 
;;; first and foremost, let us prove that i!1 /= n_init

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
{-2}  length(l!1) = i!3 - 1
{-3}  0 < i!3
{-4}  i!3 < p
{-5}  public(u!1) = public(hu(i!3))
{-6}  conc(nlist(i!2`1), ilist(i!2`2)) =
       conc(nlist(cons(n_init, l!1)),
            ilist(cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))))
[-7]  2 <= P!1
  |-------
{1}   (i!1 = n_init)
{2}   P!1 = p
{3}   rho_last(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (typepred "i!2`1" "i!2`2" "hu_list" "p")
Adding type constraints for  i!2`1, i!2`2, hu_list, p,
this simplifies to: 
restrictlast_last.1.2.1.2.1.2 : 
;;; first and foremost, let us prove that i!1 /= n_init

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`1)
{-2}  length(i!2`1) = P!1 - 1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`2)
{-4}  length(i!2`2) = P!1 - 1
{-5}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-6}  (length(hu_list) = p)
{-7}  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
{-8}  2 <= p
[-9]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
[-10] length(l!1) = i!3 - 1
[-11] 0 < i!3
[-12] i!3 < p
[-13] public(u!1) = public(hu(i!3))
[-14] conc(nlist(i!2`1), ilist(i!2`2)) =
       conc(nlist(cons(n_init, l!1)),
            ilist(cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))))
[-15] 2 <= P!1
  |-------
[1]   (i!1 = n_init)
[2]   P!1 = p
[3]   rho_last(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (delete -1 -3 -5 -9 1 3)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.1.2.1.2 : 
;;; first and foremost, let us prove that i!1 /= n_init

[-1]  length(i!2`1) = P!1 - 1
[-2]  length(i!2`2) = P!1 - 1
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  2 <= p
[-6]  length(l!1) = i!3 - 1
[-7]  0 < i!3
[-8]  i!3 < p
[-9]  public(u!1) = public(hu(i!3))
[-10] conc(nlist(i!2`1), ilist(i!2`2)) =
       conc(nlist(cons(n_init, l!1)),
            ilist(cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))))
[-11] 2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (decompose-equality -10)
Applying decompose-equality,
this simplifies to: 
restrictlast_last.1.2.1.2.1.2 : 
;;; first and foremost, let us prove that i!1 /= n_init

{-1}  nlist(i!2`1) = nlist(cons(n_init, l!1))
{-2}  ilist(i!2`2) =
       ilist(cons(car(hu_list), remove(cdr(hu_list), i!3 - 1)))
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  2 <= p
[-8]  length(l!1) = i!3 - 1
[-9]  0 < i!3
[-10] i!3 < p
[-11] public(u!1) = public(hu(i!3))
[-12] 2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictlast_last.1.2.1.2.1.2 : 
;;; first and foremost, let us prove that i!1 /= n_init

{-1}  i!2`1 = cons(n_init, l!1)
[-2]  ilist(i!2`2) =
       ilist(cons(car(hu_list), remove(cdr(hu_list), i!3 - 1)))
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  2 <= p
[-8]  length(l!1) = i!3 - 1
[-9]  0 < i!3
[-10] i!3 < p
[-11] public(u!1) = public(hu(i!3))
[-12] 2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictlast_last.1.2.1.2.1.2 : 
;;; first and foremost, let us prove that i!1 /= n_init

{-1}  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))
[-2]  i!2`1 = cons(n_init, l!1)
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  2 <= p
[-8]  length(l!1) = i!3 - 1
[-9]  0 < i!3
[-10] i!3 < p
[-11] public(u!1) = public(hu(i!3))
[-12] 2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (replace -2 -3)
Replacing using formula -2,
this simplifies to: 
restrictlast_last.1.2.1.2.1.2 : 
;;; first and foremost, let us prove that i!1 /= n_init

[-1]  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))
[-2]  i!2`1 = cons(n_init, l!1)
{-3}  length(cons(n_init, l!1)) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  2 <= p
[-8]  length(l!1) = i!3 - 1
[-9]  0 < i!3
[-10] i!3 < p
[-11] public(u!1) = public(hu(i!3))
[-12] 2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (expand "length" -3)
Expanding the definition of length,
this simplifies to: 
restrictlast_last.1.2.1.2.1.2 : 
;;; first and foremost, let us prove that i!1 /= n_init

[-1]  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))
[-2]  i!2`1 = cons(n_init, l!1)
{-3}  1 + length(l!1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  2 <= p
[-8]  length(l!1) = i!3 - 1
[-9]  0 < i!3
[-10] i!3 < p
[-11] public(u!1) = public(hu(i!3))
[-12] 2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (replace -8 -3)
Replacing using formula -8,
this simplifies to: 
restrictlast_last.1.2.1.2.1.2 : 
;;; first and foremost, let us prove that i!1 /= n_init

[-1]  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))
[-2]  i!2`1 = cons(n_init, l!1)
{-3}  1 + (i!3 - 1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  2 <= p
[-8]  length(l!1) = i!3 - 1
[-9]  0 < i!3
[-10] i!3 < p
[-11] public(u!1) = public(hu(i!3))
[-12] 2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (simplify -3)
Simplifying with decision procedures,
this simplifies to: 
restrictlast_last.1.2.1.2.1.2 : 
;;; first and foremost, let us prove that i!1 /= n_init

[-1]  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))
[-2]  i!2`1 = cons(n_init, l!1)
{-3}  i!3 = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  2 <= p
[-8]  length(l!1) = i!3 - 1
[-9]  0 < i!3
[-10] i!3 < p
[-11] public(u!1) = public(hu(i!3))
[-12] 2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (replace* -3)
Repeatedly applying the replace rule,
this simplifies to: 
restrictlast_last.1.2.1.2.1.2 : 
;;; first and foremost, let us prove that i!1 /= n_init

{-1}  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), P!1 - 1 - 1))
[-2]  i!2`1 = cons(n_init, l!1)
[-3]  i!3 = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  2 <= p
{-8}  length(l!1) = P!1 - 1 - 1
{-9}  0 < P!1 - 1
{-10} P!1 - 1 < p
{-11} public(u!1) = public(hu(P!1 - 1))
[-12] 2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (delete -2 -3 -6 -8 -9 -11)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.1.2.1.2 : 
;;; first and foremost, let us prove that i!1 /= n_init

[-1]  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), P!1 - 1 - 1))
[-2]  length(i!2`2) = P!1 - 1
[-3]  (length(hu_list) = p)
[-4]  2 <= p
[-5]  P!1 - 1 < p
[-6]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (replace -1 -2)
Replacing using formula -1,
this simplifies to: 
restrictlast_last.1.2.1.2.1.2 : 
;;; first and foremost, let us prove that i!1 /= n_init

[-1]  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), P!1 - 1 - 1))
{-2}  length(cons(car(hu_list), remove(cdr(hu_list), P!1 - 1 - 1))) =
       P!1 - 1
[-3]  (length(hu_list) = p)
[-4]  2 <= p
[-5]  P!1 - 1 < p
[-6]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.1.2.1.2 : 
;;; first and foremost, let us prove that i!1 /= n_init

[-1]  length(cons(car(hu_list), remove(cdr(hu_list), P!1 - 1 - 1))) =
       P!1 - 1
[-2]  (length(hu_list) = p)
[-3]  2 <= p
[-4]  P!1 - 1 < p
[-5]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (expand "length" -1)
Expanding the definition of length,
this simplifies to: 
restrictlast_last.1.2.1.2.1.2 : 
;;; first and foremost, let us prove that i!1 /= n_init

{-1}  1 + length[Identity](remove(cdr(hu_list), P!1 - 2)) = P!1 - 1
[-2]  (length(hu_list) = p)
[-3]  2 <= p
[-4]  P!1 - 1 < p
[-5]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (lemma "length_remove" ("c" "cdr(hu_list)" "i" "P!1-2"))
Using instance
  listprops[Identity].length_remove
Applying length_remove where 
  c gets cdr(hu_list),
  i gets P!1 - 2,
this yields  2 subgoals: 
restrictlast_last.1.2.1.2.1.2.1 : 
;;; first and foremost, let us prove that i!1 /= n_init

{-1}  length[Identity](cdr(hu_list)) - 1 =
       length[Identity](remove(cdr(hu_list), P!1 - 2))
[-2]  1 + length[Identity](remove(cdr(hu_list), P!1 - 2)) = P!1 - 1
[-3]  (length(hu_list) = p)
[-4]  2 <= p
[-5]  P!1 - 1 < p
[-6]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (replace -1 -2 rl)
Replacing using formula -1,
this simplifies to: 
restrictlast_last.1.2.1.2.1.2.1 : 
;;; first and foremost, let us prove that i!1 /= n_init

[-1]  length[Identity](cdr(hu_list)) - 1 =
       length[Identity](remove(cdr(hu_list), P!1 - 2))
{-2}  1 + (length[Identity](cdr(hu_list)) - 1) = P!1 - 1
[-3]  (length(hu_list) = p)
[-4]  2 <= p
[-5]  P!1 - 1 < p
[-6]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.1.2.1.2.1 : 
;;; first and foremost, let us prove that i!1 /= n_init

[-1]  1 + (length[Identity](cdr(hu_list)) - 1) = P!1 - 1
[-2]  (length(hu_list) = p)
[-3]  2 <= p
[-4]  P!1 - 1 < p
[-5]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (rewrite "length_cdr" -1)
Found matching substitution:
cons_l: (cons?[T]) gets hu_list,
Rewriting using length_cdr, matching in -1,
this simplifies to: 
restrictlast_last.1.2.1.2.1.2.1 : 
;;; first and foremost, let us prove that i!1 /= n_init

{-1}  length(hu_list) - 1 = P!1 - 1
[-2]  (length(hu_list) = p)
[-3]  2 <= p
[-4]  P!1 - 1 < p
[-5]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (delete -3 -4 -5)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.1.2.1.2.1 : 
;;; first and foremost, let us prove that i!1 /= n_init

[-1]  length(hu_list) - 1 = P!1 - 1
[-2]  (length(hu_list) = p)
  |-------
[1]   P!1 = p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_last.1.2.1.2.1.2.1.

restrictlast_last.1.2.1.2.1.2.2T (TCC):   

[-1]  1 + length[Identity](remove(cdr(hu_list), P!1 - 2)) = P!1 - 1
[-2]  (length(hu_list) = p)
[-3]  2 <= p
[-4]  P!1 - 1 < p
[-5]  2 <= P!1
  |-------
{1}   cons?[Identity](cdr[Identity](hu_list))
[2]   P!1 = p

Rerunning step: (delete -1 -4 -5 2)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.1.2.1.2.2T : 
;;; first and foremost, let us prove that i!1 /= n_init

[-1]  (length(hu_list) = p)
[-2]  2 <= p
  |-------
[1]   cons?[Identity](cdr[Identity](hu_list))

Rerunning step: (lemma "more_list_props[Identity].length_non_zero"
                 ("l" "hu_list"))
Applying more_list_props[Identity].length_non_zero where 
  l gets hu_list,
this simplifies to: 
restrictlast_last.1.2.1.2.1.2.2T : 
;;; first and foremost, let us prove that i!1 /= n_init

{-1}  length(hu_list) > 0 IFF cons?(hu_list)
[-2]  (length(hu_list) = p)
[-3]  2 <= p
  |-------
[1]   cons?[Identity](cdr[Identity](hu_list))

Rerunning step: (ground)
length rewrites length(cdr(hu_list))
  to 0
length rewrites length(hu_list)
  to 1
length rewrites length(hu_list)
  to 0
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_last.1.2.1.2.1.2.2T.


This completes the proof of restrictlast_last.1.2.1.2.1.2.

restrictlast_last.1.2.1.2.1.3 : 
;;; first and foremost, let us prove that i!1 /= n_init

{-1}  rho_last(conc(nlist(i!2`1), ilist(i!2`2)))
[-2]  2 <= P!1
  |-------
{1}   (i!1 = n_init)
{2}   car(i!2`1) = n_init
{3}   rho_last(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (comment "see first sibling")
Adding comment: see first sibling
this simplifies to: 
restrictlast_last.1.2.1.2.1.3 : 
;;; see first sibling

[-1]  rho_last(conc(nlist(i!2`1), ilist(i!2`2)))
[-2]  2 <= P!1
  |-------
[1]   (i!1 = n_init)
[2]   car(i!2`1) = n_init
[3]   rho_last(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.1.2.1.3 : 
;;; see first sibling

[-1]  rho_last(conc(nlist(i!2`1), ilist(i!2`2)))
[-2]  2 <= P!1
  |-------
[1]   (i!1 = n_init)
[2]   rho_last(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (lemma "listprops[Nonce].elt_append3"
                 ("l1" "i!2`1" "l2" "(: i!1 :)" "t" "n_init"))
Applying listprops[Nonce].elt_append3 where 
  l1 gets i!2`1,
  l2 gets (: i!1 :),
  t gets n_init,
this simplifies to: 
restrictlast_last.1.2.1.2.1.3 : 
;;; see first sibling

{-1}  elt(append(i!2`1, (: i!1 :)), n_init) IMPLIES
       elt(i!2`1, n_init) OR elt((: i!1 :), n_init)
[-2]  rho_last(conc(nlist(i!2`1), ilist(i!2`2)))
[-3]  2 <= P!1
  |-------
[1]   (i!1 = n_init)
[2]   rho_last(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (lemma "listprops[Nonce].elt_singleton"
                 ("t1" "i!1" "t2" "n_init"))
Applying listprops[Nonce].elt_singleton where 
  t1 gets i!1,
  t2 gets n_init,
this simplifies to: 
restrictlast_last.1.2.1.2.1.3 : 
;;; see first sibling

{-1}  elt((: i!1 :), n_init) IFF i!1 = n_init
[-2]  elt(append(i!2`1, (: i!1 :)), n_init) IMPLIES
       elt(i!2`1, n_init) OR elt((: i!1 :), n_init)
[-3]  rho_last(conc(nlist(i!2`1), ilist(i!2`2)))
[-4]  2 <= P!1
  |-------
[1]   (i!1 = n_init)
[2]   rho_last(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (grind :exclude "elt")
rho_last rewrites rho_last(nlist(append(i!2`1, (: i!1 :))))
  to NOT elt(append(i!2`1, (: i!1 :)), n_init)
rho_last rewrites rho_last(ilist(append(cdr(i!2`2), (: u!1 :))))
  to TRUE
rho_last rewrites 
  rho_last(conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :)))))
  to NOT elt(append(i!2`1, (: i!1 :)), n_init)
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_last rewrites 
  rho_last(code(public(car(i!2`2)),
                conc(nlist(append(i!2`1, (: i!1 :))),
                     ilist(append(cdr(i!2`2), (: u!1 :))))))
  to NOT elt(append(i!2`1, (: i!1 :)), n_init) OR
       EXISTS (i: {x: nat | 0 < x AND x < p}):
         public(car(i!2`2)) = public(hu(i)) AND
          EXISTS (l: {x: list[Nonce] | length(x) = i - 1}):
            conc(nlist(append(i!2`1, (: i!1 :))),
                 ilist(append(cdr(i!2`2), (: u!1 :))))
             =
             conc(nlist(cons(n_init, l)),
                  ilist(cons(car(hu_list), remove(cdr(hu_list), i - 1))))
rho_last rewrites rho_last(nlist(i!2`1))
  to FALSE
rho_last rewrites rho_last(ilist(i!2`2))
  to TRUE
rho_last rewrites rho_last(conc(nlist(i!2`1), ilist(i!2`2)))
  to FALSE
rho_last rewrites rho_last(nlist(append(i!2`1, (: i!1 :))))
  to TRUE
rho_last rewrites rho_last(ilist(append(cdr(i!2`2), (: u!1 :))))
  to TRUE
rho_last rewrites 
  rho_last(conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :)))))
  to TRUE
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_last rewrites 
  rho_last(code(public(car(i!2`2)),
                conc(nlist(append(i!2`1, (: i!1 :))),
                     ilist(append(cdr(i!2`2), (: u!1 :))))))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictlast_last.1.2.1.2.1.3.

restrictlast_last.1.2.1.2.1.4 : 
;;; first and foremost, let us prove that i!1 /= n_init

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
{-2}  length(l!1) = i!3 - 1
{-3}  0 < i!3
{-4}  i!3 < p
{-5}  public(u!1) = public(hu(i!3))
{-6}  conc(nlist(i!2`1), ilist(i!2`2)) =
       conc(nlist(cons(n_init, l!1)),
            ilist(cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))))
[-7]  2 <= P!1
  |-------
{1}   (i!1 = n_init)
{2}   car(i!2`1) = n_init
{3}   rho_last(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (comment "sequent 2 (which is a flattened false antecedent) follows from -6")
Adding comment: sequent 2 (which is a flattened false antecedent) follows from -6
this simplifies to: 
restrictlast_last.1.2.1.2.1.4 : 
;;; sequent 2 (which is a flattened false antecedent) follows from -6

[-1]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
[-2]  length(l!1) = i!3 - 1
[-3]  0 < i!3
[-4]  i!3 < p
[-5]  public(u!1) = public(hu(i!3))
[-6]  conc(nlist(i!2`1), ilist(i!2`2)) =
       conc(nlist(cons(n_init, l!1)),
            ilist(cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))))
[-7]  2 <= P!1
  |-------
[1]   (i!1 = n_init)
[2]   car(i!2`1) = n_init
[3]   rho_last(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (delete -1 -2 -3 -4 -5 -7 1 3)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.1.2.1.4 : 
;;; sequent 2 (which is a flattened false antecedent) follows from -6

[-1]  conc(nlist(i!2`1), ilist(i!2`2)) =
       conc(nlist(cons(n_init, l!1)),
            ilist(cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))))
  |-------
[1]   car(i!2`1) = n_init

Rerunning step: (mdecompose-equality -1)
Decomposing equalities,

This completes the proof of restrictlast_last.1.2.1.2.1.4.

restrictlast_last.1.2.1.2.1.5 : 
;;; first and foremost, let us prove that i!1 /= n_init

{-1}  rho_last(conc(nlist(i!2`1), ilist(i!2`2)))
[-2]  2 <= P!1
  |-------
{1}   (i!1 = n_init)
{2}   append(i!2`2, (: u!1 :)) = hu_list
{3}   rho_last(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (comment "see first sibling")
Adding comment: see first sibling
this simplifies to: 
restrictlast_last.1.2.1.2.1.5 : 
;;; see first sibling

[-1]  rho_last(conc(nlist(i!2`1), ilist(i!2`2)))
[-2]  2 <= P!1
  |-------
[1]   (i!1 = n_init)
[2]   append(i!2`2, (: u!1 :)) = hu_list
[3]   rho_last(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.1.2.1.5 : 
;;; see first sibling

[-1]  rho_last(conc(nlist(i!2`1), ilist(i!2`2)))
[-2]  2 <= P!1
  |-------
[1]   (i!1 = n_init)
[2]   rho_last(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (lemma "listprops[Nonce].elt_append3"
                 ("l1" "i!2`1" "l2" "(: i!1 :)" "t" "n_init"))
Applying listprops[Nonce].elt_append3 where 
  l1 gets i!2`1,
  l2 gets (: i!1 :),
  t gets n_init,
this simplifies to: 
restrictlast_last.1.2.1.2.1.5 : 
;;; see first sibling

{-1}  elt(append(i!2`1, (: i!1 :)), n_init) IMPLIES
       elt(i!2`1, n_init) OR elt((: i!1 :), n_init)
[-2]  rho_last(conc(nlist(i!2`1), ilist(i!2`2)))
[-3]  2 <= P!1
  |-------
[1]   (i!1 = n_init)
[2]   rho_last(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (lemma "listprops[Nonce].elt_singleton"
                 ("t1" "i!1" "t2" "n_init"))
Applying listprops[Nonce].elt_singleton where 
  t1 gets i!1,
  t2 gets n_init,
this simplifies to: 
restrictlast_last.1.2.1.2.1.5 : 
;;; see first sibling

{-1}  elt((: i!1 :), n_init) IFF i!1 = n_init
[-2]  elt(append(i!2`1, (: i!1 :)), n_init) IMPLIES
       elt(i!2`1, n_init) OR elt((: i!1 :), n_init)
[-3]  rho_last(conc(nlist(i!2`1), ilist(i!2`2)))
[-4]  2 <= P!1
  |-------
[1]   (i!1 = n_init)
[2]   rho_last(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (grind :exclude "elt")
rho_last rewrites rho_last(nlist(append(i!2`1, (: i!1 :))))
  to NOT elt(append(i!2`1, (: i!1 :)), n_init)
rho_last rewrites rho_last(ilist(append(cdr(i!2`2), (: u!1 :))))
  to TRUE
rho_last rewrites 
  rho_last(conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :)))))
  to NOT elt(append(i!2`1, (: i!1 :)), n_init)
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_last rewrites 
  rho_last(code(public(car(i!2`2)),
                conc(nlist(append(i!2`1, (: i!1 :))),
                     ilist(append(cdr(i!2`2), (: u!1 :))))))
  to NOT elt(append(i!2`1, (: i!1 :)), n_init) OR
       EXISTS (i: {x: nat | 0 < x AND x < p}):
         public(car(i!2`2)) = public(hu(i)) AND
          EXISTS (l: {x: list[Nonce] | length(x) = i - 1}):
            conc(nlist(append(i!2`1, (: i!1 :))),
                 ilist(append(cdr(i!2`2), (: u!1 :))))
             =
             conc(nlist(cons(n_init, l)),
                  ilist(cons(car(hu_list), remove(cdr(hu_list), i - 1))))
rho_last rewrites rho_last(nlist(i!2`1))
  to FALSE
rho_last rewrites rho_last(ilist(i!2`2))
  to TRUE
rho_last rewrites rho_last(conc(nlist(i!2`1), ilist(i!2`2)))
  to FALSE
rho_last rewrites rho_last(nlist(append(i!2`1, (: i!1 :))))
  to TRUE
rho_last rewrites rho_last(ilist(append(cdr(i!2`2), (: u!1 :))))
  to TRUE
rho_last rewrites 
  rho_last(conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :)))))
  to TRUE
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_last rewrites 
  rho_last(code(public(car(i!2`2)),
                conc(nlist(append(i!2`1, (: i!1 :))),
                     ilist(append(cdr(i!2`2), (: u!1 :))))))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictlast_last.1.2.1.2.1.5.

restrictlast_last.1.2.1.2.1.6 : 
;;; first and foremost, let us prove that i!1 /= n_init

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
{-2}  length(l!1) = i!3 - 1
{-3}  0 < i!3
{-4}  i!3 < p
{-5}  public(u!1) = public(hu(i!3))
{-6}  conc(nlist(i!2`1), ilist(i!2`2)) =
       conc(nlist(cons(n_init, l!1)),
            ilist(cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))))
[-7]  2 <= P!1
  |-------
{1}   (i!1 = n_init)
{2}   append(i!2`2, (: u!1 :)) = hu_list
{3}   rho_last(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (typepred "i!2`1" "i!2`2" "hu_list" "p")
Adding type constraints for  i!2`1, i!2`2, hu_list, p,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6 : 
;;; first and foremost, let us prove that i!1 /= n_init

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`1)
{-2}  length(i!2`1) = P!1 - 1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`2)
{-4}  length(i!2`2) = P!1 - 1
{-5}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-6}  (length(hu_list) = p)
{-7}  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
{-8}  2 <= p
[-9]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (l!1)
[-10] length(l!1) = i!3 - 1
[-11] 0 < i!3
[-12] i!3 < p
[-13] public(u!1) = public(hu(i!3))
[-14] conc(nlist(i!2`1), ilist(i!2`2)) =
       conc(nlist(cons(n_init, l!1)),
            ilist(cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))))
[-15] 2 <= P!1
  |-------
[1]   (i!1 = n_init)
[2]   append(i!2`2, (: u!1 :)) = hu_list
[3]   rho_last(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (delete -1 -3 -5 -9 1 3)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6 : 
;;; first and foremost, let us prove that i!1 /= n_init

[-1]  length(i!2`1) = P!1 - 1
[-2]  length(i!2`2) = P!1 - 1
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  2 <= p
[-6]  length(l!1) = i!3 - 1
[-7]  0 < i!3
[-8]  i!3 < p
[-9]  public(u!1) = public(hu(i!3))
[-10] conc(nlist(i!2`1), ilist(i!2`2)) =
       conc(nlist(cons(n_init, l!1)),
            ilist(cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))))
[-11] 2 <= P!1
  |-------
[1]   append(i!2`2, (: u!1 :)) = hu_list

Rerunning step: (decompose-equality -10)
Applying decompose-equality,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6 : 
;;; first and foremost, let us prove that i!1 /= n_init

{-1}  nlist(i!2`1) = nlist(cons(n_init, l!1))
{-2}  ilist(i!2`2) =
       ilist(cons(car(hu_list), remove(cdr(hu_list), i!3 - 1)))
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  2 <= p
[-8]  length(l!1) = i!3 - 1
[-9]  0 < i!3
[-10] i!3 < p
[-11] public(u!1) = public(hu(i!3))
[-12] 2 <= P!1
  |-------
[1]   append(i!2`2, (: u!1 :)) = hu_list

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6 : 
;;; first and foremost, let us prove that i!1 /= n_init

{-1}  i!2`1 = cons(n_init, l!1)
[-2]  ilist(i!2`2) =
       ilist(cons(car(hu_list), remove(cdr(hu_list), i!3 - 1)))
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  2 <= p
[-8]  length(l!1) = i!3 - 1
[-9]  0 < i!3
[-10] i!3 < p
[-11] public(u!1) = public(hu(i!3))
[-12] 2 <= P!1
  |-------
[1]   append(i!2`2, (: u!1 :)) = hu_list

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6 : 
;;; first and foremost, let us prove that i!1 /= n_init

{-1}  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))
[-2]  i!2`1 = cons(n_init, l!1)
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  2 <= p
[-8]  length(l!1) = i!3 - 1
[-9]  0 < i!3
[-10] i!3 < p
[-11] public(u!1) = public(hu(i!3))
[-12] 2 <= P!1
  |-------
[1]   append(i!2`2, (: u!1 :)) = hu_list

Rerunning step: (comment "first, establish some useful equalities")
Adding comment: first, establish some useful equalities
this simplifies to: 
restrictlast_last.1.2.1.2.1.6 : 
;;; first, establish some useful equalities

[-1]  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))
[-2]  i!2`1 = cons(n_init, l!1)
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  2 <= p
[-8]  length(l!1) = i!3 - 1
[-9]  0 < i!3
[-10] i!3 < p
[-11] public(u!1) = public(hu(i!3))
[-12] 2 <= P!1
  |-------
[1]   append(i!2`2, (: u!1 :)) = hu_list

Rerunning step: (case "P!1=p AND i!3=P!1-1")
Case splitting on 
   P!1 = p AND i!3 = P!1 - 1, 
this yields  2 subgoals: 
restrictlast_last.1.2.1.2.1.6.1 : 
;;; first, establish some useful equalities

{-1}  P!1 = p AND i!3 = P!1 - 1
[-2]  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))
[-3]  i!2`1 = cons(n_init, l!1)
[-4]  length(i!2`1) = P!1 - 1
[-5]  length(i!2`2) = P!1 - 1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  2 <= p
[-9]  length(l!1) = i!3 - 1
[-10] 0 < i!3
[-11] i!3 < p
[-12] public(u!1) = public(hu(i!3))
[-13] 2 <= P!1
  |-------
[1]   append(i!2`2, (: u!1 :)) = hu_list

Rerunning step: (comment "to prove: i!2`2 is hu_list without its last element and u!1 should be hu(P-1)")
Adding comment: to prove: i!2`2 is hu_list without its last element and u!1 should be hu(P-1)
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.1 : 
;;; to prove: i!2`2 is hu_list without its last element and u!1 should be hu(P-1)

[-1]  P!1 = p AND i!3 = P!1 - 1
[-2]  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))
[-3]  i!2`1 = cons(n_init, l!1)
[-4]  length(i!2`1) = P!1 - 1
[-5]  length(i!2`2) = P!1 - 1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  2 <= p
[-9]  length(l!1) = i!3 - 1
[-10] 0 < i!3
[-11] i!3 < p
[-12] public(u!1) = public(hu(i!3))
[-13] 2 <= P!1
  |-------
[1]   append(i!2`2, (: u!1 :)) = hu_list

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.1 : 
;;; to prove: i!2`2 is hu_list without its last element and u!1 should be hu(P-1)

{-1}  P!1 = p
{-2}  i!3 = P!1 - 1
[-3]  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))
[-4]  i!2`1 = cons(n_init, l!1)
[-5]  length(i!2`1) = P!1 - 1
[-6]  length(i!2`2) = P!1 - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  2 <= p
[-10] length(l!1) = i!3 - 1
[-11] 0 < i!3
[-12] i!3 < p
[-13] public(u!1) = public(hu(i!3))
[-14] 2 <= P!1
  |-------
[1]   append(i!2`2, (: u!1 :)) = hu_list

Rerunning step: (replace* -1 -2)
Repeatedly applying the replace rule,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.1 : 
;;; to prove: i!2`2 is hu_list without its last element and u!1 should be hu(P-1)

[-1]  P!1 = p
{-2}  i!3 = p - 1
{-3}  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), p - 1 - 1))
[-4]  i!2`1 = cons(n_init, l!1)
{-5}  length(i!2`1) = p - 1
{-6}  length(i!2`2) = p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  2 <= p
{-10} length(l!1) = p - 1 - 1
{-11} 0 < p - 1
{-12} p - 1 < p
{-13} public(u!1) = public(hu(p - 1))
{-14} 2 <= p
  |-------
[1]   append(i!2`2, (: u!1 :)) = hu_list

Rerunning step: (decompose-equality -13)
Applying decompose-equality,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.1 : 
;;; to prove: i!2`2 is hu_list without its last element and u!1 should be hu(P-1)

{-1}  u!1 = hu(p - 1)
[-2]  P!1 = p
[-3]  i!3 = p - 1
[-4]  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), p - 1 - 1))
[-5]  i!2`1 = cons(n_init, l!1)
[-6]  length(i!2`1) = p - 1
[-7]  length(i!2`2) = p - 1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] 2 <= p
[-11] length(l!1) = p - 1 - 1
[-12] 0 < p - 1
[-13] p - 1 < p
[-14] 2 <= p
  |-------
[1]   append(i!2`2, (: u!1 :)) = hu_list

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.1 : 
;;; to prove: i!2`2 is hu_list without its last element and u!1 should be hu(P-1)

[-1]  u!1 = hu(p - 1)
[-2]  P!1 = p
[-3]  i!3 = p - 1
[-4]  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), p - 1 - 1))
[-5]  i!2`1 = cons(n_init, l!1)
[-6]  length(i!2`1) = p - 1
[-7]  length(i!2`2) = p - 1
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] 2 <= p
[-11] length(l!1) = p - 1 - 1
[-12] 0 < p - 1
[-13] p - 1 < p
[-14] 2 <= p
  |-------
{1}   append(i!2`2, (: hu(p - 1) :)) = hu_list

Rerunning step: (delete -1 -2 -3 -5 -6 -10 -11 -12 -13)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.1 : 
;;; to prove: i!2`2 is hu_list without its last element and u!1 should be hu(P-1)

[-1]  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), p - 1 - 1))
[-2]  length(i!2`2) = p - 1
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  2 <= p
  |-------
[1]   append(i!2`2, (: hu(p - 1) :)) = hu_list

Rerunning step: (lemma "cons_remove" ("c" "hu_list" "i" "p-1-1"))
Using instance
  listprops[Identity].cons_remove
Applying cons_remove where 
  c gets hu_list,
  i gets p - 1 - 1,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.1 : 
;;; to prove: i!2`2 is hu_list without its last element and u!1 should be hu(P-1)

{-1}  cons(car(hu_list), remove(cdr(hu_list), p - 1 - 1)) =
       remove(hu_list, p - 1 - 1 + 1)
[-2]  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), p - 1 - 1))
[-3]  length(i!2`2) = p - 1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  2 <= p
  |-------
[1]   append(i!2`2, (: hu(p - 1) :)) = hu_list

Rerunning step: (replace -1 -2)
Replacing using formula -1,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.1 : 
;;; to prove: i!2`2 is hu_list without its last element and u!1 should be hu(P-1)

[-1]  cons(car(hu_list), remove(cdr(hu_list), p - 1 - 1)) =
       remove(hu_list, p - 1 - 1 + 1)
{-2}  i!2`2 = remove(hu_list, p - 1 - 1 + 1)
[-3]  length(i!2`2) = p - 1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  2 <= p
  |-------
[1]   append(i!2`2, (: hu(p - 1) :)) = hu_list

Rerunning step: (simplify -2)
Simplifying with decision procedures,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.1 : 
;;; to prove: i!2`2 is hu_list without its last element and u!1 should be hu(P-1)

[-1]  cons(car(hu_list), remove(cdr(hu_list), p - 1 - 1)) =
       remove(hu_list, p - 1 - 1 + 1)
{-2}  i!2`2 = remove(hu_list, p - 1)
[-3]  length(i!2`2) = p - 1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  2 <= p
  |-------
[1]   append(i!2`2, (: hu(p - 1) :)) = hu_list

Rerunning step: (replace* -2)
Repeatedly applying the replace rule,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.1 : 
;;; to prove: i!2`2 is hu_list without its last element and u!1 should be hu(P-1)

[-1]  cons(car(hu_list), remove(cdr(hu_list), p - 1 - 1)) =
       remove(hu_list, p - 1 - 1 + 1)
[-2]  i!2`2 = remove(hu_list, p - 1)
{-3}  length(remove(hu_list, p - 1)) = p - 1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  2 <= p
  |-------
{1}   append(remove(hu_list, p - 1), (: hu(p - 1) :)) = hu_list

Rerunning step: (delete -1 -2)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.1 : 
;;; to prove: i!2`2 is hu_list without its last element and u!1 should be hu(P-1)

[-1]  length(remove(hu_list, p - 1)) = p - 1
[-2]  (length(hu_list) = p)
[-3]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-4]  2 <= p
  |-------
[1]   append(remove(hu_list, p - 1), (: hu(p - 1) :)) = hu_list

Rerunning step: (comment "intuitively, this clearly holds")
Adding comment: intuitively, this clearly holds
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.1 : 
;;; intuitively, this clearly holds

[-1]  length(remove(hu_list, p - 1)) = p - 1
[-2]  (length(hu_list) = p)
[-3]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-4]  2 <= p
  |-------
[1]   append(remove(hu_list, p - 1), (: hu(p - 1) :)) = hu_list

Rerunning step: (comment "it is proven by equality of the lengths of the lists and equality of their elements")
Adding comment: it is proven by equality of the lengths of the lists and equality of their elements
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.1 : 
;;; it is proven by equality of the lengths of the lists and equality of their elements

[-1]  length(remove(hu_list, p - 1)) = p - 1
[-2]  (length(hu_list) = p)
[-3]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-4]  2 <= p
  |-------
[1]   append(remove(hu_list, p - 1), (: hu(p - 1) :)) = hu_list

Rerunning step: (case "length(append(remove(hu_list, p - 1), (: hu(p - 1) :))) = p")
Case splitting on 
   length(append(remove(hu_list, p - 1), (: hu(p - 1) :))) = p, 
this yields  2 subgoals: 
restrictlast_last.1.2.1.2.1.6.1.1 : 
;;; it is proven by equality of the lengths of the lists and equality of their elements

{-1}  length(append(remove(hu_list, p - 1), (: hu(p - 1) :))) = p
[-2]  length(remove(hu_list, p - 1)) = p - 1
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  2 <= p
  |-------
[1]   append(remove(hu_list, p - 1), (: hu(p - 1) :)) = hu_list

Rerunning step: (lemma "length_nth_equality[Identity]"
                 ("l1" "append(remove(hu_list, p-1), (:hu(p-1):))" "l2"
                  "hu_list"))
Ignoring 1 repeated TCCs.
Applying length_nth_equality[Identity] where 
  l1 gets append(remove(hu_list, p - 1), (: hu(p - 1) :)),
  l2 gets hu_list,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.1.1 : 
;;; it is proven by equality of the lengths of the lists and equality of their elements

{-1}  (length[Identity](append(remove(hu_list, p - 1), (: hu(p - 1) :))) =
        length[Identity](hu_list)
        AND
        FORALL (i:
                  below[length[Identity]
                            (append(remove(hu_list, p - 1),
                                    (: hu(p - 1) :)))]):
          nth(append(remove(hu_list, p - 1), (: hu(p - 1) :)), i) =
           nth(hu_list, i))
       IMPLIES append(remove(hu_list, p - 1), (: hu(p - 1) :)) = hu_list
[-2]  length(append(remove(hu_list, p - 1), (: hu(p - 1) :))) = p
[-3]  length(remove(hu_list, p - 1)) = p - 1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  2 <= p
  |-------
[1]   append(remove(hu_list, p - 1), (: hu(p - 1) :)) = hu_list

Rerunning step: (prop)
Applying propositional simplification,
this yields  2 subgoals: 
restrictlast_last.1.2.1.2.1.6.1.1.1 : 
;;; it is proven by equality of the lengths of the lists and equality of their elements

[-1]  length(append(remove(hu_list, p - 1), (: hu(p - 1) :))) = p
[-2]  length(remove(hu_list, p - 1)) = p - 1
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  2 <= p
  |-------
{1}   length[Identity](append(remove(hu_list, p - 1), (: hu(p - 1) :))) =
       length[Identity](hu_list)
[2]   append(remove(hu_list, p - 1), (: hu(p - 1) :)) = hu_list

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.1.1.1 : 
;;; it is proven by equality of the lengths of the lists and equality of their elements

[-1]  length(append(remove(hu_list, p - 1), (: hu(p - 1) :))) = p
[-2]  length(remove(hu_list, p - 1)) = p - 1
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  2 <= p
  |-------
{1}   p = length[Identity](hu_list)
[2]   append(remove(hu_list, p - 1), (: hu(p - 1) :)) = hu_list

Rerunning step: (delete -1 -2 -4 -5 2)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.1.1.1 : 
;;; it is proven by equality of the lengths of the lists and equality of their elements

[-1]  (length(hu_list) = p)
  |-------
[1]   p = length[Identity](hu_list)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_last.1.2.1.2.1.6.1.1.1.

restrictlast_last.1.2.1.2.1.6.1.1.2 : 
;;; it is proven by equality of the lengths of the lists and equality of their elements

[-1]  length(append(remove(hu_list, p - 1), (: hu(p - 1) :))) = p
[-2]  length(remove(hu_list, p - 1)) = p - 1
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  2 <= p
  |-------
{1}   FORALL (i:
                below[length[Identity]
                          (append(remove(hu_list, p - 1),
                                  (: hu(p - 1) :)))]):
        nth(append(remove(hu_list, p - 1), (: hu(p - 1) :)), i) =
         nth(hu_list, i)
[2]   append(remove(hu_list, p - 1), (: hu(p - 1) :)) = hu_list

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.1.1.2 : 
;;; it is proven by equality of the lengths of the lists and equality of their elements

{-1}  i!4 <
       length[Identity](append(remove(hu_list, p - 1), (: hu(p - 1) :)))
[-2]  length(append(remove(hu_list, p - 1), (: hu(p - 1) :))) = p
[-3]  length(remove(hu_list, p - 1)) = p - 1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  2 <= p
  |-------
{1}   nth(append(remove(hu_list, p - 1), (: hu(p - 1) :)), i!4) =
       nth(hu_list, i!4)
[2]   append(remove(hu_list, p - 1), (: hu(p - 1) :)) = hu_list

Rerunning step: (replace -2 -1)
Replacing using formula -2,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.1.1.2 : 
;;; it is proven by equality of the lengths of the lists and equality of their elements

{-1}  i!4 < p
[-2]  length(append(remove(hu_list, p - 1), (: hu(p - 1) :))) = p
[-3]  length(remove(hu_list, p - 1)) = p - 1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  2 <= p
  |-------
[1]   nth(append(remove(hu_list, p - 1), (: hu(p - 1) :)), i!4) =
       nth(hu_list, i!4)
[2]   append(remove(hu_list, p - 1), (: hu(p - 1) :)) = hu_list

Rerunning step: (delete -2 2)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.1.1.2 : 
;;; it is proven by equality of the lengths of the lists and equality of their elements

[-1]  i!4 < p
[-2]  length(remove(hu_list, p - 1)) = p - 1
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  2 <= p
  |-------
[1]   nth(append(remove(hu_list, p - 1), (: hu(p - 1) :)), i!4) =
       nth(hu_list, i!4)

Rerunning step: (stop-rewrite "remove")
Turned off sets.remove
Turned off listprops.remove
Turning off automatic rewriting for: 
   remove,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.1.1.2 : 
;;; it is proven by equality of the lengths of the lists and equality of their elements

[-1]  i!4 < p
[-2]  length(remove(hu_list, p - 1)) = p - 1
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  2 <= p
  |-------
[1]   nth(append(remove(hu_list, p - 1), (: hu(p - 1) :)), i!4) =
       nth(hu_list, i!4)

Rerunning step: (lemma "listprops[Identity].nth_append"
                 ("l1" "remove(hu_list, p-1)" "l2" "(:hu(p-1):)" "i"
                  "i!4"))
length rewrites length((: :))
  to 0
length rewrites length[Identity]((: hu(p - 1) :))
  to 1
Ignoring 1 repeated TCCs.
Applying listprops[Identity].nth_append where 
  l1 gets remove(hu_list, p - 1),
  l2 gets (: hu(p - 1) :),
  i gets i!4,
this yields  2 subgoals: 
restrictlast_last.1.2.1.2.1.6.1.1.2.1 : 
;;; it is proven by equality of the lengths of the lists and equality of their elements

{-1}  nth(append(remove(hu_list, p - 1), (: hu(p - 1) :)), i!4) =
       IF i!4 < length[Identity](remove(hu_list, p - 1))
         THEN nth(remove(hu_list, p - 1), i!4)
       ELSE nth((: hu(p - 1) :),
                i!4 - length[Identity](remove(hu_list, p - 1)))
       ENDIF
[-2]  i!4 < p
[-3]  length(remove(hu_list, p - 1)) = p - 1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  2 <= p
  |-------
[1]   nth(append(remove(hu_list, p - 1), (: hu(p - 1) :)), i!4) =
       nth(hu_list, i!4)

Rerunning step: (lemma "listprops[Identity].nth_remove"
                 ("l" "hu_list" "i" "p-1"))
Ignoring 1 repeated TCCs.
Applying listprops[Identity].nth_remove where 
  l gets hu_list,
  i gets p - 1,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.1.1.2.1 : 
;;; it is proven by equality of the lengths of the lists and equality of their elements

{-1}  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, p - 1), j) =
         IF j < p - 1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-2]  nth(append(remove(hu_list, p - 1), (: hu(p - 1) :)), i!4) =
       IF i!4 < length[Identity](remove(hu_list, p - 1))
         THEN nth(remove(hu_list, p - 1), i!4)
       ELSE nth((: hu(p - 1) :),
                i!4 - length[Identity](remove(hu_list, p - 1)))
       ENDIF
[-3]  i!4 < p
[-4]  length(remove(hu_list, p - 1)) = p - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  2 <= p
  |-------
[1]   nth(append(remove(hu_list, p - 1), (: hu(p - 1) :)), i!4) =
       nth(hu_list, i!4)

Rerunning step: (lazy-grind)
remove rewrites remove(hu_list, p - 1)
  to cons(car(hu_list), remove(cdr(hu_list), p - 2))
append rewrites 
  append(cons(car(hu_list), remove(cdr(hu_list), p - 2)), (: hu(p - 1) :))
  to cons(car(hu_list),
           append(remove(cdr(hu_list), p - 2), (: hu(p - 1) :)))
length rewrites length(cons(car(hu_list), remove(cdr(hu_list), p - 2)))
  to 1 + length(remove(cdr(hu_list), p - 2))
nth rewrites 
  nth((: hu(p - 1) :), -1 - length(remove(cdr(hu_list), p - 2)) + i!4)
  to hu(p - 1)
nth rewrites 
  nth(cons(car(hu_list),
           append(remove(cdr(hu_list), p - 2), (: hu(p - 1) :))),
      i!4)
  to nth(append(remove(cdr(hu_list), p - 2), (: hu(p - 1) :)), i!4 - 1)
nth rewrites nth(hu_list, i!4)
  to nth(cdr(hu_list), i!4 - 1)
nth rewrites nth(hu_list, p - 1)
  to nth(cdr(hu_list), p - 2)
By skolemization, if-lifting, simplification and instantiation,

This completes the proof of restrictlast_last.1.2.1.2.1.6.1.1.2.1.

restrictlast_last.1.2.1.2.1.6.1.1.2.2T (TCC):   

[-1]  i!4 < p
[-2]  length(remove(hu_list, p - 1)) = p - 1
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  2 <= p
  |-------
{1}   i!4 < 1 + length[Identity](remove[Identity](hu_list, p - 1))
[2]   nth(append(remove(hu_list, p - 1), (: hu(p - 1) :)), i!4) =
       nth(hu_list, i!4)

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.1.1.2.2T : 
;;; it is proven by equality of the lengths of the lists and equality of their elements

[-1]  i!4 < p
[-2]  length(remove(hu_list, p - 1)) = p - 1
[-3]  (length(hu_list) = p)
[-4]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-5]  2 <= p
  |-------
{1}   i!4 < 1 + (p - 1)
[2]   nth(append(remove(hu_list, p - 1), (: hu(p - 1) :)), i!4) =
       nth(hu_list, i!4)

Rerunning step: (delete -2 -3 -4 -5 2)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.1.1.2.2T : 
;;; it is proven by equality of the lengths of the lists and equality of their elements

[-1]  i!4 < p
  |-------
[1]   i!4 < 1 + (p - 1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_last.1.2.1.2.1.6.1.1.2.2T.


This completes the proof of restrictlast_last.1.2.1.2.1.6.1.1.2.


This completes the proof of restrictlast_last.1.2.1.2.1.6.1.1.

restrictlast_last.1.2.1.2.1.6.1.2 : 
;;; it is proven by equality of the lengths of the lists and equality of their elements

[-1]  length(remove(hu_list, p - 1)) = p - 1
[-2]  (length(hu_list) = p)
[-3]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-4]  2 <= p
  |-------
{1}   length(append(remove(hu_list, p - 1), (: hu(p - 1) :))) = p
[2]   append(remove(hu_list, p - 1), (: hu(p - 1) :)) = hu_list

Rerunning step: (delete -2 -3 -4 2)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.1.2 : 
;;; it is proven by equality of the lengths of the lists and equality of their elements

[-1]  length(remove(hu_list, p - 1)) = p - 1
  |-------
[1]   length(append(remove(hu_list, p - 1), (: hu(p - 1) :))) = p

Rerunning step: (stop-rewrite "remove")
Turned off sets.remove
Turned off listprops.remove
Turning off automatic rewriting for: 
   remove,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.1.2 : 
;;; it is proven by equality of the lengths of the lists and equality of their elements

[-1]  length(remove(hu_list, p - 1)) = p - 1
  |-------
[1]   length(append(remove(hu_list, p - 1), (: hu(p - 1) :))) = p

Rerunning step: (rewrite "length_append")
Found matching substitution:
l2: list[T] gets (: hu(p - 1) :),
l1: list[T] gets remove(hu_list, p - 1),
length rewrites length((: :))
  to 0
length rewrites length((: hu(p - 1) :))
  to 1
Rewriting using length_append, matching in *,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.1.2 : 
;;; it is proven by equality of the lengths of the lists and equality of their elements

[-1]  length(remove(hu_list, p - 1)) = p - 1
  |-------
{1}   1 + length(remove(hu_list, p - 1)) = p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_last.1.2.1.2.1.6.1.2.


This completes the proof of restrictlast_last.1.2.1.2.1.6.1.

restrictlast_last.1.2.1.2.1.6.2 : 
;;; first, establish some useful equalities

[-1]  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))
[-2]  i!2`1 = cons(n_init, l!1)
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  2 <= p
[-8]  length(l!1) = i!3 - 1
[-9]  0 < i!3
[-10] i!3 < p
[-11] public(u!1) = public(hu(i!3))
[-12] 2 <= P!1
  |-------
{1}   P!1 = p AND i!3 = P!1 - 1
[2]   append(i!2`2, (: u!1 :)) = hu_list

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.2 : 
;;; first, establish some useful equalities

[-1]  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))
[-2]  i!2`1 = cons(n_init, l!1)
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  2 <= p
[-8]  length(l!1) = i!3 - 1
[-9]  0 < i!3
[-10] i!3 < p
[-11] public(u!1) = public(hu(i!3))
[-12] 2 <= P!1
  |-------
[1]   P!1 = p AND i!3 = P!1 - 1

Rerunning step: (replace -2 -3)
Replacing using formula -2,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.2 : 
;;; first, establish some useful equalities

[-1]  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))
[-2]  i!2`1 = cons(n_init, l!1)
{-3}  length(cons(n_init, l!1)) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  2 <= p
[-8]  length(l!1) = i!3 - 1
[-9]  0 < i!3
[-10] i!3 < p
[-11] public(u!1) = public(hu(i!3))
[-12] 2 <= P!1
  |-------
[1]   P!1 = p AND i!3 = P!1 - 1

Rerunning step: (expand "length" -3)
Expanding the definition of length,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.2 : 
;;; first, establish some useful equalities

[-1]  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))
[-2]  i!2`1 = cons(n_init, l!1)
{-3}  1 + length(l!1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  2 <= p
[-8]  length(l!1) = i!3 - 1
[-9]  0 < i!3
[-10] i!3 < p
[-11] public(u!1) = public(hu(i!3))
[-12] 2 <= P!1
  |-------
[1]   P!1 = p AND i!3 = P!1 - 1

Rerunning step: (replace -8 -3)
Replacing using formula -8,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.2 : 
;;; first, establish some useful equalities

[-1]  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))
[-2]  i!2`1 = cons(n_init, l!1)
{-3}  1 + (i!3 - 1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  2 <= p
[-8]  length(l!1) = i!3 - 1
[-9]  0 < i!3
[-10] i!3 < p
[-11] public(u!1) = public(hu(i!3))
[-12] 2 <= P!1
  |-------
[1]   P!1 = p AND i!3 = P!1 - 1

Rerunning step: (simplify -3)
Simplifying with decision procedures,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.2 : 
;;; first, establish some useful equalities

[-1]  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))
[-2]  i!2`1 = cons(n_init, l!1)
{-3}  i!3 = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  2 <= p
[-8]  length(l!1) = i!3 - 1
[-9]  0 < i!3
[-10] i!3 < p
[-11] public(u!1) = public(hu(i!3))
[-12] 2 <= P!1
  |-------
[1]   P!1 = p AND i!3 = P!1 - 1

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.2 : 
;;; first, establish some useful equalities

[-1]  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), i!3 - 1))
[-2]  i!2`1 = cons(n_init, l!1)
[-3]  i!3 = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  2 <= p
[-8]  length(l!1) = i!3 - 1
[-9]  0 < i!3
[-10] i!3 < p
[-11] public(u!1) = public(hu(i!3))
[-12] 2 <= P!1
  |-------
{1}   P!1 = p

Rerunning step: (replace* -3)
Repeatedly applying the replace rule,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.2 : 
;;; first, establish some useful equalities

{-1}  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), P!1 - 1 - 1))
[-2]  i!2`1 = cons(n_init, l!1)
[-3]  i!3 = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  2 <= p
{-8}  length(l!1) = P!1 - 1 - 1
{-9}  0 < P!1 - 1
{-10} P!1 - 1 < p
{-11} public(u!1) = public(hu(P!1 - 1))
[-12] 2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (delete -2 -3 -6 -8 -9 -11)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.2 : 
;;; first, establish some useful equalities

[-1]  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), P!1 - 1 - 1))
[-2]  length(i!2`2) = P!1 - 1
[-3]  (length(hu_list) = p)
[-4]  2 <= p
[-5]  P!1 - 1 < p
[-6]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (replace -1 -2)
Replacing using formula -1,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.2 : 
;;; first, establish some useful equalities

[-1]  i!2`2 = cons(car(hu_list), remove(cdr(hu_list), P!1 - 1 - 1))
{-2}  length(cons(car(hu_list), remove(cdr(hu_list), P!1 - 1 - 1))) =
       P!1 - 1
[-3]  (length(hu_list) = p)
[-4]  2 <= p
[-5]  P!1 - 1 < p
[-6]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.2 : 
;;; first, establish some useful equalities

[-1]  length(cons(car(hu_list), remove(cdr(hu_list), P!1 - 1 - 1))) =
       P!1 - 1
[-2]  (length(hu_list) = p)
[-3]  2 <= p
[-4]  P!1 - 1 < p
[-5]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (expand "length" -1)
Expanding the definition of length,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.2 : 
;;; first, establish some useful equalities

{-1}  1 + length[Identity](remove(cdr(hu_list), P!1 - 2)) = P!1 - 1
[-2]  (length(hu_list) = p)
[-3]  2 <= p
[-4]  P!1 - 1 < p
[-5]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (lemma "length_remove" ("c" "cdr(hu_list)" "i" "P!1-2"))
Using instance
  listprops[Identity].length_remove
Applying length_remove where 
  c gets cdr(hu_list),
  i gets P!1 - 2,
this yields  2 subgoals: 
restrictlast_last.1.2.1.2.1.6.2.1 : 
;;; first, establish some useful equalities

{-1}  length[Identity](cdr(hu_list)) - 1 =
       length[Identity](remove(cdr(hu_list), P!1 - 2))
[-2]  1 + length[Identity](remove(cdr(hu_list), P!1 - 2)) = P!1 - 1
[-3]  (length(hu_list) = p)
[-4]  2 <= p
[-5]  P!1 - 1 < p
[-6]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (replace -1 -2 rl)
Replacing using formula -1,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.2.1 : 
;;; first, establish some useful equalities

[-1]  length[Identity](cdr(hu_list)) - 1 =
       length[Identity](remove(cdr(hu_list), P!1 - 2))
{-2}  1 + (length[Identity](cdr(hu_list)) - 1) = P!1 - 1
[-3]  (length(hu_list) = p)
[-4]  2 <= p
[-5]  P!1 - 1 < p
[-6]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.2.1 : 
;;; first, establish some useful equalities

[-1]  1 + (length[Identity](cdr(hu_list)) - 1) = P!1 - 1
[-2]  (length(hu_list) = p)
[-3]  2 <= p
[-4]  P!1 - 1 < p
[-5]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (rewrite "length_cdr" -1)
Found matching substitution:
cons_l: (cons?[T]) gets hu_list,
Rewriting using length_cdr, matching in -1,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.2.1 : 
;;; first, establish some useful equalities

{-1}  length(hu_list) - 1 = P!1 - 1
[-2]  (length(hu_list) = p)
[-3]  2 <= p
[-4]  P!1 - 1 < p
[-5]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (delete -3 -4 -5)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.2.1 : 
;;; first, establish some useful equalities

[-1]  length(hu_list) - 1 = P!1 - 1
[-2]  (length(hu_list) = p)
  |-------
[1]   P!1 = p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_last.1.2.1.2.1.6.2.1.

restrictlast_last.1.2.1.2.1.6.2.2T (TCC):   

[-1]  1 + length[Identity](remove(cdr(hu_list), P!1 - 2)) = P!1 - 1
[-2]  (length(hu_list) = p)
[-3]  2 <= p
[-4]  P!1 - 1 < p
[-5]  2 <= P!1
  |-------
{1}   cons?[Identity](cdr[Identity](hu_list))
[2]   P!1 = p

Rerunning step: (delete -1 -4 -5 2)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.2.2T : 
;;; first, establish some useful equalities

[-1]  (length(hu_list) = p)
[-2]  2 <= p
  |-------
[1]   cons?[Identity](cdr[Identity](hu_list))

Rerunning step: (lemma "more_list_props[Identity].length_non_zero"
                 ("l" "hu_list"))
Applying more_list_props[Identity].length_non_zero where 
  l gets hu_list,
this simplifies to: 
restrictlast_last.1.2.1.2.1.6.2.2T : 
;;; first, establish some useful equalities

{-1}  length(hu_list) > 0 IFF cons?(hu_list)
[-2]  (length(hu_list) = p)
[-3]  2 <= p
  |-------
[1]   cons?[Identity](cdr[Identity](hu_list))

Rerunning step: (ground)
length rewrites length(cdr(hu_list))
  to 0
length rewrites length(hu_list)
  to 1
length rewrites length(hu_list)
  to 0
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_last.1.2.1.2.1.6.2.2T.


This completes the proof of restrictlast_last.1.2.1.2.1.6.2.


This completes the proof of restrictlast_last.1.2.1.2.1.6.


This completes the proof of restrictlast_last.1.2.1.2.1.

restrictlast_last.1.2.1.2.2 : 
;;; first and foremost, let us prove that i!1 /= n_init

[-1]  rho_last(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
{1}   i!1 /= n_init
[2]   append(i!2`2, (: u!1 :)) = hu_list AND car(i!2`1) = n_init AND P!1 = p
[3]   rho_last(E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :))))))

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.1.2.2 : 
;;; first and foremost, let us prove that i!1 /= n_init

  |-------
[1]   i!1 /= n_init

Rerunning step: (typepred "i!1")
Adding type constraints for  i!1,
this simplifies to: 
restrictlast_last.1.2.1.2.2 : 
;;; first and foremost, let us prove that i!1 /= n_init

{-1}  IRpart(P!1, u!1, P!1 - 1)(i!1)
  |-------
[1]   i!1 /= n_init

Rerunning step: (lemma "n_prop" ("P" "P!1" "u" "u!1" "r" "P!1-1"))
Applying n_prop where 
  P gets P!1,
  u gets u!1,
  r gets P!1 - 1,
this simplifies to: 
restrictlast_last.1.2.1.2.2 : 
;;; first and foremost, let us prove that i!1 /= n_init

{-1}  (P!1 /= p OR P!1 - 1 /= 0) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce]
               (P!1, u!1, P!1 - 1)(n_init)
[-2]  IRpart(P!1, u!1, P!1 - 1)(i!1)
  |-------
[1]   i!1 /= n_init

Rerunning step: (grind)
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
/= rewrites i!1 /= n_init
  to TRUE
/= rewrites P!1 /= p
  to NOT (P!1 = p)
/= rewrites P!1 - 1 /= 0
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictlast_last.1.2.1.2.2.


This completes the proof of restrictlast_last.1.2.1.2.


This completes the proof of restrictlast_last.1.2.1.

restrictlast_last.1.2.2 :  

[-1]  rho_last(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
{1}   ((rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :)))) >>
         Stop[event])
        # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
{2}   R_last(trans(u!1, car(i!2`2),
                   E(public(car(i!2`2)),
                     conc(nlist(append(i!2`1, (: i!1 :))),
                          ilist(append(cdr(i!2`2), (: u!1 :)))))))
{3}   trans(u!1, car(i!2`2),
            E(public(car(i!2`2)),
              conc(nlist(append(i!2`1, (: i!1 :))),
                   ilist(append(cdr(i!2`2), (: u!1 :))))))
       >>
       ((rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :)))) >>
          Stop[event])
         # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[4]   R_last(signal(running(P!1 - 1, append(i!2`2, (: u!1 :)), car(i!2`1))))

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.2 :  

[-1]  rho_last(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   ((rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :)))) >>
         Stop[event])
        # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[2]   R_last(signal(running(P!1 - 1, append(i!2`2, (: u!1 :)), car(i!2`1))))

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictlast_last.1.2.2 :  

{-1}  rho_last(E(public(u!1), nlist((: i!1 :))))
[-2]  rho_last(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-3]  2 <= P!1
  |-------
{1}   (Stop[event] # R_last) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
{2}   R_last(rec(u!1, nth(i!2`2, P!1 - 2),
                 E(public(u!1), nlist((: i!1 :)))))
{3}   rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :)))) >>
       (Stop[event] # R_last)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[4]   R_last(signal(running(P!1 - 1, append(i!2`2, (: u!1 :)), car(i!2`1))))

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictlast_last.1.2.2 :  

[-1]  rho_last(E(public(u!1), nlist((: i!1 :))))
[-2]  rho_last(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-3]  2 <= P!1
  |-------
[1]   (Stop[event] # R_last) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)
[2]   R_last(signal(running(P!1 - 1, append(i!2`2, (: u!1 :)), car(i!2`1))))

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictlast_last.1.2.2.


This completes the proof of restrictlast_last.1.2.


This completes the proof of restrictlast_last.1.

restrictlast_last.2 :  

[-1]  2 <= P!1
  |-------
{1}   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!1 :))
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (signal(running(P!1 - 1, append(i`2, (: u!1 :)), car(i`1))) >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(nlist(append(i`1, (: i!1 :))),
                          ilist(append(cdr(i`2), (: u!1 :))))))
              >>
              (rec(u!1, nth(i`2, P!1 - 2),
                   E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
         # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictlast_last.2 :  

  |-------
[1]   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!1 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!1 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictlast_last.2.

restrictlast_last.3 :  

[-1]  2 <= P!1
  |-------
{1}   cons?[Identity](i!2`2)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (signal(running(P!1 - 1, append(i`2, (: u!1 :)), car(i`1))) >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(nlist(append(i`1, (: i!1 :))),
                          ilist(append(cdr(i`2), (: u!1 :))))))
              >>
              (rec(u!1, nth(i`2, P!1 - 2),
                   E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
         # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictlast_last.3 :  

  |-------
[1]   cons?[Identity](i!2`2)

Rerunning step: (nonemptylist "i!2`2")
Relating existence of a tail to a list's length,

This completes the proof of restrictlast_last.3.

restrictlast_last.4 :  

[-1]  2 <= P!1
  |-------
{1}   cons?[Nonce](i!2`1)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (signal(running(P!1 - 1, append(i`2, (: u!1 :)), car(i`1))) >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(nlist(append(i`1, (: i!1 :))),
                          ilist(append(cdr(i`2), (: u!1 :))))))
              >>
              (rec(u!1, nth(i`2, P!1 - 2),
                   E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
         # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictlast_last.4 :  

  |-------
[1]   cons?[Nonce](i!2`1)

Rerunning step: (nonemptylist "i!2`1")
Relating existence of a tail to a list's length,

This completes the proof of restrictlast_last.4.

restrictlast_last.5 :  

[-1]  2 <= P!1
  |-------
{1}   P!1 - 2 < length[Identity](i!2`2)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (signal(running(P!1 - 1, append(i`2, (: u!1 :)), car(i`1))) >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(nlist(append(i`1, (: i!1 :))),
                          ilist(append(cdr(i`2), (: u!1 :))))))
              >>
              (rec(u!1, nth(i`2, P!1 - 2),
                   E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
         # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (typepred "i!2`2")
Adding type constraints for  i!2`2,
this simplifies to: 
restrictlast_last.5 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`2)
{-2}  length(i!2`2) = P!1 - 1
[-3]  2 <= P!1
  |-------
[1]   P!1 - 2 < length[Identity](i!2`2)
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (signal(running(P!1 - 1, append(i`2, (: u!1 :)), car(i`1))) >>
            (trans(u!1, car(i`2),
                   E(public(car(i`2)),
                     conc(nlist(append(i`1, (: i!1 :))),
                          ilist(append(cdr(i`2), (: u!1 :))))))
              >>
              (rec(u!1, nth(i`2, P!1 - 2),
                   E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
         # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete -1 -3 2)
Deleting some formulas,
this simplifies to: 
restrictlast_last.5 :  

[-1]  length(i!2`2) = P!1 - 1
  |-------
[1]   P!1 - 2 < length[Identity](i!2`2)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictlast_last.5.

restrictlast_last.6 :  

[-1]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!1 :))
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (signal(running(P!1 - 1, append(il, (: u!1 :)), car(nl))) >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(nlist(append(nl, (: i!1 :))),
                          ilist(append(cdr(il), (: u!1 :))))))
              >>
              (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictlast_last.6 :  

  |-------
[1]   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!1 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!1 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictlast_last.6.

restrictlast_last.7 :  

[-1]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        cons?[Identity](il)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (signal(running(P!1 - 1, append(il, (: u!1 :)), car(nl))) >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(nlist(append(nl, (: i!1 :))),
                          ilist(append(cdr(il), (: u!1 :))))))
              >>
              (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete -1 2)
Deleting some formulas,
this simplifies to: 
restrictlast_last.7 :  

  |-------
[1]   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        cons?[Identity](il)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictlast_last.7 :  

  |-------
{1}   cons?[Identity](il!1)

Rerunning step: (nonemptylist "il!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictlast_last.7.

restrictlast_last.8 :  

[-1]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        cons?[Nonce](nl)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (signal(running(P!1 - 1, append(il, (: u!1 :)), car(nl))) >>
            (trans(u!1, car(il),
                   E(public(car(il)),
                     conc(nlist(append(nl, (: i!1 :))),
                          ilist(append(cdr(il), (: u!1 :))))))
              >>
              (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
                >> Stop[event]))))
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_last(msg(e)))(t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictlast_last.8 :  

  |-------
[1]   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        cons?[Nonce](nl)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictlast_last.8 :  

  |-------
{1}   cons?[Nonce](nl!1)

Rerunning step: (nonemptylist "nl!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictlast_last.8.

Q.E.D.


Run time  = 5.28 secs.
Real time = 6.77 secs.
nil
pvs(72): 
Installing rewrite rule sets.singleton_rew (all instances)
authentication_last :  

  |-------
{1}   network(USER) |> auth(T, R_last)

Rerunning step: (auto-rewrite-theory "sets")
Rewriting relative to the theory: sets,
this simplifies to: 
authentication_last :  

  |-------
[1]   network(USER) |> auth(T, R_last)

Rerunning step: (rewrite "authentication_by_rank" + ("rho" "rho_last"))
Found matching substitution:
R: setof[event] gets R_last,
T: setof[event] gets T,
users: [Identity -> process[event]] gets USER,
rho: setof[Message] gets rho_last,
member rewrites member(x, INIT)
  to INIT(x)
member rewrites member(x, rho_last)
  to rho_last(x)
subset? rewrites subset?(INIT, rho_last)
  to FORALL (x: Message): INIT(x) => rho_last(x)
member rewrites member(x, S)
  to S(x)
member rewrites member(x, rho_last)
  to rho_last(x)
subset? rewrites subset?(S, rho_last)
  to FORALL (x: Message): S(x) => rho_last(x)
Rewriting using authentication_by_rank, matching in + where
  rho gets rho_last,
this yields  4 subgoals: 
authentication_last.1 :  

  |-------
{1}   FORALL (x: Message): INIT(x) => rho_last(x)
[2]   network(USER) |> auth(T, R_last)

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_last.1 :  

  |-------
[1]   FORALL (x: Message): INIT(x) => rho_last(x)

Rerunning step: (comment "intruder's initial knowledge is in rho")
Adding comment: intruder's initial knowledge is in rho
this simplifies to: 
authentication_last.1 : 
;;; intruder's initial knowledge is in rho

  |-------
[1]   FORALL (x: Message): INIT(x) => rho_last(x)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_last.1 : 
;;; intruder's initial knowledge is in rho

  |-------
{1}   INIT(x!1) => rho_last(x!1)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_last.1 : 
;;; intruder's initial knowledge is in rho

{-1}  INIT(x!1)
  |-------
{1}   rho_last(x!1)

Rerunning step: (expand "INIT")
Expanding the definition of INIT,
this simplifies to: 
authentication_last.1 : 
;;; intruder's initial knowledge is in rho

{-1}  CASES x!1
        OF user(z): TRUE,
           nonce(z): z /= n_init,
           public(z): TRUE,
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i))
        ELSE FALSE
        ENDCASES
  |-------
[1]   rho_last(x!1)

Rerunning step: (expand "rho_last")
Expanding the definition of rho_last,
this simplifies to: 
authentication_last.1 : 
;;; intruder's initial knowledge is in rho

[-1]  CASES x!1
        OF user(z): TRUE,
           nonce(z): z /= n_init,
           public(z): TRUE,
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i))
        ELSE FALSE
        ENDCASES
  |-------
{1}   CASES x!1
        OF nonce(z): z /= n_init,
           nlist(z): NOT elt(z, n_init),
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i)),
           conc(z1, z2): rho_last(z1) AND rho_last(z2),
           commit(z1, z2, z3): z1 /= 0 OR z2 /= hu_list OR z3 /= n_init,
           code(z1, z2):
             rho_last(z2) OR
              (EXISTS (i: {x: nat | 0 < x AND x < p}):
                 z1 = public(hu(i)) AND
                  (EXISTS (l: {x: list[Nonce] | length(x) = i - 1}):
                     z2 =
                      conc(nlist(cons(n_init, l)),
                           ilist(remove(hu_list, i)))))
        ELSE TRUE
        ENDCASES

Rerunning step: (smash)
Repeatedly simplifying with BDDs, decision procedures, rewriting,
and if-lifting,

This completes the proof of authentication_last.1.

authentication_last.2 :  

  |-------
{1}   FORALL (S: setof[Message]), (m: Message):
        (FORALL (x: Message): S(x) => rho_last(x)) AND (S |- m) IMPLIES
         rho_last(m)
[2]   network(USER) |> auth(T, R_last)

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_last.2 :  

  |-------
[1]   FORALL (S: setof[Message]), (m: Message):
        (FORALL (x: Message): S(x) => rho_last(x)) AND (S |- m) IMPLIES
         rho_last(m)

Rerunning step: (comment "from of a set of messages in rho, no message not in rho can be generated")
Adding comment: from of a set of messages in rho, no message not in rho can be generated
this simplifies to: 
authentication_last.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   FORALL (S: setof[Message]), (m: Message):
        (FORALL (x: Message): S(x) => rho_last(x)) AND (S |- m) IMPLIES
         rho_last(m)

Rerunning step: (expand "|-")
Expanding the definition of |-,
this simplifies to: 
authentication_last.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   FORALL (S: setof[Message]), (m: Message):
        (FORALL (x: Message): S(x) => rho_last(x)) AND Gen(S, m) IMPLIES
         rho_last(m)

Rerunning step: (rule-induct "Gen")
Applying rule (co)induction over Gen,
this simplifies to: 
authentication_last.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  FORALL (x: Message): S!1(x) => rho_last(x)
  |-------
{1}   FORALL (m: Message):
        (     S!1(m)
          OR (EXISTS m1, m2:
                rho_last(m1) AND rho_last(m2) AND m = conc(m1, m2))
          OR (EXISTS m1: rho_last(conc(m1, m)))
          OR (EXISTS m2: rho_last(conc(m, m2)))
          OR (EXISTS (n: Nonce): rho_last(nonce(n)) AND m = nlist((: n :)))
          OR (EXISTS (n: Nonce): rho_last(nlist((: n :))) AND m = nonce(n))
          OR (EXISTS (nl1, nl2: list[Nonce]):
                rho_last(nlist(nl1)) AND
                 rho_last(nlist(nl2)) AND m = nlist(append(nl1, nl2)))
          OR (EXISTS (nl, nl1, nl2: list[Nonce]):
                rho_last(nlist(nl)) AND
                 nl = append(nl1, nl2) AND m = nlist(nl1))
          OR (EXISTS (nl, nl1, nl2: list[Nonce]):
                rho_last(nlist(nl)) AND
                 nl = append(nl1, nl2) AND m = nlist(nl2))
          OR (EXISTS (i: Identity):
                rho_last(user(i)) AND m = ilist((: i :)))
          OR (EXISTS (i: Identity):
                rho_last(ilist((: i :))) AND m = user(i))
          OR (EXISTS (il1, il2: list[Identity]):
                rho_last(ilist(il1)) AND
                 rho_last(ilist(il2)) AND m = ilist(append(il1, il2)))
          OR (EXISTS (il, il1, il2: list[Identity]):
                rho_last(ilist(il)) AND
                 il = append(il1, il2) AND m = ilist(il1))
          OR (EXISTS (il, il1, il2: list[Identity]):
                rho_last(ilist(il)) AND
                 il = append(il1, il2) AND m = ilist(il2))
          OR EXISTS m1, k: rho_last(m1) AND rho_last(k) AND m = E(k, m1))
         IMPLIES rho_last(m)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_last.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  FORALL (x: Message): S!1(x) => rho_last(x)
  |-------
{1}   (     S!1(m!2)
        OR (EXISTS m1, m2:
              rho_last(m1) AND rho_last(m2) AND m!2 = conc(m1, m2))
        OR (EXISTS m1: rho_last(conc(m1, m!2)))
        OR (EXISTS m2: rho_last(conc(m!2, m2)))
        OR (EXISTS (n: Nonce): rho_last(nonce(n)) AND m!2 = nlist((: n :)))
        OR (EXISTS (n: Nonce): rho_last(nlist((: n :))) AND m!2 = nonce(n))
        OR (EXISTS (nl1, nl2: list[Nonce]):
              rho_last(nlist(nl1)) AND
               rho_last(nlist(nl2)) AND m!2 = nlist(append(nl1, nl2)))
        OR (EXISTS (nl, nl1, nl2: list[Nonce]):
              rho_last(nlist(nl)) AND
               nl = append(nl1, nl2) AND m!2 = nlist(nl1))
        OR (EXISTS (nl, nl1, nl2: list[Nonce]):
              rho_last(nlist(nl)) AND
               nl = append(nl1, nl2) AND m!2 = nlist(nl2))
        OR (EXISTS (i: Identity):
              rho_last(user(i)) AND m!2 = ilist((: i :)))
        OR (EXISTS (i: Identity):
              rho_last(ilist((: i :))) AND m!2 = user(i))
        OR (EXISTS (il1, il2: list[Identity]):
              rho_last(ilist(il1)) AND
               rho_last(ilist(il2)) AND m!2 = ilist(append(il1, il2)))
        OR (EXISTS (il, il1, il2: list[Identity]):
              rho_last(ilist(il)) AND
               il = append(il1, il2) AND m!2 = ilist(il1))
        OR (EXISTS (il, il1, il2: list[Identity]):
              rho_last(ilist(il)) AND
               il = append(il1, il2) AND m!2 = ilist(il2))
        OR EXISTS m1, k: rho_last(m1) AND rho_last(k) AND m!2 = E(k, m1))
       IMPLIES rho_last(m!2)

Rerunning step: (smash)
Repeatedly simplifying with BDDs, decision procedures, rewriting,
and if-lifting,
this yields  15 subgoals: 
authentication_last.2.1 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  S!1(m!2)
[-2]  FORALL (x: Message): S!1(x) => rho_last(x)
  |-------
{1}   rho_last(m!2)

Rerunning step: (inst -2 "m!2")
Instantiating the top quantifier in -2 with the terms: 
 m!2,
this simplifies to: 
authentication_last.2.1 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  S!1(m!2)
{-2}  S!1(m!2) => rho_last(m!2)
  |-------
[1]   rho_last(m!2)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_last.2.1.

authentication_last.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS m1, m2: rho_last(m1) AND rho_last(m2) AND m!2 = conc(m1, m2)
[-2]  FORALL (x: Message): S!1(x) => rho_last(x)
  |-------
{1}   rho_last(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_last.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS m1, m2: rho_last(m1) AND rho_last(m2) AND m!2 = conc(m1, m2)
  |-------
[1]   rho_last(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_last.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(m1!1) AND rho_last(m2!1) AND m!2 = conc(m1!1, m2!1)
  |-------
[1]   rho_last(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_last.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(m1!1)
{-2}  rho_last(m2!1)
{-3}  m!2 = conc(m1!1, m2!1)
  |-------
[1]   rho_last(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_last.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_last(m1!1)
[-2]  rho_last(m2!1)
[-3]  m!2 = conc(m1!1, m2!1)
  |-------
{1}   rho_last(conc(m1!1, m2!1))

Rerunning step: (expand "rho_last" 1)
Expanding the definition of rho_last,
this simplifies to: 
authentication_last.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_last(m1!1)
[-2]  rho_last(m2!1)
[-3]  m!2 = conc(m1!1, m2!1)
  |-------
{1}   rho_last(m1!1) AND rho_last(m2!1)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_last.2.2.

authentication_last.2.3 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS m1: rho_last(conc(m1, m!2))
[-2]  FORALL (x: Message): S!1(x) => rho_last(x)
  |-------
{1}   rho_last(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_last.2.3 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS m1: rho_last(conc(m1, m!2))
  |-------
[1]   rho_last(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_last.2.3 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(conc(m1!1, m!2))
  |-------
[1]   rho_last(m!2)

Rerunning step: (expand "rho_last" -1)
Expanding the definition of rho_last,
this simplifies to: 
authentication_last.2.3 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  FALSE
  |-------
[1]   rho_last(m!2)

which is trivially true.

This completes the proof of authentication_last.2.3.

authentication_last.2.4 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS m2: rho_last(conc(m!2, m2))
[-2]  FORALL (x: Message): S!1(x) => rho_last(x)
  |-------
{1}   rho_last(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_last.2.4 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS m2: rho_last(conc(m!2, m2))
  |-------
[1]   rho_last(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_last.2.4 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(conc(m!2, m2!1))
  |-------
[1]   rho_last(m!2)

Rerunning step: (expand "rho_last" -1)
Expanding the definition of rho_last,
this simplifies to: 
authentication_last.2.4 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  FALSE
  |-------
[1]   rho_last(m!2)

which is trivially true.

This completes the proof of authentication_last.2.4.

authentication_last.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (n: Nonce): rho_last(nonce(n)) AND m!2 = nlist((: n :))
[-2]  FORALL (x: Message): S!1(x) => rho_last(x)
  |-------
{1}   rho_last(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_last.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (n: Nonce): rho_last(nonce(n)) AND m!2 = nlist((: n :))
  |-------
[1]   rho_last(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_last.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(nonce(n!1)) AND m!2 = nlist((: n!1 :))
  |-------
[1]   rho_last(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_last.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(nonce(n!1))
{-2}  m!2 = nlist((: n!1 :))
  |-------
[1]   rho_last(m!2)

Rerunning step: (expand "rho_last" -1)
Expanding the definition of rho_last,
this simplifies to: 
authentication_last.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  n!1 /= n_init
[-2]  m!2 = nlist((: n!1 :))
  |-------
[1]   rho_last(m!2)

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
authentication_last.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  n!1 /= n_init
[-2]  m!2 = nlist((: n!1 :))
  |-------
{1}   rho_last(nlist((: n!1 :)))

Rerunning step: (expand "rho_last")
Expanding the definition of rho_last,
this simplifies to: 
authentication_last.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  n!1 /= n_init
[-2]  m!2 = nlist((: n!1 :))
{-3}  elt((: n!1 :), n_init)
  |-------

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_last.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  n!1 /= n_init
[-2]  elt((: n!1 :), n_init)
  |-------

Rerunning step: (grind)
/= rewrites n!1 /= n_init
  to NOT (n!1 = n_init)
elt rewrites elt((: n!1 :), n_init)
  to EXISTS (i: below[length((: n!1 :))]): nth((: n!1 :), i) = n_init
length rewrites length((: :))
  to 0
length rewrites length((: n!1 :))
  to 1
nth rewrites nth((: n!1 :), i!1)
  to n!1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_last.2.5.

authentication_last.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (n: Nonce): rho_last(nlist((: n :))) AND m!2 = nonce(n)
[-2]  FORALL (x: Message): S!1(x) => rho_last(x)
  |-------
{1}   rho_last(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_last.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (n: Nonce): rho_last(nlist((: n :))) AND m!2 = nonce(n)
  |-------
[1]   rho_last(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_last.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(nlist((: n!1 :))) AND m!2 = nonce(n!1)
  |-------
[1]   rho_last(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_last.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(nlist((: n!1 :)))
{-2}  m!2 = nonce(n!1)
  |-------
[1]   rho_last(m!2)

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
authentication_last.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_last(nlist((: n!1 :)))
[-2]  m!2 = nonce(n!1)
  |-------
{1}   rho_last(nonce(n!1))

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_last.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_last(nlist((: n!1 :)))
  |-------
[1]   rho_last(nonce(n!1))

Rerunning step: (expand "rho_last")
Expanding the definition of rho_last,
this simplifies to: 
authentication_last.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   elt((: n!1 :), n_init)
{2}   n!1 /= n_init

Rerunning step: (expand "elt")
Expanding the definition of elt,
this simplifies to: 
authentication_last.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   EXISTS (i: below[length((: n!1 :))]): nth((: n!1 :), i) = n_init
[2]   n!1 /= n_init

Rerunning step: (inst 1 "0")
Instantiating the top quantifier in 1 with the terms: 
 0,
this yields  2 subgoals: 
authentication_last.2.6.1 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   nth((: n!1 :), 0) = n_init
[2]   n!1 /= n_init

Rerunning step: (grind :exclude 2)
nth rewrites nth((: n!1 :), 0)
  to n!1
/= rewrites n!1 /= n_init
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_last.2.6.1.

authentication_last.2.6.2 (TCC):   

  |-------
{1}   0 < length[Nonce]((: n!1 :))
[2]   n!1 /= n_init

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_last.2.6.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   0 < length[Nonce]((: n!1 :))

Rerunning step: (grind)
length rewrites length((: :))
  to 0
length rewrites length[Nonce]((: n!1 :))
  to 1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_last.2.6.2.


This completes the proof of authentication_last.2.6.

authentication_last.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (nl1, nl2: list[Nonce]):
        rho_last(nlist(nl1)) AND
         rho_last(nlist(nl2)) AND m!2 = nlist(append(nl1, nl2))
[-2]  FORALL (x: Message): S!1(x) => rho_last(x)
  |-------
{1}   rho_last(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_last.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (nl1, nl2: list[Nonce]):
        rho_last(nlist(nl1)) AND
         rho_last(nlist(nl2)) AND m!2 = nlist(append(nl1, nl2))
  |-------
[1]   rho_last(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_last.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(nlist(nl1!1)) AND
       rho_last(nlist(nl2!1)) AND m!2 = nlist(append(nl1!1, nl2!1))
  |-------
[1]   rho_last(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_last.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(nlist(nl1!1))
{-2}  rho_last(nlist(nl2!1))
{-3}  m!2 = nlist(append(nl1!1, nl2!1))
  |-------
[1]   rho_last(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_last.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_last(nlist(nl1!1))
[-2]  rho_last(nlist(nl2!1))
[-3]  m!2 = nlist(append(nl1!1, nl2!1))
  |-------
{1}   rho_last(nlist(append(nl1!1, nl2!1)))

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
authentication_last.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_last(nlist(nl1!1))
[-2]  rho_last(nlist(nl2!1))
  |-------
[1]   rho_last(nlist(append(nl1!1, nl2!1)))

Rerunning step: (expand "rho_last")
Expanding the definition of rho_last,
this simplifies to: 
authentication_last.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(append(nl1!1, nl2!1), n_init)
  |-------
{1}   elt(nl1!1, n_init)
{2}   elt(nl2!1, n_init)

Rerunning step: (lemma "listprops[Nonce].elt_append3"
                 ("l1" "nl1!1" "l2" "nl2!1" "t" "n_init"))
Applying listprops[Nonce].elt_append3 where 
  l1 gets nl1!1,
  l2 gets nl2!1,
  t gets n_init,
this simplifies to: 
authentication_last.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(append(nl1!1, nl2!1), n_init) IMPLIES
       elt(nl1!1, n_init) OR elt(nl2!1, n_init)
[-2]  elt(append(nl1!1, nl2!1), n_init)
  |-------
[1]   elt(nl1!1, n_init)
[2]   elt(nl2!1, n_init)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_last.2.7.

authentication_last.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (nl, nl1, nl2: list[Nonce]):
        rho_last(nlist(nl)) AND nl = append(nl1, nl2) AND m!2 = nlist(nl1)
[-2]  FORALL (x: Message): S!1(x) => rho_last(x)
  |-------
{1}   rho_last(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_last.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (nl, nl1, nl2: list[Nonce]):
        rho_last(nlist(nl)) AND nl = append(nl1, nl2) AND m!2 = nlist(nl1)
  |-------
[1]   rho_last(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_last.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(nlist(nl!1)) AND
       nl!1 = append(nl1!1, nl2!1) AND m!2 = nlist(nl1!1)
  |-------
[1]   rho_last(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_last.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(nlist(nl!1))
{-2}  nl!1 = append(nl1!1, nl2!1)
{-3}  m!2 = nlist(nl1!1)
  |-------
[1]   rho_last(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_last.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_last(nlist(nl!1))
[-2]  nl!1 = append(nl1!1, nl2!1)
[-3]  m!2 = nlist(nl1!1)
  |-------
{1}   rho_last(nlist(nl1!1))

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
authentication_last.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_last(nlist(nl!1))
[-2]  nl!1 = append(nl1!1, nl2!1)
  |-------
[1]   rho_last(nlist(nl1!1))

Rerunning step: (replace -2 -1)
Replacing using formula -2,
this simplifies to: 
authentication_last.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(nlist(append(nl1!1, nl2!1)))
[-2]  nl!1 = append(nl1!1, nl2!1)
  |-------
[1]   rho_last(nlist(nl1!1))

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_last.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_last(nlist(append(nl1!1, nl2!1)))
  |-------
[1]   rho_last(nlist(nl1!1))

Rerunning step: (expand "rho_last")
Expanding the definition of rho_last,
this simplifies to: 
authentication_last.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(nl1!1, n_init)
  |-------
{1}   elt(append(nl1!1, nl2!1), n_init)

Rerunning step: (lemma "listprops[Nonce].elt_append1"
                 ("l1" "nl1!1" "l2" "nl2!1" "t" "n_init"))
Applying listprops[Nonce].elt_append1 where 
  l1 gets nl1!1,
  l2 gets nl2!1,
  t gets n_init,
this simplifies to: 
authentication_last.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(nl1!1, n_init) IMPLIES elt(append(nl1!1, nl2!1), n_init)
[-2]  elt(nl1!1, n_init)
  |-------
[1]   elt(append(nl1!1, nl2!1), n_init)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_last.2.8.

authentication_last.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (nl, nl1, nl2: list[Nonce]):
        rho_last(nlist(nl)) AND nl = append(nl1, nl2) AND m!2 = nlist(nl2)
[-2]  FORALL (x: Message): S!1(x) => rho_last(x)
  |-------
{1}   rho_last(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_last.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (nl, nl1, nl2: list[Nonce]):
        rho_last(nlist(nl)) AND nl = append(nl1, nl2) AND m!2 = nlist(nl2)
  |-------
[1]   rho_last(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_last.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(nlist(nl!1)) AND
       nl!1 = append(nl1!1, nl2!1) AND m!2 = nlist(nl2!1)
  |-------
[1]   rho_last(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_last.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(nlist(nl!1))
{-2}  nl!1 = append(nl1!1, nl2!1)
{-3}  m!2 = nlist(nl2!1)
  |-------
[1]   rho_last(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_last.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_last(nlist(nl!1))
[-2]  nl!1 = append(nl1!1, nl2!1)
[-3]  m!2 = nlist(nl2!1)
  |-------
{1}   rho_last(nlist(nl2!1))

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
authentication_last.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_last(nlist(nl!1))
[-2]  nl!1 = append(nl1!1, nl2!1)
  |-------
[1]   rho_last(nlist(nl2!1))

Rerunning step: (replace -2 -1)
Replacing using formula -2,
this simplifies to: 
authentication_last.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(nlist(append(nl1!1, nl2!1)))
[-2]  nl!1 = append(nl1!1, nl2!1)
  |-------
[1]   rho_last(nlist(nl2!1))

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_last.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_last(nlist(append(nl1!1, nl2!1)))
  |-------
[1]   rho_last(nlist(nl2!1))

Rerunning step: (expand "rho_last")
Expanding the definition of rho_last,
this simplifies to: 
authentication_last.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(nl2!1, n_init)
  |-------
{1}   elt(append(nl1!1, nl2!1), n_init)

Rerunning step: (lemma "listprops[Nonce].elt_append2"
                 ("l1" "nl1!1" "l2" "nl2!1" "t" "n_init"))
Applying listprops[Nonce].elt_append2 where 
  l1 gets nl1!1,
  l2 gets nl2!1,
  t gets n_init,
this simplifies to: 
authentication_last.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(nl2!1, n_init) IMPLIES elt(append(nl1!1, nl2!1), n_init)
[-2]  elt(nl2!1, n_init)
  |-------
[1]   elt(append(nl1!1, nl2!1), n_init)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_last.2.9.

authentication_last.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (i: Identity): rho_last(user(i)) AND m!2 = ilist((: i :))
[-2]  FORALL (x: Message): S!1(x) => rho_last(x)
  |-------
{1}   rho_last(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_last.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (i: Identity): rho_last(user(i)) AND m!2 = ilist((: i :))
  |-------
[1]   rho_last(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_last.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(user(i!1)) AND m!2 = ilist((: i!1 :))
  |-------
[1]   rho_last(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_last.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(user(i!1))
{-2}  m!2 = ilist((: i!1 :))
  |-------
[1]   rho_last(m!2)

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
authentication_last.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_last(user(i!1))
[-2]  m!2 = ilist((: i!1 :))
  |-------
{1}   rho_last(ilist((: i!1 :)))

Rerunning step: (delete -1 -2)
Deleting some formulas,
this simplifies to: 
authentication_last.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   rho_last(ilist((: i!1 :)))

Rerunning step: (expand "rho_last")
Expanding the definition of rho_last,
this simplifies to: 
authentication_last.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_last.2.10.

authentication_last.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (i: Identity): rho_last(ilist((: i :))) AND m!2 = user(i)
[-2]  FORALL (x: Message): S!1(x) => rho_last(x)
  |-------
{1}   rho_last(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_last.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (i: Identity): rho_last(ilist((: i :))) AND m!2 = user(i)
  |-------
[1]   rho_last(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_last.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(ilist((: i!1 :))) AND m!2 = user(i!1)
  |-------
[1]   rho_last(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_last.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(ilist((: i!1 :)))
{-2}  m!2 = user(i!1)
  |-------
[1]   rho_last(m!2)

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
authentication_last.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_last(ilist((: i!1 :)))
[-2]  m!2 = user(i!1)
  |-------
{1}   rho_last(user(i!1))

Rerunning step: (delete -1 -2)
Deleting some formulas,
this simplifies to: 
authentication_last.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   rho_last(user(i!1))

Rerunning step: (expand "rho_last")
Expanding the definition of rho_last,
this simplifies to: 
authentication_last.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_last.2.11.

authentication_last.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (il1, il2: list[Identity]):
        rho_last(ilist(il1)) AND
         rho_last(ilist(il2)) AND m!2 = ilist(append(il1, il2))
[-2]  FORALL (x: Message): S!1(x) => rho_last(x)
  |-------
{1}   rho_last(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_last.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (il1, il2: list[Identity]):
        rho_last(ilist(il1)) AND
         rho_last(ilist(il2)) AND m!2 = ilist(append(il1, il2))
  |-------
[1]   rho_last(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_last.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(ilist(il1!1)) AND
       rho_last(ilist(il2!1)) AND m!2 = ilist(append(il1!1, il2!1))
  |-------
[1]   rho_last(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_last.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(ilist(il1!1))
{-2}  rho_last(ilist(il2!1))
{-3}  m!2 = ilist(append(il1!1, il2!1))
  |-------
[1]   rho_last(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_last.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_last(ilist(il1!1))
[-2]  rho_last(ilist(il2!1))
[-3]  m!2 = ilist(append(il1!1, il2!1))
  |-------
{1}   rho_last(ilist(append(il1!1, il2!1)))

Rerunning step: (delete -1 -2 -3)
Deleting some formulas,
this simplifies to: 
authentication_last.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   rho_last(ilist(append(il1!1, il2!1)))

Rerunning step: (expand "rho_last")
Expanding the definition of rho_last,
this simplifies to: 
authentication_last.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_last.2.12.

authentication_last.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (il, il1, il2: list[Identity]):
        rho_last(ilist(il)) AND il = append(il1, il2) AND m!2 = ilist(il1)
[-2]  FORALL (x: Message): S!1(x) => rho_last(x)
  |-------
{1}   rho_last(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_last.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (il, il1, il2: list[Identity]):
        rho_last(ilist(il)) AND il = append(il1, il2) AND m!2 = ilist(il1)
  |-------
[1]   rho_last(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_last.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(ilist(il!1)) AND
       il!1 = append(il1!1, il2!1) AND m!2 = ilist(il1!1)
  |-------
[1]   rho_last(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_last.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(ilist(il!1))
{-2}  il!1 = append(il1!1, il2!1)
{-3}  m!2 = ilist(il1!1)
  |-------
[1]   rho_last(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_last.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_last(ilist(il!1))
[-2]  il!1 = append(il1!1, il2!1)
[-3]  m!2 = ilist(il1!1)
  |-------
{1}   rho_last(ilist(il1!1))

Rerunning step: (delete -1 -2 -3)
Deleting some formulas,
this simplifies to: 
authentication_last.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   rho_last(ilist(il1!1))

Rerunning step: (expand "rho_last")
Expanding the definition of rho_last,
this simplifies to: 
authentication_last.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_last.2.13.

authentication_last.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (il, il1, il2: list[Identity]):
        rho_last(ilist(il)) AND il = append(il1, il2) AND m!2 = ilist(il2)
[-2]  FORALL (x: Message): S!1(x) => rho_last(x)
  |-------
{1}   rho_last(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_last.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (il, il1, il2: list[Identity]):
        rho_last(ilist(il)) AND il = append(il1, il2) AND m!2 = ilist(il2)
  |-------
[1]   rho_last(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_last.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(ilist(il!1)) AND
       il!1 = append(il1!1, il2!1) AND m!2 = ilist(il2!1)
  |-------
[1]   rho_last(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_last.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(ilist(il!1))
{-2}  il!1 = append(il1!1, il2!1)
{-3}  m!2 = ilist(il2!1)
  |-------
[1]   rho_last(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_last.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_last(ilist(il!1))
[-2]  il!1 = append(il1!1, il2!1)
[-3]  m!2 = ilist(il2!1)
  |-------
{1}   rho_last(ilist(il2!1))

Rerunning step: (delete -1 -2 -3)
Deleting some formulas,
this simplifies to: 
authentication_last.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   rho_last(ilist(il2!1))

Rerunning step: (expand "rho_last")
Expanding the definition of rho_last,
this simplifies to: 
authentication_last.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_last.2.14.

authentication_last.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS m1, k: rho_last(m1) AND rho_last(k) AND m!2 = E(k, m1)
[-2]  FORALL (x: Message): S!1(x) => rho_last(x)
  |-------
{1}   rho_last(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_last.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS m1, k: rho_last(m1) AND rho_last(k) AND m!2 = E(k, m1)
  |-------
[1]   rho_last(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_last.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(m1!1) AND rho_last(k!1) AND m!2 = E(k!1, m1!1)
  |-------
[1]   rho_last(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_last.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_last(m1!1)
{-2}  rho_last(k!1)
{-3}  m!2 = E(k!1, m1!1)
  |-------
[1]   rho_last(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_last.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_last(m1!1)
[-2]  rho_last(k!1)
[-3]  m!2 = E(k!1, m1!1)
  |-------
{1}   rho_last(E(k!1, m1!1))

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
authentication_last.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_last(m1!1)
[-2]  rho_last(k!1)
  |-------
[1]   rho_last(E(k!1, m1!1))

Rerunning step: (typepred "k!1")
Adding type constraints for  k!1,
this simplifies to: 
authentication_last.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  public?(k!1) OR secret?(k!1)
[-2]  rho_last(m1!1)
[-3]  rho_last(k!1)
  |-------
[1]   rho_last(E(k!1, m1!1))

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
authentication_last.2.15.1 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  public?(k!1)
[-2]  rho_last(m1!1)
[-3]  rho_last(k!1)
  |-------
[1]   rho_last(E(k!1, m1!1))

Rerunning step: (grind)
rho_last rewrites rho_last(k!1)
  to TRUE
E rewrites E(k!1, m1!1)
  to CASES m1!1
        OF code(k1, m1):
             CASES k1
               OF public(i):
                    IF k!1 = secret(i) THEN m1 ELSE code(k!1, m1!1) ENDIF,
                  secret(i):
                    IF k!1 = public(i) THEN m1 ELSE code(k!1, m1!1) ENDIF
               ENDCASES
        ELSE code(k!1, m1!1)
        ENDCASES
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_last rewrites rho_last(code(k!1, m1!1))
  to TRUE
rho_last rewrites rho_last(public(x_secret(x_code(m1!1))))
  to TRUE
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_last rewrites rho_last(m1!1)
  to FALSE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_last.2.15.1.

authentication_last.2.15.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  secret?(k!1)
[-2]  rho_last(m1!1)
[-3]  rho_last(k!1)
  |-------
[1]   rho_last(E(k!1, m1!1))

Rerunning step: (expand "rho_last" -3)
Expanding the definition of rho_last,
this simplifies to: 
authentication_last.2.15.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  secret?(k!1)
[-2]  rho_last(m1!1)
{-3}  CASES k!1
        OF nonce(z): z /= n_init,
           nlist(z): NOT elt(z, n_init),
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i)),
           conc(z1, z2): rho_last(z1) AND rho_last(z2),
           commit(z1, z2, z3): z1 /= 0 OR z2 /= hu_list OR z3 /= n_init,
           code(z1, z2):
             rho_last(z2) OR
              (EXISTS (i: {x: nat | 0 < x AND x < p}):
                 z1 = public(hu(i)) AND
                  (EXISTS (l: {x: list[Nonce] | length(x) = i - 1}):
                     z2 =
                      conc(nlist(cons(n_init, l)),
                           ilist(remove(hu_list, i)))))
        ELSE TRUE
        ENDCASES
  |-------
[1]   rho_last(E(k!1, m1!1))

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
authentication_last.2.15.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  secret?(k!1)
[-2]  rho_last(m1!1)
  |-------
{1}   EXISTS (i: nat_to_p): x_secret(k!1) = hu(i)
[2]   rho_last(E(k!1, m1!1))

Rerunning step: (lazy-grind)
E rewrites E(k!1, m1!1)
  to CASES m1!1
        OF code(k1, m1):
             CASES k1
               OF public(i):
                    IF k!1 = secret(i) THEN m1 ELSE code(k!1, m1!1) ENDIF,
                  secret(i):
                    IF k!1 = public(i) THEN m1 ELSE code(k!1, m1!1) ENDIF
               ENDCASES
        ELSE code(k!1, m1!1)
        ENDCASES
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_last rewrites rho_last(code(k!1, m1!1))
  to TRUE
remove rewrites remove(hu_list, i)
  to cons(car(hu_list), remove(cdr(hu_list), i - 1))
rho_last rewrites rho_last(m1!1)
  to EXISTS (i: {x: nat | 0 < x AND x < p}):
        x_code(m1!1) = public(hu(i)) AND
         EXISTS (l: {x: list[Nonce] | length(x) = i - 1}):
           y_code(m1!1) =
            conc(nlist(cons(n_init, l)),
                 ilist(cons(car(hu_list), remove(cdr(hu_list), i - 1))))
elt rewrites elt(cons(n_init, l!1), n_init)
  to EXISTS (i: below[length(cons(n_init, l!1))]):
        nth(cons(n_init, l!1), i) = n_init
rho_last rewrites rho_last(nlist(cons(n_init, l!1)))
  to NOT EXISTS (i: below[length(cons(n_init, l!1))]):
            nth(cons(n_init, l!1), i) = n_init
rho_last rewrites 
  rho_last(ilist(cons(car(hu_list), remove(cdr(hu_list), i!1 - 1))))
  to TRUE
rho_last rewrites 
  rho_last(conc(nlist(cons(n_init, l!1)),
                ilist(cons(car(hu_list), remove(cdr(hu_list), i!1 - 1)))))
  to NOT EXISTS (i: below[length(cons(n_init, l!1))]):
            nth(cons(n_init, l!1), i) = n_init
length rewrites length(cons(n_init, l!1))
  to 1 + length(l!1)
By skolemization, if-lifting, simplification and instantiation,

This completes the proof of authentication_last.2.15.2.


This completes the proof of authentication_last.2.15.


This completes the proof of authentication_last.2.

authentication_last.3 :  

  |-------
{1}   FORALL (i: Identity): USER(i) # R_last |> RankUser(rho_last)
[2]   network(USER) |> auth(T, R_last)

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_last.3 :  

  |-------
[1]   FORALL (i: Identity): USER(i) # R_last |> RankUser(rho_last)

Rerunning step: (comment "users maintain the rank function")
Adding comment: users maintain the rank function
this simplifies to: 
authentication_last.3 : 
;;; users maintain the rank function

  |-------
[1]   FORALL (i: Identity): USER(i) # R_last |> RankUser(rho_last)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_last.3 : 
;;; users maintain the rank function

  |-------
{1}   USER(i!1) # R_last |> RankUser(rho_last)

Rerunning step: (expand "USER")
Expanding the definition of USER,
this simplifies to: 
authentication_last.3 : 
;;; users maintain the rank function

  |-------
{1}   (Interleave! (P: nat_from_2):
         (Interleave! (nn0: Nonces(P, i!1, 0)): UROLE_INIT(P, i!1, nn0)) //
          (Interleave! (nnP: Nonces(P, i!1, P - 1)):
             UROLE_LAST(P, i!1, nnP))
          //
          IF P = 2 THEN Stop[event]
          ELSE (Interleave! (j: nat_1_to(P), nnJ: Nonces(P, i!1, j)):
                  UROLE_MIDDLE(P, j, i!1, nnJ))
          ENDIF)
       # R_last
       |> RankUser(rho_last)

Rerunning step: (expand "RankUser")
Expanding the definition of RankUser,
this simplifies to: 
authentication_last.3 : 
;;; users maintain the rank function

  |-------
{1}   (Interleave! (P: nat_from_2):
         (Interleave! (nn0: Nonces(P, i!1, 0)): UROLE_INIT(P, i!1, nn0)) //
          (Interleave! (nnP: Nonces(P, i!1, P - 1)):
             UROLE_LAST(P, i!1, nnP))
          //
          IF P = 2 THEN Stop[event]
          ELSE (Interleave! (j: nat_1_to(P), nnJ: Nonces(P, i!1, j)):
                  UROLE_MIDDLE(P, j, i!1, nnJ))
          ENDIF)
       # R_last
       |>
       LAMBDA (tr: list[event]):
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(tr)
          IMPLIES
          every(LAMBDA (e: event):
                  complement(rec?)(e) IMPLIES rho_last(msg(e)))
               (tr)

Rerunning step: (interleaving2)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
Applying interleaving rule,
this simplifies to: 
authentication_last.3 : 
;;; users maintain the rank function

  |-------
{1}   (Interleave! (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
       //
       (Interleave! (nnP: Nonces(i!2, i!1, i!2 - 1)):
          UROLE_LAST(i!2, i!1, nnP))
       //
       IF i!2 = 2 THEN Stop[event]
       ELSE (Interleave! (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
               UROLE_MIDDLE(i!2, j, i!1, nnJ))
       ENDIF
       # R_last
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))(t)

Rerunning step: (interleaving)
Applying interleaving rule,
this yields  2 subgoals: 
authentication_last.3.1 : 
;;; users maintain the rank function

  |-------
{1}   (((Interleave! (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
         //
         (Interleave! (nnP: Nonces(i!2, i!1, i!2 - 1)):
            UROLE_LAST(i!2, i!1, nnP))
         # R_last)
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(t) =>
           every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))
                (t))

Rerunning step: (interleaving)
Applying interleaving rule,
this yields  2 subgoals: 
authentication_last.3.1.1 : 
;;; users maintain the rank function

  |-------
{1}   (((Interleave! (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
         # R_last)
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(t) =>
           every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))
                (t))

Rerunning step: (lemma "restrictlast_init" ("P" "i!2" "u" "i!1"))
Applying restrictlast_init where 
  P gets i!2,
  u gets i!1,
this simplifies to: 
authentication_last.3.1.1 : 
;;; users maintain the rank function

{-1}  ((Interleave! (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
        # R_last)
       |> RankUser(rho_last)
  |-------
[1]   (((Interleave! (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
         # R_last)
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(t) =>
           every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))
                (t))

Rerunning step: (grind :exclude ("rho_last" "UROLE_INIT"))
Interleave rewrites 
  (Interleave! (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
  to Par(emptyset)
         (LAMBDA (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
# rewrites 
  (Par(emptyset)
      (LAMBDA (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
    # R_last)
  to Par(R_last)
         (Par(emptyset)
             (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                UROLE_INIT(i!2, i!1, nn0)),
          Stop)
Par rewrites 
  Par(R_last)
     (Par(emptyset)
         (LAMBDA (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                       UROLE_INIT(i!2, i!1, nn0)))),
             (t2: (Stop)):
        prod(R_last)(t1, t2, x)
member rewrites 
  member(x,
         Par(R_last)
            (Par(emptyset)
                (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                   UROLE_INIT(i!2, i!1, nn0)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                       UROLE_INIT(i!2, i!1, nn0)))),
             (t2: (Stop)):
        prod(R_last)(t1, t2, x)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
RankUser rewrites RankUser(rho_last)(x)
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(x) IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))(x)
member rewrites member(x, RankUser(rho_last))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(x) IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))(x)
subset? rewrites 
  subset?(Par(R_last)
             (Par(emptyset)
                 (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                    UROLE_INIT(i!2, i!1, nn0)),
              Stop),
          RankUser(rho_last))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                          UROLE_INIT(i!2, i!1, nn0)))),
                (t2: (Stop)):
           prod(R_last)(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(x)
          IMPLIES
          every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))(x)
|> rewrites 
  Par(R_last)
     (Par(emptyset)
         (LAMBDA (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0)),
      Stop)
   |> RankUser(rho_last)
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                          UROLE_INIT(i!2, i!1, nn0)))),
                (t2: (Stop)):
           prod(R_last)(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(x)
          IMPLIES
          every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))(x)
Par rewrites 
  Par(R_last)
     (Par(emptyset)
         (LAMBDA (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                       UROLE_INIT(i!2, i!1, nn0)))),
             (t2: (Stop)):
        prod(R_last)(t1, t2, x)
member rewrites 
  member(x,
         Par(R_last)
            (Par(emptyset)
                (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                   UROLE_INIT(i!2, i!1, nn0)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                       UROLE_INIT(i!2, i!1, nn0)))),
             (t2: (Stop)):
        prod(R_last)(t1, t2, x)
member rewrites 
  member(x,
         LAMBDA (t: list[event]):
           every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(t) =>
            every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))
                 (t))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(x) =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))(x)
subset? rewrites 
  subset?(Par(R_last)
             (Par(emptyset)
                 (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                    UROLE_INIT(i!2, i!1, nn0)),
              Stop),
          LAMBDA (t: list[event]):
            every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(t)
             =>
             every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))
                  (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                          UROLE_INIT(i!2, i!1, nn0)))),
                (t2: (Stop)):
           prod(R_last)(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(x) =>
          every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))(x)
|> rewrites 
  (Par(R_last)
      (Par(emptyset)
          (LAMBDA (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0)),
       Stop)
    |>
    LAMBDA (t: list[event]):
      every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(t) =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))(t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                          UROLE_INIT(i!2, i!1, nn0)))),
                (t2: (Stop)):
           prod(R_last)(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(x) =>
          every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))(x)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_last.3.1.1.

authentication_last.3.1.2 : 
;;; users maintain the rank function

  |-------
{1}   (((Interleave! (nnP: Nonces(i!2, i!1, i!2 - 1)):
           UROLE_LAST(i!2, i!1, nnP))
         # R_last)
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(t) =>
           every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))
                (t))

Rerunning step: (lemma "restrictlast_last" ("P" "i!2" "u" "i!1"))
Applying restrictlast_last where 
  P gets i!2,
  u gets i!1,
this simplifies to: 
authentication_last.3.1.2 : 
;;; users maintain the rank function

{-1}  ((Interleave! (nnP: Nonces(i!2, i!1, i!2 - 1)):
          UROLE_LAST(i!2, i!1, nnP))
        # R_last)
       |> RankUser(rho_last)
  |-------
[1]   (((Interleave! (nnP: Nonces(i!2, i!1, i!2 - 1)):
           UROLE_LAST(i!2, i!1, nnP))
         # R_last)
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(t) =>
           every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))
                (t))

Rerunning step: (grind :exclude ("rho_last" "UROLE_LAST"))
Interleave rewrites 
  (Interleave! (nnP: Nonces(i!2, i!1, i!2 - 1)): UROLE_LAST(i!2, i!1, nnP))
  to Par(emptyset)
         (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
            UROLE_LAST(i!2, i!1, nnP))
# rewrites 
  (Par(emptyset)
      (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)): UROLE_LAST(i!2, i!1, nnP))
    # R_last)
  to Par(R_last)
         (Par(emptyset)
             (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                UROLE_LAST(i!2, i!1, nnP)),
          Stop)
Par rewrites 
  Par(R_last)
     (Par(emptyset)
         (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
            UROLE_LAST(i!2, i!1, nnP)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                       UROLE_LAST(i!2, i!1, nnP)))),
             (t2: (Stop)):
        prod(R_last)(t1, t2, x)
member rewrites 
  member(x,
         Par(R_last)
            (Par(emptyset)
                (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                   UROLE_LAST(i!2, i!1, nnP)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                       UROLE_LAST(i!2, i!1, nnP)))),
             (t2: (Stop)):
        prod(R_last)(t1, t2, x)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
RankUser rewrites RankUser(rho_last)(x)
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(x) IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))(x)
member rewrites member(x, RankUser(rho_last))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(x) IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))(x)
subset? rewrites 
  subset?(Par(R_last)
             (Par(emptyset)
                 (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                    UROLE_LAST(i!2, i!1, nnP)),
              Stop),
          RankUser(rho_last))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                          UROLE_LAST(i!2, i!1, nnP)))),
                (t2: (Stop)):
           prod(R_last)(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(x)
          IMPLIES
          every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))(x)
|> rewrites 
  Par(R_last)
     (Par(emptyset)
         (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
            UROLE_LAST(i!2, i!1, nnP)),
      Stop)
   |> RankUser(rho_last)
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                          UROLE_LAST(i!2, i!1, nnP)))),
                (t2: (Stop)):
           prod(R_last)(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(x)
          IMPLIES
          every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))(x)
Par rewrites 
  Par(R_last)
     (Par(emptyset)
         (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
            UROLE_LAST(i!2, i!1, nnP)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                       UROLE_LAST(i!2, i!1, nnP)))),
             (t2: (Stop)):
        prod(R_last)(t1, t2, x)
member rewrites 
  member(x,
         Par(R_last)
            (Par(emptyset)
                (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                   UROLE_LAST(i!2, i!1, nnP)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                       UROLE_LAST(i!2, i!1, nnP)))),
             (t2: (Stop)):
        prod(R_last)(t1, t2, x)
member rewrites 
  member(x,
         LAMBDA (t: list[event]):
           every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(t) =>
            every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))
                 (t))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(x) =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))(x)
subset? rewrites 
  subset?(Par(R_last)
             (Par(emptyset)
                 (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                    UROLE_LAST(i!2, i!1, nnP)),
              Stop),
          LAMBDA (t: list[event]):
            every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(t)
             =>
             every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))
                  (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                          UROLE_LAST(i!2, i!1, nnP)))),
                (t2: (Stop)):
           prod(R_last)(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(x) =>
          every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))(x)
|> rewrites 
  (Par(R_last)
      (Par(emptyset)
          (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
             UROLE_LAST(i!2, i!1, nnP)),
       Stop)
    |>
    LAMBDA (t: list[event]):
      every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(t) =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))(t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                          UROLE_LAST(i!2, i!1, nnP)))),
                (t2: (Stop)):
           prod(R_last)(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(x) =>
          every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))(x)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_last.3.1.2.


This completes the proof of authentication_last.3.1.

authentication_last.3.2 : 
;;; users maintain the rank function

  |-------
{1}   ((IF i!2 = 2 THEN Stop[event]
        ELSE (Interleave! (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                UROLE_MIDDLE(i!2, j, i!1, nnJ))
        ENDIF
         # R_last)
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(t) =>
           every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))
                (t))

Rerunning step: (lift-if)
Lifting IF-conditions to the top level,
this simplifies to: 
authentication_last.3.2 : 
;;; users maintain the rank function

  |-------
{1}   IF i!2 = 2
        THEN ((Stop[event] # R_last) |>
               LAMBDA (t: list[event]):
                 every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))
                      (t)
                  =>
                  every(LAMBDA (e: event):
                          NOT rec?(e) IMPLIES rho_last(msg(e)))
                       (t))
      ELSE (((Interleave! (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                UROLE_MIDDLE(i!2, j, i!1, nnJ))
              # R_last)
             |>
             LAMBDA (t: list[event]):
               every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))
                    (t)
                =>
                every(LAMBDA (e: event):
                        NOT rec?(e) IMPLIES rho_last(msg(e)))
                     (t))
      ENDIF

Rerunning step: (prop)
Applying propositional simplification,
this yields  2 subgoals: 
authentication_last.3.2.1 : 
;;; users maintain the rank function

{-1}  i!2 = 2
  |-------
{1}   ((Stop[event] # R_last) |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(t) =>
           every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))
                (t))

Rerunning step: (stop)
Applying stop rule,

This completes the proof of authentication_last.3.2.1.

authentication_last.3.2.2 : 
;;; users maintain the rank function

  |-------
{1}   i!2 = 2
{2}   (((Interleave! (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
           UROLE_MIDDLE(i!2, j, i!1, nnJ))
         # R_last)
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(t) =>
           every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))
                (t))

Rerunning step: (lemma "restrictlast_middle" ("P" "i!2" "u" "i!1"))
Applying restrictlast_middle where 
  P gets i!2,
  u gets i!1,
this simplifies to: 
authentication_last.3.2.2 : 
;;; users maintain the rank function

{-1}  i!2 /= 2 =>
       (((Interleave! (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
            UROLE_MIDDLE(i!2, k, i!1, nnK))
          # R_last)
         |> RankUser(rho_last))
  |-------
[1]   i!2 = 2
[2]   (((Interleave! (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
           UROLE_MIDDLE(i!2, j, i!1, nnJ))
         # R_last)
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(t) =>
           every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))
                (t))

Rerunning step: (grind :exclude ("rho_last" "UROLE_MIDDLE"))
Interleave rewrites 
  (Interleave! (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
     UROLE_MIDDLE(i!2, k, i!1, nnK))
  to Par(emptyset)
         (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
            UROLE_MIDDLE(i!2, k, i!1, nnK))
# rewrites 
  (Par(emptyset)
      (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
         UROLE_MIDDLE(i!2, k, i!1, nnK))
    # R_last)
  to Par(R_last)
         (Par(emptyset)
             (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
                UROLE_MIDDLE(i!2, k, i!1, nnK)),
          Stop)
Par rewrites 
  Par(R_last)
     (Par(emptyset)
         (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
            UROLE_MIDDLE(i!2, k, i!1, nnK)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
                       UROLE_MIDDLE(i!2, k, i!1, nnK)))),
             (t2: (Stop)):
        prod(R_last)(t1, t2, x)
member rewrites 
  member(x,
         Par(R_last)
            (Par(emptyset)
                (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
                   UROLE_MIDDLE(i!2, k, i!1, nnK)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
                       UROLE_MIDDLE(i!2, k, i!1, nnK)))),
             (t2: (Stop)):
        prod(R_last)(t1, t2, x)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
RankUser rewrites RankUser(rho_last)(x)
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(x) IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))(x)
member rewrites member(x, RankUser(rho_last))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(x) IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))(x)
subset? rewrites 
  subset?(Par(R_last)
             (Par(emptyset)
                 (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
                    UROLE_MIDDLE(i!2, k, i!1, nnK)),
              Stop),
          RankUser(rho_last))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (k: nat_1_to(i!2),
                                nnK: Nonces(i!2, i!1, k)):
                          UROLE_MIDDLE(i!2, k, i!1, nnK)))),
                (t2: (Stop)):
           prod(R_last)(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(x)
          IMPLIES
          every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))(x)
|> rewrites 
  (Par(R_last)
      (Par(emptyset)
          (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
             UROLE_MIDDLE(i!2, k, i!1, nnK)),
       Stop)
    |> RankUser(rho_last))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (k: nat_1_to(i!2),
                                nnK: Nonces(i!2, i!1, k)):
                          UROLE_MIDDLE(i!2, k, i!1, nnK)))),
                (t2: (Stop)):
           prod(R_last)(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(x)
          IMPLIES
          every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))(x)
Par rewrites 
  Par(R_last)
     (Par(emptyset)
         (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
            UROLE_MIDDLE(i!2, k, i!1, nnK)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
                       UROLE_MIDDLE(i!2, k, i!1, nnK)))),
             (t2: (Stop)):
        prod(R_last)(t1, t2, x)
member rewrites 
  member(x,
         Par(R_last)
            (Par(emptyset)
                (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
                   UROLE_MIDDLE(i!2, k, i!1, nnK)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
                       UROLE_MIDDLE(i!2, k, i!1, nnK)))),
             (t2: (Stop)):
        prod(R_last)(t1, t2, x)
member rewrites 
  member(x,
         LAMBDA (t: list[event]):
           every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(t) =>
            every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))
                 (t))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(x) =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))(x)
subset? rewrites 
  subset?(Par(R_last)
             (Par(emptyset)
                 (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
                    UROLE_MIDDLE(i!2, k, i!1, nnK)),
              Stop),
          LAMBDA (t: list[event]):
            every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(t)
             =>
             every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))
                  (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (k: nat_1_to(i!2),
                                nnK: Nonces(i!2, i!1, k)):
                          UROLE_MIDDLE(i!2, k, i!1, nnK)))),
                (t2: (Stop)):
           prod(R_last)(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(x) =>
          every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))(x)
|> rewrites 
  (Par(R_last)
      (Par(emptyset)
          (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
             UROLE_MIDDLE(i!2, k, i!1, nnK)),
       Stop)
    |>
    LAMBDA (t: list[event]):
      every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(t) =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))(t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (k: nat_1_to(i!2),
                                nnK: Nonces(i!2, i!1, k)):
                          UROLE_MIDDLE(i!2, k, i!1, nnK)))),
                (t2: (Stop)):
           prod(R_last)(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_last(msg(e)))(x) =>
          every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_last(msg(e)))(x)
/= rewrites i!2 /= 2
  to NOT (i!2 = 2)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_last.3.2.2.


This completes the proof of authentication_last.3.2.


This completes the proof of authentication_last.3.

authentication_last.4 :  

  |-------
{1}   FORALL (e: (T)): NOT rho_last(msg(e))
[2]   network(USER) |> auth(T, R_last)

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_last.4 :  

  |-------
[1]   FORALL (e: (T)): NOT rho_last(msg(e))

Rerunning step: (comment "T is not in rho")
Adding comment: T is not in rho
this simplifies to: 
authentication_last.4 : 
;;; T is not in rho

  |-------
[1]   FORALL (e: (T)): NOT rho_last(msg(e))

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
authentication_last.4 : 
;;; T is not in rho

{-1}  T(e!1)
{-2}  rho_last(msg(e!1))
  |-------

Rerunning step: (expand "T")
Expanding the definition of T,
this simplifies to: 
authentication_last.4 : 
;;; T is not in rho

{-1}  e!1 = signal(commit(0, hu_list, n_init))
[-2]  rho_last(msg(e!1))
  |-------

Rerunning step: (replace -1 -2)
Replacing using formula -1,
this simplifies to: 
authentication_last.4 : 
;;; T is not in rho

[-1]  e!1 = signal(commit(0, hu_list, n_init))
{-2}  rho_last(msg(signal(commit(0, hu_list, n_init))))
  |-------

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
authentication_last.4 : 
;;; T is not in rho

[-1]  rho_last(msg(signal(commit(0, hu_list, n_init))))
  |-------

Rerunning step: (grind)
rho_last rewrites rho_last(commit(0, hu_list, n_init))
  to FALSE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_last.4.

Q.E.D.


Run time  = 3.75 secs.
Real time = 4.57 secs.
nil
pvs(77): 
