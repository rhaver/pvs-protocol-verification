Starting pvs-allegro -qq ...
International Allegro CL Enterprise Edition
10.1 [64-bit Linux (x86-64)] (Nov 14, 2020 18:29)
Copyright (C) 1985-2017, Franz Inc., Oakland, CA, USA.  All Rights Reserved.

This dynamic runtime copy of Allegro CL was built by:
   [TC21720] SRI International

;; Optimization settings: safety 1, space 1, speed 3, debug 1.
;; For a complete description of all compiler switches given the
;; current optimization settings evaluate (explain-compiler-settings).
;;---
;; Current reader case mode: :case-sensitive-lower

pvs(1): 
pvs(2): 
Defining stop. 
Defining stop$. 
Defining choice. 
Defining choice$. 
Defining choice2. 
Defining choice2$. 
Defining choice3. 
Defining choice3$. 
Defining prefix. 
Defining prefix$. 
Defining interleaving. 
Defining interleaving$. 
Defining interleaving2. 
Defining interleaving2$. 
Defining parallel. 
Defining parallel$. 
Defining parallel2. 
Defining parallel2$. 
Defining fix1. 
Defining fix1$. 
Defining fix2. 
Defining fix2$. 
Defining run. 
Defining run$. 
Defining mdecompose-equality. 
Defining mdecompose-equality$. 
Defining mdec-eq-last. 
Defining mdec-eq-last$. 
Defining grind-dec-eq. 
Defining grind-dec-eq$. 
stop exists as a defined rule.
Redefining stop. 
stop$ exists as a strategy.
Redefining stop$. 
choice exists as a defined rule.
Redefining choice. 
choice$ exists as a strategy.
Redefining choice$. 
choice2 exists as a defined rule.
Redefining choice2. 
choice2$ exists as a strategy.
Redefining choice2$. 
choice3 exists as a defined rule.
Redefining choice3. 
choice3$ exists as a strategy.
Redefining choice3$. 
Warning: |(defstep) prefix|, :operator was defined in
         /home/ubuntu/Desktop/csp_rules/pvs-strategies and is now being
         defined in /home/ubuntu/Desktop/gnsl/pvs-strategies

prefix exists as a defined rule.
Redefining prefix. 
prefix$ exists as a strategy.
Redefining prefix$. 
Defining prefix2. 
Defining prefix2$. 
interleaving exists as a defined rule.
Redefining interleaving. 
interleaving$ exists as a strategy.
Redefining interleaving$. 
interleaving2 exists as a defined rule.
Redefining interleaving2. 
interleaving2$ exists as a strategy.
Redefining interleaving2$. 
parallel exists as a defined rule.
Redefining parallel. 
parallel$ exists as a strategy.
Redefining parallel$. 
parallel2 exists as a defined rule.
Redefining parallel2. 
parallel2$ exists as a strategy.
Redefining parallel2$. 
fix1 exists as a defined rule.
Redefining fix1. 
fix1$ exists as a strategy.
Redefining fix1$. 
fix2 exists as a defined rule.
Redefining fix2. 
fix2$ exists as a strategy.
Redefining fix2$. 
Warning: |(defstep) run|, :operator was defined in
         /home/ubuntu/Desktop/csp_rules/pvs-strategies and is now being
         defined in /home/ubuntu/Desktop/gnsl/pvs-strategies

run exists as a defined rule.
Redefining run. 
run$ exists as a strategy.
Redefining run$. 
mdecompose-equality exists as a defined rule.
Redefining mdecompose-equality. 
mdecompose-equality$ exists as a strategy.
Redefining mdecompose-equality$. 
Warning: |(defstep) mdec-eq-last|, :operator was defined in
         /home/ubuntu/Desktop/csp_rules/pvs-strategies and is now being
         defined in /home/ubuntu/Desktop/gnsl/pvs-strategies

mdec-eq-last exists as a defined rule.
Redefining mdec-eq-last. 
mdec-eq-last$ exists as a strategy.
Redefining mdec-eq-last$. 
grind-dec-eq exists as a defined rule.
Redefining grind-dec-eq. 
grind-dec-eq$ exists as a strategy.
Redefining grind-dec-eq$. 
Defining nonemptylist. 
Defining nonemptylist$. 
stop exists as a defined rule.
Redefining stop. 
stop$ exists as a strategy.
Redefining stop$. 
choice exists as a defined rule.
Redefining choice. 
choice$ exists as a strategy.
Redefining choice$. 
choice2 exists as a defined rule.
Redefining choice2. 
choice2$ exists as a strategy.
Redefining choice2$. 
choice3 exists as a defined rule.
Redefining choice3. 
choice3$ exists as a strategy.
Redefining choice3$. 
prefix exists as a defined rule.
Redefining prefix. 
prefix$ exists as a strategy.
Redefining prefix$. 
prefix2 exists as a defined rule.
Redefining prefix2. 
prefix2$ exists as a strategy.
Redefining prefix2$. 
interleaving exists as a defined rule.
Redefining interleaving. 
interleaving$ exists as a strategy.
Redefining interleaving$. 
interleaving2 exists as a defined rule.
Redefining interleaving2. 
interleaving2$ exists as a strategy.
Redefining interleaving2$. 
parallel exists as a defined rule.
Redefining parallel. 
parallel$ exists as a strategy.
Redefining parallel$. 
parallel2 exists as a defined rule.
Redefining parallel2. 
parallel2$ exists as a strategy.
Redefining parallel2$. 
fix1 exists as a defined rule.
Redefining fix1. 
fix1$ exists as a strategy.
Redefining fix1$. 
fix2 exists as a defined rule.
Redefining fix2. 
fix2$ exists as a strategy.
Redefining fix2$. 
run exists as a defined rule.
Redefining run. 
run$ exists as a strategy.
Redefining run$. 
mdecompose-equality exists as a defined rule.
Redefining mdecompose-equality. 
mdecompose-equality$ exists as a strategy.
Redefining mdecompose-equality$. 
mdec-eq-last exists as a defined rule.
Redefining mdec-eq-last. 
mdec-eq-last$ exists as a strategy.
Redefining mdec-eq-last$. 
grind-dec-eq exists as a defined rule.
Redefining grind-dec-eq. 
grind-dec-eq$ exists as a strategy.
Redefining grind-dec-eq$. 
nonemptylist exists as a defined rule.
Redefining nonemptylist. 
nonemptylist$ exists as a strategy.
Redefining nonemptylist$. 
Installing rewrite rule sets.singleton_rew (all instances)
n_prop :  

  |-------
{1}   FORALL (P: nat_from_2, u: Identity, r: Role):
        (P /= p OR r /= p - 1) =>
         NOT pt[[nat_from_2, Identity, Role], Nonce](P, u, r)(n_last)

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
n_prop :  

{-1}  2 <= P!1
{-2}  u!1 >= 0
{-3}  r!1 >= 0
  |-------
{1}   (P!1 /= p OR r!1 /= p - 1) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, r!1)(n_last)

Rerunning step: (typepred "n_last"
                 "pt[[nat_from_2, Identity, Role], Nonce]" "p")
Adding type constraints for  n_last, pt
                                     [[nat_from_2, Identity, Role],
                                      Nonce], p,
this simplifies to: 
n_prop :  

{-1}  IRpart(p, hu(p - 1), p - 1)(n_last)
{-2}  FORALL (i: [nat_from_2, Identity, Role]),
             (j: [nat_from_2, Identity, Role]), (n: Nonce):
        i /= j AND pt[[nat_from_2, Identity, Role], Nonce](i)(n) =>
         NOT pt[[nat_from_2, Identity, Role], Nonce](j)(n)
{-3}  FORALL (i: [nat_from_2, Identity, Role]):
        EXISTS (n: Nonce): pt[[nat_from_2, Identity, Role], Nonce](i)(n)
{-4}  2 <= p
[-5]  2 <= P!1
[-6]  u!1 >= 0
[-7]  r!1 >= 0
  |-------
[1]   (P!1 /= p OR r!1 /= p - 1) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, r!1)(n_last)

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
n_prop :  

[-1]  IRpart(p, hu(p - 1), p - 1)(n_last)
[-2]  FORALL (i: [nat_from_2, Identity, Role]),
             (j: [nat_from_2, Identity, Role]), (n: Nonce):
        i /= j AND pt[[nat_from_2, Identity, Role], Nonce](i)(n) =>
         NOT pt[[nat_from_2, Identity, Role], Nonce](j)(n)
[-3]  2 <= p
[-4]  2 <= P!1
[-5]  u!1 >= 0
[-6]  r!1 >= 0
  |-------
[1]   (P!1 /= p OR r!1 /= p - 1) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, r!1)(n_last)

Rerunning step: (inst -2 "(P!1, u!1, r!1)" "(p, hu(p-1), p-1)" "n_last")
Instantiating the top quantifier in -2 with the terms: 
 (P!1, u!1, r!1), (p, hu(p-1), p-1), n_last,
this yields  2 subgoals: 
n_prop.1 :  

[-1]  IRpart(p, hu(p - 1), p - 1)(n_last)
{-2}  (P!1, u!1, r!1) /= (p, hu(p - 1), p - 1) AND
       pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, r!1)(n_last)
       =>
       NOT pt[[nat_from_2, Identity, Role], Nonce]
               (p, hu(p - 1), p - 1)(n_last)
[-3]  2 <= p
[-4]  2 <= P!1
[-5]  u!1 >= 0
[-6]  r!1 >= 0
  |-------
[1]   (P!1 /= p OR r!1 /= p - 1) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, r!1)(n_last)

Rerunning step: (grind)
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
/= rewrites P!1 /= p
  to NOT (P!1 = p)
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
/= rewrites r!1 /= p - 1
  to NOT (r!1 = p - 1)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of n_prop.1.

n_prop.2 (TCC):   

[-1]  IRpart(p, hu(p - 1), p - 1)(n_last)
[-2]  2 <= p
[-3]  2 <= P!1
[-4]  u!1 >= 0
[-5]  r!1 >= 0
  |-------
{1}   p - 1 >= 0
[2]   (P!1 /= p OR r!1 /= p - 1) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, r!1)(n_last)

Rerunning step: (delete -1 -3 -4 -5 2)
Deleting some formulas,
this simplifies to: 
n_prop.2 :  

[-1]  2 <= p
  |-------
[1]   p - 1 >= 0

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of n_prop.2.

Q.E.D.


Run time  = 0.19 secs.
Real time = 0.49 secs.
nil
pvs(22): 
Installing rewrite rule sets.singleton_rew (all instances)
n_orig :  

  |-------
{1}   FORALL (P: nat_from_2, u: Identity, r: Role):
        IRpart(P, u, r)(n_last) => (P = p AND u = hu(p - 1) AND r = p - 1)

Rerunning step: (skosimp)
Skolemizing and flattening,
this simplifies to: 
n_orig :  

{-1}  IRpart(P!1, u!1, r!1)(n_last)
  |-------
{1}   (P!1 = p AND u!1 = hu(p - 1) AND r!1 = p - 1)

Rerunning step: (typepred "pt[[nat_from_2, Identity, Role], Nonce]"
                 "n_last" "p")
Adding type constraints for  pt[[nat_from_2, Identity, Role],
                                Nonce], n_last, p,
this simplifies to: 
n_orig :  

{-1}  FORALL (i: [nat_from_2, Identity, Role]),
             (j: [nat_from_2, Identity, Role]), (n: Nonce):
        i /= j AND pt[[nat_from_2, Identity, Role], Nonce](i)(n) =>
         NOT pt[[nat_from_2, Identity, Role], Nonce](j)(n)
{-2}  FORALL (i: [nat_from_2, Identity, Role]):
        EXISTS (n: Nonce): pt[[nat_from_2, Identity, Role], Nonce](i)(n)
{-3}  IRpart(p, hu(p - 1), p - 1)(n_last)
{-4}  2 <= p
[-5]  IRpart(P!1, u!1, r!1)(n_last)
  |-------
[1]   (P!1 = p AND u!1 = hu(p - 1) AND r!1 = p - 1)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
n_orig :  

[-1]  FORALL (i: [nat_from_2, Identity, Role]),
             (j: [nat_from_2, Identity, Role]), (n: Nonce):
        i /= j AND pt[[nat_from_2, Identity, Role], Nonce](i)(n) =>
         NOT pt[[nat_from_2, Identity, Role], Nonce](j)(n)
[-2]  IRpart(p, hu(p - 1), p - 1)(n_last)
[-3]  2 <= p
[-4]  IRpart(P!1, u!1, r!1)(n_last)
  |-------
[1]   (P!1 = p AND u!1 = hu(p - 1) AND r!1 = p - 1)

Rerunning step: (inst -1 "(P!1, u!1, r!1)" "(p, hu(p-1), p-1)" "n_last")
Instantiating the top quantifier in -1 with the terms: 
 (P!1, u!1, r!1), (p, hu(p-1), p-1), n_last,
this yields  2 subgoals: 
n_orig.1 :  

{-1}  (P!1, u!1, r!1) /= (p, hu(p - 1), p - 1) AND
       pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, r!1)(n_last)
       =>
       NOT pt[[nat_from_2, Identity, Role], Nonce]
               (p, hu(p - 1), p - 1)(n_last)
[-2]  IRpart(p, hu(p - 1), p - 1)(n_last)
[-3]  2 <= p
[-4]  IRpart(P!1, u!1, r!1)(n_last)
  |-------
[1]   (P!1 = p AND u!1 = hu(p - 1) AND r!1 = p - 1)

Rerunning step: (grind)
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of n_orig.1.

n_orig.2 (TCC):   

[-1]  IRpart(p, hu(p - 1), p - 1)(n_last)
[-2]  2 <= p
[-3]  IRpart(P!1, u!1, r!1)(n_last)
  |-------
{1}   p - 1 >= 0
[2]   (P!1 = p AND u!1 = hu(p - 1) AND r!1 = p - 1)

Rerunning step: (delete -1 -3 2)
Deleting some formulas,
this simplifies to: 
n_orig.2 :  

[-1]  2 <= p
  |-------
[1]   p - 1 >= 0

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of n_orig.2.

Q.E.D.


Run time  = 0.14 secs.
Real time = 0.27 secs.
nil
pvs(27): 
Installing rewrite rule sets.singleton_rew (all instances)
hu_list_exists :  

  |-------
{1}   EXISTS (x1:
                {x: list[Identity] |
                   (length[Identity](x) = p) AND
                    (FORALL (i: nat_to_p): nth[Identity](x, i) = hu(i))}):
        TRUE

Rerunning step: (typepred "p")
Adding type constraints for  p,
this simplifies to: 
hu_list_exists :  

{-1}  2 <= p
  |-------
[1]   EXISTS (x1:
                {x: list[Identity] |
                   (length[Identity](x) = p) AND
                    (FORALL (i: nat_to_p): nth[Identity](x, i) = hu(i))}):
        TRUE

Rerunning step: (inst 1 "gen_f_list(p, 0, hu)")
Instantiating the top quantifier in 1 with the terms: 
 gen_f_list(p, 0, hu),
this yields  2 subgoals: 
hu_list_exists.1 (TCC):   

[-1]  2 <= p
  |-------
{1}   (length[Identity](gen_f_list[Identity](p, 0, hu)) = p) AND
       FORALL (i: nat_to_p):
         nth[Identity](gen_f_list[Identity](p, 0, hu), i) = hu(i)

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
hu_list_exists.1.1 :  

[-1]  2 <= p
  |-------
{1}   (length[Identity](gen_f_list[Identity](p, 0, hu)) = p)

Rerunning step: (rewrite "gen1")
Found matching substitution:
f: [below[k] -> T] gets hu,
i: below[k] gets 0,
k: nat gets p,
Rewriting using gen1, matching in *,

This completes the proof of hu_list_exists.1.1.

hu_list_exists.1.2 :  

[-1]  2 <= p
  |-------
{1}   FORALL (i: nat_to_p):
        nth[Identity](gen_f_list[Identity](p, 0, hu), i) = hu(i)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
hu_list_exists.1.2 :  

[-1]  2 <= p
  |-------
{1}   nth[Identity](gen_f_list[Identity](p, 0, hu), i!1) = hu(i!1)

Rerunning step: (rewrite "gen2")
Found matching substitution:
j: below[k - i] gets i!1,
f: [below[k] -> T] gets hu,
i: below[k] gets 0,
k: nat gets p,
Rewriting using gen2, matching in *,

This completes the proof of hu_list_exists.1.2.


This completes the proof of hu_list_exists.1.

hu_list_exists.2 (TCC):   

[-1]  2 <= p
  |-------
{1}   0 < p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of hu_list_exists.2.

Q.E.D.


Run time  = 0.13 secs.
Real time = 0.20 secs.
nil
pvs(32): 
Installing rewrite rule sets.singleton_rew (all instances)
cons_hu_list :  

  |-------
{1}   cons?(hu_list) AND length(hu_list) = p

Rerunning step: (typepred "p" "hu_list")
Adding type constraints for  p, hu_list,
this simplifies to: 
cons_hu_list :  

{-1}  2 <= p
{-2}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-3}  (length(hu_list) = p)
{-4}  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
  |-------
[1]   cons?(hu_list) AND length(hu_list) = p

Rerunning step: (delete -2 -4)
Deleting some formulas,
this simplifies to: 
cons_hu_list :  

[-1]  2 <= p
[-2]  (length(hu_list) = p)
  |-------
[1]   cons?(hu_list) AND length(hu_list) = p

Rerunning step: (lemma "more_list_props[Identity].length_non_zero"
                 ("l" "hu_list"))
Applying more_list_props[Identity].length_non_zero where 
  l gets hu_list,
this simplifies to: 
cons_hu_list :  

{-1}  length(hu_list) > 0 IFF cons?(hu_list)
[-2]  2 <= p
[-3]  (length(hu_list) = p)
  |-------
[1]   cons?(hu_list) AND length(hu_list) = p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,
Q.E.D.


Run time  = 0.04 secs.
Real time = 0.13 secs.
nil
pvs(37): 
Installing rewrite rule sets.singleton_rew (all instances)
restrictinit_init :  

  |-------
{1}   FORALL (P: nat_from_2, u: Identity):
        ((Interleave! (nn0: Nonces(P, u, 0)): UROLE_INIT(P, u, nn0)) #
          R_init)
         |> RankUser(rho_init)

Rerunning step: (auto-rewrite-theory "sets")
Rewriting relative to the theory: sets,
this simplifies to: 
restrictinit_init :  

  |-------
[1]   FORALL (P: nat_from_2, u: Identity):
        ((Interleave! (nn0: Nonces(P, u, 0)): UROLE_INIT(P, u, nn0)) #
          R_init)
         |> RankUser(rho_init)

Rerunning step: (auto-rewrite "n_last_TCC2")
Installing rewrite rule gnsl_last.n_last_TCC2
Installing automatic rewrites from: 
  n_last_TCC2
this simplifies to: 
restrictinit_init :  

  |-------
[1]   FORALL (P: nat_from_2, u: Identity):
        ((Interleave! (nn0: Nonces(P, u, 0)): UROLE_INIT(P, u, nn0)) #
          R_init)
         |> RankUser(rho_init)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictinit_init :  

  |-------
{1}   ((Interleave! (nn0: Nonces(P!1, u!1, 0)): UROLE_INIT(P!1, u!1, nn0))
        # R_init)
       |> RankUser(rho_init)

Rerunning step: (expand "RankUser")
Expanding the definition of RankUser,
this simplifies to: 
restrictinit_init :  

  |-------
{1}   ((Interleave! (nn0: Nonces(P!1, u!1, 0)): UROLE_INIT(P!1, u!1, nn0))
        # R_init)
       |>
       LAMBDA (tr: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(tr) =>
          every(LAMBDA (e: event): complement(rec?)(e) => rho_init(msg(e)))
               (tr)

Rerunning step: (interleaving2)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
Applying interleaving rule,
this simplifies to: 
restrictinit_init :  

  |-------
{1}   UROLE_INIT(P!1, u!1, i!1) # R_init |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (expand "UROLE_INIT")
Expanding the definition of UROLE_INIT,
this simplifies to: 
restrictinit_init :  

  |-------
{1}   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (signal(running(0, cons(u!1, il), nth(nl, P!1 - 2))) >>
              (trans(u!1, car(il),
                     E(public(car(il)),
                       conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                >> Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (typepred "P!1")
Adding type constraints for  P!1,
this simplifies to: 
restrictinit_init :  

{-1}  2 <= P!1
  |-------
[1]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (signal(running(0, cons(u!1, il), nth(nl, P!1 - 2))) >>
              (trans(u!1, car(il),
                     E(public(car(il)),
                       conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                >> Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (choice3)
Applying choice rule,
this yields  7 subgoals: 
restrictinit_init.1 :  

[-1]  2 <= P!1
  |-------
{1}   (trans(u!1, car(i!2`2),
             E(public(car(i!2`2)),
               conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))
        >>
        (rec(u!1, nth(i!2`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
          >>
          (signal(running(0, cons(u!1, i!2`2), nth(i!2`1, P!1 - 2))) >>
            (trans(u!1, car(i!2`2),
                   E(public(car(i!2`2)),
                     conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
              >> Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictinit_init.1.1 :  

[-1]  2 <= P!1
  |-------
{1}   rho_init(E(public(car(i!2`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))
{2}   R_init(trans(u!1, car(i!2`2),
                   E(public(car(i!2`2)),
                     conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2)))))))
{3}   trans(u!1, car(i!2`2),
            E(public(car(i!2`2)),
              conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))
       >>
       ((rec(u!1, nth(i!2`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
          >>
          (signal(running(0, cons(u!1, i!2`2), nth(i!2`1, P!1 - 2))) >>
            (trans(u!1, car(i!2`2),
                   E(public(car(i!2`2)),
                     conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
              >> Stop[event])))
         # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_init.1.1 :  

[-1]  2 <= P!1
  |-------
[1]   rho_init(E(public(car(i!2`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))

Rerunning step: (typepred "i!1")
Adding type constraints for  i!1,
this simplifies to: 
restrictinit_init.1.1 :  

{-1}  IRpart(P!1, u!1, 0)(i!1)
[-2]  2 <= P!1
  |-------
[1]   rho_init(E(public(car(i!2`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))

Rerunning step: (lemma "n_prop" ("P" "P!1" "u" "u!1" "r" "0"))
Applying n_prop where 
  P gets P!1,
  u gets u!1,
  r gets 0,
this simplifies to: 
restrictinit_init.1.1 :  

{-1}  (P!1 /= p OR 0 /= p - 1) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, 0)(n_last)
[-2]  IRpart(P!1, u!1, 0)(i!1)
[-3]  2 <= P!1
  |-------
[1]   rho_init(E(public(car(i!2`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))

Rerunning step: (lemma "listprops[Nonce].elt_singleton"
                 ("t1" "i!1" "t2" "n_last"))
Applying listprops[Nonce].elt_singleton where 
  t1 gets i!1,
  t2 gets n_last,
this simplifies to: 
restrictinit_init.1.1 :  

{-1}  elt((: i!1 :), n_last) IFF i!1 = n_last
[-2]  (P!1 /= p OR 0 /= p - 1) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, 0)(n_last)
[-3]  IRpart(P!1, u!1, 0)(i!1)
[-4]  2 <= P!1
  |-------
[1]   rho_init(E(public(car(i!2`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))

Rerunning step: (grind :if-match nil :exclude "elt")
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
/= rewrites P!1 /= p
  to NOT (P!1 = p)
/= rewrites 0 /= p - 1
  to TRUE
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
E rewrites 
  E(public(car(i!2`2)),
    conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2)))))
  to code(public(car(i!2`2)),
           conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2)))))
rho_init rewrites rho_init(nlist((: i!1 :)))
  to TRUE
rho_init rewrites rho_init(ilist(cons(u!1, cdr(i!2`2))))
  to TRUE
rho_init rewrites 
  rho_init(conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2)))))
  to TRUE
rho_init rewrites 
  rho_init(code(public(car(i!2`2)),
                conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))
  to TRUE
/= rewrites P!1 /= p
  to NOT (P!1 = p)
/= rewrites 0 /= p - 1
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictinit_init.1.1.

restrictinit_init.1.2 :  

[-1]  2 <= P!1
  |-------
{1}   ((rec(u!1, nth(i!2`2, P!1 - 2),
            E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
         >>
         (signal(running(0, cons(u!1, i!2`2), nth(i!2`1, P!1 - 2))) >>
           (trans(u!1, car(i!2`2),
                  E(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
             >> Stop[event])))
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
{2}   R_init(trans(u!1, car(i!2`2),
                   E(public(car(i!2`2)),
                     conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2)))))))
{3}   trans(u!1, car(i!2`2),
            E(public(car(i!2`2)),
              conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i!2`2))))))
       >>
       ((rec(u!1, nth(i!2`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
          >>
          (signal(running(0, cons(u!1, i!2`2), nth(i!2`1, P!1 - 2))) >>
            (trans(u!1, car(i!2`2),
                   E(public(car(i!2`2)),
                     conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
              >> Stop[event])))
         # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_init.1.2 :  

[-1]  2 <= P!1
  |-------
[1]   ((rec(u!1, nth(i!2`2, P!1 - 2),
            E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
         >>
         (signal(running(0, cons(u!1, i!2`2), nth(i!2`1, P!1 - 2))) >>
           (trans(u!1, car(i!2`2),
                  E(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
             >> Stop[event])))
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictinit_init.1.2 :  

{-1}  rho_init(E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
{1}   ((signal(running(0, cons(u!1, i!2`2), nth(i!2`1, P!1 - 2))) >>
         (trans(u!1, car(i!2`2),
                E(public(car(i!2`2)),
                  conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
           >> Stop[event]))
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
{2}   R_init(rec(u!1, nth(i!2`2, P!1 - 2),
                 E(public(u!1),
                   conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)))))
{3}   rec(u!1, nth(i!2`2, P!1 - 2),
          E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
       >>
       ((signal(running(0, cons(u!1, i!2`2), nth(i!2`1, P!1 - 2))) >>
          (trans(u!1, car(i!2`2),
                 E(public(car(i!2`2)),
                   conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
            >> Stop[event]))
         # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_init.1.2 :  

[-1]  rho_init(E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   ((signal(running(0, cons(u!1, i!2`2), nth(i!2`1, P!1 - 2))) >>
         (trans(u!1, car(i!2`2),
                E(public(car(i!2`2)),
                  conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
           >> Stop[event]))
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictinit_init.1.2.1 :  

[-1]  rho_init(E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
{1}   rho_init(running(0, cons(u!1, i!2`2), nth(i!2`1, P!1 - 2)))
{2}   R_init(signal(running(0, cons(u!1, i!2`2), nth(i!2`1, P!1 - 2))))
{3}   signal(running(0, cons(u!1, i!2`2), nth(i!2`1, P!1 - 2))) >>
       ((trans(u!1, car(i!2`2),
               E(public(car(i!2`2)),
                 conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
          >> Stop[event])
         # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_init.1.2.1 :  

  |-------
[1]   rho_init(running(0, cons(u!1, i!2`2), nth(i!2`1, P!1 - 2)))

Rerunning step: (expand "rho_init")
Expanding the definition of rho_init,
this simplifies to: 
restrictinit_init.1.2.1 :  

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictinit_init.1.2.1.

restrictinit_init.1.2.2 :  

[-1]  rho_init(E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
{1}   ((trans(u!1, car(i!2`2),
              E(public(car(i!2`2)),
                conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
         >> Stop[event])
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
{2}   R_init(signal(running(0, cons(u!1, i!2`2), nth(i!2`1, P!1 - 2))))
{3}   signal(running(0, cons(u!1, i!2`2), nth(i!2`1, P!1 - 2))) >>
       ((trans(u!1, car(i!2`2),
               E(public(car(i!2`2)),
                 conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
          >> Stop[event])
         # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete 3)
Deleting some formulas,
this simplifies to: 
restrictinit_init.1.2.2 :  

[-1]  rho_init(E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   ((trans(u!1, car(i!2`2),
              E(public(car(i!2`2)),
                conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
         >> Stop[event])
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[2]   R_init(signal(running(0, cons(u!1, i!2`2), nth(i!2`1, P!1 - 2))))

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictinit_init.1.2.2.1 :  

[-1]  rho_init(E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
{1}   rho_init(E(public(car(i!2`2)),
                 conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
{2}   R_init(trans(u!1, car(i!2`2),
                   E(public(car(i!2`2)),
                     conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1)))))
{3}   trans(u!1, car(i!2`2),
            E(public(car(i!2`2)),
              conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
       >> (Stop[event] # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[4]   R_init(signal(running(0, cons(u!1, i!2`2), nth(i!2`1, P!1 - 2))))

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_init.1.2.2.1 :  

[-1]  rho_init(E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   rho_init(E(public(car(i!2`2)),
                 conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
[2]   R_init(signal(running(0, cons(u!1, i!2`2), nth(i!2`1, P!1 - 2))))

Rerunning step: (expand "R_init")
Expanding the definition of R_init,
this simplifies to: 
restrictinit_init.1.2.2.1 :  

[-1]  rho_init(E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   rho_init(E(public(car(i!2`2)),
                 conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
{2}   signal(running(0, cons(u!1, i!2`2), nth(i!2`1, P!1 - 2))) =
       signal(running(0, hu_list, n_last))

Rerunning step: (case "cons(u!1,i!2`2)=hu_list AND nth(i!2`1,P!1-2)=n_last")
Case splitting on 
   cons(u!1, i!2`2) = hu_list AND nth(i!2`1, P!1 - 2) = n_last, 
this yields  2 subgoals: 
restrictinit_init.1.2.2.1.1 :  

{-1}  cons(u!1, i!2`2) = hu_list AND nth(i!2`1, P!1 - 2) = n_last
[-2]  rho_init(E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-3]  2 <= P!1
  |-------
[1]   rho_init(E(public(car(i!2`2)),
                 conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
[2]   signal(running(0, cons(u!1, i!2`2), nth(i!2`1, P!1 - 2))) =
       signal(running(0, hu_list, n_last))

Rerunning step: (delete -2 -3 1)
Deleting some formulas,
this simplifies to: 
restrictinit_init.1.2.2.1.1 :  

[-1]  cons(u!1, i!2`2) = hu_list AND nth(i!2`1, P!1 - 2) = n_last
  |-------
[1]   signal(running(0, cons(u!1, i!2`2), nth(i!2`1, P!1 - 2))) =
       signal(running(0, hu_list, n_last))

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictinit_init.1.2.2.1.1.

restrictinit_init.1.2.2.1.2 :  

[-1]  rho_init(E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
{1}   cons(u!1, i!2`2) = hu_list AND nth(i!2`1, P!1 - 2) = n_last
[2]   rho_init(E(public(car(i!2`2)),
                 conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
[3]   signal(running(0, cons(u!1, i!2`2), nth(i!2`1, P!1 - 2))) =
       signal(running(0, hu_list, n_last))

Rerunning step: (delete 3)
Deleting some formulas,
this simplifies to: 
restrictinit_init.1.2.2.1.2 :  

[-1]  rho_init(E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   cons(u!1, i!2`2) = hu_list AND nth(i!2`1, P!1 - 2) = n_last
[2]   rho_init(E(public(car(i!2`2)),
                 conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (expand "E")
Expanding the definition of E,
this simplifies to: 
restrictinit_init.1.2.2.1.2 :  

{-1}  rho_init(code(public(u!1),
                    conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   cons(u!1, i!2`2) = hu_list AND nth(i!2`1, P!1 - 2) = n_last
{2}   rho_init(code(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (expand "rho_init" -1)
Expanding the definition of rho_init,
this simplifies to: 
restrictinit_init.1.2.2.1.2 :  

{-1}  rho_init(conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))) OR
       (public(u!1) = public(hu(0)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
           conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)) =
            conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
[-2]  2 <= P!1
  |-------
[1]   cons(u!1, i!2`2) = hu_list AND nth(i!2`1, P!1 - 2) = n_last
[2]   rho_init(code(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (split -1)
Splitting conjunctions,
this yields  2 subgoals: 
restrictinit_init.1.2.2.1.2.1 :  

{-1}  rho_init(conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)))
[-2]  2 <= P!1
  |-------
[1]   cons(u!1, i!2`2) = hu_list AND nth(i!2`1, P!1 - 2) = n_last
[2]   rho_init(code(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (delete 1)
Deleting some formulas,
this simplifies to: 
restrictinit_init.1.2.2.1.2.1 :  

[-1]  rho_init(conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)))
[-2]  2 <= P!1
  |-------
[1]   rho_init(code(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (lemma "listprops[Nonce].elt_append2"
                 ("l1" "(:i!1:)" "l2" "i!2`1" "t" "n_last"))
Applying listprops[Nonce].elt_append2 where 
  l1 gets (: i!1 :),
  l2 gets i!2`1,
  t gets n_last,
this simplifies to: 
restrictinit_init.1.2.2.1.2.1 :  

{-1}  elt(i!2`1, n_last) IMPLIES elt(append((: i!1 :), i!2`1), n_last)
[-2]  rho_init(conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)))
[-3]  2 <= P!1
  |-------
[1]   rho_init(code(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (grind :if-match nil :exclude "elt")
append rewrites append((: :), i!2`1)
  to i!2`1
append rewrites append((: i!1 :), i!2`1)
  to cons(i!1, i!2`1)
rho_init rewrites rho_init(nlist(cons(i!1, i!2`1)))
  to FALSE
rho_init rewrites rho_init(ilist(i!2`2))
  to TRUE
rho_init rewrites rho_init(conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)))
  to FALSE
rho_init rewrites rho_init(nlist(cons(i!1, i!2`1)))
  to NOT elt(cons(i!1, i!2`1), n_last)
rho_init rewrites rho_init(ilist(i!2`2))
  to TRUE
rho_init rewrites rho_init(conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)))
  to NOT elt(cons(i!1, i!2`1), n_last)
rho_init rewrites rho_init(ilist(cons(u!1, cdr(i!2`2))))
  to TRUE
rho_init rewrites rho_init(nlist(i!2`1))
  to TRUE
rho_init rewrites rho_init(conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1)))
  to TRUE
rho_init rewrites 
  rho_init(code(public(car(i!2`2)),
                conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictinit_init.1.2.2.1.2.1.

restrictinit_init.1.2.2.1.2.2 :  

{-1}  (public(u!1) = public(hu(0)) AND
        EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
          conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)) =
           conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
[-2]  2 <= P!1
  |-------
[1]   cons(u!1, i!2`2) = hu_list AND nth(i!2`1, P!1 - 2) = n_last
[2]   rho_init(code(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictinit_init.1.2.2.1.2.2 :  

{-1}  public(u!1) = public(hu(0))
{-2}  EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
        conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)) =
         conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list)))
[-3]  2 <= P!1
  |-------
[1]   cons(u!1, i!2`2) = hu_list AND nth(i!2`1, P!1 - 2) = n_last
[2]   rho_init(code(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictinit_init.1.2.2.1.2.2 :  

[-1]  public(u!1) = public(hu(0))
{-2}  conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)) =
       conc(nlist(append(nl!1, (: n_last :))), ilist(cdr(hu_list)))
[-3]  2 <= P!1
  |-------
[1]   cons(u!1, i!2`2) = hu_list AND nth(i!2`1, P!1 - 2) = n_last
[2]   rho_init(code(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictinit_init.1.2.2.1.2.2 :  

{-1}  u!1 = hu(0)
[-2]  conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2)) =
       conc(nlist(append(nl!1, (: n_last :))), ilist(cdr(hu_list)))
[-3]  2 <= P!1
  |-------
[1]   cons(u!1, i!2`2) = hu_list AND nth(i!2`1, P!1 - 2) = n_last
[2]   rho_init(code(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictinit_init.1.2.2.1.2.2 :  

{-1}  nlist(cons(i!1, i!2`1)) = nlist(append(nl!1, (: n_last :)))
{-2}  ilist(i!2`2) = ilist(cdr(hu_list))
[-3]  u!1 = hu(0)
[-4]  2 <= P!1
  |-------
[1]   cons(u!1, i!2`2) = hu_list AND nth(i!2`1, P!1 - 2) = n_last
[2]   rho_init(code(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictinit_init.1.2.2.1.2.2 :  

{-1}  cons(i!1, i!2`1) = append(nl!1, (: n_last :))
[-2]  ilist(i!2`2) = ilist(cdr(hu_list))
[-3]  u!1 = hu(0)
[-4]  2 <= P!1
  |-------
[1]   cons(u!1, i!2`2) = hu_list AND nth(i!2`1, P!1 - 2) = n_last
[2]   rho_init(code(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictinit_init.1.2.2.1.2.2 :  

{-1}  i!2`2 = cdr(hu_list)
[-2]  cons(i!1, i!2`1) = append(nl!1, (: n_last :))
[-3]  u!1 = hu(0)
[-4]  2 <= P!1
  |-------
[1]   cons(u!1, i!2`2) = hu_list AND nth(i!2`1, P!1 - 2) = n_last
[2]   rho_init(code(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (typepred "nl!1" "i!2`1" "i!2`2" "hu_list")
Adding type constraints for  nl!1, i!2`1, i!2`2, hu_list,
this simplifies to: 
restrictinit_init.1.2.2.1.2.2 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl!1)
{-2}  length(nl!1) = p - 1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`1)
{-4}  length(i!2`1) = P!1 - 1
{-5}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`2)
{-6}  length(i!2`2) = P!1 - 1
{-7}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-8}  (length(hu_list) = p)
{-9}  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!2`2 = cdr(hu_list)
[-11] cons(i!1, i!2`1) = append(nl!1, (: n_last :))
[-12] u!1 = hu(0)
[-13] 2 <= P!1
  |-------
[1]   cons(u!1, i!2`2) = hu_list AND nth(i!2`1, P!1 - 2) = n_last
[2]   rho_init(code(public(car(i!2`2)),
                    conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))

Rerunning step: (delete -1 -3 -5 -7 2)
Deleting some formulas,
this simplifies to: 
restrictinit_init.1.2.2.1.2.2 :  

[-1]  length(nl!1) = p - 1
[-2]  length(i!2`1) = P!1 - 1
[-3]  length(i!2`2) = P!1 - 1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  i!2`2 = cdr(hu_list)
[-7]  cons(i!1, i!2`1) = append(nl!1, (: n_last :))
[-8]  u!1 = hu(0)
[-9]  2 <= P!1
  |-------
[1]   cons(u!1, i!2`2) = hu_list AND nth(i!2`1, P!1 - 2) = n_last

Rerunning step: (case "P!1=p")
Case splitting on 
   P!1 = p, 
this yields  2 subgoals: 
restrictinit_init.1.2.2.1.2.2.1 :  

{-1}  P!1 = p
[-2]  length(nl!1) = p - 1
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  i!2`2 = cdr(hu_list)
[-8]  cons(i!1, i!2`1) = append(nl!1, (: n_last :))
[-9]  u!1 = hu(0)
[-10] 2 <= P!1
  |-------
[1]   cons(u!1, i!2`2) = hu_list AND nth(i!2`1, P!1 - 2) = n_last

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
restrictinit_init.1.2.2.1.2.2.1.1 :  

[-1]  P!1 = p
[-2]  length(nl!1) = p - 1
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  i!2`2 = cdr(hu_list)
[-8]  cons(i!1, i!2`1) = append(nl!1, (: n_last :))
[-9]  u!1 = hu(0)
[-10] 2 <= P!1
  |-------
{1}   cons(u!1, i!2`2) = hu_list

Rerunning step: (replace -7 1)
Replacing using formula -7,
this simplifies to: 
restrictinit_init.1.2.2.1.2.2.1.1 :  

[-1]  P!1 = p
[-2]  length(nl!1) = p - 1
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  i!2`2 = cdr(hu_list)
[-8]  cons(i!1, i!2`1) = append(nl!1, (: n_last :))
[-9]  u!1 = hu(0)
[-10] 2 <= P!1
  |-------
{1}   cons(u!1, cdr(hu_list)) = hu_list

Rerunning step: (replace -9 1)
Replacing using formula -9,
this simplifies to: 
restrictinit_init.1.2.2.1.2.2.1.1 :  

[-1]  P!1 = p
[-2]  length(nl!1) = p - 1
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  i!2`2 = cdr(hu_list)
[-8]  cons(i!1, i!2`1) = append(nl!1, (: n_last :))
[-9]  u!1 = hu(0)
[-10] 2 <= P!1
  |-------
{1}   cons(hu(0), cdr(hu_list)) = hu_list

Rerunning step: (inst -6 "0")
Instantiating the top quantifier in -6 with the terms: 
 0,
this simplifies to: 
restrictinit_init.1.2.2.1.2.2.1.1 :  

[-1]  P!1 = p
[-2]  length(nl!1) = p - 1
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
{-6}  nth(hu_list, 0) = hu(0)
[-7]  i!2`2 = cdr(hu_list)
[-8]  cons(i!1, i!2`1) = append(nl!1, (: n_last :))
[-9]  u!1 = hu(0)
[-10] 2 <= P!1
  |-------
[1]   cons(hu(0), cdr(hu_list)) = hu_list

Rerunning step: (replace -6 1 rl)
Replacing using formula -6,
this simplifies to: 
restrictinit_init.1.2.2.1.2.2.1.1 :  

[-1]  P!1 = p
[-2]  length(nl!1) = p - 1
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  nth(hu_list, 0) = hu(0)
[-7]  i!2`2 = cdr(hu_list)
[-8]  cons(i!1, i!2`1) = append(nl!1, (: n_last :))
[-9]  u!1 = hu(0)
[-10] 2 <= P!1
  |-------
{1}   cons(nth(hu_list, 0), cdr(hu_list)) = hu_list

Rerunning step: (expand "nth" 1)
Expanding the definition of nth,
this simplifies to: 
restrictinit_init.1.2.2.1.2.2.1.1 :  

[-1]  P!1 = p
[-2]  length(nl!1) = p - 1
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  nth(hu_list, 0) = hu(0)
[-7]  i!2`2 = cdr(hu_list)
[-8]  cons(i!1, i!2`1) = append(nl!1, (: n_last :))
[-9]  u!1 = hu(0)
[-10] 2 <= P!1
  |-------
{1}   cons(car(hu_list), cdr(hu_list)) = hu_list

Rerunning step: (rewrite "list_cons_eta" 1)
Found matching substitution:
cons?_var: (cons?) gets hu_list,
Rewriting using list_cons_eta, matching in 1,

This completes the proof of restrictinit_init.1.2.2.1.2.2.1.1.

restrictinit_init.1.2.2.1.2.2.1.2 :  

[-1]  P!1 = p
[-2]  length(nl!1) = p - 1
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  i!2`2 = cdr(hu_list)
[-8]  cons(i!1, i!2`1) = append(nl!1, (: n_last :))
[-9]  u!1 = hu(0)
[-10] 2 <= P!1
  |-------
{1}   nth(i!2`1, P!1 - 2) = n_last

Rerunning step: (lemma "listprops[Identity].equality_nth"
                 ("l1" "cons(i!1,i!2`1)" "l2"
                  "append(nl!1,(:n_last:))"))
Applying listprops[Identity].equality_nth where 
  l1 gets cons(i!1, i!2`1),
  l2 gets append(nl!1, (: n_last :)),
this simplifies to: 
restrictinit_init.1.2.2.1.2.2.1.2 :  

{-1}  cons(i!1, i!2`1) = append(nl!1, (: n_last :)) IMPLIES
       FORALL (i: below[length[Identity](cons(i!1, i!2`1))]):
         nth(cons(i!1, i!2`1), i) = nth(append(nl!1, (: n_last :)), i)
[-2]  P!1 = p
[-3]  length(nl!1) = p - 1
[-4]  length(i!2`1) = P!1 - 1
[-5]  length(i!2`2) = P!1 - 1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!2`2 = cdr(hu_list)
[-9]  cons(i!1, i!2`1) = append(nl!1, (: n_last :))
[-10] u!1 = hu(0)
[-11] 2 <= P!1
  |-------
[1]   nth(i!2`1, P!1 - 2) = n_last

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictinit_init.1.2.2.1.2.2.1.2 :  

{-1}  FORALL (i: below[length[Identity](cons(i!1, i!2`1))]):
        nth(cons(i!1, i!2`1), i) = nth(append(nl!1, (: n_last :)), i)
[-2]  P!1 = p
[-3]  length(nl!1) = p - 1
[-4]  length(i!2`1) = P!1 - 1
[-5]  length(i!2`2) = P!1 - 1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!2`2 = cdr(hu_list)
[-9]  cons(i!1, i!2`1) = append(nl!1, (: n_last :))
[-10] u!1 = hu(0)
[-11] 2 <= P!1
  |-------
[1]   nth(i!2`1, P!1 - 2) = n_last

Rerunning step: (inst -1 "P!1-1")
Instantiating the top quantifier in -1 with the terms: 
 P!1-1,
this yields  2 subgoals: 
restrictinit_init.1.2.2.1.2.2.1.2.1 :  

{-1}  nth(cons(i!1, i!2`1), P!1 - 1) =
       nth(append(nl!1, (: n_last :)), P!1 - 1)
[-2]  P!1 = p
[-3]  length(nl!1) = p - 1
[-4]  length(i!2`1) = P!1 - 1
[-5]  length(i!2`2) = P!1 - 1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!2`2 = cdr(hu_list)
[-9]  cons(i!1, i!2`1) = append(nl!1, (: n_last :))
[-10] u!1 = hu(0)
[-11] 2 <= P!1
  |-------
[1]   nth(i!2`1, P!1 - 2) = n_last

Rerunning step: (expand "nth" -1 1)
Expanding the definition of nth,
this simplifies to: 
restrictinit_init.1.2.2.1.2.2.1.2.1 :  

{-1}  nth(i!2`1, P!1 - 2) = nth(append(nl!1, (: n_last :)), P!1 - 1)
[-2]  P!1 = p
[-3]  length(nl!1) = p - 1
[-4]  length(i!2`1) = P!1 - 1
[-5]  length(i!2`2) = P!1 - 1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!2`2 = cdr(hu_list)
[-9]  cons(i!1, i!2`1) = append(nl!1, (: n_last :))
[-10] u!1 = hu(0)
[-11] 2 <= P!1
  |-------
[1]   nth(i!2`1, P!1 - 2) = n_last

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictinit_init.1.2.2.1.2.2.1.2.1 :  

[-1]  nth(i!2`1, P!1 - 2) = nth(append(nl!1, (: n_last :)), P!1 - 1)
[-2]  P!1 = p
[-3]  length(nl!1) = p - 1
[-4]  length(i!2`1) = P!1 - 1
[-5]  length(i!2`2) = P!1 - 1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!2`2 = cdr(hu_list)
[-9]  cons(i!1, i!2`1) = append(nl!1, (: n_last :))
[-10] u!1 = hu(0)
[-11] 2 <= P!1
  |-------
{1}   nth(append(nl!1, (: n_last :)), P!1 - 1) = n_last

Rerunning step: (rewrite "nth_append" 1)
Found matching substitution:
i: below[length(l1) + length(l2)] gets P!1 - 1,
l2: list[T] gets (: n_last :),
l1: list[T] gets nl!1,
Rewriting using nth_append, matching in 1,
this yields  2 subgoals: 
restrictinit_init.1.2.2.1.2.2.1.2.1.1 :  

{-1}  nth(i!2`1, P!1 - 2) =
       IF P!1 - 1 < length[Identity](nl!1) THEN nth(nl!1, P!1 - 1)
       ELSE nth((: n_last :), P!1 - 1 - length[Identity](nl!1))
       ENDIF
[-2]  P!1 = p
[-3]  length(nl!1) = p - 1
[-4]  length(i!2`1) = P!1 - 1
[-5]  length(i!2`2) = P!1 - 1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!2`2 = cdr(hu_list)
[-9]  cons(i!1, i!2`1) = append(nl!1, (: n_last :))
[-10] u!1 = hu(0)
[-11] 2 <= P!1
  |-------
{1}   IF P!1 - 1 < length[Identity](nl!1) THEN nth(nl!1, P!1 - 1)
      ELSE nth((: n_last :), P!1 - 1 - length[Identity](nl!1))
      ENDIF
       = n_last

Rerunning step: (replace* -2 -3)
Repeatedly applying the replace rule,
this simplifies to: 
restrictinit_init.1.2.2.1.2.2.1.2.1.1 :  

{-1}  nth(i!2`1, p - 2) =
       IF p - 1 < p - 1 THEN nth(nl!1, p - 1)
       ELSE nth((: n_last :), p - 1 - (p - 1))
       ENDIF
[-2]  P!1 = p
[-3]  length(nl!1) = p - 1
{-4}  length(i!2`1) = p - 1
{-5}  length(i!2`2) = p - 1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!2`2 = cdr(hu_list)
[-9]  cons(i!1, i!2`1) = append(nl!1, (: n_last :))
[-10] u!1 = hu(0)
{-11} 2 <= p
  |-------
{1}   IF p - 1 < p - 1 THEN nth(nl!1, p - 1)
      ELSE nth((: n_last :), p - 1 - (p - 1))
      ENDIF
       = n_last

Rerunning step: (delete -)
Deleting some formulas,
this simplifies to: 
restrictinit_init.1.2.2.1.2.2.1.2.1.1 :  

  |-------
[1]   IF p - 1 < p - 1 THEN nth(nl!1, p - 1)
      ELSE nth((: n_last :), p - 1 - (p - 1))
      ENDIF
       = n_last

Rerunning step: (grind)
nth rewrites nth((: n_last :), 0)
  to n_last
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictinit_init.1.2.2.1.2.2.1.2.1.1.

restrictinit_init.1.2.2.1.2.2.1.2.1.2 :  

[-1]  nth(i!2`1, P!1 - 2) = nth(append(nl!1, (: n_last :)), P!1 - 1)
[-2]  P!1 = p
[-3]  length(nl!1) = p - 1
[-4]  length(i!2`1) = P!1 - 1
[-5]  length(i!2`2) = P!1 - 1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!2`2 = cdr(hu_list)
[-9]  cons(i!1, i!2`1) = append(nl!1, (: n_last :))
[-10] u!1 = hu(0)
[-11] 2 <= P!1
  |-------
{1}   P!1 - 1 < length[Identity]((: n_last :)) + length[Identity](nl!1)
[2]   nth(append(nl!1, (: n_last :)), P!1 - 1) = n_last

Rerunning step: (delete -1 -4 -5 -6 -7 -8 -9 -10 -11 2)
Deleting some formulas,
this simplifies to: 
restrictinit_init.1.2.2.1.2.2.1.2.1.2 :  

[-1]  P!1 = p
[-2]  length(nl!1) = p - 1
  |-------
[1]   P!1 - 1 < length[Identity]((: n_last :)) + length[Identity](nl!1)

Rerunning step: (grind)
length rewrites length[Identity]((: :))
  to 0
length rewrites length[Identity]((: n_last :))
  to 1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictinit_init.1.2.2.1.2.2.1.2.1.2.


This completes the proof of restrictinit_init.1.2.2.1.2.2.1.2.1.

restrictinit_init.1.2.2.1.2.2.1.2.2 (TCC):   

[-1]  P!1 = p
[-2]  length(nl!1) = p - 1
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  i!2`2 = cdr(hu_list)
[-8]  cons(i!1, i!2`1) = append(nl!1, (: n_last :))
[-9]  u!1 = hu(0)
[-10] 2 <= P!1
  |-------
{1}   P!1 - 1 < length[Identity](cons[Nonce](i!1, i!2`1))
[2]   nth(i!2`1, P!1 - 2) = n_last

Rerunning step: (expand "length" 1)
Expanding the definition of length,
this simplifies to: 
restrictinit_init.1.2.2.1.2.2.1.2.2 :  

[-1]  P!1 = p
[-2]  length(nl!1) = p - 1
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  i!2`2 = cdr(hu_list)
[-8]  cons(i!1, i!2`1) = append(nl!1, (: n_last :))
[-9]  u!1 = hu(0)
[-10] 2 <= P!1
  |-------
{1}   P!1 - 1 < 1 + length[Identity](i!2`1)
[2]   nth(i!2`1, P!1 - 2) = n_last

Rerunning step: (delete -1 -2 -4 -5 -6 -7 -8 -9 -10 2)
Deleting some formulas,
this simplifies to: 
restrictinit_init.1.2.2.1.2.2.1.2.2 :  

[-1]  length(i!2`1) = P!1 - 1
  |-------
[1]   P!1 - 1 < 1 + length[Identity](i!2`1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictinit_init.1.2.2.1.2.2.1.2.2.


This completes the proof of restrictinit_init.1.2.2.1.2.2.1.2.


This completes the proof of restrictinit_init.1.2.2.1.2.2.1.

restrictinit_init.1.2.2.1.2.2.2 :  

[-1]  length(nl!1) = p - 1
[-2]  length(i!2`1) = P!1 - 1
[-3]  length(i!2`2) = P!1 - 1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  i!2`2 = cdr(hu_list)
[-7]  cons(i!1, i!2`1) = append(nl!1, (: n_last :))
[-8]  u!1 = hu(0)
[-9]  2 <= P!1
  |-------
{1}   P!1 = p
[2]   cons(u!1, i!2`2) = hu_list AND nth(i!2`1, P!1 - 2) = n_last

Rerunning step: (replace -6 -3)
Replacing using formula -6,
this simplifies to: 
restrictinit_init.1.2.2.1.2.2.2 :  

[-1]  length(nl!1) = p - 1
[-2]  length(i!2`1) = P!1 - 1
{-3}  length(cdr(hu_list)) = P!1 - 1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  i!2`2 = cdr(hu_list)
[-7]  cons(i!1, i!2`1) = append(nl!1, (: n_last :))
[-8]  u!1 = hu(0)
[-9]  2 <= P!1
  |-------
[1]   P!1 = p
[2]   cons(u!1, i!2`2) = hu_list AND nth(i!2`1, P!1 - 2) = n_last

Rerunning step: (rewrite "length_cdr" -3)
Found matching substitution:
cons_l: (cons?[T]) gets hu_list,
Rewriting using length_cdr, matching in -3,
this simplifies to: 
restrictinit_init.1.2.2.1.2.2.2 :  

[-1]  length(nl!1) = p - 1
[-2]  length(i!2`1) = P!1 - 1
{-3}  length(hu_list) - 1 = P!1 - 1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  i!2`2 = cdr(hu_list)
[-7]  cons(i!1, i!2`1) = append(nl!1, (: n_last :))
[-8]  u!1 = hu(0)
[-9]  2 <= P!1
  |-------
[1]   P!1 = p
[2]   cons(u!1, i!2`2) = hu_list AND nth(i!2`1, P!1 - 2) = n_last

Rerunning step: (delete -1 -2 -5 -6 -7 -8 -9 2)
Deleting some formulas,
this simplifies to: 
restrictinit_init.1.2.2.1.2.2.2 :  

[-1]  length(hu_list) - 1 = P!1 - 1
[-2]  (length(hu_list) = p)
  |-------
[1]   P!1 = p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictinit_init.1.2.2.1.2.2.2.


This completes the proof of restrictinit_init.1.2.2.1.2.2.


This completes the proof of restrictinit_init.1.2.2.1.2.


This completes the proof of restrictinit_init.1.2.2.1.

restrictinit_init.1.2.2.2 :  

[-1]  rho_init(E(public(u!1), conc(nlist(cons(i!1, i!2`1)), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
{1}   (Stop[event] # R_init) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
{2}   R_init(trans(u!1, car(i!2`2),
                   E(public(car(i!2`2)),
                     conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1)))))
{3}   trans(u!1, car(i!2`2),
            E(public(car(i!2`2)),
              conc(ilist(cons(u!1, cdr(i!2`2))), nlist(i!2`1))))
       >> (Stop[event] # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[4]   R_init(signal(running(0, cons(u!1, i!2`2), nth(i!2`1, P!1 - 2))))

Rerunning step: (delete - 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictinit_init.1.2.2.2 :  

  |-------
[1]   (Stop[event] # R_init) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictinit_init.1.2.2.2.


This completes the proof of restrictinit_init.1.2.2.


This completes the proof of restrictinit_init.1.2.


This completes the proof of restrictinit_init.1.

restrictinit_init.2 :  

[-1]  2 <= P!1
  |-------
{1}   P!1 - 2 < length[Nonce](i!2`1)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, i`1)), ilist(i`2))))
            >>
            (signal(running(0, cons(u!1, i`2), nth(i`1, P!1 - 2))) >>
              (trans(u!1, car(i`2),
                     E(public(car(i`2)),
                       conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
                >> Stop[event]))))
         # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
restrictinit_init.2 :  

[-1]  2 <= P!1
  |-------
[1]   P!1 - 2 < length[Nonce](i!2`1)

Rerunning step: (nonemptylist "i!2`1")
Relating existence of a tail to a list's length,

This completes the proof of restrictinit_init.2.

restrictinit_init.3 :  

[-1]  2 <= P!1
  |-------
{1}   P!1 - 2 < length[Identity](i!2`2)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, i`1)), ilist(i`2))))
            >>
            (signal(running(0, cons(u!1, i`2), nth(i`1, P!1 - 2))) >>
              (trans(u!1, car(i`2),
                     E(public(car(i`2)),
                       conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
                >> Stop[event]))))
         # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
restrictinit_init.3 :  

[-1]  2 <= P!1
  |-------
[1]   P!1 - 2 < length[Identity](i!2`2)

Rerunning step: (nonemptylist "i!2`2")
Relating existence of a tail to a list's length,

This completes the proof of restrictinit_init.3.

restrictinit_init.4 :  

[-1]  2 <= P!1
  |-------
{1}   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!1 :))
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, i`1)), ilist(i`2))))
            >>
            (signal(running(0, cons(u!1, i`2), nth(i`1, P!1 - 2))) >>
              (trans(u!1, car(i`2),
                     E(public(car(i`2)),
                       conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
                >> Stop[event]))))
         # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictinit_init.4 :  

  |-------
[1]   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!1 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!1 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictinit_init.4.

restrictinit_init.5 :  

[-1]  2 <= P!1
  |-------
{1}   cons?[Identity](i!2`2)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, i`1)), ilist(i`2))))
            >>
            (signal(running(0, cons(u!1, i`2), nth(i`1, P!1 - 2))) >>
              (trans(u!1, car(i`2),
                     E(public(car(i`2)),
                       conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
                >> Stop[event]))))
         # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
restrictinit_init.5 :  

[-1]  2 <= P!1
  |-------
[1]   cons?[Identity](i!2`2)

Rerunning step: (nonemptylist "i!2`2")
Relating existence of a tail to a list's length,

This completes the proof of restrictinit_init.5.

restrictinit_init.6 :  

[-1]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!1 :))
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (signal(running(0, cons(u!1, il), nth(nl, P!1 - 2))) >>
              (trans(u!1, car(il),
                     E(public(car(il)),
                       conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                >> Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictinit_init.6 :  

  |-------
[1]   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!1 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!1 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictinit_init.6.

restrictinit_init.7 :  

[-1]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        cons?[Identity](il)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (signal(running(0, cons(u!1, il), nth(nl, P!1 - 2))) >>
              (trans(u!1, car(il),
                     E(public(car(il)),
                       conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                >> Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictinit_init.7 :  

[-1]  2 <= P!1
  |-------
{1}   cons?[Identity](il!1)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!1 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!1, nl)), ilist(il))))
            >>
            (signal(running(0, cons(u!1, il), nth(nl, P!1 - 2))) >>
              (trans(u!1, car(il),
                     E(public(car(il)),
                       conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                >> Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
restrictinit_init.7 :  

[-1]  2 <= P!1
  |-------
[1]   cons?[Identity](il!1)

Rerunning step: (nonemptylist "il!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictinit_init.7.

Q.E.D.


Run time  = 2.58 secs.
Real time = 3.77 secs.
nil
pvs(42): 
Installing rewrite rule sets.singleton_rew (all instances)
restrictinit_middle :  

  |-------
{1}   FORALL (P: nat_from_2, u: Identity):
        P /= 2 =>
         (((Interleave! (k: nat_1_to(P), nnK: Nonces(P, u, k)):
              UROLE_MIDDLE(P, k, u, nnK))
            # R_init)
           |> RankUser(rho_init))

Rerunning step: (auto-rewrite-theory "sets")
Rewriting relative to the theory: sets,
this simplifies to: 
restrictinit_middle :  

  |-------
[1]   FORALL (P: nat_from_2, u: Identity):
        P /= 2 =>
         (((Interleave! (k: nat_1_to(P), nnK: Nonces(P, u, k)):
              UROLE_MIDDLE(P, k, u, nnK))
            # R_init)
           |> RankUser(rho_init))

Rerunning step: (auto-rewrite "n_last_TCC2" "USER_TCC2")
Installing rewrite rule gnsl_last.n_last_TCC2
Installing rewrite rule gnsl_last.USER_TCC2
Installing automatic rewrites from: 
  n_last_TCC2
  USER_TCC2
this simplifies to: 
restrictinit_middle :  

  |-------
[1]   FORALL (P: nat_from_2, u: Identity):
        P /= 2 =>
         (((Interleave! (k: nat_1_to(P), nnK: Nonces(P, u, k)):
              UROLE_MIDDLE(P, k, u, nnK))
            # R_init)
           |> RankUser(rho_init))

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictinit_middle :  

  |-------
{1}   P!1 /= 2 =>
       (((Interleave! (k: nat_1_to(P!1), nnK: Nonces(P!1, u!1, k)):
            UROLE_MIDDLE(P!1, k, u!1, nnK))
          # R_init)
         |> RankUser(rho_init))

Rerunning step: (expand "RankUser")
Expanding the definition of RankUser,
this simplifies to: 
restrictinit_middle :  

  |-------
{1}   P!1 /= 2 =>
       (((Interleave! (k: nat_1_to(P!1), nnK: Nonces(P!1, u!1, k)):
            UROLE_MIDDLE(P!1, k, u!1, nnK))
          # R_init)
         |>
         LAMBDA (tr: list[event]):
           every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(tr) =>
            every(LAMBDA (e: event):
                    complement(rec?)(e) => rho_init(msg(e)))
                 (tr))

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictinit_middle :  

  |-------
{1}   P!1 = 2
{2}   (((Interleave! (k: nat_1_to(P!1), nnK: Nonces(P!1, u!1, k)):
           UROLE_MIDDLE(P!1, k, u!1, nnK))
         # R_init)
        |>
        LAMBDA (tr: list[event]):
          every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(tr) =>
           every(LAMBDA (e: event): complement(rec?)(e) => rho_init(msg(e)))
                (tr))

Rerunning step: (interleaving2)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
USER_TCC2 rewrites EXISTS (x: [k: nat_1_to(P!1), Nonces(P!1, u!1, k)]): TRUE
  to TRUE
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
USER_TCC2 rewrites EXISTS (x: [k: nat_1_to(P!1), Nonces(P!1, u!1, k)]): TRUE
  to TRUE
Applying interleaving rule,
this simplifies to: 
restrictinit_middle :  

  |-------
[1]   P!1 = 2
{2}   UROLE_MIDDLE(P!1, i!1`1, u!1, i!1`2) # R_init |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (typepred "P!1" "i!1`1")
Adding type constraints for  P!1, i!1`1,
this simplifies to: 
restrictinit_middle :  

{-1}  2 <= P!1
{-2}  0 < i!1`1
{-3}  i!1`1 < P!1 - 1
  |-------
[1]   P!1 = 2
[2]   UROLE_MIDDLE(P!1, i!1`1, u!1, i!1`2) # R_init |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (expand "UROLE_MIDDLE")
Expanding the definition of UROLE_MIDDLE,
this simplifies to: 
restrictinit_middle :  

[-1]  2 <= P!1
[-2]  0 < i!1`1
[-3]  i!1`1 < P!1 - 1
  |-------
[1]   P!1 = 2
{2}   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1: {x: list[Identity] | length(x) = i!1`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              (signal(running(i!1`1, append(il1, cons(u!1, il2)),
                              nth(nl2, P!1 - 2 - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (choice3)
Applying choice rule,
this yields  5 subgoals: 
restrictinit_middle.1 :  

[-1]  2 <= P!1
[-2]  0 < i!1`1
[-3]  i!1`1 < P!1 - 1
  |-------
[1]   P!1 = 2
{2}   (rec(u!1, nth(i!2`3, i!1`1 - 1),
           E(public(u!1), conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
        >>
        (trans(u!1, car(i!2`4),
               E(public(car(i!2`4)),
                 conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
          >>
          (rec(u!1, nth(i!2`3, i!1`1 - 1),
               E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
            >>
            (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                            nth(i!2`2, P!1 - 2 - i!1`1)))
              >>
              ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4))
                >> Stop[event])))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictinit_middle.1 :  

{-1}  rho_init(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
{1}   ((trans(u!1, car(i!2`4),
              E(public(car(i!2`4)),
                conc(nlist(append(i!2`1, (: i!1`2 :))),
                     ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
         >>
         (rec(u!1, nth(i!2`3, i!1`1 - 1),
              E(public(u!1),
                conc(ilist(append(i!2`3, i!2`4)),
                     nlist(cons(i!1`2, i!2`2)))))
           >>
           (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                           nth(i!2`2, P!1 - 2 - i!1`1)))
             >>
             ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
               Stop[event]))))
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
{2}   R_init(rec(u!1, nth(i!2`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))))
{3}   rec(u!1, nth(i!2`3, i!1`1 - 1),
          E(public(u!1), conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
       >>
       ((trans(u!1, car(i!2`4),
               E(public(car(i!2`4)),
                 conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
          >>
          (rec(u!1, nth(i!2`3, i!1`1 - 1),
               E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
            >>
            (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                            nth(i!2`2, P!1 - 2 - i!1`1)))
              >>
              ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4))
                >> Stop[event]))))
         # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[4]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_middle.1 :  

[-1]  rho_init(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
[1]   ((trans(u!1, car(i!2`4),
              E(public(car(i!2`4)),
                conc(nlist(append(i!2`1, (: i!1`2 :))),
                     ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
         >>
         (rec(u!1, nth(i!2`3, i!1`1 - 1),
              E(public(u!1),
                conc(ilist(append(i!2`3, i!2`4)),
                     nlist(cons(i!1`2, i!2`2)))))
           >>
           (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                           nth(i!2`2, P!1 - 2 - i!1`1)))
             >>
             ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
               Stop[event]))))
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[2]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictinit_middle.1.1 :  

[-1]  rho_init(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
{1}   rho_init(E(public(car(i!2`4)),
                 conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
{2}   R_init(trans(u!1, car(i!2`4),
                   E(public(car(i!2`4)),
                     conc(nlist(append(i!2`1, (: i!1`2 :))),
                          ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))))
{3}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(nlist(append(i!2`1, (: i!1`2 :))),
                   ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
       >>
       ((rec(u!1, nth(i!2`3, i!1`1 - 1),
             E(public(u!1),
               conc(ilist(append(i!2`3, i!2`4)),
                    nlist(cons(i!1`2, i!2`2)))))
          >>
          (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                          nth(i!2`2, P!1 - 2 - i!1`1)))
            >>
            ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
              Stop[event])))
         # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[4]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_middle.1.1 :  

[-1]  rho_init(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
[1]   rho_init(E(public(car(i!2`4)),
                 conc(nlist(append(i!2`1, (: i!1`2 :))),
                      ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   P!1 = 2

Rerunning step: (expand "E")
Expanding the definition of E,
this simplifies to: 
restrictinit_middle.1.1 :  

{-1}  rho_init(code(public(u!1),
                    conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
{1}   rho_init(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   P!1 = 2

Rerunning step: (expand "rho_init" -1)
Expanding the definition of rho_init,
this simplifies to: 
restrictinit_middle.1.1 :  

{-1}  rho_init(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))) OR
       (public(u!1) = public(hu(0)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
           conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
            conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
[1]   rho_init(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   P!1 = 2

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
restrictinit_middle.1.1.1 :  

{-1}  rho_init(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
[1]   rho_init(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   P!1 = 2

Rerunning step: (typepred "i!1`2")
Adding type constraints for  i!1`2,
this simplifies to: 
restrictinit_middle.1.1.1 :  

{-1}  IRpart(P!1, u!1, i!1`1)(i!1`2)
[-2]  rho_init(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
[1]   rho_init(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   P!1 = 2

Rerunning step: (lemma "n_prop" ("P" "P!1" "u" "u!1" "r" "i!1`1"))
Applying n_prop where 
  P gets P!1,
  u gets u!1,
  r gets i!1`1,
this simplifies to: 
restrictinit_middle.1.1.1 :  

{-1}  (P!1 /= p OR i!1`1 /= p - 1) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, i!1`1)(n_last)
[-2]  IRpart(P!1, u!1, i!1`1)(i!1`2)
[-3]  rho_init(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
[-4]  2 <= P!1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
  |-------
[1]   rho_init(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   P!1 = 2

Rerunning step: (lemma "listprops[Nonce].elt_append3"
                 ("l1" "i!2`1" "l2" "(:i!1`2:)" "t" "n_last"))
Applying listprops[Nonce].elt_append3 where 
  l1 gets i!2`1,
  l2 gets (: i!1`2 :),
  t gets n_last,
this simplifies to: 
restrictinit_middle.1.1.1 :  

{-1}  elt(append(i!2`1, (: i!1`2 :)), n_last) IMPLIES
       elt(i!2`1, n_last) OR elt((: i!1`2 :), n_last)
[-2]  (P!1 /= p OR i!1`1 /= p - 1) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, i!1`1)(n_last)
[-3]  IRpart(P!1, u!1, i!1`1)(i!1`2)
[-4]  rho_init(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
[-5]  2 <= P!1
[-6]  0 < i!1`1
[-7]  i!1`1 < P!1 - 1
  |-------
[1]   rho_init(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   P!1 = 2

Rerunning step: (lemma "listprops[Nonce].elt_singleton"
                 ("t1" "i!1`2" "t2" "n_last"))
Applying listprops[Nonce].elt_singleton where 
  t1 gets i!1`2,
  t2 gets n_last,
this simplifies to: 
restrictinit_middle.1.1.1 :  

{-1}  elt((: i!1`2 :), n_last) IFF i!1`2 = n_last
[-2]  elt(append(i!2`1, (: i!1`2 :)), n_last) IMPLIES
       elt(i!2`1, n_last) OR elt((: i!1`2 :), n_last)
[-3]  (P!1 /= p OR i!1`1 /= p - 1) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, i!1`1)(n_last)
[-4]  IRpart(P!1, u!1, i!1`1)(i!1`2)
[-5]  rho_init(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
[-6]  2 <= P!1
[-7]  0 < i!1`1
[-8]  i!1`1 < P!1 - 1
  |-------
[1]   rho_init(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   P!1 = 2

Rerunning step: (grind :if-match nil :exclude "elt")
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
/= rewrites P!1 /= p
  to NOT (P!1 = p)
/= rewrites i!1`1 /= p - 1
  to TRUE
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
rho_init rewrites rho_init(nlist(i!2`1))
  to FALSE
rho_init rewrites rho_init(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_init rewrites rho_init(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
  to FALSE
/= rewrites P!1 /= p
  to NOT (P!1 = p)
/= rewrites i!1`1 /= p - 1
  to TRUE
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
rho_init rewrites rho_init(nlist(i!2`1))
  to NOT elt(i!2`1, n_last)
rho_init rewrites rho_init(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_init rewrites rho_init(conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))))
  to NOT elt(i!2`1, n_last)
rho_init rewrites rho_init(nlist(append(i!2`1, (: i!1`2 :))))
  to TRUE
rho_init rewrites rho_init(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
  to TRUE
rho_init rewrites 
  rho_init(conc(nlist(append(i!2`1, (: i!1`2 :))),
                ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))
  to TRUE
rho_init rewrites 
  rho_init(code(public(car(i!2`4)),
                conc(nlist(append(i!2`1, (: i!1`2 :))),
                     ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
  to TRUE
/= rewrites P!1 /= p
  to NOT (P!1 = p)
/= rewrites i!1`1 /= p - 1
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictinit_middle.1.1.1.

restrictinit_middle.1.1.2 :  

{-1}  (public(u!1) = public(hu(0)) AND
        EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
          conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
           conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
[1]   rho_init(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   P!1 = 2

Rerunning step: (comment "contradiction in -1")
Adding comment: contradiction in -1
this simplifies to: 
restrictinit_middle.1.1.2 : 
;;; contradiction in -1

[-1]  (public(u!1) = public(hu(0)) AND
        EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
          conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
           conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
[1]   rho_init(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   P!1 = 2

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictinit_middle.1.1.2 : 
;;; contradiction in -1

{-1}  public(u!1) = public(hu(0))
{-2}  conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4))) =
       conc(nlist(append(nl!1, (: n_last :))), ilist(cdr(hu_list)))
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
[1]   rho_init(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   P!1 = 2

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictinit_middle.1.1.2 : 
;;; contradiction in -1

{-1}  nlist(i!2`1) = nlist(append(nl!1, (: n_last :)))
{-2}  ilist(append(i!2`3, i!2`4)) = ilist(cdr(hu_list))
[-3]  public(u!1) = public(hu(0))
[-4]  2 <= P!1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
  |-------
[1]   rho_init(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   P!1 = 2

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictinit_middle.1.1.2 : 
;;; contradiction in -1

{-1}  i!2`1 = append(nl!1, (: n_last :))
[-2]  ilist(append(i!2`3, i!2`4)) = ilist(cdr(hu_list))
[-3]  public(u!1) = public(hu(0))
[-4]  2 <= P!1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
  |-------
[1]   rho_init(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   P!1 = 2

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictinit_middle.1.1.2 : 
;;; contradiction in -1

{-1}  append(i!2`3, i!2`4) = cdr(hu_list)
[-2]  i!2`1 = append(nl!1, (: n_last :))
[-3]  public(u!1) = public(hu(0))
[-4]  2 <= P!1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
  |-------
[1]   rho_init(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   P!1 = 2

Rerunning step: (typepred "i!2`1" "i!2`3" "i!2`4" "nl!1" "hu_list")
Adding type constraints for  i!2`1, i!2`3, i!2`4, nl!1, hu_list,
this simplifies to: 
restrictinit_middle.1.1.2 : 
;;; contradiction in -1

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`1)
{-2}  length(i!2`1) = i!1`1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`3)
{-4}  length(i!2`3) = i!1`1
{-5}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`4)
{-6}  length(i!2`4) = P!1 - 1 - i!1`1
{-7}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl!1)
{-8}  length(nl!1) = p - 1
{-9}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-10} (length(hu_list) = p)
{-11} FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] append(i!2`3, i!2`4) = cdr(hu_list)
[-13] i!2`1 = append(nl!1, (: n_last :))
[-14] public(u!1) = public(hu(0))
[-15] 2 <= P!1
[-16] 0 < i!1`1
[-17] i!1`1 < P!1 - 1
  |-------
[1]   rho_init(code(public(car(i!2`4)),
                    conc(nlist(append(i!2`1, (: i!1`2 :))),
                         ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
[2]   P!1 = 2

Rerunning step: (delete -1 -3 -5 -7 -9 -14 +)
Deleting some formulas,
this simplifies to: 
restrictinit_middle.1.1.2 : 
;;; contradiction in -1

[-1]  length(i!2`1) = i!1`1
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  length(nl!1) = p - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  append(i!2`3, i!2`4) = cdr(hu_list)
[-8]  i!2`1 = append(nl!1, (: n_last :))
[-9]  2 <= P!1
[-10] 0 < i!1`1
[-11] i!1`1 < P!1 - 1
  |-------

Rerunning step: (case "P!1=p")
Case splitting on 
   P!1 = p, 
this yields  2 subgoals: 
restrictinit_middle.1.1.2.1 : 
;;; contradiction in -1

{-1}  P!1 = p
[-2]  length(i!2`1) = i!1`1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  length(nl!1) = p - 1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = cdr(hu_list)
[-9]  i!2`1 = append(nl!1, (: n_last :))
[-10] 2 <= P!1
[-11] 0 < i!1`1
[-12] i!1`1 < P!1 - 1
  |-------

Rerunning step: (replace -9 -2)
Replacing using formula -9,
this simplifies to: 
restrictinit_middle.1.1.2.1 : 
;;; contradiction in -1

[-1]  P!1 = p
{-2}  length(append(nl!1, (: n_last :))) = i!1`1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  length(nl!1) = p - 1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = cdr(hu_list)
[-9]  i!2`1 = append(nl!1, (: n_last :))
[-10] 2 <= P!1
[-11] 0 < i!1`1
[-12] i!1`1 < P!1 - 1
  |-------

Rerunning step: (rewrite "length_append" -2)
Found matching substitution:
l2: list[T] gets (: n_last :),
l1: list[T] gets nl!1,
Rewriting using length_append, matching in -2,
this simplifies to: 
restrictinit_middle.1.1.2.1 : 
;;; contradiction in -1

[-1]  P!1 = p
{-2}  length((: n_last :)) + length(nl!1) = i!1`1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  length(nl!1) = p - 1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = cdr(hu_list)
[-9]  i!2`1 = append(nl!1, (: n_last :))
[-10] 2 <= P!1
[-11] 0 < i!1`1
[-12] i!1`1 < P!1 - 1
  |-------

Rerunning step: (delete -3 -4 -6 -7 -8 -9 -10 -11)
Deleting some formulas,
this simplifies to: 
restrictinit_middle.1.1.2.1 : 
;;; contradiction in -1

[-1]  P!1 = p
[-2]  length((: n_last :)) + length(nl!1) = i!1`1
[-3]  length(nl!1) = p - 1
[-4]  i!1`1 < P!1 - 1
  |-------

Rerunning step: (grind)
length rewrites length[Nonce]((: :))
  to 0
length rewrites length((: n_last :))
  to 1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictinit_middle.1.1.2.1.

restrictinit_middle.1.1.2.2 : 
;;; contradiction in -1

[-1]  length(i!2`1) = i!1`1
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  length(nl!1) = p - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  append(i!2`3, i!2`4) = cdr(hu_list)
[-8]  i!2`1 = append(nl!1, (: n_last :))
[-9]  2 <= P!1
[-10] 0 < i!1`1
[-11] i!1`1 < P!1 - 1
  |-------
{1}   P!1 = p

Rerunning step: (lemma "listprops[Identity].equality_length"
                 ("l1" "append(i!2`3,i!2`4)" "l2" "cdr(hu_list)"))
Applying listprops[Identity].equality_length where 
  l1 gets append(i!2`3, i!2`4),
  l2 gets cdr(hu_list),
this simplifies to: 
restrictinit_middle.1.1.2.2 : 
;;; contradiction in -1

{-1}  append(i!2`3, i!2`4) = cdr(hu_list) IMPLIES
       length[Identity](append(i!2`3, i!2`4)) =
        length[Identity](cdr(hu_list))
[-2]  length(i!2`1) = i!1`1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  length(nl!1) = p - 1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = cdr(hu_list)
[-9]  i!2`1 = append(nl!1, (: n_last :))
[-10] 2 <= P!1
[-11] 0 < i!1`1
[-12] i!1`1 < P!1 - 1
  |-------
[1]   P!1 = p

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictinit_middle.1.1.2.2 : 
;;; contradiction in -1

{-1}  length[Identity](append(i!2`3, i!2`4)) =
       length[Identity](cdr(hu_list))
[-2]  length(i!2`1) = i!1`1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  length(nl!1) = p - 1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = cdr(hu_list)
[-9]  i!2`1 = append(nl!1, (: n_last :))
[-10] 2 <= P!1
[-11] 0 < i!1`1
[-12] i!1`1 < P!1 - 1
  |-------
[1]   P!1 = p

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets i!2`4,
l1: list[T] gets i!2`3,
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictinit_middle.1.1.2.2 : 
;;; contradiction in -1

{-1}  length(i!2`3) + length(i!2`4) = length[Identity](cdr(hu_list))
[-2]  length(i!2`1) = i!1`1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  length(nl!1) = p - 1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = cdr(hu_list)
[-9]  i!2`1 = append(nl!1, (: n_last :))
[-10] 2 <= P!1
[-11] 0 < i!1`1
[-12] i!1`1 < P!1 - 1
  |-------
[1]   P!1 = p

Rerunning step: (rewrite "length_cdr" -1)
Found matching substitution:
cons_l: (cons?[T]) gets hu_list,
Rewriting using length_cdr, matching in -1,
this simplifies to: 
restrictinit_middle.1.1.2.2 : 
;;; contradiction in -1

{-1}  length(i!2`3) + length(i!2`4) = length(hu_list) - 1
[-2]  length(i!2`1) = i!1`1
[-3]  length(i!2`3) = i!1`1
[-4]  length(i!2`4) = P!1 - 1 - i!1`1
[-5]  length(nl!1) = p - 1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!2`3, i!2`4) = cdr(hu_list)
[-9]  i!2`1 = append(nl!1, (: n_last :))
[-10] 2 <= P!1
[-11] 0 < i!1`1
[-12] i!1`1 < P!1 - 1
  |-------
[1]   P!1 = p

Rerunning step: (delete -2 -5 -7 -8 -9 -10 -11 -12)
Deleting some formulas,
this simplifies to: 
restrictinit_middle.1.1.2.2 : 
;;; contradiction in -1

[-1]  length(i!2`3) + length(i!2`4) = length(hu_list) - 1
[-2]  length(i!2`3) = i!1`1
[-3]  length(i!2`4) = P!1 - 1 - i!1`1
[-4]  (length(hu_list) = p)
  |-------
[1]   P!1 = p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictinit_middle.1.1.2.2.


This completes the proof of restrictinit_middle.1.1.2.


This completes the proof of restrictinit_middle.1.1.

restrictinit_middle.1.2 :  

[-1]  rho_init(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
{1}   ((rec(u!1, nth(i!2`3, i!1`1 - 1),
            E(public(u!1),
              conc(ilist(append(i!2`3, i!2`4)),
                   nlist(cons(i!1`2, i!2`2)))))
         >>
         (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                         nth(i!2`2, P!1 - 2 - i!1`1)))
           >>
           ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
             Stop[event])))
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
{2}   R_init(trans(u!1, car(i!2`4),
                   E(public(car(i!2`4)),
                     conc(nlist(append(i!2`1, (: i!1`2 :))),
                          ilist(append(i!2`3, cons(u!1, cdr(i!2`4))))))))
{3}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(nlist(append(i!2`1, (: i!1`2 :))),
                   ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))))
       >>
       ((rec(u!1, nth(i!2`3, i!1`1 - 1),
             E(public(u!1),
               conc(ilist(append(i!2`3, i!2`4)),
                    nlist(cons(i!1`2, i!2`2)))))
          >>
          (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                          nth(i!2`2, P!1 - 2 - i!1`1)))
            >>
            ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
              Stop[event])))
         # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[4]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_middle.1.2 :  

[-1]  rho_init(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
[1]   ((rec(u!1, nth(i!2`3, i!1`1 - 1),
            E(public(u!1),
              conc(ilist(append(i!2`3, i!2`4)),
                   nlist(cons(i!1`2, i!2`2)))))
         >>
         (signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                         nth(i!2`2, P!1 - 2 - i!1`1)))
           >>
           ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
             Stop[event])))
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[2]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictinit_middle.1.2 :  

{-1}  rho_init(E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
[-2]  rho_init(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
{1}   ((signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                       nth(i!2`2, P!1 - 2 - i!1`1)))
         >>
         ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
           Stop[event]))
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
{2}   R_init(rec(u!1, nth(i!2`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i!2`3, i!2`4)),
                        nlist(cons(i!1`2, i!2`2))))))
{3}   rec(u!1, nth(i!2`3, i!1`1 - 1),
          E(public(u!1),
            conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2)))))
       >>
       ((signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                        nth(i!2`2, P!1 - 2 - i!1`1)))
          >>
          ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
            Stop[event]))
         # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[4]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_middle.1.2 :  

[-1]  rho_init(E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
[-2]  rho_init(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
[1]   ((signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                       nth(i!2`2, P!1 - 2 - i!1`1)))
         >>
         ((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
           Stop[event]))
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[2]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictinit_middle.1.2.1 :  

[-1]  rho_init(E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
[-2]  rho_init(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
{1}   rho_init(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                       nth(i!2`2, P!1 - 2 - i!1`1)))
{2}   R_init(signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                            nth(i!2`2, P!1 - 2 - i!1`1))))
{3}   signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                     nth(i!2`2, P!1 - 2 - i!1`1)))
       >>
       (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
          Stop[event])
         # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[4]   P!1 = 2

Rerunning step: (delete - 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictinit_middle.1.2.1 :  

  |-------
[1]   rho_init(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                       nth(i!2`2, P!1 - 2 - i!1`1)))

Rerunning step: (expand "rho_init")
Expanding the definition of rho_init,
this simplifies to: 
restrictinit_middle.1.2.1 :  

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictinit_middle.1.2.1.

restrictinit_middle.1.2.2 :  

[-1]  rho_init(E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
[-2]  rho_init(E(public(u!1),
                 conc(nlist(i!2`1), ilist(append(i!2`3, i!2`4)))))
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
{1}   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
{2}   R_init(signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                            nth(i!2`2, P!1 - 2 - i!1`1))))
{3}   signal(running(i!1`1, append(i!2`3, cons(u!1, i!2`4)),
                     nth(i!2`2, P!1 - 2 - i!1`1)))
       >>
       (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
          Stop[event])
         # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[4]   P!1 = 2

Rerunning step: (delete -2 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_middle.1.2.2 :  

[-1]  rho_init(E(public(u!1),
                 conc(ilist(append(i!2`3, i!2`4)),
                      nlist(cons(i!1`2, i!2`2)))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[2]   P!1 = 2

Rerunning step: (expand "E")
Expanding the definition of E,
this simplifies to: 
restrictinit_middle.1.2.2 :  

{-1}  rho_init(code(public(u!1),
                    conc(ilist(append(i!2`3, i!2`4)),
                         nlist(cons(i!1`2, i!2`2)))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[2]   P!1 = 2

Rerunning step: (expand "rho_init" -1)
Expanding the definition of rho_init,
this simplifies to: 
restrictinit_middle.1.2.2 :  

{-1}  rho_init(conc(ilist(append(i!2`3, i!2`4)),
                    nlist(cons(i!1`2, i!2`2))))
       OR
       (public(u!1) = public(hu(0)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
           conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
            conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[2]   P!1 = 2

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
restrictinit_middle.1.2.2.1 :  

{-1}  rho_init(conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[2]   P!1 = 2

Rerunning step: (expand "LastMessage")
Expanding the definition of LastMessage,
this simplifies to: 
restrictinit_middle.1.2.2.1 :  

[-1]  rho_init(conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
{1}   ((IF i!1`1 = P!1 - 2
          THEN trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2)))
        ELSE trans(u!1, car(i!2`4),
                   E(public(car(i!2`4)),
                     conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                          nlist(i!2`2))))
        ENDIF
         >> Stop[event])
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[2]   P!1 = 2

Rerunning step: (lift-if)
Lifting IF-conditions to the top level,
this simplifies to: 
restrictinit_middle.1.2.2.1 :  

[-1]  rho_init(conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
{1}   IF i!1`1 = P!1 - 2
        THEN ((trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2)))
                >> Stop[event])
               # R_init)
              |>
              LAMBDA (t: list[event]):
                every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
                 every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))
                      (t)
      ELSE ((trans(u!1, car(i!2`4),
                   E(public(car(i!2`4)),
                     conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                          nlist(i!2`2))))
              >> Stop[event])
             # R_init)
            |>
            LAMBDA (t: list[event]):
              every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
               every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
      ENDIF
[2]   P!1 = 2

Rerunning step: (prop)
Applying propositional simplification,
this yields  2 subgoals: 
restrictinit_middle.1.2.2.1.1 :  

{-1}  i!1`1 = P!1 - 2
[-2]  rho_init(conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
{1}   ((trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))) >>
         Stop[event])
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[2]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictinit_middle.1.2.2.1.1.1 :  

[-1]  i!1`1 = P!1 - 2
[-2]  rho_init(conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
{1}   rho_init(E(public(car(i!2`4)), nlist(i!2`2)))
{2}   R_init(trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))))
{3}   trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))) >>
       (Stop[event] # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[4]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_middle.1.2.2.1.1.1 :  

[-1]  i!1`1 = P!1 - 2
[-2]  rho_init(conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
[1]   rho_init(E(public(car(i!2`4)), nlist(i!2`2)))
[2]   P!1 = 2

Rerunning step: (lemma "listprops[Nonce].elt_append2"
                 ("l1" "(:i!1`2:)" "l2" "i!2`2" "t" "n_last"))
Applying listprops[Nonce].elt_append2 where 
  l1 gets (: i!1`2 :),
  l2 gets i!2`2,
  t gets n_last,
this simplifies to: 
restrictinit_middle.1.2.2.1.1.1 :  

{-1}  elt(i!2`2, n_last) IMPLIES elt(append((: i!1`2 :), i!2`2), n_last)
[-2]  i!1`1 = P!1 - 2
[-3]  rho_init(conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
[-4]  2 <= P!1
[-5]  0 < i!1`1
[-6]  i!1`1 < P!1 - 1
  |-------
[1]   rho_init(E(public(car(i!2`4)), nlist(i!2`2)))
[2]   P!1 = 2

Rerunning step: (grind :if-match nil :exclude "elt")
append rewrites append((: :), i!2`2)
  to i!2`2
append rewrites append((: i!1`2 :), i!2`2)
  to cons(i!1`2, i!2`2)
E rewrites E(public(car(i!2`4)), nlist(i!2`2))
  to code(public(car(i!2`4)), nlist(i!2`2))
rho_init rewrites rho_init(nlist(i!2`2))
  to NOT elt(i!2`2, n_last)
rho_init rewrites rho_init(code(public(car(i!2`4)), nlist(i!2`2)))
  to NOT elt(i!2`2, n_last)
rho_init rewrites rho_init(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_init rewrites rho_init(nlist(cons(i!1`2, i!2`2)))
  to FALSE
rho_init rewrites 
  rho_init(conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
  to FALSE
E rewrites E(public(car(i!2`4)), nlist(i!2`2))
  to code(public(car(i!2`4)), nlist(i!2`2))
rho_init rewrites rho_init(nlist(i!2`2))
  to TRUE
rho_init rewrites rho_init(code(public(car(i!2`4)), nlist(i!2`2)))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictinit_middle.1.2.2.1.1.1.

restrictinit_middle.1.2.2.1.1.2 :  

[-1]  i!1`1 = P!1 - 2
[-2]  rho_init(conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
{1}   (Stop[event] # R_init) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
{2}   R_init(trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))))
{3}   trans(u!1, car(i!2`4), E(public(car(i!2`4)), nlist(i!2`2))) >>
       (Stop[event] # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[4]   P!1 = 2

Rerunning step: (delete - 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictinit_middle.1.2.2.1.1.2 :  

  |-------
[1]   (Stop[event] # R_init) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictinit_middle.1.2.2.1.1.2.


This completes the proof of restrictinit_middle.1.2.2.1.1.

restrictinit_middle.1.2.2.1.2 :  

[-1]  rho_init(conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
{1}   i!1`1 = P!1 - 2
{2}   ((trans(u!1, car(i!2`4),
              E(public(car(i!2`4)),
                conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                     nlist(i!2`2))))
         >> Stop[event])
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[3]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictinit_middle.1.2.2.1.2.1 :  

[-1]  rho_init(conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
{1}   rho_init(E(public(car(i!2`4)),
                 conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                      nlist(i!2`2))))
{2}   R_init(trans(u!1, car(i!2`4),
                   E(public(car(i!2`4)),
                     conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                          nlist(i!2`2)))))
{3}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                   nlist(i!2`2))))
       >> (Stop[event] # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[4]   i!1`1 = P!1 - 2
[5]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_middle.1.2.2.1.2.1 :  

[-1]  rho_init(conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
[1]   rho_init(E(public(car(i!2`4)),
                 conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                      nlist(i!2`2))))
[2]   i!1`1 = P!1 - 2
[3]   P!1 = 2

Rerunning step: (lemma "listprops[Nonce].elt_append2"
                 ("l1" "(:i!1`2:)" "l2" "i!2`2" "t" "n_last"))
Applying listprops[Nonce].elt_append2 where 
  l1 gets (: i!1`2 :),
  l2 gets i!2`2,
  t gets n_last,
this simplifies to: 
restrictinit_middle.1.2.2.1.2.1 :  

{-1}  elt(i!2`2, n_last) IMPLIES elt(append((: i!1`2 :), i!2`2), n_last)
[-2]  rho_init(conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
[1]   rho_init(E(public(car(i!2`4)),
                 conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                      nlist(i!2`2))))
[2]   i!1`1 = P!1 - 2
[3]   P!1 = 2

Rerunning step: (grind :if-match nil :exclude "elt")
append rewrites append((: :), i!2`2)
  to i!2`2
append rewrites append((: i!1`2 :), i!2`2)
  to cons(i!1`2, i!2`2)
E rewrites 
  E(public(car(i!2`4)),
    conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)))
  to code(public(car(i!2`4)),
           conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)))
rho_init rewrites rho_init(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
  to TRUE
rho_init rewrites rho_init(nlist(i!2`2))
  to NOT elt(i!2`2, n_last)
rho_init rewrites 
  rho_init(conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)))
  to NOT elt(i!2`2, n_last)
rho_init rewrites 
  rho_init(code(public(car(i!2`4)),
                conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                     nlist(i!2`2))))
  to NOT elt(i!2`2, n_last) OR
       (public(car(i!2`4)) = public(hu(0)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
           conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2))
            = conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
rho_init rewrites rho_init(ilist(append(i!2`3, i!2`4)))
  to TRUE
rho_init rewrites rho_init(nlist(cons(i!1`2, i!2`2)))
  to FALSE
rho_init rewrites 
  rho_init(conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
  to FALSE
E rewrites 
  E(public(car(i!2`4)),
    conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)))
  to code(public(car(i!2`4)),
           conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)))
rho_init rewrites rho_init(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))))
  to TRUE
rho_init rewrites rho_init(nlist(i!2`2))
  to TRUE
rho_init rewrites 
  rho_init(conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))), nlist(i!2`2)))
  to TRUE
rho_init rewrites 
  rho_init(code(public(car(i!2`4)),
                conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                     nlist(i!2`2))))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictinit_middle.1.2.2.1.2.1.

restrictinit_middle.1.2.2.1.2.2 :  

[-1]  rho_init(conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
{1}   (Stop[event] # R_init) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
{2}   R_init(trans(u!1, car(i!2`4),
                   E(public(car(i!2`4)),
                     conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                          nlist(i!2`2)))))
{3}   trans(u!1, car(i!2`4),
            E(public(car(i!2`4)),
              conc(ilist(append(i!2`3, cons(u!1, cdr(i!2`4)))),
                   nlist(i!2`2))))
       >> (Stop[event] # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[4]   i!1`1 = P!1 - 2
[5]   P!1 = 2

Rerunning step: (delete - 2 3 4 5)
Deleting some formulas,
this simplifies to: 
restrictinit_middle.1.2.2.1.2.2 :  

  |-------
[1]   (Stop[event] # R_init) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictinit_middle.1.2.2.1.2.2.


This completes the proof of restrictinit_middle.1.2.2.1.2.


This completes the proof of restrictinit_middle.1.2.2.1.

restrictinit_middle.1.2.2.2 :  

{-1}  (public(u!1) = public(hu(0)) AND
        EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
          conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
           conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[2]   P!1 = 2

Rerunning step: (comment "contradiction in -1")
Adding comment: contradiction in -1
this simplifies to: 
restrictinit_middle.1.2.2.2 : 
;;; contradiction in -1

[-1]  (public(u!1) = public(hu(0)) AND
        EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
          conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
           conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
[-2]  2 <= P!1
[-3]  0 < i!1`1
[-4]  i!1`1 < P!1 - 1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[2]   P!1 = 2

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictinit_middle.1.2.2.2 : 
;;; contradiction in -1

{-1}  public(u!1) = public(hu(0))
{-2}  EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
        conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
         conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list)))
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[2]   P!1 = 2

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictinit_middle.1.2.2.2 : 
;;; contradiction in -1

[-1]  public(u!1) = public(hu(0))
{-2}  conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
       conc(nlist(append(nl!1, (: n_last :))), ilist(cdr(hu_list)))
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
[1]   (((LastMessage(P!1, i!1`1, u!1, i!2`1, i!2`2, i!2`3, i!2`4)) >>
         Stop[event])
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[2]   P!1 = 2

Rerunning step: (delete -1 -3 -4 -5 +)
Deleting some formulas,
this simplifies to: 
restrictinit_middle.1.2.2.2 : 
;;; contradiction in -1

[-1]  conc(ilist(append(i!2`3, i!2`4)), nlist(cons(i!1`2, i!2`2))) =
       conc(nlist(append(nl!1, (: n_last :))), ilist(cdr(hu_list)))
  |-------

Rerunning step: (decompose-equality -1)
Applying decompose-equality,

This completes the proof of restrictinit_middle.1.2.2.2.


This completes the proof of restrictinit_middle.1.2.2.


This completes the proof of restrictinit_middle.1.2.


This completes the proof of restrictinit_middle.1.

restrictinit_middle.2 :  

[-1]  2 <= P!1
[-2]  0 < i!1`1
[-3]  i!1`1 < P!1 - 1
  |-------
{1}   P!1 - 2 - i!1`1 < length[Nonce](i!2`2)
[2]   P!1 = 2
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!1`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!1`2, i`2)))))
              >>
              (signal(running(i!1`1, append(i`3, cons(u!1, i`4)),
                              nth(i`2, P!1 - 2 - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (typepred "i!2`2")
Adding type constraints for  i!2`2,
this simplifies to: 
restrictinit_middle.2 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`2)
{-2}  length(i!2`2) = P!1 - 1 - i!1`1
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
[1]   P!1 - 2 - i!1`1 < length[Nonce](i!2`2)
[2]   P!1 = 2
[3]   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!1`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!1`2, i`2)))))
              >>
              (signal(running(i!1`1, append(i`3, cons(u!1, i`4)),
                              nth(i`2, P!1 - 2 - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete -1 -3 -4 -5 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_middle.2 :  

[-1]  length(i!2`2) = P!1 - 1 - i!1`1
  |-------
[1]   P!1 - 2 - i!1`1 < length[Nonce](i!2`2)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictinit_middle.2.

restrictinit_middle.3 :  

[-1]  2 <= P!1
[-2]  0 < i!1`1
[-3]  i!1`1 < P!1 - 1
  |-------
{1}   cons?[Identity](i!2`4)
[2]   P!1 = 2
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!1`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!1`2, i`2)))))
              >>
              (signal(running(i!1`1, append(i`3, cons(u!1, i`4)),
                              nth(i`2, P!1 - 2 - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete -2 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_middle.3 :  

[-1]  2 <= P!1
[-2]  i!1`1 < P!1 - 1
  |-------
[1]   cons?[Identity](i!2`4)

Rerunning step: (nonemptylist "i!2`4")
Relating existence of a tail to a list's length,

This completes the proof of restrictinit_middle.3.

restrictinit_middle.4 :  

[-1]  2 <= P!1
[-2]  0 < i!1`1
[-3]  i!1`1 < P!1 - 1
  |-------
{1}   i!1`1 - 1 < length[Identity](i!2`3)
[2]   P!1 = 2
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!1`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!1`2, i`2)))))
              >>
              (signal(running(i!1`1, append(i`3, cons(u!1, i`4)),
                              nth(i`2, P!1 - 2 - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (typepred "i!2`3")
Adding type constraints for  i!2`3,
this simplifies to: 
restrictinit_middle.4 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`3)
{-2}  length(i!2`3) = i!1`1
[-3]  2 <= P!1
[-4]  0 < i!1`1
[-5]  i!1`1 < P!1 - 1
  |-------
[1]   i!1`1 - 1 < length[Identity](i!2`3)
[2]   P!1 = 2
[3]   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!1`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
                  {x: list[Identity] | length(x) = i!1`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}]):
        (rec(u!1, nth(i`3, i!1`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!1`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!1`2, i`2)))))
              >>
              (signal(running(i!1`1, append(i`3, cons(u!1, i`4)),
                              nth(i`2, P!1 - 2 - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete -1 -3 -4 -5 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_middle.4 :  

[-1]  length(i!2`3) = i!1`1
  |-------
[1]   i!1`1 - 1 < length[Identity](i!2`3)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictinit_middle.4.

restrictinit_middle.5 :  

[-1]  2 <= P!1
[-2]  0 < i!1`1
[-3]  i!1`1 < P!1 - 1
  |-------
{1}   FORALL (nl1: {x: list[Nonce] | length[Nonce](x) = i!1`1},
              nl2: {x: list[Nonce] | length[Nonce](x) = P!1 - 1 - i!1`1},
              il1: {x: list[Identity] | length[Identity](x) = i!1`1},
              il2:
                {x: list[Identity] |
                   length[Identity](x) = P!1 - 1 - i!1`1}):
        cons?[Identity](il2)
[2]   P!1 = 2
[3]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1: {x: list[Identity] | length(x) = i!1`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              (signal(running(i!1`1, append(il1, cons(u!1, il2)),
                              nth(nl2, P!1 - 2 - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictinit_middle.5 :  

[-1]  2 <= P!1
[-2]  0 < i!1`1
[-3]  i!1`1 < P!1 - 1
  |-------
{1}   cons?[Identity](il2!1)
[2]   P!1 = 2
[3]   Choice! (nl1: {x: list[Nonce] | length(x) = i!1`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!1`1},
               il1: {x: list[Identity] | length(x) = i!1`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!1`1}):
        (rec(u!1, nth(il1, i!1`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!1`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!1`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!1`2, nl2)))))
              >>
              (signal(running(i!1`1, append(il1, cons(u!1, il2)),
                              nth(nl2, P!1 - 2 - i!1`1)))
                >>
                ((LastMessage(P!1, i!1`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete -2 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_middle.5 :  

[-1]  2 <= P!1
[-2]  i!1`1 < P!1 - 1
  |-------
[1]   cons?[Identity](il2!1)

Rerunning step: (nonemptylist "il2!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictinit_middle.5.

Q.E.D.


Run time  = 3.15 secs.
Real time = 4.33 secs.
nil
pvs(47): 
Installing rewrite rule sets.singleton_rew (all instances)
restrictinit_last :  

  |-------
{1}   FORALL (P: nat_from_2, u: Identity):
        ((Interleave! (nnP: Nonces(P, u, P - 1)): UROLE_LAST(P, u, nnP)) #
          R_init)
         |> RankUser(rho_init)

Rerunning step: (auto-rewrite-theory "sets")
Rewriting relative to the theory: sets,
this simplifies to: 
restrictinit_last :  

  |-------
[1]   FORALL (P: nat_from_2, u: Identity):
        ((Interleave! (nnP: Nonces(P, u, P - 1)): UROLE_LAST(P, u, nnP)) #
          R_init)
         |> RankUser(rho_init)

Rerunning step: (auto-rewrite "n_last_TCC2")
Installing rewrite rule gnsl_last.n_last_TCC2
Installing automatic rewrites from: 
  n_last_TCC2
this simplifies to: 
restrictinit_last :  

  |-------
[1]   FORALL (P: nat_from_2, u: Identity):
        ((Interleave! (nnP: Nonces(P, u, P - 1)): UROLE_LAST(P, u, nnP)) #
          R_init)
         |> RankUser(rho_init)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictinit_last :  

  |-------
{1}   ((Interleave! (nnP: Nonces(P!1, u!1, P!1 - 1)):
          UROLE_LAST(P!1, u!1, nnP))
        # R_init)
       |> RankUser(rho_init)

Rerunning step: (expand "RankUser")
Expanding the definition of RankUser,
this simplifies to: 
restrictinit_last :  

  |-------
{1}   ((Interleave! (nnP: Nonces(P!1, u!1, P!1 - 1)):
          UROLE_LAST(P!1, u!1, nnP))
        # R_init)
       |>
       LAMBDA (tr: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(tr) =>
          every(LAMBDA (e: event): complement(rec?)(e) => rho_init(msg(e)))
               (tr)

Rerunning step: (interleaving2)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
Applying interleaving rule,
this simplifies to: 
restrictinit_last :  

  |-------
{1}   UROLE_LAST(P!1, u!1, i!1) # R_init |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (expand "UROLE_LAST")
Expanding the definition of UROLE_LAST,
this simplifies to: 
restrictinit_last :  

  |-------
{1}   IF i!1 = n_last
        THEN Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
                      il:
                        {x: list[Identity] |
                           length(x) = P!1 - 1 AND
                            FORALL (i: below[P!1 - 1]):
                              nth(x, i) = hu(i)}):
               (rec(u!1, nth(il, P!1 - 2),
                    E(public(u!1), conc(nlist(nl), ilist(il))))
                 >>
                 (trans(u!1, car(il),
                        E(public(car(il)),
                          conc(nlist(append(nl, (: i!1 :))),
                               ilist(append(cdr(il), (: u!1 :))))))
                   >>
                   (rec(u!1, nth(il, P!1 - 2),
                        E(public(u!1), nlist((: i!1 :))))
                     >>
                     (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!1))
                       >> Stop[event]))))
      ELSE Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
                    il: {x: list[Identity] | length(x) = P!1 - 1}):
             (rec(u!1, nth(il, P!1 - 2),
                  E(public(u!1), conc(nlist(nl), ilist(il))))
               >>
               (trans(u!1, car(il),
                      E(public(car(il)),
                        conc(nlist(append(nl, (: i!1 :))),
                             ilist(append(cdr(il), (: u!1 :))))))
                 >>
                 (rec(u!1, nth(il, P!1 - 2),
                      E(public(u!1), nlist((: i!1 :))))
                   >>
                   (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!1)) >>
                     Stop[event]))))
      ENDIF
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (lift-if)
Lifting IF-conditions to the top level,
this simplifies to: 
restrictinit_last :  

  |-------
{1}   IF i!1 = n_last
        THEN Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
                      il:
                        {x: list[Identity] |
                           length(x) = P!1 - 1 AND
                            FORALL (i: below[P!1 - 1]):
                              nth(x, i) = hu(i)}):
               (rec(u!1, nth(il, P!1 - 2),
                    E(public(u!1), conc(nlist(nl), ilist(il))))
                 >>
                 (trans(u!1, car(il),
                        E(public(car(il)),
                          conc(nlist(append(nl, (: i!1 :))),
                               ilist(append(cdr(il), (: u!1 :))))))
                   >>
                   (rec(u!1, nth(il, P!1 - 2),
                        E(public(u!1), nlist((: i!1 :))))
                     >>
                     (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!1))
                       >> Stop[event]))))
              # R_init
              |>
              LAMBDA (t: list[event]):
                every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
                 every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))
                      (t)
      ELSE Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
                    il: {x: list[Identity] | length(x) = P!1 - 1}):
             (rec(u!1, nth(il, P!1 - 2),
                  E(public(u!1), conc(nlist(nl), ilist(il))))
               >>
               (trans(u!1, car(il),
                      E(public(car(il)),
                        conc(nlist(append(nl, (: i!1 :))),
                             ilist(append(cdr(il), (: u!1 :))))))
                 >>
                 (rec(u!1, nth(il, P!1 - 2),
                      E(public(u!1), nlist((: i!1 :))))
                   >>
                   (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!1)) >>
                     Stop[event]))))
            # R_init
            |>
            LAMBDA (t: list[event]):
              every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
               every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
      ENDIF

Rerunning step: (typepred "P!1")
Adding type constraints for  P!1,
this simplifies to: 
restrictinit_last :  

{-1}  2 <= P!1
  |-------
[1]   IF i!1 = n_last
        THEN Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
                      il:
                        {x: list[Identity] |
                           length(x) = P!1 - 1 AND
                            FORALL (i: below[P!1 - 1]):
                              nth(x, i) = hu(i)}):
               (rec(u!1, nth(il, P!1 - 2),
                    E(public(u!1), conc(nlist(nl), ilist(il))))
                 >>
                 (trans(u!1, car(il),
                        E(public(car(il)),
                          conc(nlist(append(nl, (: i!1 :))),
                               ilist(append(cdr(il), (: u!1 :))))))
                   >>
                   (rec(u!1, nth(il, P!1 - 2),
                        E(public(u!1), nlist((: i!1 :))))
                     >>
                     (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!1))
                       >> Stop[event]))))
              # R_init
              |>
              LAMBDA (t: list[event]):
                every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
                 every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))
                      (t)
      ELSE Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
                    il: {x: list[Identity] | length(x) = P!1 - 1}):
             (rec(u!1, nth(il, P!1 - 2),
                  E(public(u!1), conc(nlist(nl), ilist(il))))
               >>
               (trans(u!1, car(il),
                      E(public(car(il)),
                        conc(nlist(append(nl, (: i!1 :))),
                             ilist(append(cdr(il), (: u!1 :))))))
                 >>
                 (rec(u!1, nth(il, P!1 - 2),
                      E(public(u!1), nlist((: i!1 :))))
                   >>
                   (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!1)) >>
                     Stop[event]))))
            # R_init
            |>
            LAMBDA (t: list[event]):
              every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
               every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
      ENDIF

Rerunning step: (prop)
Applying propositional simplification,
this yields  2 subgoals: 
restrictinit_last.1 :  

{-1}  i!1 = n_last
[-2]  2 <= P!1
  |-------
{1}   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    length(x) = P!1 - 1 AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!1 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!1)) >>
                Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (choice3)
Applying choice rule,
this yields  12 subgoals: 
restrictinit_last.1.1 :  

[-1]  i!1 = n_last
[-2]  2 <= P!1
  |-------
{1}   (rec(u!1, nth(i!2`2, P!1 - 2),
           E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
        >>
        (trans(u!1, car(i!2`2),
               E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :))))))
          >>
          (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
            >>
            (signal(commit(P!1 - 1, append(i!2`2, (: u!1 :)), i!1)) >>
              Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (case "P!1=p AND u!1=hu(p-1)")
n_last_TCC2 rewrites p - 1 >= 0
  to TRUE
Case splitting on 
   P!1 = p AND u!1 = hu(p - 1), 
this yields  2 subgoals: 
restrictinit_last.1.1.1 :  

{-1}  P!1 = p AND u!1 = hu(p - 1)
[-2]  i!1 = n_last
[-3]  2 <= P!1
  |-------
[1]   (rec(u!1, nth(i!2`2, P!1 - 2),
           E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
        >>
        (trans(u!1, car(i!2`2),
               E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :))))))
          >>
          (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
            >>
            (signal(commit(P!1 - 1, append(i!2`2, (: u!1 :)), i!1)) >>
              Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictinit_last.1.1.1 :  

{-1}  P!1 = p
{-2}  u!1 = hu(p - 1)
[-3]  i!1 = n_last
[-4]  2 <= P!1
  |-------
[1]   (rec(u!1, nth(i!2`2, P!1 - 2),
           E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
        >>
        (trans(u!1, car(i!2`2),
               E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :))))))
          >>
          (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
            >>
            (signal(commit(P!1 - 1, append(i!2`2, (: u!1 :)), i!1)) >>
              Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (replace* -1 -2 -3)
Repeatedly applying the replace rule,
this simplifies to: 
restrictinit_last.1.1.1 :  

[-1]  P!1 = p
[-2]  u!1 = hu(p - 1)
[-3]  i!1 = n_last
{-4}  2 <= p
  |-------
{1}   (rec(hu(p - 1), nth(i!2`2, p - 2),
           E(public(hu(p - 1)), conc(nlist(i!2`1), ilist(i!2`2))))
        >>
        (trans(hu(p - 1), car(i!2`2),
               E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: n_last :))),
                      ilist(append(cdr(i!2`2), (: hu(p - 1) :))))))
          >>
          (rec(hu(p - 1), nth(i!2`2, p - 2),
               E(public(hu(p - 1)), nlist((: n_last :))))
            >>
            (signal(commit(p - 1, append(i!2`2, (: hu(p - 1) :)), n_last))
              >> Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (prefix)
n_last_TCC2 rewrites p - 1 >= 0
  to TRUE
Applying prefix rule,
this simplifies to: 
restrictinit_last.1.1.1 :  

{-1}  rho_init(E(public(hu(p - 1)), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  P!1 = p
[-3]  u!1 = hu(p - 1)
[-4]  i!1 = n_last
[-5]  2 <= p
  |-------
{1}   ((trans(hu(p - 1), car(i!2`2),
              E(public(car(i!2`2)),
                conc(nlist(append(i!2`1, (: n_last :))),
                     ilist(append(cdr(i!2`2), (: hu(p - 1) :))))))
         >>
         (rec(hu(p - 1), nth(i!2`2, p - 2),
              E(public(hu(p - 1)), nlist((: n_last :))))
           >>
           (signal(commit(p - 1, append(i!2`2, (: hu(p - 1) :)), n_last))
             >> Stop[event])))
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
{2}   R_init(rec(hu(p - 1), nth(i!2`2, p - 2),
                 E(public(hu(p - 1)), conc(nlist(i!2`1), ilist(i!2`2)))))
{3}   rec(hu(p - 1), nth(i!2`2, p - 2),
          E(public(hu(p - 1)), conc(nlist(i!2`1), ilist(i!2`2))))
       >>
       ((trans(hu(p - 1), car(i!2`2),
               E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: n_last :))),
                      ilist(append(cdr(i!2`2), (: hu(p - 1) :))))))
          >>
          (rec(hu(p - 1), nth(i!2`2, p - 2),
               E(public(hu(p - 1)), nlist((: n_last :))))
            >>
            (signal(commit(p - 1, append(i!2`2, (: hu(p - 1) :)), n_last))
              >> Stop[event])))
         # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_last.1.1.1 :  

[-1]  rho_init(E(public(hu(p - 1)), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  P!1 = p
[-3]  u!1 = hu(p - 1)
[-4]  i!1 = n_last
[-5]  2 <= p
  |-------
[1]   ((trans(hu(p - 1), car(i!2`2),
              E(public(car(i!2`2)),
                conc(nlist(append(i!2`1, (: n_last :))),
                     ilist(append(cdr(i!2`2), (: hu(p - 1) :))))))
         >>
         (rec(hu(p - 1), nth(i!2`2, p - 2),
              E(public(hu(p - 1)), nlist((: n_last :))))
           >>
           (signal(commit(p - 1, append(i!2`2, (: hu(p - 1) :)), n_last))
             >> Stop[event])))
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictinit_last.1.1.1.1 :  

[-1]  rho_init(E(public(hu(p - 1)), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  P!1 = p
[-3]  u!1 = hu(p - 1)
[-4]  i!1 = n_last
[-5]  2 <= p
  |-------
{1}   rho_init(E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: n_last :))),
                      ilist(append(cdr(i!2`2), (: hu(p - 1) :))))))
{2}   R_init(trans(hu(p - 1), car(i!2`2),
                   E(public(car(i!2`2)),
                     conc(nlist(append(i!2`1, (: n_last :))),
                          ilist(append(cdr(i!2`2), (: hu(p - 1) :)))))))
{3}   trans(hu(p - 1), car(i!2`2),
            E(public(car(i!2`2)),
              conc(nlist(append(i!2`1, (: n_last :))),
                   ilist(append(cdr(i!2`2), (: hu(p - 1) :))))))
       >>
       ((rec(hu(p - 1), nth(i!2`2, p - 2),
             E(public(hu(p - 1)), nlist((: n_last :))))
          >>
          (signal(commit(p - 1, append(i!2`2, (: hu(p - 1) :)), n_last)) >>
            Stop[event]))
         # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete -1 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_last.1.1.1.1 :  

[-1]  P!1 = p
[-2]  u!1 = hu(p - 1)
[-3]  i!1 = n_last
[-4]  2 <= p
  |-------
[1]   rho_init(E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: n_last :))),
                      ilist(append(cdr(i!2`2), (: hu(p - 1) :))))))

Rerunning step: (expand "E")
Expanding the definition of E,
this simplifies to: 
restrictinit_last.1.1.1.1 :  

[-1]  P!1 = p
[-2]  u!1 = hu(p - 1)
[-3]  i!1 = n_last
[-4]  2 <= p
  |-------
{1}   rho_init(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: n_last :))),
                         ilist(append(cdr(i!2`2), (: hu(p - 1) :))))))

Rerunning step: (expand "rho_init")
Expanding the definition of rho_init,
this simplifies to: 
restrictinit_last.1.1.1.1 :  

[-1]  P!1 = p
[-2]  u!1 = hu(p - 1)
[-3]  i!1 = n_last
[-4]  2 <= p
  |-------
{1}   rho_init(conc(nlist(append(i!2`1, (: n_last :))),
                    ilist(append(cdr(i!2`2), (: hu(p - 1) :)))))
       OR
       (public(car(i!2`2)) = public(hu(0)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
           conc(nlist(append(i!2`1, (: n_last :))),
                ilist(append(cdr(i!2`2), (: hu(p - 1) :))))
            = conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictinit_last.1.1.1.1 :  

[-1]  P!1 = p
[-2]  u!1 = hu(p - 1)
[-3]  i!1 = n_last
[-4]  2 <= p
  |-------
{1}   rho_init(conc(nlist(append(i!2`1, (: n_last :))),
                    ilist(append(cdr(i!2`2), (: hu(p - 1) :)))))
{2}   (public(car(i!2`2)) = public(hu(0)) AND
        EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
          conc(nlist(append(i!2`1, (: n_last :))),
               ilist(append(cdr(i!2`2), (: hu(p - 1) :))))
           = conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))

Rerunning step: (typepred "i!2`1" "i!2`2" "hu_list")
Adding type constraints for  i!2`1, i!2`2, hu_list,
this simplifies to: 
restrictinit_last.1.1.1.1 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`1)
{-2}  length(i!2`1) = P!1 - 1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`2)
{-4}  length(i!2`2) = P!1 - 1
{-5}  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
{-6}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-7}  (length(hu_list) = p)
{-8}  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  P!1 = p
[-10] u!1 = hu(p - 1)
[-11] i!1 = n_last
[-12] 2 <= p
  |-------
[1]   rho_init(conc(nlist(append(i!2`1, (: n_last :))),
                    ilist(append(cdr(i!2`2), (: hu(p - 1) :)))))
[2]   (public(car(i!2`2)) = public(hu(0)) AND
        EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
          conc(nlist(append(i!2`1, (: n_last :))),
               ilist(append(cdr(i!2`2), (: hu(p - 1) :))))
           = conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))

Rerunning step: (delete -1 -3 -6 -10 -11 1)
Deleting some formulas,
this simplifies to: 
restrictinit_last.1.1.1.1 :  

[-1]  length(i!2`1) = P!1 - 1
[-2]  length(i!2`2) = P!1 - 1
[-3]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  P!1 = p
[-7]  2 <= p
  |-------
[1]   (public(car(i!2`2)) = public(hu(0)) AND
        EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
          conc(nlist(append(i!2`1, (: n_last :))),
               ilist(append(cdr(i!2`2), (: hu(p - 1) :))))
           = conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
restrictinit_last.1.1.1.1.1 :  

[-1]  length(i!2`1) = P!1 - 1
[-2]  length(i!2`2) = P!1 - 1
[-3]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  P!1 = p
[-7]  2 <= p
  |-------
{1}   public(car(i!2`2)) = public(hu(0))

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictinit_last.1.1.1.1.1 :  

[-1]  length(i!2`1) = P!1 - 1
[-2]  length(i!2`2) = P!1 - 1
[-3]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  P!1 = p
[-7]  2 <= p
  |-------
{1}   car(i!2`2) = hu(0)

Rerunning step: (inst -3 "0")
Instantiating the top quantifier in -3 with the terms: 
 0,
this simplifies to: 
restrictinit_last.1.1.1.1.1 :  

[-1]  length(i!2`1) = P!1 - 1
[-2]  length(i!2`2) = P!1 - 1
{-3}  nth(i!2`2, 0) = hu(0)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  P!1 = p
[-7]  2 <= p
  |-------
[1]   car(i!2`2) = hu(0)

Rerunning step: (expand "nth" -3)
Expanding the definition of nth,
this simplifies to: 
restrictinit_last.1.1.1.1.1 :  

[-1]  length(i!2`1) = P!1 - 1
[-2]  length(i!2`2) = P!1 - 1
{-3}  car(i!2`2) = hu(0)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  P!1 = p
[-7]  2 <= p
  |-------
[1]   car(i!2`2) = hu(0)

which is trivially true.

This completes the proof of restrictinit_last.1.1.1.1.1.

restrictinit_last.1.1.1.1.2 :  

[-1]  length(i!2`1) = P!1 - 1
[-2]  length(i!2`2) = P!1 - 1
[-3]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  P!1 = p
[-7]  2 <= p
  |-------
{1}   EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
        conc(nlist(append(i!2`1, (: n_last :))),
             ilist(append(cdr(i!2`2), (: hu(p - 1) :))))
         = conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list)))

Rerunning step: (inst 1 "i!2`1")
Instantiating the top quantifier in 1 with the terms: 
 i!2`1,
this simplifies to: 
restrictinit_last.1.1.1.1.2 :  

[-1]  length(i!2`1) = P!1 - 1
[-2]  length(i!2`2) = P!1 - 1
[-3]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  P!1 = p
[-7]  2 <= p
  |-------
{1}   conc(nlist(append(i!2`1, (: n_last :))),
           ilist(append(cdr(i!2`2), (: hu(p - 1) :))))
       = conc(nlist(append(i!2`1, (: n_last :))), ilist(cdr(hu_list)))

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictinit_last.1.1.1.1.2 :  

[-1]  length(i!2`1) = P!1 - 1
[-2]  length(i!2`2) = P!1 - 1
[-3]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  P!1 = p
[-7]  2 <= p
  |-------
{1}   ilist(append(cdr(i!2`2), (: hu(p - 1) :))) = ilist(cdr(hu_list))

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictinit_last.1.1.1.1.2 :  

[-1]  length(i!2`1) = P!1 - 1
[-2]  length(i!2`2) = P!1 - 1
[-3]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  P!1 = p
[-7]  2 <= p
  |-------
{1}   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (case "length(append(cdr(i!2`2),(:hu(p-1):)))=p-1")
Case splitting on 
   length(append(cdr(i!2`2), (: hu(p - 1) :))) = p - 1, 
this yields  2 subgoals: 
restrictinit_last.1.1.1.1.2.1 :  

{-1}  length(append(cdr(i!2`2), (: hu(p - 1) :))) = p - 1
[-2]  length(i!2`1) = P!1 - 1
[-3]  length(i!2`2) = P!1 - 1
[-4]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  P!1 = p
[-8]  2 <= p
  |-------
[1]   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (rewrite "length_nth_equality[Identity]")
Found matching substitution:
l2: list[Identity] gets cdr(hu_list),
l1: list[Identity] gets append(cdr(i!2`2), (: hu(p - 1) :)),
Rewriting using length_nth_equality[Identity], matching in *,
this yields  2 subgoals: 
restrictinit_last.1.1.1.1.2.1.1 :  

[-1]  length(append(cdr(i!2`2), (: hu(p - 1) :))) = p - 1
[-2]  length(i!2`1) = P!1 - 1
[-3]  length(i!2`2) = P!1 - 1
[-4]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  P!1 = p
[-8]  2 <= p
  |-------
{1}   length[Identity](append(cdr(i!2`2), (: hu(p - 1) :))) =
       length[Identity](cdr(hu_list))
[2]   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (rewrite "length_cdr" 1)
Found matching substitution:
cons_l: (cons?[T]) gets hu_list,
Rewriting using length_cdr, matching in 1,
this simplifies to: 
restrictinit_last.1.1.1.1.2.1.1 :  

[-1]  length(append(cdr(i!2`2), (: hu(p - 1) :))) = p - 1
[-2]  length(i!2`1) = P!1 - 1
[-3]  length(i!2`2) = P!1 - 1
[-4]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  P!1 = p
[-8]  2 <= p
  |-------
{1}   length[Identity](append(cdr(i!2`2), (: hu(p - 1) :))) =
       length(hu_list) - 1
[2]   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (delete -2 -3 -4 -6 -7 -8 2)
Deleting some formulas,
this simplifies to: 
restrictinit_last.1.1.1.1.2.1.1 :  

[-1]  length(append(cdr(i!2`2), (: hu(p - 1) :))) = p - 1
[-2]  (length(hu_list) = p)
  |-------
[1]   length[Identity](append(cdr(i!2`2), (: hu(p - 1) :))) =
       length(hu_list) - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictinit_last.1.1.1.1.2.1.1.

restrictinit_last.1.1.1.1.2.1.2 :  

[-1]  length(append(cdr(i!2`2), (: hu(p - 1) :))) = p - 1
[-2]  length(i!2`1) = P!1 - 1
[-3]  length(i!2`2) = P!1 - 1
[-4]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  P!1 = p
[-8]  2 <= p
  |-------
{1}   FORALL (i:
                below[length[Identity]
                          (append(cdr(i!2`2), (: hu(p - 1) :)))]):
        nth(append(cdr(i!2`2), (: hu(p - 1) :)), i) = nth(cdr(hu_list), i)
[2]   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictinit_last.1.1.1.1.2.1.2 :  

{-1}  i!3 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-2]  length(append(cdr(i!2`2), (: hu(p - 1) :))) = p - 1
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  2 <= p
  |-------
{1}   nth(append(cdr(i!2`2), (: hu(p - 1) :)), i!3) = nth(cdr(hu_list), i!3)
[2]   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (lemma "listprops[Identity].nth_append"
                 ("l1" "cdr(i!2`2)" "l2" "(:hu(p-1):)" "i" "i!3"))
Applying listprops[Identity].nth_append where 
  l1 gets cdr(i!2`2),
  l2 gets (: hu(p - 1) :),
  i gets i!3,
this yields  2 subgoals: 
restrictinit_last.1.1.1.1.2.1.2.1 :  

{-1}  nth(append(cdr(i!2`2), (: hu(p - 1) :)), i!3) =
       IF i!3 < length[Identity](cdr(i!2`2)) THEN nth(cdr(i!2`2), i!3)
       ELSE nth((: hu(p - 1) :), i!3 - length[Identity](cdr(i!2`2)))
       ENDIF
[-2]  i!3 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-3]  length(append(cdr(i!2`2), (: hu(p - 1) :))) = p - 1
[-4]  length(i!2`1) = P!1 - 1
[-5]  length(i!2`2) = P!1 - 1
[-6]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  P!1 = p
[-10] 2 <= p
  |-------
[1]   nth(append(cdr(i!2`2), (: hu(p - 1) :)), i!3) = nth(cdr(hu_list), i!3)
[2]   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictinit_last.1.1.1.1.2.1.2.1 :  

[-1]  nth(append(cdr(i!2`2), (: hu(p - 1) :)), i!3) =
       IF i!3 < length[Identity](cdr(i!2`2)) THEN nth(cdr(i!2`2), i!3)
       ELSE nth((: hu(p - 1) :), i!3 - length[Identity](cdr(i!2`2)))
       ENDIF
[-2]  i!3 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-3]  length(append(cdr(i!2`2), (: hu(p - 1) :))) = p - 1
[-4]  length(i!2`1) = P!1 - 1
[-5]  length(i!2`2) = P!1 - 1
[-6]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  P!1 = p
[-10] 2 <= p
  |-------
{1}   IF i!3 < length[Identity](cdr(i!2`2)) THEN nth(cdr(i!2`2), i!3)
      ELSE nth((: hu(p - 1) :), i!3 - length[Identity](cdr(i!2`2)))
      ENDIF
       = nth(cdr(hu_list), i!3)
[2]   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (delete -1 2)
Deleting some formulas,
this simplifies to: 
restrictinit_last.1.1.1.1.2.1.2.1 :  

[-1]  i!3 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-2]  length(append(cdr(i!2`2), (: hu(p - 1) :))) = p - 1
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  2 <= p
  |-------
[1]   IF i!3 < length[Identity](cdr(i!2`2)) THEN nth(cdr(i!2`2), i!3)
      ELSE nth((: hu(p - 1) :), i!3 - length[Identity](cdr(i!2`2)))
      ENDIF
       = nth(cdr(hu_list), i!3)

Rerunning step: (rewrite "length_cdr" 1)
Found matching substitution:
cons_l: (cons?[T]) gets i!2`2,
Rewriting using length_cdr, matching in 1,
this simplifies to: 
restrictinit_last.1.1.1.1.2.1.2.1 :  

[-1]  i!3 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-2]  length(append(cdr(i!2`2), (: hu(p - 1) :))) = p - 1
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  2 <= p
  |-------
{1}   IF i!3 < length(i!2`2) - 1 THEN nth(cdr(i!2`2), i!3)
      ELSE nth((: hu(p - 1) :), i!3 - (length(i!2`2) - 1))
      ENDIF
       = nth(cdr(hu_list), i!3)

Rerunning step: (lemma "nth_cdr" ("c" "hu_list" "i" "i!3"))
Using instance
  listprops[Identity].nth_cdr
Applying nth_cdr where 
  c gets hu_list,
  i gets i!3,
this simplifies to: 
restrictinit_last.1.1.1.1.2.1.2.1 :  

{-1}  nth(cdr(hu_list), i!3) = nth(hu_list, i!3 + 1)
[-2]  i!3 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-3]  length(append(cdr(i!2`2), (: hu(p - 1) :))) = p - 1
[-4]  length(i!2`1) = P!1 - 1
[-5]  length(i!2`2) = P!1 - 1
[-6]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  P!1 = p
[-10] 2 <= p
  |-------
[1]   IF i!3 < length(i!2`2) - 1 THEN nth(cdr(i!2`2), i!3)
      ELSE nth((: hu(p - 1) :), i!3 - (length(i!2`2) - 1))
      ENDIF
       = nth(cdr(hu_list), i!3)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictinit_last.1.1.1.1.2.1.2.1 :  

[-1]  nth(cdr(hu_list), i!3) = nth(hu_list, i!3 + 1)
[-2]  i!3 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-3]  length(append(cdr(i!2`2), (: hu(p - 1) :))) = p - 1
[-4]  length(i!2`1) = P!1 - 1
[-5]  length(i!2`2) = P!1 - 1
[-6]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  P!1 = p
[-10] 2 <= p
  |-------
{1}   IF i!3 < length(i!2`2) - 1 THEN nth(cdr(i!2`2), i!3)
      ELSE nth((: hu(p - 1) :), i!3 - (length(i!2`2) - 1))
      ENDIF
       = nth(hu_list, i!3 + 1)

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictinit_last.1.1.1.1.2.1.2.1 :  

[-1]  i!3 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-2]  length(append(cdr(i!2`2), (: hu(p - 1) :))) = p - 1
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  2 <= p
  |-------
[1]   IF i!3 < length(i!2`2) - 1 THEN nth(cdr(i!2`2), i!3)
      ELSE nth((: hu(p - 1) :), i!3 - (length(i!2`2) - 1))
      ENDIF
       = nth(hu_list, i!3 + 1)

Rerunning step: (inst -7 "i!3+1")
Instantiating the top quantifier in -7 with the terms: 
 i!3+1,
this simplifies to: 
restrictinit_last.1.1.1.1.2.1.2.1 :  

[-1]  i!3 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-2]  length(append(cdr(i!2`2), (: hu(p - 1) :))) = p - 1
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-6]  (length(hu_list) = p)
{-7}  nth(hu_list, i!3 + 1) = hu(i!3 + 1)
[-8]  P!1 = p
[-9]  2 <= p
  |-------
[1]   IF i!3 < length(i!2`2) - 1 THEN nth(cdr(i!2`2), i!3)
      ELSE nth((: hu(p - 1) :), i!3 - (length(i!2`2) - 1))
      ENDIF
       = nth(hu_list, i!3 + 1)

Rerunning step: (case "i!3<p-2 OR i!3=p-2")
Case splitting on 
   i!3 < p - 2 OR i!3 = p - 2, 
this yields  2 subgoals: 
restrictinit_last.1.1.1.1.2.1.2.1.1 :  

{-1}  i!3 < p - 2 OR i!3 = p - 2
[-2]  i!3 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-3]  length(append(cdr(i!2`2), (: hu(p - 1) :))) = p - 1
[-4]  length(i!2`1) = P!1 - 1
[-5]  length(i!2`2) = P!1 - 1
[-6]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-7]  (length(hu_list) = p)
[-8]  nth(hu_list, i!3 + 1) = hu(i!3 + 1)
[-9]  P!1 = p
[-10] 2 <= p
  |-------
[1]   IF i!3 < length(i!2`2) - 1 THEN nth(cdr(i!2`2), i!3)
      ELSE nth((: hu(p - 1) :), i!3 - (length(i!2`2) - 1))
      ENDIF
       = nth(hu_list, i!3 + 1)

Rerunning step: (grind :exclude "nth")
Trying repeated skolemization, instantiation, and if-lifting,
this yields  2 subgoals: 
restrictinit_last.1.1.1.1.2.1.2.1.1.1 :  

{-1}  i!3 < p - 2
{-2}  i!3 < p - 1
[-3]  length(append(cdr(i!2`2), (: hu(p - 1) :))) = p - 1
{-4}  length(i!2`1) = p - 1
{-5}  length(i!2`2) = p - 1
{-6}  nth(i!2`2, 1 + i!3) = hu(1 + i!3)
[-7]  (length(hu_list) = p)
{-8}  nth(hu_list, 1 + i!3) = hu(1 + i!3)
[-9]  P!1 = p
[-10] 2 <= p
  |-------
{1}   nth(cdr(i!2`2), i!3) = hu(1 + i!3)

Rerunning step: (expand "nth" -6)
Expanding the definition of nth,
this simplifies to: 
restrictinit_last.1.1.1.1.2.1.2.1.1.1 :  

[-1]  i!3 < p - 2
[-2]  i!3 < p - 1
[-3]  length(append(cdr(i!2`2), (: hu(p - 1) :))) = p - 1
[-4]  length(i!2`1) = p - 1
[-5]  length(i!2`2) = p - 1
{-6}  nth(cdr(i!2`2), i!3) = hu(1 + i!3)
[-7]  (length(hu_list) = p)
[-8]  nth(hu_list, 1 + i!3) = hu(1 + i!3)
[-9]  P!1 = p
[-10] 2 <= p
  |-------
[1]   nth(cdr(i!2`2), i!3) = hu(1 + i!3)

which is trivially true.

This completes the proof of restrictinit_last.1.1.1.1.2.1.2.1.1.1.

restrictinit_last.1.1.1.1.2.1.2.1.1.2 :  

{-1}  i!3 = p - 2
{-2}  p - 2 < p - 1
[-3]  length(append(cdr(i!2`2), (: hu(p - 1) :))) = p - 1
{-4}  length(i!2`1) = p - 1
{-5}  length(i!2`2) = p - 1
[-6]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-7]  (length(hu_list) = p)
{-8}  nth(hu_list, p - 1) = hu(p - 1)
[-9]  P!1 = p
[-10] 2 <= p
  |-------
{1}   nth((: hu(p - 1) :), 0) = hu(p - 1)

Rerunning step: (expand "nth" 1)
Expanding the definition of nth,
this simplifies to: 
restrictinit_last.1.1.1.1.2.1.2.1.1.2 :  

[-1]  i!3 = p - 2
[-2]  p - 2 < p - 1
[-3]  length(append(cdr(i!2`2), (: hu(p - 1) :))) = p - 1
[-4]  length(i!2`1) = p - 1
[-5]  length(i!2`2) = p - 1
[-6]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-7]  (length(hu_list) = p)
[-8]  nth(hu_list, p - 1) = hu(p - 1)
[-9]  P!1 = p
[-10] 2 <= p
  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictinit_last.1.1.1.1.2.1.2.1.1.2.


This completes the proof of restrictinit_last.1.1.1.1.2.1.2.1.1.

restrictinit_last.1.1.1.1.2.1.2.1.2 :  

[-1]  i!3 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-2]  length(append(cdr(i!2`2), (: hu(p - 1) :))) = p - 1
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-6]  (length(hu_list) = p)
[-7]  nth(hu_list, i!3 + 1) = hu(i!3 + 1)
[-8]  P!1 = p
[-9]  2 <= p
  |-------
{1}   i!3 < p - 2 OR i!3 = p - 2
[2]   IF i!3 < length(i!2`2) - 1 THEN nth(cdr(i!2`2), i!3)
      ELSE nth((: hu(p - 1) :), i!3 - (length(i!2`2) - 1))
      ENDIF
       = nth(hu_list, i!3 + 1)

Rerunning step: (delete -3 -4 -5 -6 -7 -8 -9 2)
Deleting some formulas,
this simplifies to: 
restrictinit_last.1.1.1.1.2.1.2.1.2 :  

[-1]  i!3 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-2]  length(append(cdr(i!2`2), (: hu(p - 1) :))) = p - 1
  |-------
[1]   i!3 < p - 2 OR i!3 = p - 2

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictinit_last.1.1.1.1.2.1.2.1.2.


This completes the proof of restrictinit_last.1.1.1.1.2.1.2.1.

restrictinit_last.1.1.1.1.2.1.2.2T (TCC):   

[-1]  i!3 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
[-2]  length(append(cdr(i!2`2), (: hu(p - 1) :))) = p - 1
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  P!1 = p
[-9]  2 <= p
  |-------
{1}   i!3 <
       length[Identity](cdr[Identity](i!2`2)) +
        length[Identity]((: hu(p - 1) :))
[2]   nth(append(cdr(i!2`2), (: hu(p - 1) :)), i!3) = nth(cdr(hu_list), i!3)
[3]   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (delete -2 -3 -4 -5 -6 -7 -8 -9 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_last.1.1.1.1.2.1.2.2T :  

[-1]  i!3 < length[Identity](append(cdr(i!2`2), (: hu(p - 1) :)))
  |-------
[1]   i!3 <
       length[Identity](cdr[Identity](i!2`2)) +
        length[Identity]((: hu(p - 1) :))

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets (: hu(p - 1) :),
l1: list[T] gets cdr(i!2`2),
Rewriting using length_append, matching in -1,

This completes the proof of restrictinit_last.1.1.1.1.2.1.2.2T.


This completes the proof of restrictinit_last.1.1.1.1.2.1.2.


This completes the proof of restrictinit_last.1.1.1.1.2.1.

restrictinit_last.1.1.1.1.2.2 :  

[-1]  length(i!2`1) = P!1 - 1
[-2]  length(i!2`2) = P!1 - 1
[-3]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  P!1 = p
[-7]  2 <= p
  |-------
{1}   length(append(cdr(i!2`2), (: hu(p - 1) :))) = p - 1
[2]   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets (: hu(p - 1) :),
l1: list[T] gets cdr(i!2`2),
Rewriting using length_append, matching in 1,
this simplifies to: 
restrictinit_last.1.1.1.1.2.2 :  

[-1]  length(i!2`1) = P!1 - 1
[-2]  length(i!2`2) = P!1 - 1
[-3]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  P!1 = p
[-7]  2 <= p
  |-------
{1}   length(cdr(i!2`2)) + length((: hu(p - 1) :)) = p - 1
[2]   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (rewrite "length_cdr" 1)
Found matching substitution:
cons_l: (cons?[T]) gets i!2`2,
Rewriting using length_cdr, matching in 1,
this simplifies to: 
restrictinit_last.1.1.1.1.2.2 :  

[-1]  length(i!2`1) = P!1 - 1
[-2]  length(i!2`2) = P!1 - 1
[-3]  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  P!1 = p
[-7]  2 <= p
  |-------
{1}   length(i!2`2) - 1 + length((: hu(p - 1) :)) = p - 1
[2]   append(cdr(i!2`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (delete -1 -3 -4 -5 -7 2)
Deleting some formulas,
this simplifies to: 
restrictinit_last.1.1.1.1.2.2 :  

[-1]  length(i!2`2) = P!1 - 1
[-2]  P!1 = p
  |-------
[1]   length(i!2`2) - 1 + length((: hu(p - 1) :)) = p - 1

Rerunning step: (grind)
length rewrites length[Identity]((: :))
  to 0
length rewrites length((: hu(p - 1) :))
  to 1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictinit_last.1.1.1.1.2.2.


This completes the proof of restrictinit_last.1.1.1.1.2.


This completes the proof of restrictinit_last.1.1.1.1.

restrictinit_last.1.1.1.2 :  

[-1]  rho_init(E(public(hu(p - 1)), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  P!1 = p
[-3]  u!1 = hu(p - 1)
[-4]  i!1 = n_last
[-5]  2 <= p
  |-------
{1}   ((rec(hu(p - 1), nth(i!2`2, p - 2),
            E(public(hu(p - 1)), nlist((: n_last :))))
         >>
         (signal(commit(p - 1, append(i!2`2, (: hu(p - 1) :)), n_last)) >>
           Stop[event]))
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
{2}   R_init(trans(hu(p - 1), car(i!2`2),
                   E(public(car(i!2`2)),
                     conc(nlist(append(i!2`1, (: n_last :))),
                          ilist(append(cdr(i!2`2), (: hu(p - 1) :)))))))
{3}   trans(hu(p - 1), car(i!2`2),
            E(public(car(i!2`2)),
              conc(nlist(append(i!2`1, (: n_last :))),
                   ilist(append(cdr(i!2`2), (: hu(p - 1) :))))))
       >>
       ((rec(hu(p - 1), nth(i!2`2, p - 2),
             E(public(hu(p - 1)), nlist((: n_last :))))
          >>
          (signal(commit(p - 1, append(i!2`2, (: hu(p - 1) :)), n_last)) >>
            Stop[event]))
         # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_last.1.1.1.2 :  

[-1]  rho_init(E(public(hu(p - 1)), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  P!1 = p
[-3]  u!1 = hu(p - 1)
[-4]  i!1 = n_last
[-5]  2 <= p
  |-------
[1]   ((rec(hu(p - 1), nth(i!2`2, p - 2),
            E(public(hu(p - 1)), nlist((: n_last :))))
         >>
         (signal(commit(p - 1, append(i!2`2, (: hu(p - 1) :)), n_last)) >>
           Stop[event]))
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictinit_last.1.1.1.2 :  

{-1}  rho_init(E(public(hu(p - 1)), nlist((: n_last :))))
[-2]  rho_init(E(public(hu(p - 1)), conc(nlist(i!2`1), ilist(i!2`2))))
[-3]  P!1 = p
[-4]  u!1 = hu(p - 1)
[-5]  i!1 = n_last
[-6]  2 <= p
  |-------
{1}   ((signal(commit(p - 1, append(i!2`2, (: hu(p - 1) :)), n_last)) >>
         Stop[event])
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
{2}   R_init(rec(hu(p - 1), nth(i!2`2, p - 2),
                 E(public(hu(p - 1)), nlist((: n_last :)))))
{3}   rec(hu(p - 1), nth(i!2`2, p - 2),
          E(public(hu(p - 1)), nlist((: n_last :))))
       >>
       ((signal(commit(p - 1, append(i!2`2, (: hu(p - 1) :)), n_last)) >>
          Stop[event])
         # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete -2 -3 -4 -5 -6 +)
Deleting some formulas,
this simplifies to: 
restrictinit_last.1.1.1.2 :  

[-1]  rho_init(E(public(hu(p - 1)), nlist((: n_last :))))
  |-------

Rerunning step: (grind :if-match nil)
E rewrites E(public(hu(p - 1)), nlist((: n_last :)))
  to code(public(hu(p - 1)), nlist((: n_last :)))
elt rewrites elt((: n_last :), n_last)
  to EXISTS (i: below[length((: n_last :))]): nth((: n_last :), i) = n_last
rho_init rewrites rho_init(nlist((: n_last :)))
  to NOT EXISTS (i: below[length((: n_last :))]):
            nth((: n_last :), i) = n_last
rho_init rewrites rho_init(code(public(hu(p - 1)), nlist((: n_last :))))
  to NOT EXISTS (i: below[length((: n_last :))]):
            nth((: n_last :), i) = n_last
Trying repeated skolemization, instantiation, and if-lifting,
this simplifies to: 
restrictinit_last.1.1.1.2 :  

  |-------
{1}   EXISTS (i: below[length((: n_last :))]): nth((: n_last :), i) = n_last

Rerunning step: (inst 1 "0")
length rewrites length[Identity]((: :))
  to 0
length rewrites length[Nonce]((: n_last :))
  to 1
Instantiating the top quantifier in 1 with the terms: 
 0,
this simplifies to: 
restrictinit_last.1.1.1.2 :  

  |-------
{1}   nth((: n_last :), 0) = n_last

Rerunning step: (expand "nth")
Expanding the definition of nth,
this simplifies to: 
restrictinit_last.1.1.1.2 :  

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictinit_last.1.1.1.2.


This completes the proof of restrictinit_last.1.1.1.

restrictinit_last.1.1.2 :  

[-1]  i!1 = n_last
[-2]  2 <= P!1
  |-------
{1}   P!1 = p AND u!1 = hu(p - 1)
[2]   (rec(u!1, nth(i!2`2, P!1 - 2),
           E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
        >>
        (trans(u!1, car(i!2`2),
               E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :))))))
          >>
          (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
            >>
            (signal(commit(P!1 - 1, append(i!2`2, (: u!1 :)), i!1)) >>
              Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (typepred "i!1")
Adding type constraints for  i!1,
this simplifies to: 
restrictinit_last.1.1.2 :  

{-1}  IRpart(P!1, u!1, P!1 - 1)(i!1)
[-2]  i!1 = n_last
[-3]  2 <= P!1
  |-------
[1]   P!1 = p AND u!1 = hu(p - 1)
[2]   (rec(u!1, nth(i!2`2, P!1 - 2),
           E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
        >>
        (trans(u!1, car(i!2`2),
               E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :))))))
          >>
          (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
            >>
            (signal(commit(P!1 - 1, append(i!2`2, (: u!1 :)), i!1)) >>
              Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (lemma "n_orig" ("P" "P!1" "u" "u!1" "r" "P!1-1"))
Applying n_orig where 
  P gets P!1,
  u gets u!1,
  r gets P!1 - 1,
this simplifies to: 
restrictinit_last.1.1.2 :  

{-1}  IRpart(P!1, u!1, P!1 - 1)(n_last) =>
       (P!1 = p AND u!1 = hu(p - 1) AND P!1 - 1 = p - 1)
[-2]  IRpart(P!1, u!1, P!1 - 1)(i!1)
[-3]  i!1 = n_last
[-4]  2 <= P!1
  |-------
[1]   P!1 = p AND u!1 = hu(p - 1)
[2]   (rec(u!1, nth(i!2`2, P!1 - 2),
           E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
        >>
        (trans(u!1, car(i!2`2),
               E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :))))))
          >>
          (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
            >>
            (signal(commit(P!1 - 1, append(i!2`2, (: u!1 :)), i!1)) >>
              Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete -4 2)
Deleting some formulas,
this simplifies to: 
restrictinit_last.1.1.2 :  

[-1]  IRpart(P!1, u!1, P!1 - 1)(n_last) =>
       (P!1 = p AND u!1 = hu(p - 1) AND P!1 - 1 = p - 1)
[-2]  IRpart(P!1, u!1, P!1 - 1)(i!1)
[-3]  i!1 = n_last
  |-------
[1]   P!1 = p AND u!1 = hu(p - 1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictinit_last.1.1.2.


This completes the proof of restrictinit_last.1.1.

restrictinit_last.1.2 :  

[-1]  i!1 = n_last
[-2]  2 <= P!1
  |-------
{1}   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!1 :))
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     length(x) = P!1 - 1 AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!1 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!1)) >>
                Stop[event]))))
         # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictinit_last.1.2 :  

  |-------
[1]   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!1 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!1 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictinit_last.1.2.

restrictinit_last.1.3 :  

[-1]  i!1 = n_last
[-2]  2 <= P!1
  |-------
{1}   cons?[Identity](i!2`2)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     length(x) = P!1 - 1 AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!1 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!1)) >>
                Stop[event]))))
         # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete -1 2)
Deleting some formulas,
this simplifies to: 
restrictinit_last.1.3 :  

[-1]  2 <= P!1
  |-------
[1]   cons?[Identity](i!2`2)

Rerunning step: (nonemptylist "i!2`2")
Relating existence of a tail to a list's length,

This completes the proof of restrictinit_last.1.3.

restrictinit_last.1.4 :  

[-1]  i!1 = n_last
[-2]  2 <= P!1
  |-------
{1}   P!1 - 2 < length[Identity](i!2`2)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     length(x) = P!1 - 1 AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!1 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!1)) >>
                Stop[event]))))
         # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (typepred "i!2`2")
Adding type constraints for  i!2`2,
this simplifies to: 
restrictinit_last.1.4 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`2)
{-2}  length(i!2`2) = P!1 - 1
{-3}  FORALL (i: below[P!1 - 1]): nth(i!2`2, i) = hu(i)
[-4]  i!1 = n_last
[-5]  2 <= P!1
  |-------
[1]   P!1 - 2 < length[Identity](i!2`2)
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     length(x) = P!1 - 1 AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!1 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!1)) >>
                Stop[event]))))
         # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete -1 -3 -4 -5 2)
Deleting some formulas,
this simplifies to: 
restrictinit_last.1.4 :  

[-1]  length(i!2`2) = P!1 - 1
  |-------
[1]   P!1 - 2 < length[Identity](i!2`2)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictinit_last.1.4.

restrictinit_last.1.5 :  

[-1]  i!1 = n_last
[-2]  2 <= P!1
  |-------
{1}   length(x!1) = P!1 - 1 IMPLIES FORALL (i: below[P!1 - 1]): i < p
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     length(x) = P!1 - 1 AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!1 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!1)) >>
                Stop[event]))))
         # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictinit_last.1.5 :  

{-1}  length(x!1) = P!1 - 1
[-2]  i!1 = n_last
[-3]  2 <= P!1
  |-------
{1}   FORALL (i: below[P!1 - 1]): i < p
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     length(x) = P!1 - 1 AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!1 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!1)) >>
                Stop[event]))))
         # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictinit_last.1.5 :  

{-1}  i!2 < P!1 - 1
[-2]  length(x!1) = P!1 - 1
[-3]  i!1 = n_last
[-4]  2 <= P!1
  |-------
{1}   i!2 < p
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     length(x) = P!1 - 1 AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!1 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!1)) >>
                Stop[event]))))
         # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete -2 2)
Deleting some formulas,
this simplifies to: 
restrictinit_last.1.5 :  

[-1]  i!2 < P!1 - 1
[-2]  i!1 = n_last
[-3]  2 <= P!1
  |-------
[1]   i!2 < p

Rerunning step: (typepred "i!1")
Adding type constraints for  i!1,
this simplifies to: 
restrictinit_last.1.5 :  

{-1}  IRpart(P!1, u!1, P!1 - 1)(i!1)
[-2]  i!2 < P!1 - 1
[-3]  i!1 = n_last
[-4]  2 <= P!1
  |-------
[1]   i!2 < p

Rerunning step: (lemma "n_orig" ("P" "P!1" "u" "u!1" "r" "P!1-1"))
Applying n_orig where 
  P gets P!1,
  u gets u!1,
  r gets P!1 - 1,
this simplifies to: 
restrictinit_last.1.5 :  

{-1}  IRpart(P!1, u!1, P!1 - 1)(n_last) =>
       (P!1 = p AND u!1 = hu(p - 1) AND P!1 - 1 = p - 1)
[-2]  IRpart(P!1, u!1, P!1 - 1)(i!1)
[-3]  i!2 < P!1 - 1
[-4]  i!1 = n_last
[-5]  2 <= P!1
  |-------
[1]   i!2 < p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictinit_last.1.5.

restrictinit_last.1.6 :  

[-1]  i!1 = n_last
[-2]  2 <= P!1
  |-------
{1}   length(x!1) = P!1 - 1 IMPLIES
       FORALL (i: below[P!1 - 1]): i < length[Identity](x!1)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     length(x) = P!1 - 1 AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!1 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!1)) >>
                Stop[event]))))
         # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictinit_last.1.6 :  

{-1}  length(x!1) = P!1 - 1
[-2]  i!1 = n_last
[-3]  2 <= P!1
  |-------
{1}   FORALL (i: below[P!1 - 1]): i < length[Identity](x!1)
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     length(x) = P!1 - 1 AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!1 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!1)) >>
                Stop[event]))))
         # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictinit_last.1.6 :  

{-1}  i!2 < P!1 - 1
[-2]  length(x!1) = P!1 - 1
[-3]  i!1 = n_last
[-4]  2 <= P!1
  |-------
{1}   i!2 < length[Identity](x!1)
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     length(x) = P!1 - 1 AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!1 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!1)) >>
                Stop[event]))))
         # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete -3 -4 2)
Deleting some formulas,
this simplifies to: 
restrictinit_last.1.6 :  

[-1]  i!2 < P!1 - 1
[-2]  length(x!1) = P!1 - 1
  |-------
[1]   i!2 < length[Identity](x!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictinit_last.1.6.

restrictinit_last.1.7 :  

[-1]  i!1 = n_last
[-2]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il:
                {x: list[Identity] |
                   length[Identity](x) = P!1 - 1 AND
                    FORALL (i: below[P!1 - 1]):
                      nth[Identity](x, i) = hu(i)}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!1 :))
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    length(x) = P!1 - 1 AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!1 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!1)) >>
                Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictinit_last.1.7 :  

  |-------
[1]   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il:
                {x: list[Identity] |
                   length[Identity](x) = P!1 - 1 AND
                    FORALL (i: below[P!1 - 1]):
                      nth[Identity](x, i) = hu(i)}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!1 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!1 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictinit_last.1.7.

restrictinit_last.1.8 :  

[-1]  i!1 = n_last
[-2]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il:
                {x: list[Identity] |
                   length[Identity](x) = P!1 - 1 AND
                    FORALL (i: below[P!1 - 1]):
                      nth[Identity](x, i) = hu(i)}):
        cons?[Identity](il)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    length(x) = P!1 - 1 AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!1 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!1)) >>
                Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictinit_last.1.8 :  

[-1]  i!1 = n_last
[-2]  2 <= P!1
  |-------
{1}   cons?[Identity](il!1)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    length(x) = P!1 - 1 AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!1 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!1)) >>
                Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete -1 2)
Deleting some formulas,
this simplifies to: 
restrictinit_last.1.8 :  

[-1]  2 <= P!1
  |-------
[1]   cons?[Identity](il!1)

Rerunning step: (nonemptylist "il!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictinit_last.1.8.

restrictinit_last.1.9 :  

[-1]  i!1 = n_last
[-2]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              x: list[Identity]):
        length(x) = P!1 - 1 IMPLIES FORALL (i: below[P!1 - 1]): i < p
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    length(x) = P!1 - 1 AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!1 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!1)) >>
                Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictinit_last.1.9 :  

{-1}  length(x!1) = P!1 - 1
[-2]  i!1 = n_last
[-3]  2 <= P!1
  |-------
{1}   i!2 < p
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    length(x) = P!1 - 1 AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!1 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!1)) >>
                Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (typepred "i!1" "i!2")
Adding type constraints for  i!1, i!2,
this simplifies to: 
restrictinit_last.1.9 :  

{-1}  IRpart(P!1, u!1, P!1 - 1)(i!1)
{-2}  i!2 < P!1 - 1
[-3]  length(x!1) = P!1 - 1
[-4]  i!1 = n_last
[-5]  2 <= P!1
  |-------
[1]   i!2 < p
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    length(x) = P!1 - 1 AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!1 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!1)) >>
                Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete -3 -5 2)
Deleting some formulas,
this simplifies to: 
restrictinit_last.1.9 :  

[-1]  IRpart(P!1, u!1, P!1 - 1)(i!1)
[-2]  i!2 < P!1 - 1
[-3]  i!1 = n_last
  |-------
[1]   i!2 < p

Rerunning step: (lemma "n_orig" ("P" "P!1" "u" "u!1" "r" "P!1-1"))
Applying n_orig where 
  P gets P!1,
  u gets u!1,
  r gets P!1 - 1,
this simplifies to: 
restrictinit_last.1.9 :  

{-1}  IRpart(P!1, u!1, P!1 - 1)(n_last) =>
       (P!1 = p AND u!1 = hu(p - 1) AND P!1 - 1 = p - 1)
[-2]  IRpart(P!1, u!1, P!1 - 1)(i!1)
[-3]  i!2 < P!1 - 1
[-4]  i!1 = n_last
  |-------
[1]   i!2 < p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictinit_last.1.9.

restrictinit_last.1.10 :  

[-1]  i!1 = n_last
[-2]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              x: list[Identity]):
        length(x) = P!1 - 1 IMPLIES
         FORALL (i: below[P!1 - 1]): i < length[Identity](x)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    length(x) = P!1 - 1 AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!1 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!1)) >>
                Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictinit_last.1.10 :  

{-1}  length(x!1) = P!1 - 1
[-2]  i!1 = n_last
[-3]  2 <= P!1
  |-------
{1}   i!2 < length[Identity](x!1)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    length(x) = P!1 - 1 AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!1 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!1)) >>
                Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (typepred "i!2")
Adding type constraints for  i!2,
this simplifies to: 
restrictinit_last.1.10 :  

{-1}  i!2 < P!1 - 1
[-2]  length(x!1) = P!1 - 1
[-3]  i!1 = n_last
[-4]  2 <= P!1
  |-------
[1]   i!2 < length[Identity](x!1)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    length(x) = P!1 - 1 AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!1 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!1)) >>
                Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete -3 -4 2)
Deleting some formulas,
this simplifies to: 
restrictinit_last.1.10 :  

[-1]  i!2 < P!1 - 1
[-2]  length(x!1) = P!1 - 1
  |-------
[1]   i!2 < length[Identity](x!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictinit_last.1.10.

restrictinit_last.1.11 :  

[-1]  i!1 = n_last
[-2]  2 <= P!1
  |-------
{1}   FORALL (x: list[Identity]):
        length(x) = P!1 - 1 IMPLIES FORALL (i: below[P!1 - 1]): i < p
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    length(x) = P!1 - 1 AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!1 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!1)) >>
                Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
restrictinit_last.1.11 :  

[-1]  i!1 = n_last
[-2]  2 <= P!1
  |-------
[1]   FORALL (x: list[Identity]):
        length(x) = P!1 - 1 IMPLIES FORALL (i: below[P!1 - 1]): i < p

Rerunning step: (typepred i!1)
Adding type constraints for  i!1,
this simplifies to: 
restrictinit_last.1.11 :  

{-1}  IRpart(P!1, u!1, P!1 - 1)(i!1)
[-2]  i!1 = n_last
[-3]  2 <= P!1
  |-------
[1]   FORALL (x: list[Identity]):
        length(x) = P!1 - 1 IMPLIES FORALL (i: below[P!1 - 1]): i < p

Rerunning step: (lemma "n_orig" ("P" "P!1" "u" "u!1" "r" "P!1-1"))
Applying n_orig where 
  P gets P!1,
  u gets u!1,
  r gets P!1 - 1,
this simplifies to: 
restrictinit_last.1.11 :  

{-1}  IRpart(P!1, u!1, P!1 - 1)(n_last) =>
       (P!1 = p AND u!1 = hu(p - 1) AND P!1 - 1 = p - 1)
[-2]  IRpart(P!1, u!1, P!1 - 1)(i!1)
[-3]  i!1 = n_last
[-4]  2 <= P!1
  |-------
[1]   FORALL (x: list[Identity]):
        length(x) = P!1 - 1 IMPLIES FORALL (i: below[P!1 - 1]): i < p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictinit_last.1.11.

restrictinit_last.1.12 :  

[-1]  i!1 = n_last
[-2]  2 <= P!1
  |-------
{1}   FORALL (x: list[Identity]):
        length(x) = P!1 - 1 IMPLIES
         FORALL (i: below[P!1 - 1]): i < length[Identity](x)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    length(x) = P!1 - 1 AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!1 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!1)) >>
                Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictinit_last.1.12 :  

  |-------
[1]   FORALL (x: list[Identity]):
        length(x) = P!1 - 1 IMPLIES
         FORALL (i: below[P!1 - 1]): i < length[Identity](x)

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictinit_last.1.12 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (x!1)
  |-------
{1}   length(x!1) = P!1 - 1 IMPLIES
       FORALL (i: below[P!1 - 1]): i < length[Identity](x!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictinit_last.1.12.


This completes the proof of restrictinit_last.1.

restrictinit_last.2 :  

[-1]  2 <= P!1
  |-------
{1}   i!1 = n_last
{2}   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!1 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!1)) >>
                Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (choice3)
Applying choice rule,
this yields  6 subgoals: 
restrictinit_last.2.1 :  

[-1]  2 <= P!1
  |-------
[1]   i!1 = n_last
{2}   (rec(u!1, nth(i!2`2, P!1 - 2),
           E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
        >>
        (trans(u!1, car(i!2`2),
               E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :))))))
          >>
          (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
            >>
            (signal(commit(P!1 - 1, append(i!2`2, (: u!1 :)), i!1)) >>
              Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictinit_last.2.1 :  

{-1}  rho_init(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
{1}   ((trans(u!1, car(i!2`2),
              E(public(car(i!2`2)),
                conc(nlist(append(i!2`1, (: i!1 :))),
                     ilist(append(cdr(i!2`2), (: u!1 :))))))
         >>
         (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
           >>
           (signal(commit(P!1 - 1, append(i!2`2, (: u!1 :)), i!1)) >>
             Stop[event])))
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
{2}   R_init(rec(u!1, nth(i!2`2, P!1 - 2),
                 E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2)))))
{3}   rec(u!1, nth(i!2`2, P!1 - 2),
          E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
       >>
       ((trans(u!1, car(i!2`2),
               E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :))))))
          >>
          (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
            >>
            (signal(commit(P!1 - 1, append(i!2`2, (: u!1 :)), i!1)) >>
              Stop[event])))
         # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[4]   i!1 = n_last

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_last.2.1 :  

[-1]  rho_init(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   ((trans(u!1, car(i!2`2),
              E(public(car(i!2`2)),
                conc(nlist(append(i!2`1, (: i!1 :))),
                     ilist(append(cdr(i!2`2), (: u!1 :))))))
         >>
         (rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
           >>
           (signal(commit(P!1 - 1, append(i!2`2, (: u!1 :)), i!1)) >>
             Stop[event])))
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[2]   i!1 = n_last

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictinit_last.2.1.1 :  

[-1]  rho_init(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
{1}   rho_init(E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :))))))
{2}   R_init(trans(u!1, car(i!2`2),
                   E(public(car(i!2`2)),
                     conc(nlist(append(i!2`1, (: i!1 :))),
                          ilist(append(cdr(i!2`2), (: u!1 :)))))))
{3}   trans(u!1, car(i!2`2),
            E(public(car(i!2`2)),
              conc(nlist(append(i!2`1, (: i!1 :))),
                   ilist(append(cdr(i!2`2), (: u!1 :))))))
       >>
       ((rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :)))) >>
          (signal(commit(P!1 - 1, append(i!2`2, (: u!1 :)), i!1)) >>
            Stop[event]))
         # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[4]   i!1 = n_last

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_last.2.1.1 :  

[-1]  rho_init(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   rho_init(E(public(car(i!2`2)),
                 conc(nlist(append(i!2`1, (: i!1 :))),
                      ilist(append(cdr(i!2`2), (: u!1 :))))))
[2]   i!1 = n_last

Rerunning step: (expand "E")
Expanding the definition of E,
this simplifies to: 
restrictinit_last.2.1.1 :  

{-1}  rho_init(code(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
{1}   rho_init(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))
[2]   i!1 = n_last

Rerunning step: (expand "rho_init" -1)
Expanding the definition of rho_init,
this simplifies to: 
restrictinit_last.2.1.1 :  

{-1}  rho_init(conc(nlist(i!2`1), ilist(i!2`2))) OR
       (public(u!1) = public(hu(0)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
           conc(nlist(i!2`1), ilist(i!2`2)) =
            conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
[-2]  2 <= P!1
  |-------
[1]   rho_init(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))
[2]   i!1 = n_last

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
restrictinit_last.2.1.1.1 :  

{-1}  rho_init(conc(nlist(i!2`1), ilist(i!2`2)))
[-2]  2 <= P!1
  |-------
[1]   rho_init(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))
[2]   i!1 = n_last

Rerunning step: (lemma "listprops[Nonce].elt_append3"
                 ("l1" "i!2`1" "l2" "(:i!1:)" "t" "n_last"))
Applying listprops[Nonce].elt_append3 where 
  l1 gets i!2`1,
  l2 gets (: i!1 :),
  t gets n_last,
this simplifies to: 
restrictinit_last.2.1.1.1 :  

{-1}  elt(append(i!2`1, (: i!1 :)), n_last) IMPLIES
       elt(i!2`1, n_last) OR elt((: i!1 :), n_last)
[-2]  rho_init(conc(nlist(i!2`1), ilist(i!2`2)))
[-3]  2 <= P!1
  |-------
[1]   rho_init(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))
[2]   i!1 = n_last

Rerunning step: (lemma "listprops[Nonce].elt_singleton"
                 ("t1" "i!1" "t2" "n_last"))
Applying listprops[Nonce].elt_singleton where 
  t1 gets i!1,
  t2 gets n_last,
this simplifies to: 
restrictinit_last.2.1.1.1 :  

{-1}  elt((: i!1 :), n_last) IFF i!1 = n_last
[-2]  elt(append(i!2`1, (: i!1 :)), n_last) IMPLIES
       elt(i!2`1, n_last) OR elt((: i!1 :), n_last)
[-3]  rho_init(conc(nlist(i!2`1), ilist(i!2`2)))
[-4]  2 <= P!1
  |-------
[1]   rho_init(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))
[2]   i!1 = n_last

Rerunning step: (grind :exclude "elt")
rho_init rewrites rho_init(nlist(i!2`1))
  to FALSE
rho_init rewrites rho_init(ilist(i!2`2))
  to TRUE
rho_init rewrites rho_init(conc(nlist(i!2`1), ilist(i!2`2)))
  to FALSE
rho_init rewrites rho_init(nlist(i!2`1))
  to NOT elt(i!2`1, n_last)
rho_init rewrites rho_init(ilist(i!2`2))
  to TRUE
rho_init rewrites rho_init(conc(nlist(i!2`1), ilist(i!2`2)))
  to NOT elt(i!2`1, n_last)
rho_init rewrites rho_init(nlist(append(i!2`1, (: i!1 :))))
  to TRUE
rho_init rewrites rho_init(ilist(append(cdr(i!2`2), (: u!1 :))))
  to TRUE
rho_init rewrites 
  rho_init(conc(nlist(append(i!2`1, (: i!1 :))),
                ilist(append(cdr(i!2`2), (: u!1 :)))))
  to TRUE
rho_init rewrites 
  rho_init(code(public(car(i!2`2)),
                conc(nlist(append(i!2`1, (: i!1 :))),
                     ilist(append(cdr(i!2`2), (: u!1 :))))))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictinit_last.2.1.1.1.

restrictinit_last.2.1.1.2 :  

{-1}  (public(u!1) = public(hu(0)) AND
        EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
          conc(nlist(i!2`1), ilist(i!2`2)) =
           conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
[-2]  2 <= P!1
  |-------
[1]   rho_init(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))
[2]   i!1 = n_last

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictinit_last.2.1.1.2 :  

{-1}  public(u!1) = public(hu(0))
{-2}  conc(nlist(i!2`1), ilist(i!2`2)) =
       conc(nlist(append(nl!1, (: n_last :))), ilist(cdr(hu_list)))
[-3]  2 <= P!1
  |-------
[1]   rho_init(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))
[2]   i!1 = n_last

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictinit_last.2.1.1.2 :  

{-1}  u!1 = hu(0)
[-2]  conc(nlist(i!2`1), ilist(i!2`2)) =
       conc(nlist(append(nl!1, (: n_last :))), ilist(cdr(hu_list)))
[-3]  2 <= P!1
  |-------
[1]   rho_init(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))
[2]   i!1 = n_last

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictinit_last.2.1.1.2 :  

{-1}  nlist(i!2`1) = nlist(append(nl!1, (: n_last :)))
{-2}  ilist(i!2`2) = ilist(cdr(hu_list))
[-3]  u!1 = hu(0)
[-4]  2 <= P!1
  |-------
[1]   rho_init(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))
[2]   i!1 = n_last

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictinit_last.2.1.1.2 :  

{-1}  i!2`1 = append(nl!1, (: n_last :))
[-2]  ilist(i!2`2) = ilist(cdr(hu_list))
[-3]  u!1 = hu(0)
[-4]  2 <= P!1
  |-------
[1]   rho_init(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))
[2]   i!1 = n_last

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictinit_last.2.1.1.2 :  

{-1}  i!2`2 = cdr(hu_list)
[-2]  i!2`1 = append(nl!1, (: n_last :))
[-3]  u!1 = hu(0)
[-4]  2 <= P!1
  |-------
[1]   rho_init(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))
[2]   i!1 = n_last

Rerunning step: (typepred "nl!1" "i!2`1" "i!2`2" "hu_list")
Adding type constraints for  nl!1, i!2`1, i!2`2, hu_list,
this simplifies to: 
restrictinit_last.2.1.1.2 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl!1)
{-2}  length(nl!1) = p - 1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`1)
{-4}  length(i!2`1) = P!1 - 1
{-5}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`2)
{-6}  length(i!2`2) = P!1 - 1
{-7}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-8}  (length(hu_list) = p)
{-9}  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!2`2 = cdr(hu_list)
[-11] i!2`1 = append(nl!1, (: n_last :))
[-12] u!1 = hu(0)
[-13] 2 <= P!1
  |-------
[1]   rho_init(code(public(car(i!2`2)),
                    conc(nlist(append(i!2`1, (: i!1 :))),
                         ilist(append(cdr(i!2`2), (: u!1 :))))))
[2]   i!1 = n_last

Rerunning step: (delete -1 -3 -5 -7 +)
Deleting some formulas,
this simplifies to: 
restrictinit_last.2.1.1.2 :  

[-1]  length(nl!1) = p - 1
[-2]  length(i!2`1) = P!1 - 1
[-3]  length(i!2`2) = P!1 - 1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  i!2`2 = cdr(hu_list)
[-7]  i!2`1 = append(nl!1, (: n_last :))
[-8]  u!1 = hu(0)
[-9]  2 <= P!1
  |-------

Rerunning step: (case "P!1=p")
Case splitting on 
   P!1 = p, 
this yields  2 subgoals: 
restrictinit_last.2.1.1.2.1 :  

{-1}  P!1 = p
[-2]  length(nl!1) = p - 1
[-3]  length(i!2`1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  i!2`2 = cdr(hu_list)
[-8]  i!2`1 = append(nl!1, (: n_last :))
[-9]  u!1 = hu(0)
[-10] 2 <= P!1
  |-------

Rerunning step: (replace -8 -3)
Replacing using formula -8,
this simplifies to: 
restrictinit_last.2.1.1.2.1 :  

[-1]  P!1 = p
[-2]  length(nl!1) = p - 1
{-3}  length(append(nl!1, (: n_last :))) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  i!2`2 = cdr(hu_list)
[-8]  i!2`1 = append(nl!1, (: n_last :))
[-9]  u!1 = hu(0)
[-10] 2 <= P!1
  |-------

Rerunning step: (rewrite "length_append" -3)
Found matching substitution:
l2: list[T] gets (: n_last :),
l1: list[T] gets nl!1,
Rewriting using length_append, matching in -3,
this simplifies to: 
restrictinit_last.2.1.1.2.1 :  

[-1]  P!1 = p
[-2]  length(nl!1) = p - 1
{-3}  length((: n_last :)) + length(nl!1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  i!2`2 = cdr(hu_list)
[-8]  i!2`1 = append(nl!1, (: n_last :))
[-9]  u!1 = hu(0)
[-10] 2 <= P!1
  |-------

Rerunning step: (replace -2 -3)
Replacing using formula -2,
this simplifies to: 
restrictinit_last.2.1.1.2.1 :  

[-1]  P!1 = p
[-2]  length(nl!1) = p - 1
{-3}  length((: n_last :)) + (p - 1) = P!1 - 1
[-4]  length(i!2`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  i!2`2 = cdr(hu_list)
[-8]  i!2`1 = append(nl!1, (: n_last :))
[-9]  u!1 = hu(0)
[-10] 2 <= P!1
  |-------

Rerunning step: (delete -2 -4 -5 -6 -7 -8 -9 -10)
Deleting some formulas,
this simplifies to: 
restrictinit_last.2.1.1.2.1 :  

[-1]  P!1 = p
[-2]  length((: n_last :)) + (p - 1) = P!1 - 1
  |-------

Rerunning step: (grind)
length rewrites length[Identity]((: :))
  to 0
length rewrites length((: n_last :))
  to 1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictinit_last.2.1.1.2.1.

restrictinit_last.2.1.1.2.2 :  

[-1]  length(nl!1) = p - 1
[-2]  length(i!2`1) = P!1 - 1
[-3]  length(i!2`2) = P!1 - 1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  i!2`2 = cdr(hu_list)
[-7]  i!2`1 = append(nl!1, (: n_last :))
[-8]  u!1 = hu(0)
[-9]  2 <= P!1
  |-------
{1}   P!1 = p

Rerunning step: (replace -6 -3)
Replacing using formula -6,
this simplifies to: 
restrictinit_last.2.1.1.2.2 :  

[-1]  length(nl!1) = p - 1
[-2]  length(i!2`1) = P!1 - 1
{-3}  length(cdr(hu_list)) = P!1 - 1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  i!2`2 = cdr(hu_list)
[-7]  i!2`1 = append(nl!1, (: n_last :))
[-8]  u!1 = hu(0)
[-9]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (rewrite "length_cdr" -3)
Found matching substitution:
cons_l: (cons?[T]) gets hu_list,
Rewriting using length_cdr, matching in -3,
this simplifies to: 
restrictinit_last.2.1.1.2.2 :  

[-1]  length(nl!1) = p - 1
[-2]  length(i!2`1) = P!1 - 1
{-3}  length(hu_list) - 1 = P!1 - 1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  i!2`2 = cdr(hu_list)
[-7]  i!2`1 = append(nl!1, (: n_last :))
[-8]  u!1 = hu(0)
[-9]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (delete -1 -2 -5 -6 -7 -8 -9)
Deleting some formulas,
this simplifies to: 
restrictinit_last.2.1.1.2.2 :  

[-1]  length(hu_list) - 1 = P!1 - 1
[-2]  (length(hu_list) = p)
  |-------
[1]   P!1 = p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictinit_last.2.1.1.2.2.


This completes the proof of restrictinit_last.2.1.1.2.


This completes the proof of restrictinit_last.2.1.1.

restrictinit_last.2.1.2 :  

[-1]  rho_init(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
{1}   ((rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :)))) >>
         (signal(commit(P!1 - 1, append(i!2`2, (: u!1 :)), i!1)) >>
           Stop[event]))
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
{2}   R_init(trans(u!1, car(i!2`2),
                   E(public(car(i!2`2)),
                     conc(nlist(append(i!2`1, (: i!1 :))),
                          ilist(append(cdr(i!2`2), (: u!1 :)))))))
{3}   trans(u!1, car(i!2`2),
            E(public(car(i!2`2)),
              conc(nlist(append(i!2`1, (: i!1 :))),
                   ilist(append(cdr(i!2`2), (: u!1 :))))))
       >>
       ((rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :)))) >>
          (signal(commit(P!1 - 1, append(i!2`2, (: u!1 :)), i!1)) >>
            Stop[event]))
         # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[4]   i!1 = n_last

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_last.2.1.2 :  

[-1]  rho_init(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-2]  2 <= P!1
  |-------
[1]   ((rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :)))) >>
         (signal(commit(P!1 - 1, append(i!2`2, (: u!1 :)), i!1)) >>
           Stop[event]))
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[2]   i!1 = n_last

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictinit_last.2.1.2 :  

{-1}  rho_init(E(public(u!1), nlist((: i!1 :))))
[-2]  rho_init(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-3]  2 <= P!1
  |-------
{1}   ((signal(commit(P!1 - 1, append(i!2`2, (: u!1 :)), i!1)) >>
         Stop[event])
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
{2}   R_init(rec(u!1, nth(i!2`2, P!1 - 2),
                 E(public(u!1), nlist((: i!1 :)))))
{3}   rec(u!1, nth(i!2`2, P!1 - 2), E(public(u!1), nlist((: i!1 :)))) >>
       ((signal(commit(P!1 - 1, append(i!2`2, (: u!1 :)), i!1)) >>
          Stop[event])
         # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[4]   i!1 = n_last

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_last.2.1.2 :  

[-1]  rho_init(E(public(u!1), nlist((: i!1 :))))
[-2]  rho_init(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-3]  2 <= P!1
  |-------
[1]   ((signal(commit(P!1 - 1, append(i!2`2, (: u!1 :)), i!1)) >>
         Stop[event])
        # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[2]   i!1 = n_last

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictinit_last.2.1.2.1 :  

[-1]  rho_init(E(public(u!1), nlist((: i!1 :))))
[-2]  rho_init(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-3]  2 <= P!1
  |-------
{1}   rho_init(commit(P!1 - 1, append(i!2`2, (: u!1 :)), i!1))
{2}   R_init(signal(commit(P!1 - 1, append(i!2`2, (: u!1 :)), i!1)))
{3}   signal(commit(P!1 - 1, append(i!2`2, (: u!1 :)), i!1)) >>
       (Stop[event] # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[4]   i!1 = n_last

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_last.2.1.2.1 :  

  |-------
[1]   rho_init(commit(P!1 - 1, append(i!2`2, (: u!1 :)), i!1))
[2]   i!1 = n_last

Rerunning step: (grind)
/= rewrites append(i!2`2, (: u!1 :)) /= hu_list
  to NOT (append(i!2`2, (: u!1 :)) = hu_list)
rho_init rewrites rho_init(commit(P!1 - 1, append(i!2`2, (: u!1 :)), i!1))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictinit_last.2.1.2.1.

restrictinit_last.2.1.2.2 :  

[-1]  rho_init(E(public(u!1), nlist((: i!1 :))))
[-2]  rho_init(E(public(u!1), conc(nlist(i!2`1), ilist(i!2`2))))
[-3]  2 <= P!1
  |-------
{1}   (Stop[event] # R_init) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
{2}   R_init(signal(commit(P!1 - 1, append(i!2`2, (: u!1 :)), i!1)))
{3}   signal(commit(P!1 - 1, append(i!2`2, (: u!1 :)), i!1)) >>
       (Stop[event] # R_init)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)
[4]   i!1 = n_last

Rerunning step: (delete - 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictinit_last.2.1.2.2 :  

  |-------
[1]   (Stop[event] # R_init) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictinit_last.2.1.2.2.


This completes the proof of restrictinit_last.2.1.2.


This completes the proof of restrictinit_last.2.1.

restrictinit_last.2.2 :  

[-1]  2 <= P!1
  |-------
{1}   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!1 :))
[2]   i!1 = n_last
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!1 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!1)) >>
                Stop[event]))))
         # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_last.2.2 :  

  |-------
[1]   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!1 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!1 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictinit_last.2.2.

restrictinit_last.2.3 :  

[-1]  2 <= P!1
  |-------
{1}   cons?[Identity](i!2`2)
[2]   i!1 = n_last
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!1 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!1)) >>
                Stop[event]))))
         # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_last.2.3 :  

[-1]  2 <= P!1
  |-------
[1]   cons?[Identity](i!2`2)

Rerunning step: (nonemptylist "i!2`2")
Relating existence of a tail to a list's length,

This completes the proof of restrictinit_last.2.3.

restrictinit_last.2.4 :  

[-1]  2 <= P!1
  |-------
{1}   P!1 - 2 < length[Identity](i!2`2)
[2]   i!1 = n_last
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!1 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!1)) >>
                Stop[event]))))
         # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (typepred "i!2`2")
Adding type constraints for  i!2`2,
this simplifies to: 
restrictinit_last.2.4 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!2`2)
{-2}  length(i!2`2) = P!1 - 1
[-3]  2 <= P!1
  |-------
[1]   P!1 - 2 < length[Identity](i!2`2)
[2]   i!1 = n_last
[3]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!1 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!1)) >>
                Stop[event]))))
         # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete -1 -3 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_last.2.4 :  

[-1]  length(i!2`2) = P!1 - 1
  |-------
[1]   P!1 - 2 < length[Identity](i!2`2)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictinit_last.2.4.

restrictinit_last.2.5 :  

[-1]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!1 :))
[2]   i!1 = n_last
[3]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!1 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!1)) >>
                Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_last.2.5 :  

  |-------
[1]   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!1 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!1 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictinit_last.2.5.

restrictinit_last.2.6 :  

[-1]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        cons?[Identity](il)
[2]   i!1 = n_last
[3]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!1 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!1)) >>
                Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictinit_last.2.6 :  

[-1]  2 <= P!1
  |-------
{1}   cons?[Identity](il!1)
[2]   i!1 = n_last
[3]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!1 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!1 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!1)) >>
                Stop[event]))))
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_init(msg(e)))(t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictinit_last.2.6 :  

[-1]  2 <= P!1
  |-------
[1]   cons?[Identity](il!1)

Rerunning step: (nonemptylist "il!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictinit_last.2.6.


This completes the proof of restrictinit_last.2.

Q.E.D.


Run time  = 4.87 secs.
Real time = 6.63 secs.
nil
pvs(52): 
Installing rewrite rule sets.singleton_rew (all instances)
authentication_init :  

  |-------
{1}   network(USER) |> auth(T, R_init)

Rerunning step: (auto-rewrite-theory "sets")
Rewriting relative to the theory: sets,
this simplifies to: 
authentication_init :  

  |-------
[1]   network(USER) |> auth(T, R_init)

Rerunning step: (rewrite "authentication_by_rank" + ("rho" "rho_init"))
Found matching substitution:
R: setof[event] gets R_init,
T: setof[event] gets T,
users: [Identity -> process[event]] gets USER,
rho: setof[Message] gets rho_init,
member rewrites member(x, INIT)
  to INIT(x)
member rewrites member(x, rho_init)
  to rho_init(x)
subset? rewrites subset?(INIT, rho_init)
  to FORALL (x: Message): INIT(x) => rho_init(x)
member rewrites member(x, S)
  to S(x)
member rewrites member(x, rho_init)
  to rho_init(x)
subset? rewrites subset?(S, rho_init)
  to FORALL (x: Message): S(x) => rho_init(x)
Rewriting using authentication_by_rank, matching in + where
  rho gets rho_init,
this yields  4 subgoals: 
authentication_init.1 :  

  |-------
{1}   FORALL (x: Message): INIT(x) => rho_init(x)
[2]   network(USER) |> auth(T, R_init)

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_init.1 :  

  |-------
[1]   FORALL (x: Message): INIT(x) => rho_init(x)

Rerunning step: (comment "intruder's initial knowledge is in rho")
Adding comment: intruder's initial knowledge is in rho
this simplifies to: 
authentication_init.1 : 
;;; intruder's initial knowledge is in rho

  |-------
[1]   FORALL (x: Message): INIT(x) => rho_init(x)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_init.1 : 
;;; intruder's initial knowledge is in rho

  |-------
{1}   INIT(x!1) => rho_init(x!1)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_init.1 : 
;;; intruder's initial knowledge is in rho

{-1}  INIT(x!1)
  |-------
{1}   rho_init(x!1)

Rerunning step: (expand "INIT")
Expanding the definition of INIT,
this simplifies to: 
authentication_init.1 : 
;;; intruder's initial knowledge is in rho

{-1}  CASES x!1
        OF user(z): TRUE,
           nonce(z): z /= n_last,
           public(z): TRUE,
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i))
        ELSE FALSE
        ENDCASES
  |-------
[1]   rho_init(x!1)

Rerunning step: (expand "rho_init")
Expanding the definition of rho_init,
this simplifies to: 
authentication_init.1 : 
;;; intruder's initial knowledge is in rho

[-1]  CASES x!1
        OF user(z): TRUE,
           nonce(z): z /= n_last,
           public(z): TRUE,
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i))
        ELSE FALSE
        ENDCASES
  |-------
{1}   CASES x!1
        OF nonce(z): z /= n_last,
           nlist(z): NOT elt(z, n_last),
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i)),
           conc(z1, z2): rho_init(z1) AND rho_init(z2),
           commit(z1, z2, z3):
             z1 /= p - 1 OR z2 /= hu_list OR z3 /= n_last,
           code(z1, z2):
             rho_init(z2) OR
              (z1 = public(hu(0)) AND
                (EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
                   z2 =
                    conc(nlist(append(nl, (: n_last :))),
                         ilist(cdr(hu_list)))))
        ELSE TRUE
        ENDCASES

Rerunning step: (smash)
Repeatedly simplifying with BDDs, decision procedures, rewriting,
and if-lifting,

This completes the proof of authentication_init.1.

authentication_init.2 :  

  |-------
{1}   FORALL (S: setof[Message]), (m: Message):
        (FORALL (x: Message): S(x) => rho_init(x)) AND (S |- m) IMPLIES
         rho_init(m)
[2]   network(USER) |> auth(T, R_init)

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_init.2 :  

  |-------
[1]   FORALL (S: setof[Message]), (m: Message):
        (FORALL (x: Message): S(x) => rho_init(x)) AND (S |- m) IMPLIES
         rho_init(m)

Rerunning step: (comment "from of a set of messages in rho, no message not in rho can be generated")
Adding comment: from of a set of messages in rho, no message not in rho can be generated
this simplifies to: 
authentication_init.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   FORALL (S: setof[Message]), (m: Message):
        (FORALL (x: Message): S(x) => rho_init(x)) AND (S |- m) IMPLIES
         rho_init(m)

Rerunning step: (expand "|-")
Expanding the definition of |-,
this simplifies to: 
authentication_init.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   FORALL (S: setof[Message]), (m: Message):
        (FORALL (x: Message): S(x) => rho_init(x)) AND Gen(S, m) IMPLIES
         rho_init(m)

Rerunning step: (rule-induct "Gen")
Applying rule (co)induction over Gen,
this simplifies to: 
authentication_init.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  FORALL (x: Message): S!1(x) => rho_init(x)
  |-------
{1}   FORALL (m: Message):
        (     S!1(m)
          OR (EXISTS m1, m2:
                rho_init(m1) AND rho_init(m2) AND m = conc(m1, m2))
          OR (EXISTS m1: rho_init(conc(m1, m)))
          OR (EXISTS m2: rho_init(conc(m, m2)))
          OR (EXISTS (n: Nonce): rho_init(nonce(n)) AND m = nlist((: n :)))
          OR (EXISTS (n: Nonce): rho_init(nlist((: n :))) AND m = nonce(n))
          OR (EXISTS (nl1, nl2: list[Nonce]):
                rho_init(nlist(nl1)) AND
                 rho_init(nlist(nl2)) AND m = nlist(append(nl1, nl2)))
          OR (EXISTS (nl, nl1, nl2: list[Nonce]):
                rho_init(nlist(nl)) AND
                 nl = append(nl1, nl2) AND m = nlist(nl1))
          OR (EXISTS (nl, nl1, nl2: list[Nonce]):
                rho_init(nlist(nl)) AND
                 nl = append(nl1, nl2) AND m = nlist(nl2))
          OR (EXISTS (i: Identity):
                rho_init(user(i)) AND m = ilist((: i :)))
          OR (EXISTS (i: Identity):
                rho_init(ilist((: i :))) AND m = user(i))
          OR (EXISTS (il1, il2: list[Identity]):
                rho_init(ilist(il1)) AND
                 rho_init(ilist(il2)) AND m = ilist(append(il1, il2)))
          OR (EXISTS (il, il1, il2: list[Identity]):
                rho_init(ilist(il)) AND
                 il = append(il1, il2) AND m = ilist(il1))
          OR (EXISTS (il, il1, il2: list[Identity]):
                rho_init(ilist(il)) AND
                 il = append(il1, il2) AND m = ilist(il2))
          OR EXISTS m1, k: rho_init(m1) AND rho_init(k) AND m = E(k, m1))
         IMPLIES rho_init(m)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_init.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  FORALL (x: Message): S!1(x) => rho_init(x)
  |-------
{1}   (     S!1(m!2)
        OR (EXISTS m1, m2:
              rho_init(m1) AND rho_init(m2) AND m!2 = conc(m1, m2))
        OR (EXISTS m1: rho_init(conc(m1, m!2)))
        OR (EXISTS m2: rho_init(conc(m!2, m2)))
        OR (EXISTS (n: Nonce): rho_init(nonce(n)) AND m!2 = nlist((: n :)))
        OR (EXISTS (n: Nonce): rho_init(nlist((: n :))) AND m!2 = nonce(n))
        OR (EXISTS (nl1, nl2: list[Nonce]):
              rho_init(nlist(nl1)) AND
               rho_init(nlist(nl2)) AND m!2 = nlist(append(nl1, nl2)))
        OR (EXISTS (nl, nl1, nl2: list[Nonce]):
              rho_init(nlist(nl)) AND
               nl = append(nl1, nl2) AND m!2 = nlist(nl1))
        OR (EXISTS (nl, nl1, nl2: list[Nonce]):
              rho_init(nlist(nl)) AND
               nl = append(nl1, nl2) AND m!2 = nlist(nl2))
        OR (EXISTS (i: Identity):
              rho_init(user(i)) AND m!2 = ilist((: i :)))
        OR (EXISTS (i: Identity):
              rho_init(ilist((: i :))) AND m!2 = user(i))
        OR (EXISTS (il1, il2: list[Identity]):
              rho_init(ilist(il1)) AND
               rho_init(ilist(il2)) AND m!2 = ilist(append(il1, il2)))
        OR (EXISTS (il, il1, il2: list[Identity]):
              rho_init(ilist(il)) AND
               il = append(il1, il2) AND m!2 = ilist(il1))
        OR (EXISTS (il, il1, il2: list[Identity]):
              rho_init(ilist(il)) AND
               il = append(il1, il2) AND m!2 = ilist(il2))
        OR EXISTS m1, k: rho_init(m1) AND rho_init(k) AND m!2 = E(k, m1))
       IMPLIES rho_init(m!2)

Rerunning step: (smash)
Repeatedly simplifying with BDDs, decision procedures, rewriting,
and if-lifting,
this yields  15 subgoals: 
authentication_init.2.1 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  S!1(m!2)
[-2]  FORALL (x: Message): S!1(x) => rho_init(x)
  |-------
{1}   rho_init(m!2)

Rerunning step: (inst -2 "m!2")
Instantiating the top quantifier in -2 with the terms: 
 m!2,
this simplifies to: 
authentication_init.2.1 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  S!1(m!2)
{-2}  S!1(m!2) => rho_init(m!2)
  |-------
[1]   rho_init(m!2)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_init.2.1.

authentication_init.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS m1, m2: rho_init(m1) AND rho_init(m2) AND m!2 = conc(m1, m2)
[-2]  FORALL (x: Message): S!1(x) => rho_init(x)
  |-------
{1}   rho_init(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_init.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS m1, m2: rho_init(m1) AND rho_init(m2) AND m!2 = conc(m1, m2)
  |-------
[1]   rho_init(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_init.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(m1!1) AND rho_init(m2!1) AND m!2 = conc(m1!1, m2!1)
  |-------
[1]   rho_init(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_init.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(m1!1)
{-2}  rho_init(m2!1)
{-3}  m!2 = conc(m1!1, m2!1)
  |-------
[1]   rho_init(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_init.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_init(m1!1)
[-2]  rho_init(m2!1)
[-3]  m!2 = conc(m1!1, m2!1)
  |-------
{1}   rho_init(conc(m1!1, m2!1))

Rerunning step: (expand "rho_init" 1)
Expanding the definition of rho_init,
this simplifies to: 
authentication_init.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_init(m1!1)
[-2]  rho_init(m2!1)
[-3]  m!2 = conc(m1!1, m2!1)
  |-------
{1}   rho_init(m1!1) AND rho_init(m2!1)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_init.2.2.

authentication_init.2.3 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS m1: rho_init(conc(m1, m!2))
[-2]  FORALL (x: Message): S!1(x) => rho_init(x)
  |-------
{1}   rho_init(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_init.2.3 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS m1: rho_init(conc(m1, m!2))
  |-------
[1]   rho_init(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_init.2.3 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(conc(m1!1, m!2))
  |-------
[1]   rho_init(m!2)

Rerunning step: (expand "rho_init" -1)
Expanding the definition of rho_init,
this simplifies to: 
authentication_init.2.3 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  FALSE
  |-------
[1]   rho_init(m!2)

which is trivially true.

This completes the proof of authentication_init.2.3.

authentication_init.2.4 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS m2: rho_init(conc(m!2, m2))
[-2]  FORALL (x: Message): S!1(x) => rho_init(x)
  |-------
{1}   rho_init(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_init.2.4 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS m2: rho_init(conc(m!2, m2))
  |-------
[1]   rho_init(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_init.2.4 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(conc(m!2, m2!1))
  |-------
[1]   rho_init(m!2)

Rerunning step: (expand "rho_init" -1)
Expanding the definition of rho_init,
this simplifies to: 
authentication_init.2.4 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  FALSE
  |-------
[1]   rho_init(m!2)

which is trivially true.

This completes the proof of authentication_init.2.4.

authentication_init.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (n: Nonce): rho_init(nonce(n)) AND m!2 = nlist((: n :))
[-2]  FORALL (x: Message): S!1(x) => rho_init(x)
  |-------
{1}   rho_init(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_init.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (n: Nonce): rho_init(nonce(n)) AND m!2 = nlist((: n :))
  |-------
[1]   rho_init(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_init.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(nonce(n!1)) AND m!2 = nlist((: n!1 :))
  |-------
[1]   rho_init(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_init.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(nonce(n!1))
{-2}  m!2 = nlist((: n!1 :))
  |-------
[1]   rho_init(m!2)

Rerunning step: (expand "rho_init" -1)
Expanding the definition of rho_init,
this simplifies to: 
authentication_init.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  n!1 /= n_last
[-2]  m!2 = nlist((: n!1 :))
  |-------
[1]   rho_init(m!2)

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
authentication_init.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  n!1 /= n_last
[-2]  m!2 = nlist((: n!1 :))
  |-------
{1}   rho_init(nlist((: n!1 :)))

Rerunning step: (expand "rho_init")
Expanding the definition of rho_init,
this simplifies to: 
authentication_init.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  n!1 /= n_last
[-2]  m!2 = nlist((: n!1 :))
{-3}  elt((: n!1 :), n_last)
  |-------

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_init.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  n!1 /= n_last
[-2]  elt((: n!1 :), n_last)
  |-------

Rerunning step: (grind)
/= rewrites n!1 /= n_last
  to NOT (n!1 = n_last)
elt rewrites elt((: n!1 :), n_last)
  to EXISTS (i: below[length((: n!1 :))]): nth((: n!1 :), i) = n_last
length rewrites length[Nonce]((: :))
  to 0
length rewrites length((: n!1 :))
  to 1
nth rewrites nth((: n!1 :), i!1)
  to n!1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_init.2.5.

authentication_init.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (n: Nonce): rho_init(nlist((: n :))) AND m!2 = nonce(n)
[-2]  FORALL (x: Message): S!1(x) => rho_init(x)
  |-------
{1}   rho_init(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_init.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (n: Nonce): rho_init(nlist((: n :))) AND m!2 = nonce(n)
  |-------
[1]   rho_init(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_init.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(nlist((: n!1 :))) AND m!2 = nonce(n!1)
  |-------
[1]   rho_init(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_init.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(nlist((: n!1 :)))
{-2}  m!2 = nonce(n!1)
  |-------
[1]   rho_init(m!2)

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
authentication_init.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_init(nlist((: n!1 :)))
[-2]  m!2 = nonce(n!1)
  |-------
{1}   rho_init(nonce(n!1))

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_init.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_init(nlist((: n!1 :)))
  |-------
[1]   rho_init(nonce(n!1))

Rerunning step: (expand "rho_init")
Expanding the definition of rho_init,
this simplifies to: 
authentication_init.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   elt((: n!1 :), n_last)
{2}   n!1 /= n_last

Rerunning step: (expand "elt")
Expanding the definition of elt,
this simplifies to: 
authentication_init.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   EXISTS (i: below[length((: n!1 :))]): nth((: n!1 :), i) = n_last
[2]   n!1 /= n_last

Rerunning step: (inst 1 "0")
Instantiating the top quantifier in 1 with the terms: 
 0,
this yields  2 subgoals: 
authentication_init.2.6.1 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   nth((: n!1 :), 0) = n_last
[2]   n!1 /= n_last

Rerunning step: (grind :exclude 2)
nth rewrites nth((: n!1 :), 0)
  to n!1
/= rewrites n!1 /= n_last
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_init.2.6.1.

authentication_init.2.6.2 (TCC):   

  |-------
{1}   0 < length[Nonce]((: n!1 :))
[2]   n!1 /= n_last

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_init.2.6.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   0 < length[Nonce]((: n!1 :))

Rerunning step: (grind)
length rewrites length[Nonce]((: :))
  to 0
length rewrites length[Nonce]((: n!1 :))
  to 1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_init.2.6.2.


This completes the proof of authentication_init.2.6.

authentication_init.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (nl1, nl2: list[Nonce]):
        rho_init(nlist(nl1)) AND
         rho_init(nlist(nl2)) AND m!2 = nlist(append(nl1, nl2))
[-2]  FORALL (x: Message): S!1(x) => rho_init(x)
  |-------
{1}   rho_init(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_init.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (nl1, nl2: list[Nonce]):
        rho_init(nlist(nl1)) AND
         rho_init(nlist(nl2)) AND m!2 = nlist(append(nl1, nl2))
  |-------
[1]   rho_init(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_init.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(nlist(nl1!1)) AND
       rho_init(nlist(nl2!1)) AND m!2 = nlist(append(nl1!1, nl2!1))
  |-------
[1]   rho_init(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_init.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(nlist(nl1!1))
{-2}  rho_init(nlist(nl2!1))
{-3}  m!2 = nlist(append(nl1!1, nl2!1))
  |-------
[1]   rho_init(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_init.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_init(nlist(nl1!1))
[-2]  rho_init(nlist(nl2!1))
[-3]  m!2 = nlist(append(nl1!1, nl2!1))
  |-------
{1}   rho_init(nlist(append(nl1!1, nl2!1)))

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
authentication_init.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_init(nlist(nl1!1))
[-2]  rho_init(nlist(nl2!1))
  |-------
[1]   rho_init(nlist(append(nl1!1, nl2!1)))

Rerunning step: (expand "rho_init")
Expanding the definition of rho_init,
this simplifies to: 
authentication_init.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(append(nl1!1, nl2!1), n_last)
  |-------
{1}   elt(nl1!1, n_last)
{2}   elt(nl2!1, n_last)

Rerunning step: (lemma "listprops[Nonce].elt_append3"
                 ("l1" "nl1!1" "l2" "nl2!1" "t" "n_last"))
Applying listprops[Nonce].elt_append3 where 
  l1 gets nl1!1,
  l2 gets nl2!1,
  t gets n_last,
this simplifies to: 
authentication_init.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(append(nl1!1, nl2!1), n_last) IMPLIES
       elt(nl1!1, n_last) OR elt(nl2!1, n_last)
[-2]  elt(append(nl1!1, nl2!1), n_last)
  |-------
[1]   elt(nl1!1, n_last)
[2]   elt(nl2!1, n_last)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_init.2.7.

authentication_init.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (nl, nl1, nl2: list[Nonce]):
        rho_init(nlist(nl)) AND nl = append(nl1, nl2) AND m!2 = nlist(nl1)
[-2]  FORALL (x: Message): S!1(x) => rho_init(x)
  |-------
{1}   rho_init(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_init.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (nl, nl1, nl2: list[Nonce]):
        rho_init(nlist(nl)) AND nl = append(nl1, nl2) AND m!2 = nlist(nl1)
  |-------
[1]   rho_init(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_init.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(nlist(nl!1)) AND
       nl!1 = append(nl1!1, nl2!1) AND m!2 = nlist(nl1!1)
  |-------
[1]   rho_init(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_init.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(nlist(nl!1))
{-2}  nl!1 = append(nl1!1, nl2!1)
{-3}  m!2 = nlist(nl1!1)
  |-------
[1]   rho_init(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_init.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_init(nlist(nl!1))
[-2]  nl!1 = append(nl1!1, nl2!1)
[-3]  m!2 = nlist(nl1!1)
  |-------
{1}   rho_init(nlist(nl1!1))

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
authentication_init.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_init(nlist(nl!1))
[-2]  nl!1 = append(nl1!1, nl2!1)
  |-------
[1]   rho_init(nlist(nl1!1))

Rerunning step: (replace -2 -1)
Replacing using formula -2,
this simplifies to: 
authentication_init.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(nlist(append(nl1!1, nl2!1)))
[-2]  nl!1 = append(nl1!1, nl2!1)
  |-------
[1]   rho_init(nlist(nl1!1))

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_init.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_init(nlist(append(nl1!1, nl2!1)))
  |-------
[1]   rho_init(nlist(nl1!1))

Rerunning step: (expand "rho_init")
Expanding the definition of rho_init,
this simplifies to: 
authentication_init.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(nl1!1, n_last)
  |-------
{1}   elt(append(nl1!1, nl2!1), n_last)

Rerunning step: (lemma "listprops[Nonce].elt_append1"
                 ("l1" "nl1!1" "l2" "nl2!1" "t" "n_last"))
Applying listprops[Nonce].elt_append1 where 
  l1 gets nl1!1,
  l2 gets nl2!1,
  t gets n_last,
this simplifies to: 
authentication_init.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(nl1!1, n_last) IMPLIES elt(append(nl1!1, nl2!1), n_last)
[-2]  elt(nl1!1, n_last)
  |-------
[1]   elt(append(nl1!1, nl2!1), n_last)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_init.2.8.

authentication_init.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (nl, nl1, nl2: list[Nonce]):
        rho_init(nlist(nl)) AND nl = append(nl1, nl2) AND m!2 = nlist(nl2)
[-2]  FORALL (x: Message): S!1(x) => rho_init(x)
  |-------
{1}   rho_init(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_init.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (nl, nl1, nl2: list[Nonce]):
        rho_init(nlist(nl)) AND nl = append(nl1, nl2) AND m!2 = nlist(nl2)
  |-------
[1]   rho_init(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_init.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(nlist(nl!1)) AND
       nl!1 = append(nl1!1, nl2!1) AND m!2 = nlist(nl2!1)
  |-------
[1]   rho_init(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_init.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(nlist(nl!1))
{-2}  nl!1 = append(nl1!1, nl2!1)
{-3}  m!2 = nlist(nl2!1)
  |-------
[1]   rho_init(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_init.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_init(nlist(nl!1))
[-2]  nl!1 = append(nl1!1, nl2!1)
[-3]  m!2 = nlist(nl2!1)
  |-------
{1}   rho_init(nlist(nl2!1))

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
authentication_init.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_init(nlist(nl!1))
[-2]  nl!1 = append(nl1!1, nl2!1)
  |-------
[1]   rho_init(nlist(nl2!1))

Rerunning step: (replace -2 -1)
Replacing using formula -2,
this simplifies to: 
authentication_init.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(nlist(append(nl1!1, nl2!1)))
[-2]  nl!1 = append(nl1!1, nl2!1)
  |-------
[1]   rho_init(nlist(nl2!1))

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_init.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_init(nlist(append(nl1!1, nl2!1)))
  |-------
[1]   rho_init(nlist(nl2!1))

Rerunning step: (expand "rho_init")
Expanding the definition of rho_init,
this simplifies to: 
authentication_init.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(nl2!1, n_last)
  |-------
{1}   elt(append(nl1!1, nl2!1), n_last)

Rerunning step: (lemma "listprops[Nonce].elt_append2"
                 ("l1" "nl1!1" "l2" "nl2!1" "t" "n_last"))
Applying listprops[Nonce].elt_append2 where 
  l1 gets nl1!1,
  l2 gets nl2!1,
  t gets n_last,
this simplifies to: 
authentication_init.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(nl2!1, n_last) IMPLIES elt(append(nl1!1, nl2!1), n_last)
[-2]  elt(nl2!1, n_last)
  |-------
[1]   elt(append(nl1!1, nl2!1), n_last)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_init.2.9.

authentication_init.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (i: Identity): rho_init(user(i)) AND m!2 = ilist((: i :))
[-2]  FORALL (x: Message): S!1(x) => rho_init(x)
  |-------
{1}   rho_init(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_init.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (i: Identity): rho_init(user(i)) AND m!2 = ilist((: i :))
  |-------
[1]   rho_init(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_init.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(user(i!1)) AND m!2 = ilist((: i!1 :))
  |-------
[1]   rho_init(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_init.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(user(i!1))
{-2}  m!2 = ilist((: i!1 :))
  |-------
[1]   rho_init(m!2)

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
authentication_init.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_init(user(i!1))
[-2]  m!2 = ilist((: i!1 :))
  |-------
{1}   rho_init(ilist((: i!1 :)))

Rerunning step: (delete -1 -2)
Deleting some formulas,
this simplifies to: 
authentication_init.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   rho_init(ilist((: i!1 :)))

Rerunning step: (expand "rho_init")
Expanding the definition of rho_init,
this simplifies to: 
authentication_init.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_init.2.10.

authentication_init.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (i: Identity): rho_init(ilist((: i :))) AND m!2 = user(i)
[-2]  FORALL (x: Message): S!1(x) => rho_init(x)
  |-------
{1}   rho_init(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_init.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (i: Identity): rho_init(ilist((: i :))) AND m!2 = user(i)
  |-------
[1]   rho_init(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_init.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(ilist((: i!1 :))) AND m!2 = user(i!1)
  |-------
[1]   rho_init(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_init.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(ilist((: i!1 :)))
{-2}  m!2 = user(i!1)
  |-------
[1]   rho_init(m!2)

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
authentication_init.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_init(ilist((: i!1 :)))
[-2]  m!2 = user(i!1)
  |-------
{1}   rho_init(user(i!1))

Rerunning step: (delete -1 -2)
Deleting some formulas,
this simplifies to: 
authentication_init.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   rho_init(user(i!1))

Rerunning step: (expand "rho_init")
Expanding the definition of rho_init,
this simplifies to: 
authentication_init.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_init.2.11.

authentication_init.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (il1, il2: list[Identity]):
        rho_init(ilist(il1)) AND
         rho_init(ilist(il2)) AND m!2 = ilist(append(il1, il2))
[-2]  FORALL (x: Message): S!1(x) => rho_init(x)
  |-------
{1}   rho_init(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_init.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (il1, il2: list[Identity]):
        rho_init(ilist(il1)) AND
         rho_init(ilist(il2)) AND m!2 = ilist(append(il1, il2))
  |-------
[1]   rho_init(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_init.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(ilist(il1!1)) AND
       rho_init(ilist(il2!1)) AND m!2 = ilist(append(il1!1, il2!1))
  |-------
[1]   rho_init(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_init.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(ilist(il1!1))
{-2}  rho_init(ilist(il2!1))
{-3}  m!2 = ilist(append(il1!1, il2!1))
  |-------
[1]   rho_init(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_init.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_init(ilist(il1!1))
[-2]  rho_init(ilist(il2!1))
[-3]  m!2 = ilist(append(il1!1, il2!1))
  |-------
{1}   rho_init(ilist(append(il1!1, il2!1)))

Rerunning step: (delete -1 -2 -3)
Deleting some formulas,
this simplifies to: 
authentication_init.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   rho_init(ilist(append(il1!1, il2!1)))

Rerunning step: (expand "rho_init")
Expanding the definition of rho_init,
this simplifies to: 
authentication_init.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_init.2.12.

authentication_init.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (il, il1, il2: list[Identity]):
        rho_init(ilist(il)) AND il = append(il1, il2) AND m!2 = ilist(il1)
[-2]  FORALL (x: Message): S!1(x) => rho_init(x)
  |-------
{1}   rho_init(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_init.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (il, il1, il2: list[Identity]):
        rho_init(ilist(il)) AND il = append(il1, il2) AND m!2 = ilist(il1)
  |-------
[1]   rho_init(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_init.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(ilist(il!1)) AND
       il!1 = append(il1!1, il2!1) AND m!2 = ilist(il1!1)
  |-------
[1]   rho_init(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_init.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(ilist(il!1))
{-2}  il!1 = append(il1!1, il2!1)
{-3}  m!2 = ilist(il1!1)
  |-------
[1]   rho_init(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_init.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_init(ilist(il!1))
[-2]  il!1 = append(il1!1, il2!1)
[-3]  m!2 = ilist(il1!1)
  |-------
{1}   rho_init(ilist(il1!1))

Rerunning step: (delete -1 -2 -3)
Deleting some formulas,
this simplifies to: 
authentication_init.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   rho_init(ilist(il1!1))

Rerunning step: (expand "rho_init")
Expanding the definition of rho_init,
this simplifies to: 
authentication_init.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_init.2.13.

authentication_init.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (il, il1, il2: list[Identity]):
        rho_init(ilist(il)) AND il = append(il1, il2) AND m!2 = ilist(il2)
[-2]  FORALL (x: Message): S!1(x) => rho_init(x)
  |-------
{1}   rho_init(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_init.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (il, il1, il2: list[Identity]):
        rho_init(ilist(il)) AND il = append(il1, il2) AND m!2 = ilist(il2)
  |-------
[1]   rho_init(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_init.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(ilist(il!1)) AND
       il!1 = append(il1!1, il2!1) AND m!2 = ilist(il2!1)
  |-------
[1]   rho_init(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_init.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(ilist(il!1))
{-2}  il!1 = append(il1!1, il2!1)
{-3}  m!2 = ilist(il2!1)
  |-------
[1]   rho_init(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_init.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_init(ilist(il!1))
[-2]  il!1 = append(il1!1, il2!1)
[-3]  m!2 = ilist(il2!1)
  |-------
{1}   rho_init(ilist(il2!1))

Rerunning step: (delete -1 -2 -3)
Deleting some formulas,
this simplifies to: 
authentication_init.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   rho_init(ilist(il2!1))

Rerunning step: (expand "rho_init")
Expanding the definition of rho_init,
this simplifies to: 
authentication_init.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_init.2.14.

authentication_init.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS m1, k: rho_init(m1) AND rho_init(k) AND m!2 = E(k, m1)
[-2]  FORALL (x: Message): S!1(x) => rho_init(x)
  |-------
{1}   rho_init(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_init.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS m1, k: rho_init(m1) AND rho_init(k) AND m!2 = E(k, m1)
  |-------
[1]   rho_init(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_init.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(m1!1) AND rho_init(k!1) AND m!2 = E(k!1, m1!1)
  |-------
[1]   rho_init(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_init.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_init(m1!1)
{-2}  rho_init(k!1)
{-3}  m!2 = E(k!1, m1!1)
  |-------
[1]   rho_init(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_init.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_init(m1!1)
[-2]  rho_init(k!1)
[-3]  m!2 = E(k!1, m1!1)
  |-------
{1}   rho_init(E(k!1, m1!1))

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
authentication_init.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_init(m1!1)
[-2]  rho_init(k!1)
  |-------
[1]   rho_init(E(k!1, m1!1))

Rerunning step: (typepred "k!1")
Adding type constraints for  k!1,
this simplifies to: 
authentication_init.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  public?(k!1) OR secret?(k!1)
[-2]  rho_init(m1!1)
[-3]  rho_init(k!1)
  |-------
[1]   rho_init(E(k!1, m1!1))

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
authentication_init.2.15.1 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  public?(k!1)
[-2]  rho_init(m1!1)
[-3]  rho_init(k!1)
  |-------
[1]   rho_init(E(k!1, m1!1))

Rerunning step: (grind)
rho_init rewrites rho_init(k!1)
  to TRUE
E rewrites E(k!1, m1!1)
  to CASES m1!1
        OF code(k1, m1):
             CASES k1
               OF public(i):
                    IF k!1 = secret(i) THEN m1 ELSE code(k!1, m1!1) ENDIF,
                  secret(i):
                    IF k!1 = public(i) THEN m1 ELSE code(k!1, m1!1) ENDIF
               ENDCASES
        ELSE code(k!1, m1!1)
        ENDCASES
rho_init rewrites rho_init(code(k!1, m1!1))
  to TRUE
rho_init rewrites rho_init(public(x_secret(x_code(m1!1))))
  to TRUE
rho_init rewrites rho_init(m1!1)
  to FALSE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_init.2.15.1.

authentication_init.2.15.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  secret?(k!1)
[-2]  rho_init(m1!1)
[-3]  rho_init(k!1)
  |-------
[1]   rho_init(E(k!1, m1!1))

Rerunning step: (expand "rho_init" -3)
Expanding the definition of rho_init,
this simplifies to: 
authentication_init.2.15.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  secret?(k!1)
[-2]  rho_init(m1!1)
{-3}  CASES k!1
        OF nonce(z): z /= n_last,
           nlist(z): NOT elt(z, n_last),
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i)),
           conc(z1, z2): rho_init(z1) AND rho_init(z2),
           commit(z1, z2, z3):
             z1 /= p - 1 OR z2 /= hu_list OR z3 /= n_last,
           code(z1, z2):
             rho_init(z2) OR
              (z1 = public(hu(0)) AND
                (EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
                   z2 =
                    conc(nlist(append(nl, (: n_last :))),
                         ilist(cdr(hu_list)))))
        ELSE TRUE
        ENDCASES
  |-------
[1]   rho_init(E(k!1, m1!1))

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
authentication_init.2.15.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  secret?(k!1)
[-2]  rho_init(m1!1)
  |-------
{1}   EXISTS (i: nat_to_p): x_secret(k!1) = hu(i)
[2]   rho_init(E(k!1, m1!1))

Rerunning step: (lazy-grind)
E rewrites E(k!1, m1!1)
  to CASES m1!1
        OF code(k1, m1):
             CASES k1
               OF public(i):
                    IF k!1 = secret(i) THEN m1 ELSE code(k!1, m1!1) ENDIF,
                  secret(i):
                    IF k!1 = public(i) THEN m1 ELSE code(k!1, m1!1) ENDIF
               ENDCASES
        ELSE code(k!1, m1!1)
        ENDCASES
rho_init rewrites rho_init(code(k!1, m1!1))
  to TRUE
rho_init rewrites rho_init(m1!1)
  to (x_code(m1!1) = public(hu(0)) AND
        EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
          y_code(m1!1) =
           conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
elt rewrites elt(append(nl!1, (: n_last :)), n_last)
  to EXISTS (i: below[length(append(nl!1, (: n_last :)))]):
        nth(append(nl!1, (: n_last :)), i) = n_last
rho_init rewrites rho_init(nlist(append(nl!1, (: n_last :))))
  to NOT EXISTS (i: below[length(append(nl!1, (: n_last :)))]):
            nth(append(nl!1, (: n_last :)), i) = n_last
rho_init rewrites rho_init(ilist(cdr(hu_list)))
  to TRUE
rho_init rewrites 
  rho_init(conc(nlist(append(nl!1, (: n_last :))), ilist(cdr(hu_list))))
  to NOT EXISTS (i: below[length(append(nl!1, (: n_last :)))]):
            nth(append(nl!1, (: n_last :)), i) = n_last
By skolemization, if-lifting, simplification and instantiation,

This completes the proof of authentication_init.2.15.2.


This completes the proof of authentication_init.2.15.


This completes the proof of authentication_init.2.

authentication_init.3 :  

  |-------
{1}   FORALL (i: Identity): USER(i) # R_init |> RankUser(rho_init)
[2]   network(USER) |> auth(T, R_init)

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_init.3 :  

  |-------
[1]   FORALL (i: Identity): USER(i) # R_init |> RankUser(rho_init)

Rerunning step: (comment "users maintain the rank function")
Adding comment: users maintain the rank function
this simplifies to: 
authentication_init.3 : 
;;; users maintain the rank function

  |-------
[1]   FORALL (i: Identity): USER(i) # R_init |> RankUser(rho_init)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_init.3 : 
;;; users maintain the rank function

  |-------
{1}   USER(i!1) # R_init |> RankUser(rho_init)

Rerunning step: (expand "USER")
Expanding the definition of USER,
this simplifies to: 
authentication_init.3 : 
;;; users maintain the rank function

  |-------
{1}   (Interleave! (P: nat_from_2):
         (Interleave! (nn0: Nonces(P, i!1, 0)): UROLE_INIT(P, i!1, nn0)) //
          (Interleave! (nnP: Nonces(P, i!1, P - 1)):
             UROLE_LAST(P, i!1, nnP))
          //
          IF P = 2 THEN Stop[event]
          ELSE (Interleave! (j: nat_1_to(P), nnJ: Nonces(P, i!1, j)):
                  UROLE_MIDDLE(P, j, i!1, nnJ))
          ENDIF)
       # R_init
       |> RankUser(rho_init)

Rerunning step: (expand "RankUser")
Expanding the definition of RankUser,
this simplifies to: 
authentication_init.3 : 
;;; users maintain the rank function

  |-------
{1}   (Interleave! (P: nat_from_2):
         (Interleave! (nn0: Nonces(P, i!1, 0)): UROLE_INIT(P, i!1, nn0)) //
          (Interleave! (nnP: Nonces(P, i!1, P - 1)):
             UROLE_LAST(P, i!1, nnP))
          //
          IF P = 2 THEN Stop[event]
          ELSE (Interleave! (j: nat_1_to(P), nnJ: Nonces(P, i!1, j)):
                  UROLE_MIDDLE(P, j, i!1, nnJ))
          ENDIF)
       # R_init
       |>
       LAMBDA (tr: list[event]):
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(tr)
          IMPLIES
          every(LAMBDA (e: event):
                  complement(rec?)(e) IMPLIES rho_init(msg(e)))
               (tr)

Rerunning step: (interleaving2)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
Applying interleaving rule,
this simplifies to: 
authentication_init.3 : 
;;; users maintain the rank function

  |-------
{1}   (Interleave! (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
       //
       (Interleave! (nnP: Nonces(i!2, i!1, i!2 - 1)):
          UROLE_LAST(i!2, i!1, nnP))
       //
       IF i!2 = 2 THEN Stop[event]
       ELSE (Interleave! (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
               UROLE_MIDDLE(i!2, j, i!1, nnJ))
       ENDIF
       # R_init
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))(t)

Rerunning step: (interleaving)
Applying interleaving rule,
this yields  2 subgoals: 
authentication_init.3.1 : 
;;; users maintain the rank function

  |-------
{1}   (((Interleave! (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
         //
         (Interleave! (nnP: Nonces(i!2, i!1, i!2 - 1)):
            UROLE_LAST(i!2, i!1, nnP))
         # R_init)
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(t) =>
           every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))
                (t))

Rerunning step: (interleaving)
Applying interleaving rule,
this yields  2 subgoals: 
authentication_init.3.1.1 : 
;;; users maintain the rank function

  |-------
{1}   (((Interleave! (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
         # R_init)
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(t) =>
           every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))
                (t))

Rerunning step: (lemma "restrictinit_init" ("P" "i!2" "u" "i!1"))
Applying restrictinit_init where 
  P gets i!2,
  u gets i!1,
this simplifies to: 
authentication_init.3.1.1 : 
;;; users maintain the rank function

{-1}  ((Interleave! (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
        # R_init)
       |> RankUser(rho_init)
  |-------
[1]   (((Interleave! (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
         # R_init)
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(t) =>
           every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))
                (t))

Rerunning step: (grind :exclude ("rho_init" "UROLE_INIT"))
Interleave rewrites 
  (Interleave! (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
  to Par(emptyset)
         (LAMBDA (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
# rewrites 
  (Par(emptyset)
      (LAMBDA (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0))
    # R_init)
  to Par(R_init)
         (Par(emptyset)
             (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                UROLE_INIT(i!2, i!1, nn0)),
          Stop)
Par rewrites 
  Par(R_init)
     (Par(emptyset)
         (LAMBDA (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                       UROLE_INIT(i!2, i!1, nn0)))),
             (t2: (Stop)):
        prod(R_init)(t1, t2, x)
member rewrites 
  member(x,
         Par(R_init)
            (Par(emptyset)
                (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                   UROLE_INIT(i!2, i!1, nn0)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                       UROLE_INIT(i!2, i!1, nn0)))),
             (t2: (Stop)):
        prod(R_init)(t1, t2, x)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
RankUser rewrites RankUser(rho_init)(x)
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(x) IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))(x)
member rewrites member(x, RankUser(rho_init))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(x) IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))(x)
subset? rewrites 
  subset?(Par(R_init)
             (Par(emptyset)
                 (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                    UROLE_INIT(i!2, i!1, nn0)),
              Stop),
          RankUser(rho_init))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                          UROLE_INIT(i!2, i!1, nn0)))),
                (t2: (Stop)):
           prod(R_init)(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(x)
          IMPLIES
          every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))(x)
|> rewrites 
  Par(R_init)
     (Par(emptyset)
         (LAMBDA (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0)),
      Stop)
   |> RankUser(rho_init)
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                          UROLE_INIT(i!2, i!1, nn0)))),
                (t2: (Stop)):
           prod(R_init)(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(x)
          IMPLIES
          every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))(x)
Par rewrites 
  Par(R_init)
     (Par(emptyset)
         (LAMBDA (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                       UROLE_INIT(i!2, i!1, nn0)))),
             (t2: (Stop)):
        prod(R_init)(t1, t2, x)
member rewrites 
  member(x,
         Par(R_init)
            (Par(emptyset)
                (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                   UROLE_INIT(i!2, i!1, nn0)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                       UROLE_INIT(i!2, i!1, nn0)))),
             (t2: (Stop)):
        prod(R_init)(t1, t2, x)
member rewrites 
  member(x,
         LAMBDA (t: list[event]):
           every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(t) =>
            every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))
                 (t))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(x) =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))(x)
subset? rewrites 
  subset?(Par(R_init)
             (Par(emptyset)
                 (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                    UROLE_INIT(i!2, i!1, nn0)),
              Stop),
          LAMBDA (t: list[event]):
            every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(t)
             =>
             every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))
                  (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                          UROLE_INIT(i!2, i!1, nn0)))),
                (t2: (Stop)):
           prod(R_init)(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(x) =>
          every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))(x)
|> rewrites 
  (Par(R_init)
      (Par(emptyset)
          (LAMBDA (nn0: Nonces(i!2, i!1, 0)): UROLE_INIT(i!2, i!1, nn0)),
       Stop)
    |>
    LAMBDA (t: list[event]):
      every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(t) =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))(t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nn0: Nonces(i!2, i!1, 0)):
                          UROLE_INIT(i!2, i!1, nn0)))),
                (t2: (Stop)):
           prod(R_init)(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(x) =>
          every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))(x)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_init.3.1.1.

authentication_init.3.1.2 : 
;;; users maintain the rank function

  |-------
{1}   (((Interleave! (nnP: Nonces(i!2, i!1, i!2 - 1)):
           UROLE_LAST(i!2, i!1, nnP))
         # R_init)
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(t) =>
           every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))
                (t))

Rerunning step: (lemma "restrictinit_last" ("P" "i!2" "u" "i!1"))
Applying restrictinit_last where 
  P gets i!2,
  u gets i!1,
this simplifies to: 
authentication_init.3.1.2 : 
;;; users maintain the rank function

{-1}  ((Interleave! (nnP: Nonces(i!2, i!1, i!2 - 1)):
          UROLE_LAST(i!2, i!1, nnP))
        # R_init)
       |> RankUser(rho_init)
  |-------
[1]   (((Interleave! (nnP: Nonces(i!2, i!1, i!2 - 1)):
           UROLE_LAST(i!2, i!1, nnP))
         # R_init)
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(t) =>
           every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))
                (t))

Rerunning step: (grind :exclude ("rho_init" "UROLE_LAST"))
Interleave rewrites 
  (Interleave! (nnP: Nonces(i!2, i!1, i!2 - 1)): UROLE_LAST(i!2, i!1, nnP))
  to Par(emptyset)
         (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
            UROLE_LAST(i!2, i!1, nnP))
# rewrites 
  (Par(emptyset)
      (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)): UROLE_LAST(i!2, i!1, nnP))
    # R_init)
  to Par(R_init)
         (Par(emptyset)
             (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                UROLE_LAST(i!2, i!1, nnP)),
          Stop)
Par rewrites 
  Par(R_init)
     (Par(emptyset)
         (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
            UROLE_LAST(i!2, i!1, nnP)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                       UROLE_LAST(i!2, i!1, nnP)))),
             (t2: (Stop)):
        prod(R_init)(t1, t2, x)
member rewrites 
  member(x,
         Par(R_init)
            (Par(emptyset)
                (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                   UROLE_LAST(i!2, i!1, nnP)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                       UROLE_LAST(i!2, i!1, nnP)))),
             (t2: (Stop)):
        prod(R_init)(t1, t2, x)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
RankUser rewrites RankUser(rho_init)(x)
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(x) IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))(x)
member rewrites member(x, RankUser(rho_init))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(x) IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))(x)
subset? rewrites 
  subset?(Par(R_init)
             (Par(emptyset)
                 (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                    UROLE_LAST(i!2, i!1, nnP)),
              Stop),
          RankUser(rho_init))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                          UROLE_LAST(i!2, i!1, nnP)))),
                (t2: (Stop)):
           prod(R_init)(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(x)
          IMPLIES
          every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))(x)
|> rewrites 
  Par(R_init)
     (Par(emptyset)
         (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
            UROLE_LAST(i!2, i!1, nnP)),
      Stop)
   |> RankUser(rho_init)
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                          UROLE_LAST(i!2, i!1, nnP)))),
                (t2: (Stop)):
           prod(R_init)(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(x)
          IMPLIES
          every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))(x)
Par rewrites 
  Par(R_init)
     (Par(emptyset)
         (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
            UROLE_LAST(i!2, i!1, nnP)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                       UROLE_LAST(i!2, i!1, nnP)))),
             (t2: (Stop)):
        prod(R_init)(t1, t2, x)
member rewrites 
  member(x,
         Par(R_init)
            (Par(emptyset)
                (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                   UROLE_LAST(i!2, i!1, nnP)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                       UROLE_LAST(i!2, i!1, nnP)))),
             (t2: (Stop)):
        prod(R_init)(t1, t2, x)
member rewrites 
  member(x,
         LAMBDA (t: list[event]):
           every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(t) =>
            every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))
                 (t))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(x) =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))(x)
subset? rewrites 
  subset?(Par(R_init)
             (Par(emptyset)
                 (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                    UROLE_LAST(i!2, i!1, nnP)),
              Stop),
          LAMBDA (t: list[event]):
            every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(t)
             =>
             every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))
                  (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                          UROLE_LAST(i!2, i!1, nnP)))),
                (t2: (Stop)):
           prod(R_init)(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(x) =>
          every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))(x)
|> rewrites 
  (Par(R_init)
      (Par(emptyset)
          (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
             UROLE_LAST(i!2, i!1, nnP)),
       Stop)
    |>
    LAMBDA (t: list[event]):
      every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(t) =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))(t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nnP: Nonces(i!2, i!1, i!2 - 1)):
                          UROLE_LAST(i!2, i!1, nnP)))),
                (t2: (Stop)):
           prod(R_init)(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(x) =>
          every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))(x)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_init.3.1.2.


This completes the proof of authentication_init.3.1.

authentication_init.3.2 : 
;;; users maintain the rank function

  |-------
{1}   ((IF i!2 = 2 THEN Stop[event]
        ELSE (Interleave! (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                UROLE_MIDDLE(i!2, j, i!1, nnJ))
        ENDIF
         # R_init)
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(t) =>
           every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))
                (t))

Rerunning step: (lift-if)
Lifting IF-conditions to the top level,
this simplifies to: 
authentication_init.3.2 : 
;;; users maintain the rank function

  |-------
{1}   IF i!2 = 2
        THEN ((Stop[event] # R_init) |>
               LAMBDA (t: list[event]):
                 every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))
                      (t)
                  =>
                  every(LAMBDA (e: event):
                          NOT rec?(e) IMPLIES rho_init(msg(e)))
                       (t))
      ELSE (((Interleave! (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
                UROLE_MIDDLE(i!2, j, i!1, nnJ))
              # R_init)
             |>
             LAMBDA (t: list[event]):
               every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))
                    (t)
                =>
                every(LAMBDA (e: event):
                        NOT rec?(e) IMPLIES rho_init(msg(e)))
                     (t))
      ENDIF

Rerunning step: (prop)
Applying propositional simplification,
this yields  2 subgoals: 
authentication_init.3.2.1 : 
;;; users maintain the rank function

{-1}  i!2 = 2
  |-------
{1}   ((Stop[event] # R_init) |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(t) =>
           every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))
                (t))

Rerunning step: (stop)
Applying stop rule,

This completes the proof of authentication_init.3.2.1.

authentication_init.3.2.2 : 
;;; users maintain the rank function

  |-------
{1}   i!2 = 2
{2}   (((Interleave! (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
           UROLE_MIDDLE(i!2, j, i!1, nnJ))
         # R_init)
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(t) =>
           every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))
                (t))

Rerunning step: (lemma "restrictinit_middle" ("P" "i!2" "u" "i!1"))
Applying restrictinit_middle where 
  P gets i!2,
  u gets i!1,
this simplifies to: 
authentication_init.3.2.2 : 
;;; users maintain the rank function

{-1}  i!2 /= 2 =>
       (((Interleave! (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
            UROLE_MIDDLE(i!2, k, i!1, nnK))
          # R_init)
         |> RankUser(rho_init))
  |-------
[1]   i!2 = 2
[2]   (((Interleave! (j: nat_1_to(i!2), nnJ: Nonces(i!2, i!1, j)):
           UROLE_MIDDLE(i!2, j, i!1, nnJ))
         # R_init)
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(t) =>
           every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))
                (t))

Rerunning step: (grind :exclude ("rho_init" "UROLE_MIDDLE"))
Interleave rewrites 
  (Interleave! (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
     UROLE_MIDDLE(i!2, k, i!1, nnK))
  to Par(emptyset)
         (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
            UROLE_MIDDLE(i!2, k, i!1, nnK))
# rewrites 
  (Par(emptyset)
      (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
         UROLE_MIDDLE(i!2, k, i!1, nnK))
    # R_init)
  to Par(R_init)
         (Par(emptyset)
             (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
                UROLE_MIDDLE(i!2, k, i!1, nnK)),
          Stop)
Par rewrites 
  Par(R_init)
     (Par(emptyset)
         (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
            UROLE_MIDDLE(i!2, k, i!1, nnK)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
                       UROLE_MIDDLE(i!2, k, i!1, nnK)))),
             (t2: (Stop)):
        prod(R_init)(t1, t2, x)
member rewrites 
  member(x,
         Par(R_init)
            (Par(emptyset)
                (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
                   UROLE_MIDDLE(i!2, k, i!1, nnK)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
                       UROLE_MIDDLE(i!2, k, i!1, nnK)))),
             (t2: (Stop)):
        prod(R_init)(t1, t2, x)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
RankUser rewrites RankUser(rho_init)(x)
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(x) IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))(x)
member rewrites member(x, RankUser(rho_init))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(x) IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))(x)
subset? rewrites 
  subset?(Par(R_init)
             (Par(emptyset)
                 (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
                    UROLE_MIDDLE(i!2, k, i!1, nnK)),
              Stop),
          RankUser(rho_init))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (k: nat_1_to(i!2),
                                nnK: Nonces(i!2, i!1, k)):
                          UROLE_MIDDLE(i!2, k, i!1, nnK)))),
                (t2: (Stop)):
           prod(R_init)(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(x)
          IMPLIES
          every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))(x)
|> rewrites 
  (Par(R_init)
      (Par(emptyset)
          (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
             UROLE_MIDDLE(i!2, k, i!1, nnK)),
       Stop)
    |> RankUser(rho_init))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (k: nat_1_to(i!2),
                                nnK: Nonces(i!2, i!1, k)):
                          UROLE_MIDDLE(i!2, k, i!1, nnK)))),
                (t2: (Stop)):
           prod(R_init)(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(x)
          IMPLIES
          every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))(x)
Par rewrites 
  Par(R_init)
     (Par(emptyset)
         (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
            UROLE_MIDDLE(i!2, k, i!1, nnK)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
                       UROLE_MIDDLE(i!2, k, i!1, nnK)))),
             (t2: (Stop)):
        prod(R_init)(t1, t2, x)
member rewrites 
  member(x,
         Par(R_init)
            (Par(emptyset)
                (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
                   UROLE_MIDDLE(i!2, k, i!1, nnK)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
                       UROLE_MIDDLE(i!2, k, i!1, nnK)))),
             (t2: (Stop)):
        prod(R_init)(t1, t2, x)
member rewrites 
  member(x,
         LAMBDA (t: list[event]):
           every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(t) =>
            every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))
                 (t))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(x) =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))(x)
subset? rewrites 
  subset?(Par(R_init)
             (Par(emptyset)
                 (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
                    UROLE_MIDDLE(i!2, k, i!1, nnK)),
              Stop),
          LAMBDA (t: list[event]):
            every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(t)
             =>
             every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))
                  (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (k: nat_1_to(i!2),
                                nnK: Nonces(i!2, i!1, k)):
                          UROLE_MIDDLE(i!2, k, i!1, nnK)))),
                (t2: (Stop)):
           prod(R_init)(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(x) =>
          every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))(x)
|> rewrites 
  (Par(R_init)
      (Par(emptyset)
          (LAMBDA (k: nat_1_to(i!2), nnK: Nonces(i!2, i!1, k)):
             UROLE_MIDDLE(i!2, k, i!1, nnK)),
       Stop)
    |>
    LAMBDA (t: list[event]):
      every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(t) =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))(t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (k: nat_1_to(i!2),
                                nnK: Nonces(i!2, i!1, k)):
                          UROLE_MIDDLE(i!2, k, i!1, nnK)))),
                (t2: (Stop)):
           prod(R_init)(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_init(msg(e)))(x) =>
          every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_init(msg(e)))(x)
/= rewrites i!2 /= 2
  to NOT (i!2 = 2)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_init.3.2.2.


This completes the proof of authentication_init.3.2.


This completes the proof of authentication_init.3.

authentication_init.4 :  

  |-------
{1}   FORALL (e: (T)): NOT rho_init(msg(e))
[2]   network(USER) |> auth(T, R_init)

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_init.4 :  

  |-------
[1]   FORALL (e: (T)): NOT rho_init(msg(e))

Rerunning step: (comment "T is not in rho")
Adding comment: T is not in rho
this simplifies to: 
authentication_init.4 : 
;;; T is not in rho

  |-------
[1]   FORALL (e: (T)): NOT rho_init(msg(e))

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
authentication_init.4 : 
;;; T is not in rho

{-1}  T(e!1)
{-2}  rho_init(msg(e!1))
  |-------

Rerunning step: (expand "T")
Expanding the definition of T,
this simplifies to: 
authentication_init.4 : 
;;; T is not in rho

{-1}  e!1 = signal(commit(p - 1, hu_list, n_last))
[-2]  rho_init(msg(e!1))
  |-------

Rerunning step: (replace -1 -2)
Replacing using formula -1,
this simplifies to: 
authentication_init.4 : 
;;; T is not in rho

[-1]  e!1 = signal(commit(p - 1, hu_list, n_last))
{-2}  rho_init(msg(signal(commit(p - 1, hu_list, n_last))))
  |-------

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
authentication_init.4 : 
;;; T is not in rho

[-1]  rho_init(msg(signal(commit(p - 1, hu_list, n_last))))
  |-------

Rerunning step: (grind)
rho_init rewrites rho_init(commit(p - 1, hu_list, n_last))
  to FALSE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_init.4.

Q.E.D.


Run time  = 3.45 secs.
Real time = 4.25 secs.
nil
pvs(57): 
Installing rewrite rule sets.singleton_rew (all instances)
restrictmiddle_init :  

  |-------
{1}   FORALL (P: nat_from_2, i: nat_1_to(p), u: Identity):
        ((Interleave! (nn0: Nonces(P, u, 0)): UROLE_INIT(P, u, nn0)) #
          R_middle(i))
         |> RankUser(rho_middle(i))

Rerunning step: (auto-rewrite-theory "sets")
Rewriting relative to the theory: sets,
this simplifies to: 
restrictmiddle_init :  

  |-------
[1]   FORALL (P: nat_from_2, i: nat_1_to(p), u: Identity):
        ((Interleave! (nn0: Nonces(P, u, 0)): UROLE_INIT(P, u, nn0)) #
          R_middle(i))
         |> RankUser(rho_middle(i))

Rerunning step: (auto-rewrite "n_last_TCC2")
Installing rewrite rule gnsl_last.n_last_TCC2
Installing automatic rewrites from: 
  n_last_TCC2
this simplifies to: 
restrictmiddle_init :  

  |-------
[1]   FORALL (P: nat_from_2, i: nat_1_to(p), u: Identity):
        ((Interleave! (nn0: Nonces(P, u, 0)): UROLE_INIT(P, u, nn0)) #
          R_middle(i))
         |> RankUser(rho_middle(i))

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictmiddle_init :  

  |-------
{1}   ((Interleave! (nn0: Nonces(P!1, u!1, 0)): UROLE_INIT(P!1, u!1, nn0))
        # R_middle(i!1))
       |> RankUser(rho_middle(i!1))

Rerunning step: (expand "RankUser")
Expanding the definition of RankUser,
this simplifies to: 
restrictmiddle_init :  

  |-------
{1}   ((Interleave! (nn0: Nonces(P!1, u!1, 0)): UROLE_INIT(P!1, u!1, nn0))
        # R_middle(i!1))
       |>
       LAMBDA (tr: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(tr)
          =>
          every(LAMBDA (e: event):
                  complement(rec?)(e) => rho_middle(i!1)(msg(e)))
               (tr)

Rerunning step: (interleaving2)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
Applying interleaving rule,
this simplifies to: 
restrictmiddle_init :  

  |-------
{1}   UROLE_INIT(P!1, u!1, i!2) # R_middle(i!1) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (expand "UROLE_INIT")
Expanding the definition of UROLE_INIT,
this simplifies to: 
restrictmiddle_init :  

  |-------
{1}   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, nl)), ilist(il))))
            >>
            (signal(running(0, cons(u!1, il), nth(nl, P!1 - 2))) >>
              (trans(u!1, car(il),
                     E(public(car(il)),
                       conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (typepred "P!1")
Adding type constraints for  P!1,
this simplifies to: 
restrictmiddle_init :  

{-1}  2 <= P!1
  |-------
[1]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, nl)), ilist(il))))
            >>
            (signal(running(0, cons(u!1, il), nth(nl, P!1 - 2))) >>
              (trans(u!1, car(il),
                     E(public(car(il)),
                       conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (choice3)
Applying choice rule,
this yields  7 subgoals: 
restrictmiddle_init.1 :  

[-1]  2 <= P!1
  |-------
{1}   (trans(u!1, car(i!3`2),
             E(public(car(i!3`2)),
               conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i!3`2))))))
        >>
        (rec(u!1, nth(i!3`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
          >>
          (signal(running(0, cons(u!1, i!3`2), nth(i!3`1, P!1 - 2))) >>
            (trans(u!1, car(i!3`2),
                   E(public(car(i!3`2)),
                     conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
              >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictmiddle_init.1.1 :  

[-1]  2 <= P!1
  |-------
{1}   rho_middle(i!1)
                (E(public(car(i!3`2)),
                   conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i!3`2))))))
{2}   R_middle(i!1)
              (trans(u!1, car(i!3`2),
                     E(public(car(i!3`2)),
                       conc(nlist((: i!2 :)),
                            ilist(cons(u!1, cdr(i!3`2)))))))
{3}   trans(u!1, car(i!3`2),
            E(public(car(i!3`2)),
              conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i!3`2))))))
       >>
       ((rec(u!1, nth(i!3`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
          >>
          (signal(running(0, cons(u!1, i!3`2), nth(i!3`1, P!1 - 2))) >>
            (trans(u!1, car(i!3`2),
                   E(public(car(i!3`2)),
                     conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
              >> Stop[event])))
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.1 :  

[-1]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (E(public(car(i!3`2)),
                   conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i!3`2))))))

Rerunning step: (typepred "i!2")
Adding type constraints for  i!2,
this simplifies to: 
restrictmiddle_init.1.1 :  

{-1}  IRpart(P!1, u!1, 0)(i!2)
[-2]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (E(public(car(i!3`2)),
                   conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i!3`2))))))

Rerunning step: (lemma "n_prop" ("P" "P!1" "u" "u!1" "r" "0"))
Applying n_prop where 
  P gets P!1,
  u gets u!1,
  r gets 0,
this simplifies to: 
restrictmiddle_init.1.1 :  

{-1}  (P!1 /= p OR 0 /= p - 1) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, 0)(n_last)
[-2]  IRpart(P!1, u!1, 0)(i!2)
[-3]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (E(public(car(i!3`2)),
                   conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i!3`2))))))

Rerunning step: (lemma "listprops[Nonce].elt_singleton"
                 ("t1" "i!2" "t2" "n_last"))
Applying listprops[Nonce].elt_singleton where 
  t1 gets i!2,
  t2 gets n_last,
this simplifies to: 
restrictmiddle_init.1.1 :  

{-1}  elt((: i!2 :), n_last) IFF i!2 = n_last
[-2]  (P!1 /= p OR 0 /= p - 1) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, 0)(n_last)
[-3]  IRpart(P!1, u!1, 0)(i!2)
[-4]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (E(public(car(i!3`2)),
                   conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i!3`2))))))

Rerunning step: (grind :if-match nil :exclude "elt")
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
/= rewrites P!1 /= p
  to NOT (P!1 = p)
/= rewrites 0 /= p - 1
  to TRUE
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
E rewrites 
  E(public(car(i!3`2)),
    conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i!3`2)))))
  to code(public(car(i!3`2)),
           conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i!3`2)))))
rho_middle rewrites rho_middle(i!1)(nlist((: i!2 :)))
  to TRUE
rho_middle rewrites rho_middle(i!1)(ilist(cons(u!1, cdr(i!3`2))))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)(conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i!3`2)))))
  to TRUE
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites 
  rho_middle(i!1)
            (code(public(car(i!3`2)),
                  conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i!3`2))))))
  to TRUE
/= rewrites P!1 /= p
  to NOT (P!1 = p)
/= rewrites 0 /= p - 1
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_init.1.1.

restrictmiddle_init.1.2 :  

[-1]  2 <= P!1
  |-------
{1}   ((rec(u!1, nth(i!3`2, P!1 - 2),
            E(public(u!1), conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
         >>
         (signal(running(0, cons(u!1, i!3`2), nth(i!3`1, P!1 - 2))) >>
           (trans(u!1, car(i!3`2),
                  E(public(car(i!3`2)),
                    conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
             >> Stop[event])))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (trans(u!1, car(i!3`2),
                     E(public(car(i!3`2)),
                       conc(nlist((: i!2 :)),
                            ilist(cons(u!1, cdr(i!3`2)))))))
{3}   trans(u!1, car(i!3`2),
            E(public(car(i!3`2)),
              conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i!3`2))))))
       >>
       ((rec(u!1, nth(i!3`2, P!1 - 2),
             E(public(u!1), conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
          >>
          (signal(running(0, cons(u!1, i!3`2), nth(i!3`1, P!1 - 2))) >>
            (trans(u!1, car(i!3`2),
                   E(public(car(i!3`2)),
                     conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
              >> Stop[event])))
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.2 :  

[-1]  2 <= P!1
  |-------
[1]   ((rec(u!1, nth(i!3`2, P!1 - 2),
            E(public(u!1), conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
         >>
         (signal(running(0, cons(u!1, i!3`2), nth(i!3`1, P!1 - 2))) >>
           (trans(u!1, car(i!3`2),
                  E(public(car(i!3`2)),
                    conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
             >> Stop[event])))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictmiddle_init.1.2 :  

{-1}  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
{1}   ((signal(running(0, cons(u!1, i!3`2), nth(i!3`1, P!1 - 2))) >>
         (trans(u!1, car(i!3`2),
                E(public(car(i!3`2)),
                  conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
           >> Stop[event]))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (rec(u!1, nth(i!3`2, P!1 - 2),
                   E(public(u!1),
                     conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2)))))
{3}   rec(u!1, nth(i!3`2, P!1 - 2),
          E(public(u!1), conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
       >>
       ((signal(running(0, cons(u!1, i!3`2), nth(i!3`1, P!1 - 2))) >>
          (trans(u!1, car(i!3`2),
                 E(public(car(i!3`2)),
                   conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
            >> Stop[event]))
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.2 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
[1]   ((signal(running(0, cons(u!1, i!3`2), nth(i!3`1, P!1 - 2))) >>
         (trans(u!1, car(i!3`2),
                E(public(car(i!3`2)),
                  conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
           >> Stop[event]))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictmiddle_init.1.2.1 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
{1}   rho_middle(i!1)(running(0, cons(u!1, i!3`2), nth(i!3`1, P!1 - 2)))
{2}   R_middle(i!1)
              (signal(running(0, cons(u!1, i!3`2), nth(i!3`1, P!1 - 2))))
{3}   signal(running(0, cons(u!1, i!3`2), nth(i!3`1, P!1 - 2))) >>
       ((trans(u!1, car(i!3`2),
               E(public(car(i!3`2)),
                 conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
          >> Stop[event])
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.2.1 :  

  |-------
[1]   rho_middle(i!1)(running(0, cons(u!1, i!3`2), nth(i!3`1, P!1 - 2)))

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
restrictmiddle_init.1.2.1 :  

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictmiddle_init.1.2.1.

restrictmiddle_init.1.2.2 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
{1}   ((trans(u!1, car(i!3`2),
              E(public(car(i!3`2)),
                conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
         >> Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (signal(running(0, cons(u!1, i!3`2), nth(i!3`1, P!1 - 2))))
{3}   signal(running(0, cons(u!1, i!3`2), nth(i!3`1, P!1 - 2))) >>
       ((trans(u!1, car(i!3`2),
               E(public(car(i!3`2)),
                 conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
          >> Stop[event])
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.2.2 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
[1]   ((trans(u!1, car(i!3`2),
              E(public(car(i!3`2)),
                conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
         >> Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictmiddle_init.1.2.2.1 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
{1}   rho_middle(i!1)
                (E(public(car(i!3`2)),
                   conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
{2}   R_middle(i!1)
              (trans(u!1, car(i!3`2),
                     E(public(car(i!3`2)),
                       conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1)))))
{3}   trans(u!1, car(i!3`2),
            E(public(car(i!3`2)),
              conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
       >> (Stop[event] # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.2.2.1 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (E(public(car(i!3`2)),
                   conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))

Rerunning step: (expand "E")
Expanding the definition of E,
this simplifies to: 
restrictmiddle_init.1.2.2.1 :  

{-1}  rho_middle(i!1)
                (code(public(u!1),
                      conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
{1}   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))

Rerunning step: (expand "rho_middle" -1)
Expanding the definition of rho_middle,
this simplifies to: 
restrictmiddle_init.1.2.2.1 :  

{-1}  rho_middle(i!1)(conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))) OR
       (public(u!1) = public(hu(0)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
           conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2)) =
            conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
        OR
        EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
          public(u!1) = public(hu(j)) AND
           EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
             conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2)) =
              conc(ilist(remove(hu_list, j)),
                   nlist(append(nl, (: n_last :))))
[-2]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))

Rerunning step: (split)
Splitting conjunctions,
this yields  3 subgoals: 
restrictmiddle_init.1.2.2.1.1 :  

{-1}  rho_middle(i!1)(conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2)))
[-2]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))

Rerunning step: (lemma "listprops[Nonce].elt_append2"
                 ("l1" "(:i!2:)" "l2" "i!3`1" "t" "n_last"))
Applying listprops[Nonce].elt_append2 where 
  l1 gets (: i!2 :),
  l2 gets i!3`1,
  t gets n_last,
this simplifies to: 
restrictmiddle_init.1.2.2.1.1 :  

{-1}  elt(i!3`1, n_last) IMPLIES elt(append((: i!2 :), i!3`1), n_last)
[-2]  rho_middle(i!1)(conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2)))
[-3]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))

Rerunning step: (grind :if-match nil :exclude "elt")
append rewrites append((: :), i!3`1)
  to i!3`1
append rewrites append((: i!2 :), i!3`1)
  to cons(i!2, i!3`1)
rho_middle rewrites rho_middle(i!1)(nlist(cons(i!2, i!3`1)))
  to FALSE
rho_middle rewrites rho_middle(i!1)(ilist(i!3`2))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)(conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2)))
  to FALSE
rho_middle rewrites rho_middle(i!1)(nlist(cons(i!2, i!3`1)))
  to NOT elt(cons(i!2, i!3`1), n_last)
rho_middle rewrites rho_middle(i!1)(ilist(i!3`2))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)(conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2)))
  to NOT elt(cons(i!2, i!3`1), n_last)
rho_middle rewrites rho_middle(i!1)(ilist(cons(u!1, cdr(i!3`2))))
  to TRUE
rho_middle rewrites rho_middle(i!1)(nlist(i!3`1))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)(conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1)))
  to TRUE
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites 
  rho_middle(i!1)
            (code(public(car(i!3`2)),
                  conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_init.1.2.2.1.1.

restrictmiddle_init.1.2.2.1.2 :  

{-1}  (public(u!1) = public(hu(0)) AND
        EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
          conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2)) =
           conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
[-2]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2 :  

{-1}  public(u!1) = public(hu(0))
{-2}  EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
        conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2)) =
         conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list)))
[-3]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2 :  

[-1]  public(u!1) = public(hu(0))
{-2}  conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2)) =
       conc(nlist(append(nl!1, (: n_last :))), ilist(cdr(hu_list)))
[-3]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2 :  

{-1}  u!1 = hu(0)
[-2]  conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2)) =
       conc(nlist(append(nl!1, (: n_last :))), ilist(cdr(hu_list)))
[-3]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2 :  

{-1}  nlist(cons(i!2, i!3`1)) = nlist(append(nl!1, (: n_last :)))
{-2}  ilist(i!3`2) = ilist(cdr(hu_list))
[-3]  u!1 = hu(0)
[-4]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2 :  

{-1}  cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-2]  ilist(i!3`2) = ilist(cdr(hu_list))
[-3]  u!1 = hu(0)
[-4]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2 :  

{-1}  i!3`2 = cdr(hu_list)
[-2]  cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-3]  u!1 = hu(0)
[-4]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))

Rerunning step: (typepred "i!3`1" "i!3`2" "nl!1" "hu_list" "i!1")
Adding type constraints for  i!3`1, i!3`2, nl!1, hu_list, i!1,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`1)
{-2}  length(i!3`1) = P!1 - 1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`2)
{-4}  length(i!3`2) = P!1 - 1
{-5}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl!1)
{-6}  length(nl!1) = p - 1
{-7}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-8}  (length(hu_list) = p)
{-9}  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
{-10} 0 < i!1
{-11} i!1 < p - 1
[-12] i!3`2 = cdr(hu_list)
[-13] cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-14] u!1 = hu(0)
[-15] 2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))

Rerunning step: (expand "rho_middle" 1)
Expanding the definition of rho_middle,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2 :  

[-1]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`1)
[-2]  length(i!3`1) = P!1 - 1
[-3]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`2)
[-4]  length(i!3`2) = P!1 - 1
[-5]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl!1)
[-6]  length(nl!1) = p - 1
[-7]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] 0 < i!1
[-11] i!1 < p - 1
[-12] i!3`2 = cdr(hu_list)
[-13] cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-14] u!1 = hu(0)
[-15] 2 <= P!1
  |-------
{1}   rho_middle(i!1)(conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))) OR
       (public(car(i!3`2)) = public(hu(0)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
           conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1)) =
            conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
        OR
        EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
          public(car(i!3`2)) = public(hu(j)) AND
           EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
             conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1)) =
              conc(ilist(remove(hu_list, j)),
                   nlist(append(nl, (: n_last :))))

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2 :  

[-1]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`1)
[-2]  length(i!3`1) = P!1 - 1
[-3]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`2)
[-4]  length(i!3`2) = P!1 - 1
[-5]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl!1)
[-6]  length(nl!1) = p - 1
[-7]  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] 0 < i!1
[-11] i!1 < p - 1
[-12] i!3`2 = cdr(hu_list)
[-13] cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-14] u!1 = hu(0)
[-15] 2 <= P!1
  |-------
{1}   rho_middle(i!1)(conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1)))
{2}   (public(car(i!3`2)) = public(hu(0)) AND
        EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
          conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1)) =
           conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
{3}   EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
        public(car(i!3`2)) = public(hu(j)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
           conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1)) =
            conc(ilist(remove(hu_list, j)), nlist(append(nl, (: n_last :))))

Rerunning step: (delete -1 -3 -5 -7 1 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2 :  

[-1]  length(i!3`1) = P!1 - 1
[-2]  length(i!3`2) = P!1 - 1
[-3]  length(nl!1) = p - 1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  0 < i!1
[-7]  i!1 < p - 1
[-8]  i!3`2 = cdr(hu_list)
[-9]  cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-10] u!1 = hu(0)
[-11] 2 <= P!1
  |-------
[1]   EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
        public(car(i!3`2)) = public(hu(j)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
           conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1)) =
            conc(ilist(remove(hu_list, j)), nlist(append(nl, (: n_last :))))

Rerunning step: (case "P!1=p")
Case splitting on 
   P!1 = p, 
this yields  2 subgoals: 
restrictmiddle_init.1.2.2.1.2.1 :  

{-1}  P!1 = p
[-2]  length(i!3`1) = P!1 - 1
[-3]  length(i!3`2) = P!1 - 1
[-4]  length(nl!1) = p - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  0 < i!1
[-8]  i!1 < p - 1
[-9]  i!3`2 = cdr(hu_list)
[-10] cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-11] u!1 = hu(0)
[-12] 2 <= P!1
  |-------
[1]   EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
        public(car(i!3`2)) = public(hu(j)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
           conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1)) =
            conc(ilist(remove(hu_list, j)), nlist(append(nl, (: n_last :))))

Rerunning step: (comment "next message is sent to hu(1)")
Adding comment: next message is sent to hu(1)
this simplifies to: 
restrictmiddle_init.1.2.2.1.2.1 : 
;;; next message is sent to hu(1)

[-1]  P!1 = p
[-2]  length(i!3`1) = P!1 - 1
[-3]  length(i!3`2) = P!1 - 1
[-4]  length(nl!1) = p - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  0 < i!1
[-8]  i!1 < p - 1
[-9]  i!3`2 = cdr(hu_list)
[-10] cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-11] u!1 = hu(0)
[-12] 2 <= P!1
  |-------
[1]   EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
        public(car(i!3`2)) = public(hu(j)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
           conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1)) =
            conc(ilist(remove(hu_list, j)), nlist(append(nl, (: n_last :))))

Rerunning step: (inst 1 "1")
Instantiating the top quantifier in 1 with the terms: 
 1,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2.1 : 
;;; next message is sent to hu(1)

[-1]  P!1 = p
[-2]  length(i!3`1) = P!1 - 1
[-3]  length(i!3`2) = P!1 - 1
[-4]  length(nl!1) = p - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  0 < i!1
[-8]  i!1 < p - 1
[-9]  i!3`2 = cdr(hu_list)
[-10] cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-11] u!1 = hu(0)
[-12] 2 <= P!1
  |-------
{1}   public(car(i!3`2)) = public(hu(1)) AND
       EXISTS (nl: {x: list[Nonce] | length(x) = p - 2}):
         conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1)) =
          conc(ilist(remove(hu_list, 1)), nlist(append(nl, (: n_last :))))

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
restrictmiddle_init.1.2.2.1.2.1.1 : 
;;; next message is sent to hu(1)

[-1]  P!1 = p
[-2]  length(i!3`1) = P!1 - 1
[-3]  length(i!3`2) = P!1 - 1
[-4]  length(nl!1) = p - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  0 < i!1
[-8]  i!1 < p - 1
[-9]  i!3`2 = cdr(hu_list)
[-10] cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-11] u!1 = hu(0)
[-12] 2 <= P!1
  |-------
{1}   public(car(i!3`2)) = public(hu(1))

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2.1.1 : 
;;; next message is sent to hu(1)

[-1]  P!1 = p
[-2]  length(i!3`1) = P!1 - 1
[-3]  length(i!3`2) = P!1 - 1
[-4]  length(nl!1) = p - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  0 < i!1
[-8]  i!1 < p - 1
[-9]  i!3`2 = cdr(hu_list)
[-10] cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-11] u!1 = hu(0)
[-12] 2 <= P!1
  |-------
{1}   car(i!3`2) = hu(1)

Rerunning step: (replace -9 1)
Replacing using formula -9,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2.1.1 : 
;;; next message is sent to hu(1)

[-1]  P!1 = p
[-2]  length(i!3`1) = P!1 - 1
[-3]  length(i!3`2) = P!1 - 1
[-4]  length(nl!1) = p - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  0 < i!1
[-8]  i!1 < p - 1
[-9]  i!3`2 = cdr(hu_list)
[-10] cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-11] u!1 = hu(0)
[-12] 2 <= P!1
  |-------
{1}   car(cdr(hu_list)) = hu(1)

Rerunning step: (inst -6 "1")
Instantiating the top quantifier in -6 with the terms: 
 1,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2.1.1 : 
;;; next message is sent to hu(1)

[-1]  P!1 = p
[-2]  length(i!3`1) = P!1 - 1
[-3]  length(i!3`2) = P!1 - 1
[-4]  length(nl!1) = p - 1
[-5]  (length(hu_list) = p)
{-6}  nth(hu_list, 1) = hu(1)
[-7]  0 < i!1
[-8]  i!1 < p - 1
[-9]  i!3`2 = cdr(hu_list)
[-10] cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-11] u!1 = hu(0)
[-12] 2 <= P!1
  |-------
[1]   car(cdr(hu_list)) = hu(1)

Rerunning step: (replace -6 1 rl)
Replacing using formula -6,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2.1.1 : 
;;; next message is sent to hu(1)

[-1]  P!1 = p
[-2]  length(i!3`1) = P!1 - 1
[-3]  length(i!3`2) = P!1 - 1
[-4]  length(nl!1) = p - 1
[-5]  (length(hu_list) = p)
[-6]  nth(hu_list, 1) = hu(1)
[-7]  0 < i!1
[-8]  i!1 < p - 1
[-9]  i!3`2 = cdr(hu_list)
[-10] cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-11] u!1 = hu(0)
[-12] 2 <= P!1
  |-------
{1}   car(cdr(hu_list)) = nth(hu_list, 1)

Rerunning step: (delete -)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2.1.1 : 
;;; next message is sent to hu(1)

  |-------
[1]   car(cdr(hu_list)) = nth(hu_list, 1)

Rerunning step: (grind)
nth rewrites nth(cdr(hu_list), 0)
  to car(cdr(hu_list))
nth rewrites nth(hu_list, 1)
  to car(cdr(hu_list))
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_init.1.2.2.1.2.1.1.

restrictmiddle_init.1.2.2.1.2.1.2 : 
;;; next message is sent to hu(1)

[-1]  P!1 = p
[-2]  length(i!3`1) = P!1 - 1
[-3]  length(i!3`2) = P!1 - 1
[-4]  length(nl!1) = p - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  0 < i!1
[-8]  i!1 < p - 1
[-9]  i!3`2 = cdr(hu_list)
[-10] cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-11] u!1 = hu(0)
[-12] 2 <= P!1
  |-------
{1}   EXISTS (nl: {x: list[Nonce] | length(x) = p - 2}):
        conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1)) =
         conc(ilist(remove(hu_list, 1)), nlist(append(nl, (: n_last :))))

Rerunning step: (replace* -1)
Repeatedly applying the replace rule,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2.1.2 : 
;;; next message is sent to hu(1)

[-1]  P!1 = p
{-2}  length(i!3`1) = p - 1
{-3}  length(i!3`2) = p - 1
[-4]  length(nl!1) = p - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  0 < i!1
[-8]  i!1 < p - 1
[-9]  i!3`2 = cdr(hu_list)
[-10] cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-11] u!1 = hu(0)
{-12} 2 <= p
  |-------
[1]   EXISTS (nl: {x: list[Nonce] | length(x) = p - 2}):
        conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1)) =
         conc(ilist(remove(hu_list, 1)), nlist(append(nl, (: n_last :))))

Rerunning step: (lemma "more_list_props[Identity].length_non_zero"
                 ("l" "nl!1"))
Applying more_list_props[Identity].length_non_zero where 
  l gets nl!1,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2.1.2 : 
;;; next message is sent to hu(1)

{-1}  length(nl!1) > 0 IFF cons?(nl!1)
[-2]  P!1 = p
[-3]  length(i!3`1) = p - 1
[-4]  length(i!3`2) = p - 1
[-5]  length(nl!1) = p - 1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  0 < i!1
[-9]  i!1 < p - 1
[-10] i!3`2 = cdr(hu_list)
[-11] cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-12] u!1 = hu(0)
[-13] 2 <= p
  |-------
[1]   EXISTS (nl: {x: list[Nonce] | length(x) = p - 2}):
        conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1)) =
         conc(ilist(remove(hu_list, 1)), nlist(append(nl, (: n_last :))))

Rerunning step: (ground)
Applying propositional simplification and decision procedures,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2.1.2 : 
;;; next message is sent to hu(1)

{-1}  length(nl!1) > 0
{-2}  cons?(nl!1)
[-3]  P!1 = p
[-4]  length(i!3`1) = p - 1
[-5]  length(i!3`2) = p - 1
[-6]  length(nl!1) = p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] i!3`2 = cdr(hu_list)
[-12] cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-13] u!1 = hu(0)
[-14] 2 <= p
  |-------
[1]   EXISTS (nl: {x: list[Nonce] | length(x) = p - 2}):
        conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1)) =
         conc(ilist(remove(hu_list, 1)), nlist(append(nl, (: n_last :))))

Rerunning step: (inst 1 "cdr(nl!1)")
Instantiating the top quantifier in 1 with the terms: 
 cdr(nl!1),
this yields  2 subgoals: 
restrictmiddle_init.1.2.2.1.2.1.2.1 : 
;;; next message is sent to hu(1)

[-1]  length(nl!1) > 0
[-2]  cons?(nl!1)
[-3]  P!1 = p
[-4]  length(i!3`1) = p - 1
[-5]  length(i!3`2) = p - 1
[-6]  length(nl!1) = p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] i!3`2 = cdr(hu_list)
[-12] cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-13] u!1 = hu(0)
[-14] 2 <= p
  |-------
{1}   conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1)) =
       conc(ilist(remove(hu_list, 1)),
            nlist(append(cdr(nl!1), (: n_last :))))

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this yields  2 subgoals: 
restrictmiddle_init.1.2.2.1.2.1.2.1.1 : 
;;; next message is sent to hu(1)

[-1]  length(nl!1) > 0
[-2]  cons?(nl!1)
[-3]  P!1 = p
[-4]  length(i!3`1) = p - 1
[-5]  length(i!3`2) = p - 1
[-6]  length(nl!1) = p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] i!3`2 = cdr(hu_list)
[-12] cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-13] u!1 = hu(0)
[-14] 2 <= p
  |-------
{1}   ilist(cons(u!1, cdr(i!3`2))) = ilist(remove(hu_list, 1))

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2.1.2.1.1 : 
;;; next message is sent to hu(1)

[-1]  length(nl!1) > 0
[-2]  cons?(nl!1)
[-3]  P!1 = p
[-4]  length(i!3`1) = p - 1
[-5]  length(i!3`2) = p - 1
[-6]  length(nl!1) = p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] i!3`2 = cdr(hu_list)
[-12] cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-13] u!1 = hu(0)
[-14] 2 <= p
  |-------
{1}   cons(u!1, cdr(i!3`2)) = remove(hu_list, 1)

Rerunning step: (replace -11 1)
Replacing using formula -11,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2.1.2.1.1 : 
;;; next message is sent to hu(1)

[-1]  length(nl!1) > 0
[-2]  cons?(nl!1)
[-3]  P!1 = p
[-4]  length(i!3`1) = p - 1
[-5]  length(i!3`2) = p - 1
[-6]  length(nl!1) = p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] i!3`2 = cdr(hu_list)
[-12] cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-13] u!1 = hu(0)
[-14] 2 <= p
  |-------
{1}   cons(u!1, cdr(cdr(hu_list))) = remove(hu_list, 1)

Rerunning step: (replace -13 1)
Replacing using formula -13,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2.1.2.1.1 : 
;;; next message is sent to hu(1)

[-1]  length(nl!1) > 0
[-2]  cons?(nl!1)
[-3]  P!1 = p
[-4]  length(i!3`1) = p - 1
[-5]  length(i!3`2) = p - 1
[-6]  length(nl!1) = p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] i!3`2 = cdr(hu_list)
[-12] cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-13] u!1 = hu(0)
[-14] 2 <= p
  |-------
{1}   cons(hu(0), cdr(cdr(hu_list))) = remove(hu_list, 1)

Rerunning step: (inst -8 "0")
Instantiating the top quantifier in -8 with the terms: 
 0,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2.1.2.1.1 : 
;;; next message is sent to hu(1)

[-1]  length(nl!1) > 0
[-2]  cons?(nl!1)
[-3]  P!1 = p
[-4]  length(i!3`1) = p - 1
[-5]  length(i!3`2) = p - 1
[-6]  length(nl!1) = p - 1
[-7]  (length(hu_list) = p)
{-8}  nth(hu_list, 0) = hu(0)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] i!3`2 = cdr(hu_list)
[-12] cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-13] u!1 = hu(0)
[-14] 2 <= p
  |-------
[1]   cons(hu(0), cdr(cdr(hu_list))) = remove(hu_list, 1)

Rerunning step: (replace -8 1 rl)
Replacing using formula -8,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2.1.2.1.1 : 
;;; next message is sent to hu(1)

[-1]  length(nl!1) > 0
[-2]  cons?(nl!1)
[-3]  P!1 = p
[-4]  length(i!3`1) = p - 1
[-5]  length(i!3`2) = p - 1
[-6]  length(nl!1) = p - 1
[-7]  (length(hu_list) = p)
[-8]  nth(hu_list, 0) = hu(0)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] i!3`2 = cdr(hu_list)
[-12] cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-13] u!1 = hu(0)
[-14] 2 <= p
  |-------
{1}   cons(nth(hu_list, 0), cdr(cdr(hu_list))) = remove(hu_list, 1)

Rerunning step: (delete -)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2.1.2.1.1 : 
;;; next message is sent to hu(1)

  |-------
[1]   cons(nth(hu_list, 0), cdr(cdr(hu_list))) = remove(hu_list, 1)

Rerunning step: (grind)
nth rewrites nth(hu_list, 0)
  to car(hu_list)
remove rewrites remove(cdr(hu_list), 0)
  to cdr(cdr(hu_list))
remove rewrites remove(hu_list, 1)
  to cons(car(hu_list), cdr(cdr(hu_list)))
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_init.1.2.2.1.2.1.2.1.1.

restrictmiddle_init.1.2.2.1.2.1.2.1.2 : 
;;; next message is sent to hu(1)

[-1]  length(nl!1) > 0
[-2]  cons?(nl!1)
[-3]  P!1 = p
[-4]  length(i!3`1) = p - 1
[-5]  length(i!3`2) = p - 1
[-6]  length(nl!1) = p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] i!3`2 = cdr(hu_list)
[-12] cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-13] u!1 = hu(0)
[-14] 2 <= p
  |-------
{1}   nlist(i!3`1) = nlist(append(cdr(nl!1), (: n_last :)))

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2.1.2.1.2 : 
;;; next message is sent to hu(1)

[-1]  length(nl!1) > 0
[-2]  cons?(nl!1)
[-3]  P!1 = p
[-4]  length(i!3`1) = p - 1
[-5]  length(i!3`2) = p - 1
[-6]  length(nl!1) = p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] i!3`2 = cdr(hu_list)
[-12] cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-13] u!1 = hu(0)
[-14] 2 <= p
  |-------
{1}   i!3`1 = append(cdr(nl!1), (: n_last :))

Rerunning step: (expand "append" -12)
Expanding the definition of append,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2.1.2.1.2 : 
;;; next message is sent to hu(1)

[-1]  length(nl!1) > 0
[-2]  cons?(nl!1)
[-3]  P!1 = p
[-4]  length(i!3`1) = p - 1
[-5]  length(i!3`2) = p - 1
[-6]  length(nl!1) = p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] i!3`2 = cdr(hu_list)
{-12} cons(i!2, i!3`1) = cons(car(nl!1), append(cdr(nl!1), (: n_last :)))
[-13] u!1 = hu(0)
[-14] 2 <= p
  |-------
[1]   i!3`1 = append(cdr(nl!1), (: n_last :))

Rerunning step: (decompose-equality -12)
Applying decompose-equality,

This completes the proof of restrictmiddle_init.1.2.2.1.2.1.2.1.2.


This completes the proof of restrictmiddle_init.1.2.2.1.2.1.2.1.

restrictmiddle_init.1.2.2.1.2.1.2.2 (TCC):   

[-1]  length(nl!1) > 0
[-2]  cons?(nl!1)
[-3]  P!1 = p
[-4]  length(i!3`1) = p - 1
[-5]  length(i!3`2) = p - 1
[-6]  length(nl!1) = p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] i!3`2 = cdr(hu_list)
[-12] cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-13] u!1 = hu(0)
[-14] 2 <= p
  |-------
{1}   length[Nonce](cdr[Nonce](nl!1)) = p - 2

Rerunning step: (rewrite "length_cdr" 1)
Found matching substitution:
cons_l: (cons?[T]) gets nl!1,
Rewriting using length_cdr, matching in 1,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2.1.2.2 : 
;;; next message is sent to hu(1)

[-1]  length(nl!1) > 0
[-2]  cons?(nl!1)
[-3]  P!1 = p
[-4]  length(i!3`1) = p - 1
[-5]  length(i!3`2) = p - 1
[-6]  length(nl!1) = p - 1
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] i!3`2 = cdr(hu_list)
[-12] cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-13] u!1 = hu(0)
[-14] 2 <= p
  |-------
{1}   length(nl!1) - 1 = p - 2

Rerunning step: (delete -1 -2 -3 -4 -5 -7 -8 -9 -10 -11 -12 -13 -14)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2.1.2.2 : 
;;; next message is sent to hu(1)

[-1]  length(nl!1) = p - 1
  |-------
[1]   length(nl!1) - 1 = p - 2

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_init.1.2.2.1.2.1.2.2.


This completes the proof of restrictmiddle_init.1.2.2.1.2.1.2.


This completes the proof of restrictmiddle_init.1.2.2.1.2.1.

restrictmiddle_init.1.2.2.1.2.2 :  

[-1]  length(i!3`1) = P!1 - 1
[-2]  length(i!3`2) = P!1 - 1
[-3]  length(nl!1) = p - 1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  0 < i!1
[-7]  i!1 < p - 1
[-8]  i!3`2 = cdr(hu_list)
[-9]  cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-10] u!1 = hu(0)
[-11] 2 <= P!1
  |-------
{1}   P!1 = p
[2]   EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
        public(car(i!3`2)) = public(hu(j)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
           conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1)) =
            conc(ilist(remove(hu_list, j)), nlist(append(nl, (: n_last :))))

Rerunning step: (replace -8 -2)
Replacing using formula -8,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2.2 :  

[-1]  length(i!3`1) = P!1 - 1
{-2}  length(cdr(hu_list)) = P!1 - 1
[-3]  length(nl!1) = p - 1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  0 < i!1
[-7]  i!1 < p - 1
[-8]  i!3`2 = cdr(hu_list)
[-9]  cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-10] u!1 = hu(0)
[-11] 2 <= P!1
  |-------
[1]   P!1 = p
[2]   EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
        public(car(i!3`2)) = public(hu(j)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
           conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1)) =
            conc(ilist(remove(hu_list, j)), nlist(append(nl, (: n_last :))))

Rerunning step: (rewrite "length_cdr" -2)
Found matching substitution:
cons_l: (cons?[T]) gets hu_list,
Rewriting using length_cdr, matching in -2,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2.2 :  

[-1]  length(i!3`1) = P!1 - 1
{-2}  length(hu_list) - 1 = P!1 - 1
[-3]  length(nl!1) = p - 1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  0 < i!1
[-7]  i!1 < p - 1
[-8]  i!3`2 = cdr(hu_list)
[-9]  cons(i!2, i!3`1) = append(nl!1, (: n_last :))
[-10] u!1 = hu(0)
[-11] 2 <= P!1
  |-------
[1]   P!1 = p
[2]   EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
        public(car(i!3`2)) = public(hu(j)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
           conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1)) =
            conc(ilist(remove(hu_list, j)), nlist(append(nl, (: n_last :))))

Rerunning step: (delete -1 -3 -5 -6 -7 -8 -9 -10 -11 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.2.2.1.2.2 :  

[-1]  length(hu_list) - 1 = P!1 - 1
[-2]  (length(hu_list) = p)
  |-------
[1]   P!1 = p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_init.1.2.2.1.2.2.


This completes the proof of restrictmiddle_init.1.2.2.1.2.

restrictmiddle_init.1.2.2.1.3 :  

{-1}  EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
        public(u!1) = public(hu(j)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
           conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2)) =
            conc(ilist(remove(hu_list, j)), nlist(append(nl, (: n_last :))))
[-2]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictmiddle_init.1.2.2.1.3 :  

{-1}  public(u!1) = public(hu(j!1))
{-2}  conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2)) =
       conc(ilist(remove(hu_list, j!1)), nlist(append(nl!1, (: n_last :))))
[-3]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))

Rerunning step: (decompose-equality -2)
Applying decompose-equality,

This completes the proof of restrictmiddle_init.1.2.2.1.3.


This completes the proof of restrictmiddle_init.1.2.2.1.

restrictmiddle_init.1.2.2.2 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(cons(i!2, i!3`1)), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
{1}   (Stop[event] # R_middle(i!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (trans(u!1, car(i!3`2),
                     E(public(car(i!3`2)),
                       conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1)))))
{3}   trans(u!1, car(i!3`2),
            E(public(car(i!3`2)),
              conc(ilist(cons(u!1, cdr(i!3`2))), nlist(i!3`1))))
       >> (Stop[event] # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.1.2.2.2 :  

  |-------
[1]   (Stop[event] # R_middle(i!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictmiddle_init.1.2.2.2.


This completes the proof of restrictmiddle_init.1.2.2.


This completes the proof of restrictmiddle_init.1.2.


This completes the proof of restrictmiddle_init.1.

restrictmiddle_init.2 :  

[-1]  2 <= P!1
  |-------
{1}   P!1 - 2 < length[Nonce](i!3`1)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, i`1)), ilist(i`2))))
            >>
            (signal(running(0, cons(u!1, i`2), nth(i`1, P!1 - 2))) >>
              (trans(u!1, car(i`2),
                     E(public(car(i`2)),
                       conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
                >> Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (typepred "i!3`1")
Adding type constraints for  i!3`1,
this simplifies to: 
restrictmiddle_init.2 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`1)
{-2}  length(i!3`1) = P!1 - 1
[-3]  2 <= P!1
  |-------
[1]   P!1 - 2 < length[Nonce](i!3`1)
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, i`1)), ilist(i`2))))
            >>
            (signal(running(0, cons(u!1, i`2), nth(i`1, P!1 - 2))) >>
              (trans(u!1, car(i`2),
                     E(public(car(i`2)),
                       conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
                >> Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -3 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.2 :  

[-1]  length(i!3`1) = P!1 - 1
  |-------
[1]   P!1 - 2 < length[Nonce](i!3`1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_init.2.

restrictmiddle_init.3 :  

[-1]  2 <= P!1
  |-------
{1}   P!1 - 2 < length[Identity](i!3`2)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, i`1)), ilist(i`2))))
            >>
            (signal(running(0, cons(u!1, i`2), nth(i`1, P!1 - 2))) >>
              (trans(u!1, car(i`2),
                     E(public(car(i`2)),
                       conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
                >> Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (typepred "i!3`2")
Adding type constraints for  i!3`2,
this simplifies to: 
restrictmiddle_init.3 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`2)
{-2}  length(i!3`2) = P!1 - 1
[-3]  2 <= P!1
  |-------
[1]   P!1 - 2 < length[Identity](i!3`2)
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, i`1)), ilist(i`2))))
            >>
            (signal(running(0, cons(u!1, i`2), nth(i`1, P!1 - 2))) >>
              (trans(u!1, car(i`2),
                     E(public(car(i`2)),
                       conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
                >> Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -3 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.3 :  

[-1]  length(i!3`2) = P!1 - 1
  |-------
[1]   P!1 - 2 < length[Identity](i!3`2)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_init.3.

restrictmiddle_init.4 :  

[-1]  2 <= P!1
  |-------
{1}   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!2 :))
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, i`1)), ilist(i`2))))
            >>
            (signal(running(0, cons(u!1, i`2), nth(i`1, P!1 - 2))) >>
              (trans(u!1, car(i`2),
                     E(public(car(i`2)),
                       conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
                >> Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.4 :  

  |-------
[1]   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!2 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!2 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_init.4.

restrictmiddle_init.5 :  

[-1]  2 <= P!1
  |-------
{1}   cons?[Identity](i!3`2)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (trans(u!1, car(i`2),
               E(public(car(i`2)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(i`2))))))
          >>
          (rec(u!1, nth(i`2, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, i`1)), ilist(i`2))))
            >>
            (signal(running(0, cons(u!1, i`2), nth(i`1, P!1 - 2))) >>
              (trans(u!1, car(i`2),
                     E(public(car(i`2)),
                       conc(ilist(cons(u!1, cdr(i`2))), nlist(i`1))))
                >> Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.5 :  

[-1]  2 <= P!1
  |-------
[1]   cons?[Identity](i!3`2)

Rerunning step: (nonemptylist "i!3`2")
Relating existence of a tail to a list's length,

This completes the proof of restrictmiddle_init.5.

restrictmiddle_init.6 :  

[-1]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!2 :))
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, nl)), ilist(il))))
            >>
            (signal(running(0, cons(u!1, il), nth(nl, P!1 - 2))) >>
              (trans(u!1, car(il),
                     E(public(car(il)),
                       conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.6 :  

  |-------
[1]   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!2 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!2 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_init.6.

restrictmiddle_init.7 :  

[-1]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        cons?[Identity](il)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, nl)), ilist(il))))
            >>
            (signal(running(0, cons(u!1, il), nth(nl, P!1 - 2))) >>
              (trans(u!1, car(il),
                     E(public(car(il)),
                       conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictmiddle_init.7 :  

[-1]  2 <= P!1
  |-------
{1}   cons?[Identity](il!1)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (trans(u!1, car(il),
               E(public(car(il)),
                 conc(nlist((: i!2 :)), ilist(cons(u!1, cdr(il))))))
          >>
          (rec(u!1, nth(il, P!1 - 2),
               E(public(u!1), conc(nlist(cons(i!2, nl)), ilist(il))))
            >>
            (signal(running(0, cons(u!1, il), nth(nl, P!1 - 2))) >>
              (trans(u!1, car(il),
                     E(public(car(il)),
                       conc(ilist(cons(u!1, cdr(il))), nlist(nl))))
                >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_init.7 :  

[-1]  2 <= P!1
  |-------
[1]   cons?[Identity](il!1)

Rerunning step: (nonemptylist "il!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictmiddle_init.7.

Q.E.D.


Run time  = 2.43 secs.
Real time = 3.79 secs.
nil
pvs(62): 
Installing rewrite rule sets.singleton_rew (all instances)
restrictmiddle_middle :  

  |-------
{1}   FORALL (P: nat_from_2, i: nat_1_to(p), u: Identity):
        P /= 2 =>
         (((Interleave! (k: nat_1_to(P), nnK: Nonces(P, u, k)):
              UROLE_MIDDLE(P, k, u, nnK))
            # R_middle(i))
           |> RankUser(rho_middle(i)))

Rerunning step: (auto-rewrite-theory "sets")
Rewriting relative to the theory: sets,
this simplifies to: 
restrictmiddle_middle :  

  |-------
[1]   FORALL (P: nat_from_2, i: nat_1_to(p), u: Identity):
        P /= 2 =>
         (((Interleave! (k: nat_1_to(P), nnK: Nonces(P, u, k)):
              UROLE_MIDDLE(P, k, u, nnK))
            # R_middle(i))
           |> RankUser(rho_middle(i)))

Rerunning step: (auto-rewrite "USER_TCC2" "n_last_TCC2")
Installing rewrite rule gnsl_last.USER_TCC2
Installing rewrite rule gnsl_last.n_last_TCC2
Installing automatic rewrites from: 
  USER_TCC2
  n_last_TCC2
this simplifies to: 
restrictmiddle_middle :  

  |-------
[1]   FORALL (P: nat_from_2, i: nat_1_to(p), u: Identity):
        P /= 2 =>
         (((Interleave! (k: nat_1_to(P), nnK: Nonces(P, u, k)):
              UROLE_MIDDLE(P, k, u, nnK))
            # R_middle(i))
           |> RankUser(rho_middle(i)))

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictmiddle_middle :  

  |-------
{1}   P!1 /= 2 =>
       (((Interleave! (k: nat_1_to(P!1), nnK: Nonces(P!1, u!1, k)):
            UROLE_MIDDLE(P!1, k, u!1, nnK))
          # R_middle(i!1))
         |> RankUser(rho_middle(i!1)))

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictmiddle_middle :  

  |-------
{1}   P!1 = 2
{2}   (((Interleave! (k: nat_1_to(P!1), nnK: Nonces(P!1, u!1, k)):
           UROLE_MIDDLE(P!1, k, u!1, nnK))
         # R_middle(i!1))
        |> RankUser(rho_middle(i!1)))

Rerunning step: (expand "RankUser")
Expanding the definition of RankUser,
this simplifies to: 
restrictmiddle_middle :  

  |-------
[1]   P!1 = 2
{2}   (((Interleave! (k: nat_1_to(P!1), nnK: Nonces(P!1, u!1, k)):
           UROLE_MIDDLE(P!1, k, u!1, nnK))
         # R_middle(i!1))
        |>
        LAMBDA (tr: list[event]):
          every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(tr)
           =>
           every(LAMBDA (e: event):
                   complement(rec?)(e) => rho_middle(i!1)(msg(e)))
                (tr))

Rerunning step: (interleaving2)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
USER_TCC2 rewrites EXISTS (x: [k: nat_1_to(P!1), Nonces(P!1, u!1, k)]): TRUE
  to TRUE
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
USER_TCC2 rewrites EXISTS (x: [k: nat_1_to(P!1), Nonces(P!1, u!1, k)]): TRUE
  to TRUE
Applying interleaving rule,
this simplifies to: 
restrictmiddle_middle :  

  |-------
[1]   P!1 = 2
{2}   UROLE_MIDDLE(P!1, i!2`1, u!1, i!2`2) # R_middle(i!1) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (expand "UROLE_MIDDLE")
Expanding the definition of UROLE_MIDDLE,
this simplifies to: 
restrictmiddle_middle :  

  |-------
[1]   P!1 = 2
{2}   Choice! (nl1: {x: list[Nonce] | length(x) = i!2`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!2`1},
               il1: {x: list[Identity] | length(x) = i!2`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!2`1}):
        (rec(u!1, nth(il1, i!2`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!2`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!2`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!2`2, nl2)))))
              >>
              (signal(running(i!2`1, append(il1, cons(u!1, il2)),
                              nth(nl2, P!1 - 2 - i!2`1)))
                >>
                ((LastMessage(P!1, i!2`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (typepred "P!1" "i!2`1")
Adding type constraints for  P!1, i!2`1,
this simplifies to: 
restrictmiddle_middle :  

{-1}  2 <= P!1
{-2}  0 < i!2`1
{-3}  i!2`1 < P!1 - 1
  |-------
[1]   P!1 = 2
[2]   Choice! (nl1: {x: list[Nonce] | length(x) = i!2`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!2`1},
               il1: {x: list[Identity] | length(x) = i!2`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!2`1}):
        (rec(u!1, nth(il1, i!2`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!2`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!2`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!2`2, nl2)))))
              >>
              (signal(running(i!2`1, append(il1, cons(u!1, il2)),
                              nth(nl2, P!1 - 2 - i!2`1)))
                >>
                ((LastMessage(P!1, i!2`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (choice3)
Applying choice rule,
this yields  5 subgoals: 
restrictmiddle_middle.1 :  

[-1]  2 <= P!1
[-2]  0 < i!2`1
[-3]  i!2`1 < P!1 - 1
  |-------
[1]   P!1 = 2
{2}   (rec(u!1, nth(i!3`3, i!2`1 - 1),
           E(public(u!1), conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
        >>
        (trans(u!1, car(i!3`4),
               E(public(car(i!3`4)),
                 conc(nlist(append(i!3`1, (: i!2`2 :))),
                      ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
          >>
          (rec(u!1, nth(i!3`3, i!2`1 - 1),
               E(public(u!1),
                 conc(ilist(append(i!3`3, i!3`4)),
                      nlist(cons(i!2`2, i!3`2)))))
            >>
            (signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                            nth(i!3`2, P!1 - 2 - i!2`1)))
              >>
              ((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4))
                >> Stop[event])))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictmiddle_middle.1 :  

{-1}  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
{1}   ((trans(u!1, car(i!3`4),
              E(public(car(i!3`4)),
                conc(nlist(append(i!3`1, (: i!2`2 :))),
                     ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
         >>
         (rec(u!1, nth(i!3`3, i!2`1 - 1),
              E(public(u!1),
                conc(ilist(append(i!3`3, i!3`4)),
                     nlist(cons(i!2`2, i!3`2)))))
           >>
           (signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                           nth(i!3`2, P!1 - 2 - i!2`1)))
             >>
             ((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
               Stop[event]))))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (rec(u!1, nth(i!3`3, i!2`1 - 1),
                   E(public(u!1),
                     conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))))
{3}   rec(u!1, nth(i!3`3, i!2`1 - 1),
          E(public(u!1), conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
       >>
       ((trans(u!1, car(i!3`4),
               E(public(car(i!3`4)),
                 conc(nlist(append(i!3`1, (: i!2`2 :))),
                      ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
          >>
          (rec(u!1, nth(i!3`3, i!2`1 - 1),
               E(public(u!1),
                 conc(ilist(append(i!3`3, i!3`4)),
                      nlist(cons(i!2`2, i!3`2)))))
            >>
            (signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                            nth(i!3`2, P!1 - 2 - i!2`1)))
              >>
              ((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4))
                >> Stop[event]))))
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   ((trans(u!1, car(i!3`4),
              E(public(car(i!3`4)),
                conc(nlist(append(i!3`1, (: i!2`2 :))),
                     ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
         >>
         (rec(u!1, nth(i!3`3, i!2`1 - 1),
              E(public(u!1),
                conc(ilist(append(i!3`3, i!3`4)),
                     nlist(cons(i!2`2, i!3`2)))))
           >>
           (signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                           nth(i!3`2, P!1 - 2 - i!2`1)))
             >>
             ((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
               Stop[event]))))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[2]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictmiddle_middle.1.1 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
{1}   rho_middle(i!1)
                (E(public(car(i!3`4)),
                   conc(nlist(append(i!3`1, (: i!2`2 :))),
                        ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
{2}   R_middle(i!1)
              (trans(u!1, car(i!3`4),
                     E(public(car(i!3`4)),
                       conc(nlist(append(i!3`1, (: i!2`2 :))),
                            ilist(append(i!3`3, cons(u!1, cdr(i!3`4))))))))
{3}   trans(u!1, car(i!3`4),
            E(public(car(i!3`4)),
              conc(nlist(append(i!3`1, (: i!2`2 :))),
                   ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
       >>
       ((rec(u!1, nth(i!3`3, i!2`1 - 1),
             E(public(u!1),
               conc(ilist(append(i!3`3, i!3`4)),
                    nlist(cons(i!2`2, i!3`2)))))
          >>
          (signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                          nth(i!3`2, P!1 - 2 - i!2`1)))
            >>
            ((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
              Stop[event])))
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.1 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   rho_middle(i!1)
                (E(public(car(i!3`4)),
                   conc(nlist(append(i!3`1, (: i!2`2 :))),
                        ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[2]   P!1 = 2

Rerunning step: (expand "E")
Expanding the definition of E,
this simplifies to: 
restrictmiddle_middle.1.1 :  

{-1}  rho_middle(i!1)
                (code(public(u!1),
                      conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
{1}   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[2]   P!1 = 2

Rerunning step: (expand "rho_middle" -1)
Expanding the definition of rho_middle,
this simplifies to: 
restrictmiddle_middle.1.1 :  

{-1}  rho_middle(i!1)(conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))) OR
       (public(u!1) = public(hu(0)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
           conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))) =
            conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
        OR
        EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
          public(u!1) = public(hu(j)) AND
           EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
             conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))) =
              conc(ilist(remove(hu_list, j)),
                   nlist(append(nl, (: n_last :))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[2]   P!1 = 2

Rerunning step: (split)
Splitting conjunctions,
this yields  3 subgoals: 
restrictmiddle_middle.1.1.1 :  

{-1}  rho_middle(i!1)(conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[2]   P!1 = 2

Rerunning step: (typepred "i!2`2")
Adding type constraints for  i!2`2,
this simplifies to: 
restrictmiddle_middle.1.1.1 :  

{-1}  IRpart(P!1, u!1, i!2`1)(i!2`2)
[-2]  rho_middle(i!1)(conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[2]   P!1 = 2

Rerunning step: (lemma "n_prop" ("P" "P!1" "u" "u!1" "r" "i!2`1"))
Applying n_prop where 
  P gets P!1,
  u gets u!1,
  r gets i!2`1,
this simplifies to: 
restrictmiddle_middle.1.1.1 :  

{-1}  (P!1 /= p OR i!2`1 /= p - 1) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, i!2`1)(n_last)
[-2]  IRpart(P!1, u!1, i!2`1)(i!2`2)
[-3]  rho_middle(i!1)(conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
[-4]  2 <= P!1
[-5]  0 < i!2`1
[-6]  i!2`1 < P!1 - 1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[2]   P!1 = 2

Rerunning step: (lemma "listprops[Nonce].elt_append3"
                 ("l1" "i!3`1" "l2" "(:i!2`2:)" "t" "n_last"))
Applying listprops[Nonce].elt_append3 where 
  l1 gets i!3`1,
  l2 gets (: i!2`2 :),
  t gets n_last,
this simplifies to: 
restrictmiddle_middle.1.1.1 :  

{-1}  elt(append(i!3`1, (: i!2`2 :)), n_last) IMPLIES
       elt(i!3`1, n_last) OR elt((: i!2`2 :), n_last)
[-2]  (P!1 /= p OR i!2`1 /= p - 1) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, i!2`1)(n_last)
[-3]  IRpart(P!1, u!1, i!2`1)(i!2`2)
[-4]  rho_middle(i!1)(conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
[-5]  2 <= P!1
[-6]  0 < i!2`1
[-7]  i!2`1 < P!1 - 1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[2]   P!1 = 2

Rerunning step: (lemma "listprops[Nonce].elt_singleton"
                 ("t1" "i!2`2" "t2" "n_last"))
Applying listprops[Nonce].elt_singleton where 
  t1 gets i!2`2,
  t2 gets n_last,
this simplifies to: 
restrictmiddle_middle.1.1.1 :  

{-1}  elt((: i!2`2 :), n_last) IFF i!2`2 = n_last
[-2]  elt(append(i!3`1, (: i!2`2 :)), n_last) IMPLIES
       elt(i!3`1, n_last) OR elt((: i!2`2 :), n_last)
[-3]  (P!1 /= p OR i!2`1 /= p - 1) =>
       NOT pt[[nat_from_2, Identity, Role], Nonce](P!1, u!1, i!2`1)(n_last)
[-4]  IRpart(P!1, u!1, i!2`1)(i!2`2)
[-5]  rho_middle(i!1)(conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
[-6]  2 <= P!1
[-7]  0 < i!2`1
[-8]  i!2`1 < P!1 - 1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[2]   P!1 = 2

Rerunning step: (grind :if-match nil :exclude "elt")
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
/= rewrites P!1 /= p
  to NOT (P!1 = p)
/= rewrites i!2`1 /= p - 1
  to TRUE
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
rho_middle rewrites rho_middle(i!1)(nlist(i!3`1))
  to FALSE
rho_middle rewrites rho_middle(i!1)(ilist(append(i!3`3, i!3`4)))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)(conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
  to FALSE
/= rewrites P!1 /= p
  to NOT (P!1 = p)
/= rewrites i!2`1 /= p - 1
  to TRUE
IRpart rewrites IRpart
  to pt[[nat_from_2, Identity, Role], Nonce]
rho_middle rewrites rho_middle(i!1)(nlist(i!3`1))
  to NOT elt(i!3`1, n_last)
rho_middle rewrites rho_middle(i!1)(ilist(append(i!3`3, i!3`4)))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)(conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))))
  to NOT elt(i!3`1, n_last)
rho_middle rewrites rho_middle(i!1)(nlist(append(i!3`1, (: i!2`2 :))))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)
            (conc(nlist(append(i!3`1, (: i!2`2 :))),
                  ilist(append(i!3`3, cons(u!1, cdr(i!3`4))))))
  to TRUE
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites 
  rho_middle(i!1)
            (code(public(car(i!3`4)),
                  conc(nlist(append(i!3`1, (: i!2`2 :))),
                       ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
  to TRUE
/= rewrites P!1 /= p
  to NOT (P!1 = p)
/= rewrites i!2`1 /= p - 1
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_middle.1.1.1.

restrictmiddle_middle.1.1.2 :  

{-1}  (public(u!1) = public(hu(0)) AND
        EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
          conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))) =
           conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[2]   P!1 = 2

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictmiddle_middle.1.1.2 :  

{-1}  public(u!1) = public(hu(0))
{-2}  conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))) =
       conc(nlist(append(nl!1, (: n_last :))), ilist(cdr(hu_list)))
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[2]   P!1 = 2

Rerunning step: (comment "a contradiction is lurking in -2")
Adding comment: a contradiction is lurking in -2
this simplifies to: 
restrictmiddle_middle.1.1.2 : 
;;; a contradiction is lurking in -2

[-1]  public(u!1) = public(hu(0))
[-2]  conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))) =
       conc(nlist(append(nl!1, (: n_last :))), ilist(cdr(hu_list)))
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[2]   P!1 = 2

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_middle.1.1.2 : 
;;; a contradiction is lurking in -2

{-1}  nlist(i!3`1) = nlist(append(nl!1, (: n_last :)))
{-2}  ilist(append(i!3`3, i!3`4)) = ilist(cdr(hu_list))
[-3]  public(u!1) = public(hu(0))
[-4]  2 <= P!1
[-5]  0 < i!2`1
[-6]  i!2`1 < P!1 - 1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[2]   P!1 = 2

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_middle.1.1.2 : 
;;; a contradiction is lurking in -2

{-1}  i!3`1 = append(nl!1, (: n_last :))
[-2]  ilist(append(i!3`3, i!3`4)) = ilist(cdr(hu_list))
[-3]  public(u!1) = public(hu(0))
[-4]  2 <= P!1
[-5]  0 < i!2`1
[-6]  i!2`1 < P!1 - 1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[2]   P!1 = 2

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_middle.1.1.2 : 
;;; a contradiction is lurking in -2

{-1}  append(i!3`3, i!3`4) = cdr(hu_list)
[-2]  i!3`1 = append(nl!1, (: n_last :))
[-3]  public(u!1) = public(hu(0))
[-4]  2 <= P!1
[-5]  0 < i!2`1
[-6]  i!2`1 < P!1 - 1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[2]   P!1 = 2

Rerunning step: (typepred "nl!1" "i!3`1" "i!3`3" "i!3`4" "hu_list")
Adding type constraints for  nl!1, i!3`1, i!3`3, i!3`4, hu_list,
this simplifies to: 
restrictmiddle_middle.1.1.2 : 
;;; a contradiction is lurking in -2

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl!1)
{-2}  length(nl!1) = p - 1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`1)
{-4}  length(i!3`1) = i!2`1
{-5}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`3)
{-6}  length(i!3`3) = i!2`1
{-7}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`4)
{-8}  length(i!3`4) = P!1 - 1 - i!2`1
{-9}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-10} (length(hu_list) = p)
{-11} FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] append(i!3`3, i!3`4) = cdr(hu_list)
[-13] i!3`1 = append(nl!1, (: n_last :))
[-14] public(u!1) = public(hu(0))
[-15] 2 <= P!1
[-16] 0 < i!2`1
[-17] i!2`1 < P!1 - 1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[2]   P!1 = 2

Rerunning step: (delete -1 -3 -5 -7 -9 -14 +)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.1.2 : 
;;; a contradiction is lurking in -2

[-1]  length(nl!1) = p - 1
[-2]  length(i!3`1) = i!2`1
[-3]  length(i!3`3) = i!2`1
[-4]  length(i!3`4) = P!1 - 1 - i!2`1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  append(i!3`3, i!3`4) = cdr(hu_list)
[-8]  i!3`1 = append(nl!1, (: n_last :))
[-9]  2 <= P!1
[-10] 0 < i!2`1
[-11] i!2`1 < P!1 - 1
  |-------

Rerunning step: (case "P!1=p")
Case splitting on 
   P!1 = p, 
this yields  2 subgoals: 
restrictmiddle_middle.1.1.2.1 : 
;;; a contradiction is lurking in -2

{-1}  P!1 = p
[-2]  length(nl!1) = p - 1
[-3]  length(i!3`1) = i!2`1
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = P!1 - 1 - i!2`1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!3`3, i!3`4) = cdr(hu_list)
[-9]  i!3`1 = append(nl!1, (: n_last :))
[-10] 2 <= P!1
[-11] 0 < i!2`1
[-12] i!2`1 < P!1 - 1
  |-------

Rerunning step: (replace -9 -3)
Replacing using formula -9,
this simplifies to: 
restrictmiddle_middle.1.1.2.1 : 
;;; a contradiction is lurking in -2

[-1]  P!1 = p
[-2]  length(nl!1) = p - 1
{-3}  length(append(nl!1, (: n_last :))) = i!2`1
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = P!1 - 1 - i!2`1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!3`3, i!3`4) = cdr(hu_list)
[-9]  i!3`1 = append(nl!1, (: n_last :))
[-10] 2 <= P!1
[-11] 0 < i!2`1
[-12] i!2`1 < P!1 - 1
  |-------

Rerunning step: (rewrite "length_append" -3)
Found matching substitution:
l2: list[T] gets (: n_last :),
l1: list[T] gets nl!1,
Rewriting using length_append, matching in -3,
this simplifies to: 
restrictmiddle_middle.1.1.2.1 : 
;;; a contradiction is lurking in -2

[-1]  P!1 = p
[-2]  length(nl!1) = p - 1
{-3}  length((: n_last :)) + length(nl!1) = i!2`1
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = P!1 - 1 - i!2`1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!3`3, i!3`4) = cdr(hu_list)
[-9]  i!3`1 = append(nl!1, (: n_last :))
[-10] 2 <= P!1
[-11] 0 < i!2`1
[-12] i!2`1 < P!1 - 1
  |-------

Rerunning step: (delete -4 -5 -6 -7 -8 -9 -10 -11)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.1.2.1 : 
;;; a contradiction is lurking in -2

[-1]  P!1 = p
[-2]  length(nl!1) = p - 1
[-3]  length((: n_last :)) + length(nl!1) = i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------

Rerunning step: (grind)
length rewrites length[Nonce]((: :))
  to 0
length rewrites length((: n_last :))
  to 1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_middle.1.1.2.1.

restrictmiddle_middle.1.1.2.2 : 
;;; a contradiction is lurking in -2

[-1]  length(nl!1) = p - 1
[-2]  length(i!3`1) = i!2`1
[-3]  length(i!3`3) = i!2`1
[-4]  length(i!3`4) = P!1 - 1 - i!2`1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  append(i!3`3, i!3`4) = cdr(hu_list)
[-8]  i!3`1 = append(nl!1, (: n_last :))
[-9]  2 <= P!1
[-10] 0 < i!2`1
[-11] i!2`1 < P!1 - 1
  |-------
{1}   P!1 = p

Rerunning step: (lemma "listprops[Identity].equality_length"
                 ("l1" "append(i!3`3,i!3`4)" "l2" "cdr(hu_list)"))
Applying listprops[Identity].equality_length where 
  l1 gets append(i!3`3, i!3`4),
  l2 gets cdr(hu_list),
this simplifies to: 
restrictmiddle_middle.1.1.2.2 : 
;;; a contradiction is lurking in -2

{-1}  append(i!3`3, i!3`4) = cdr(hu_list) IMPLIES
       length[Identity](append(i!3`3, i!3`4)) =
        length[Identity](cdr(hu_list))
[-2]  length(nl!1) = p - 1
[-3]  length(i!3`1) = i!2`1
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = P!1 - 1 - i!2`1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!3`3, i!3`4) = cdr(hu_list)
[-9]  i!3`1 = append(nl!1, (: n_last :))
[-10] 2 <= P!1
[-11] 0 < i!2`1
[-12] i!2`1 < P!1 - 1
  |-------
[1]   P!1 = p

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictmiddle_middle.1.1.2.2 : 
;;; a contradiction is lurking in -2

{-1}  length[Identity](append(i!3`3, i!3`4)) =
       length[Identity](cdr(hu_list))
[-2]  length(nl!1) = p - 1
[-3]  length(i!3`1) = i!2`1
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = P!1 - 1 - i!2`1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!3`3, i!3`4) = cdr(hu_list)
[-9]  i!3`1 = append(nl!1, (: n_last :))
[-10] 2 <= P!1
[-11] 0 < i!2`1
[-12] i!2`1 < P!1 - 1
  |-------
[1]   P!1 = p

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets i!3`4,
l1: list[T] gets i!3`3,
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictmiddle_middle.1.1.2.2 : 
;;; a contradiction is lurking in -2

{-1}  length(i!3`3) + length(i!3`4) = length[Identity](cdr(hu_list))
[-2]  length(nl!1) = p - 1
[-3]  length(i!3`1) = i!2`1
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = P!1 - 1 - i!2`1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!3`3, i!3`4) = cdr(hu_list)
[-9]  i!3`1 = append(nl!1, (: n_last :))
[-10] 2 <= P!1
[-11] 0 < i!2`1
[-12] i!2`1 < P!1 - 1
  |-------
[1]   P!1 = p

Rerunning step: (rewrite "length_cdr" -1)
Found matching substitution:
cons_l: (cons?[T]) gets hu_list,
Rewriting using length_cdr, matching in -1,
this simplifies to: 
restrictmiddle_middle.1.1.2.2 : 
;;; a contradiction is lurking in -2

{-1}  length(i!3`3) + length(i!3`4) = length(hu_list) - 1
[-2]  length(nl!1) = p - 1
[-3]  length(i!3`1) = i!2`1
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = P!1 - 1 - i!2`1
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  append(i!3`3, i!3`4) = cdr(hu_list)
[-9]  i!3`1 = append(nl!1, (: n_last :))
[-10] 2 <= P!1
[-11] 0 < i!2`1
[-12] i!2`1 < P!1 - 1
  |-------
[1]   P!1 = p

Rerunning step: (delete -2 -3 -7 -8 -9 -10 -11 -12)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.1.2.2 : 
;;; a contradiction is lurking in -2

[-1]  length(i!3`3) + length(i!3`4) = length(hu_list) - 1
[-2]  length(i!3`3) = i!2`1
[-3]  length(i!3`4) = P!1 - 1 - i!2`1
[-4]  (length(hu_list) = p)
  |-------
[1]   P!1 = p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_middle.1.1.2.2.


This completes the proof of restrictmiddle_middle.1.1.2.

restrictmiddle_middle.1.1.3 :  

{-1}  EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
        public(u!1) = public(hu(j)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
           conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))) =
            conc(ilist(remove(hu_list, j)), nlist(append(nl, (: n_last :))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[2]   P!1 = 2

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictmiddle_middle.1.1.3 :  

{-1}  public(u!1) = public(hu(j!1))
{-2}  conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))) =
       conc(ilist(remove(hu_list, j!1)), nlist(append(nl!1, (: n_last :))))
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(nlist(append(i!3`1, (: i!2`2 :))),
                           ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
[2]   P!1 = 2

Rerunning step: (delete -1 -3 -4 -5 +)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.1.3 :  

[-1]  conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4))) =
       conc(ilist(remove(hu_list, j!1)), nlist(append(nl!1, (: n_last :))))
  |-------

Rerunning step: (decompose-equality -1)
Applying decompose-equality,

This completes the proof of restrictmiddle_middle.1.1.3.


This completes the proof of restrictmiddle_middle.1.1.

restrictmiddle_middle.1.2 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
{1}   ((rec(u!1, nth(i!3`3, i!2`1 - 1),
            E(public(u!1),
              conc(ilist(append(i!3`3, i!3`4)),
                   nlist(cons(i!2`2, i!3`2)))))
         >>
         (signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                         nth(i!3`2, P!1 - 2 - i!2`1)))
           >>
           ((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
             Stop[event])))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (trans(u!1, car(i!3`4),
                     E(public(car(i!3`4)),
                       conc(nlist(append(i!3`1, (: i!2`2 :))),
                            ilist(append(i!3`3, cons(u!1, cdr(i!3`4))))))))
{3}   trans(u!1, car(i!3`4),
            E(public(car(i!3`4)),
              conc(nlist(append(i!3`1, (: i!2`2 :))),
                   ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))))
       >>
       ((rec(u!1, nth(i!3`3, i!2`1 - 1),
             E(public(u!1),
               conc(ilist(append(i!3`3, i!3`4)),
                    nlist(cons(i!2`2, i!3`2)))))
          >>
          (signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                          nth(i!3`2, P!1 - 2 - i!2`1)))
            >>
            ((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
              Stop[event])))
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   ((rec(u!1, nth(i!3`3, i!2`1 - 1),
            E(public(u!1),
              conc(ilist(append(i!3`3, i!3`4)),
                   nlist(cons(i!2`2, i!3`2)))))
         >>
         (signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                         nth(i!3`2, P!1 - 2 - i!2`1)))
           >>
           ((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
             Stop[event])))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[2]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictmiddle_middle.1.2 :  

{-1}  rho_middle(i!1)
                (E(public(u!1),
                   conc(ilist(append(i!3`3, i!3`4)),
                        nlist(cons(i!2`2, i!3`2)))))
[-2]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
{1}   ((signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                       nth(i!3`2, P!1 - 2 - i!2`1)))
         >>
         ((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
           Stop[event]))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (rec(u!1, nth(i!3`3, i!2`1 - 1),
                   E(public(u!1),
                     conc(ilist(append(i!3`3, i!3`4)),
                          nlist(cons(i!2`2, i!3`2))))))
{3}   rec(u!1, nth(i!3`3, i!2`1 - 1),
          E(public(u!1),
            conc(ilist(append(i!3`3, i!3`4)), nlist(cons(i!2`2, i!3`2)))))
       >>
       ((signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                        nth(i!3`2, P!1 - 2 - i!2`1)))
          >>
          ((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
            Stop[event]))
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   P!1 = 2

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(ilist(append(i!3`3, i!3`4)),
                        nlist(cons(i!2`2, i!3`2)))))
[-2]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
[1]   ((signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                       nth(i!3`2, P!1 - 2 - i!2`1)))
         >>
         ((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
           Stop[event]))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[2]   P!1 = 2

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.1 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(ilist(append(i!3`3, i!3`4)),
                        nlist(cons(i!2`2, i!3`2)))))
[-2]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
{1}   rho_middle(i!1)
                (running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                         nth(i!3`2, P!1 - 2 - i!2`1)))
{2}   R_middle(i!1)
              (signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                              nth(i!3`2, P!1 - 2 - i!2`1))))
{3}   signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                     nth(i!3`2, P!1 - 2 - i!2`1)))
       >>
       (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
          Stop[event])
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   P!1 = 2

Rerunning step: (delete - 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.1 :  

  |-------
[1]   rho_middle(i!1)
                (running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                         nth(i!3`2, P!1 - 2 - i!2`1)))

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
restrictmiddle_middle.1.2.1 :  

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictmiddle_middle.1.2.1.

restrictmiddle_middle.1.2.2 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(ilist(append(i!3`3, i!3`4)),
                        nlist(cons(i!2`2, i!3`2)))))
[-2]  rho_middle(i!1)
                (E(public(u!1),
                   conc(nlist(i!3`1), ilist(append(i!3`3, i!3`4)))))
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
{1}   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                              nth(i!3`2, P!1 - 2 - i!2`1))))
{3}   signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                     nth(i!3`2, P!1 - 2 - i!2`1)))
       >>
       (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
          Stop[event])
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   P!1 = 2

Rerunning step: (delete -2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(ilist(append(i!3`3, i!3`4)),
                        nlist(cons(i!2`2, i!3`2)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[2]   R_middle(i!1)
              (signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                              nth(i!3`2, P!1 - 2 - i!2`1))))
[3]   P!1 = 2

Rerunning step: (expand "R_middle" 2)
Expanding the definition of R_middle,
this simplifies to: 
restrictmiddle_middle.1.2.2 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(ilist(append(i!3`3, i!3`4)),
                        nlist(cons(i!2`2, i!3`2)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                     nth(i!3`2, P!1 - 2 - i!2`1)))
       = signal(running(i!1, hu_list, n_last))
[3]   P!1 = 2

Rerunning step: (case "i!1=i!2`1 AND append(i!3`3,cons(u!1,i!3`4))=hu_list AND nth(i!3`2,P!1-2-i!2`1)=n_last")
Case splitting on 
   i!1 = i!2`1 AND
    append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
     nth(i!3`2, P!1 - 2 - i!2`1) = n_last, 
this yields  2 subgoals: 
restrictmiddle_middle.1.2.2.1 :  

{-1}  i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[-2]  rho_middle(i!1)
                (E(public(u!1),
                   conc(ilist(append(i!3`3, i!3`4)),
                        nlist(cons(i!2`2, i!3`2)))))
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
[1]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[2]   signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                     nth(i!3`2, P!1 - 2 - i!2`1)))
       = signal(running(i!1, hu_list, n_last))
[3]   P!1 = 2

Rerunning step: (delete -2 -3 -4 -5 1 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.1 :  

[-1]  i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
  |-------
[1]   signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                     nth(i!3`2, P!1 - 2 - i!2`1)))
       = signal(running(i!1, hu_list, n_last))

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_middle.1.2.2.1.

restrictmiddle_middle.1.2.2.2 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(ilist(append(i!3`3, i!3`4)),
                        nlist(cons(i!2`2, i!3`2)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
{1}   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[2]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   signal(running(i!2`1, append(i!3`3, cons(u!1, i!3`4)),
                     nth(i!3`2, P!1 - 2 - i!2`1)))
       = signal(running(i!1, hu_list, n_last))
[4]   P!1 = 2

Rerunning step: (delete 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2 :  

[-1]  rho_middle(i!1)
                (E(public(u!1),
                   conc(ilist(append(i!3`3, i!3`4)),
                        nlist(cons(i!2`2, i!3`2)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[2]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (expand "E")
Expanding the definition of E,
this simplifies to: 
restrictmiddle_middle.1.2.2.2 :  

{-1}  rho_middle(i!1)
                (code(public(u!1),
                      conc(ilist(append(i!3`3, i!3`4)),
                           nlist(cons(i!2`2, i!3`2)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[2]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (comment "in this situation, the user is not blocked on R, so explore all options that make -1 true")
Adding comment: in this situation, the user is not blocked on R, so explore all options that make -1 true
this simplifies to: 
restrictmiddle_middle.1.2.2.2 : 
;;; in this situation, the user is not blocked on R, so explore all options that make -1 true

[-1]  rho_middle(i!1)
                (code(public(u!1),
                      conc(ilist(append(i!3`3, i!3`4)),
                           nlist(cons(i!2`2, i!3`2)))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[2]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (expand "rho_middle" -1)
Expanding the definition of rho_middle,
this simplifies to: 
restrictmiddle_middle.1.2.2.2 : 
;;; in this situation, the user is not blocked on R, so explore all options that make -1 true

{-1}  rho_middle(i!1)
                (conc(ilist(append(i!3`3, i!3`4)),
                      nlist(cons(i!2`2, i!3`2))))
       OR
       (public(u!1) = public(hu(0)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
           conc(ilist(append(i!3`3, i!3`4)), nlist(cons(i!2`2, i!3`2))) =
            conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
        OR
        EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
          public(u!1) = public(hu(j)) AND
           EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
             conc(ilist(append(i!3`3, i!3`4)), nlist(cons(i!2`2, i!3`2))) =
              conc(ilist(remove(hu_list, j)),
                   nlist(append(nl, (: n_last :))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[2]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (split -1)
Splitting conjunctions,
this yields  3 subgoals: 
restrictmiddle_middle.1.2.2.2.1 : 
;;; in this situation, the user is not blocked on R, so explore all options that make -1 true

{-1}  rho_middle(i!1)
                (conc(ilist(append(i!3`3, i!3`4)),
                      nlist(cons(i!2`2, i!3`2))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[2]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (comment "the received message was 'clean', so the outgoing messages will be too")
Adding comment: the received message was 'clean', so the outgoing messages will be too
this simplifies to: 
restrictmiddle_middle.1.2.2.2.1 : 
;;; the received message was 'clean', so the outgoing messages will be too

[-1]  rho_middle(i!1)
                (conc(ilist(append(i!3`3, i!3`4)),
                      nlist(cons(i!2`2, i!3`2))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[2]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (delete -2 -3 -4 1 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.1 : 
;;; the received message was 'clean', so the outgoing messages will be too

[-1]  rho_middle(i!1)
                (conc(ilist(append(i!3`3, i!3`4)),
                      nlist(cons(i!2`2, i!3`2))))
  |-------
[1]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (expand "LastMessage")
Expanding the definition of LastMessage,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.1 : 
;;; the received message was 'clean', so the outgoing messages will be too

[-1]  rho_middle(i!1)
                (conc(ilist(append(i!3`3, i!3`4)),
                      nlist(cons(i!2`2, i!3`2))))
  |-------
{1}   ((IF i!2`1 = P!1 - 2
          THEN trans(u!1, car(i!3`4), E(public(car(i!3`4)), nlist(i!3`2)))
        ELSE trans(u!1, car(i!3`4),
                   E(public(car(i!3`4)),
                     conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                          nlist(i!3`2))))
        ENDIF
         >> Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (lift-if)
Lifting IF-conditions to the top level,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.1 : 
;;; the received message was 'clean', so the outgoing messages will be too

[-1]  rho_middle(i!1)
                (conc(ilist(append(i!3`3, i!3`4)),
                      nlist(cons(i!2`2, i!3`2))))
  |-------
{1}   IF i!2`1 = P!1 - 2
        THEN ((trans(u!1, car(i!3`4), E(public(car(i!3`4)), nlist(i!3`2)))
                >> Stop[event])
               # R_middle(i!1))
              |>
              LAMBDA (t: list[event]):
                every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))
                     (t)
                 =>
                 every(LAMBDA (e: event):
                         NOT rec?(e) => rho_middle(i!1)(msg(e)))
                      (t)
      ELSE ((trans(u!1, car(i!3`4),
                   E(public(car(i!3`4)),
                     conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                          nlist(i!3`2))))
              >> Stop[event])
             # R_middle(i!1))
            |>
            LAMBDA (t: list[event]):
              every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))
                   (t)
               =>
               every(LAMBDA (e: event):
                       NOT rec?(e) => rho_middle(i!1)(msg(e)))
                    (t)
      ENDIF

Rerunning step: (prop)
Applying propositional simplification,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.2.2.1.1 : 
;;; the received message was 'clean', so the outgoing messages will be too

{-1}  i!2`1 = P!1 - 2
[-2]  rho_middle(i!1)
                (conc(ilist(append(i!3`3, i!3`4)),
                      nlist(cons(i!2`2, i!3`2))))
  |-------
{1}   ((trans(u!1, car(i!3`4), E(public(car(i!3`4)), nlist(i!3`2))) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.2.2.1.1.1 : 
;;; the received message was 'clean', so the outgoing messages will be too

[-1]  i!2`1 = P!1 - 2
[-2]  rho_middle(i!1)
                (conc(ilist(append(i!3`3, i!3`4)),
                      nlist(cons(i!2`2, i!3`2))))
  |-------
{1}   rho_middle(i!1)(E(public(car(i!3`4)), nlist(i!3`2)))
{2}   R_middle(i!1)
              (trans(u!1, car(i!3`4), E(public(car(i!3`4)), nlist(i!3`2))))
{3}   trans(u!1, car(i!3`4), E(public(car(i!3`4)), nlist(i!3`2))) >>
       (Stop[event] # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.1.1.1 : 
;;; the received message was 'clean', so the outgoing messages will be too

[-1]  i!2`1 = P!1 - 2
[-2]  rho_middle(i!1)
                (conc(ilist(append(i!3`3, i!3`4)),
                      nlist(cons(i!2`2, i!3`2))))
  |-------
[1]   rho_middle(i!1)(E(public(car(i!3`4)), nlist(i!3`2)))
[2]   trans(u!1, car(i!3`4), E(public(car(i!3`4)), nlist(i!3`2))) >>
       (Stop[event] # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (lemma "listprops[Nonce].elt_append2"
                 ("l1" "(:i!2`2:)" "l2" "i!3`2" "t" "n_last"))
Applying listprops[Nonce].elt_append2 where 
  l1 gets (: i!2`2 :),
  l2 gets i!3`2,
  t gets n_last,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.1.1.1 : 
;;; the received message was 'clean', so the outgoing messages will be too

{-1}  elt(i!3`2, n_last) IMPLIES elt(append((: i!2`2 :), i!3`2), n_last)
[-2]  i!2`1 = P!1 - 2
[-3]  rho_middle(i!1)
                (conc(ilist(append(i!3`3, i!3`4)),
                      nlist(cons(i!2`2, i!3`2))))
  |-------
[1]   rho_middle(i!1)(E(public(car(i!3`4)), nlist(i!3`2)))
[2]   trans(u!1, car(i!3`4), E(public(car(i!3`4)), nlist(i!3`2))) >>
       (Stop[event] # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (grind :exclude "elt")
append rewrites append((: :), i!3`2)
  to i!3`2
append rewrites append((: i!2`2 :), i!3`2)
  to cons(i!2`2, i!3`2)
E rewrites E(public(car(i!3`4)), nlist(i!3`2))
  to code(public(car(i!3`4)), nlist(i!3`2))
rho_middle rewrites rho_middle(i!1)(nlist(i!3`2))
  to NOT elt(i!3`2, n_last)
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites rho_middle(i!1)(code(public(car(i!3`4)), nlist(i!3`2)))
  to NOT elt(i!3`2, n_last)
# rewrites (Stop[event] # R_middle(i!1))
  to Par(R_middle(i!1))(Stop[event], Stop)
>> rewrites 
  (trans(u!1, car(i!3`4), code(public(car(i!3`4)), nlist(i!3`2))) >>
    Par(R_middle(i!1))(Stop[event], Stop))
      (x)
  to null?(x) OR
       EXISTS (t1: (Par(R_middle(i!1))(Stop[event], Stop))):
         x =
          cons(trans(u!1, car(i!3`4),
                     code(public(car(i!3`4)), nlist(i!3`2))),
               t1)
member rewrites 
  member(x,
         trans(u!1, car(i!3`4), code(public(car(i!3`4)), nlist(i!3`2))) >>
          Par(R_middle(i!1))(Stop[event], Stop))
  to null?(x) OR
       EXISTS (t1: (Par(R_middle(i!1))(Stop[event], Stop))):
         x =
          cons(trans(u!1, car(i!3`4),
                     code(public(car(i!3`4)), nlist(i!3`2))),
               t1)
member rewrites 
  member(x,
         LAMBDA (t: list[event]):
           every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t)
            =>
            every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
                 (t))
  to every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(x) =>
       every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))(x)
subset? rewrites 
  subset?(trans(u!1, car(i!3`4), code(public(car(i!3`4)), nlist(i!3`2))) >>
           Par(R_middle(i!1))(Stop[event], Stop),
          LAMBDA (t: list[event]):
            every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t)
             =>
             every(LAMBDA (e: event):
                     NOT rec?(e) => rho_middle(i!1)(msg(e)))
                  (t))
  to FORALL (x: list[event]):
        (null?(x) OR
          EXISTS (t1: (Par(R_middle(i!1))(Stop[event], Stop))):
            x =
             cons(trans(u!1, car(i!3`4),
                        code(public(car(i!3`4)), nlist(i!3`2))),
                  t1))
         =>
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(x) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (x)
|> rewrites 
  trans(u!1, car(i!3`4), code(public(car(i!3`4)), nlist(i!3`2))) >>
   Par(R_middle(i!1))(Stop[event], Stop)
   |>
   LAMBDA (t: list[event]):
     every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
      every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))(t)
  to FORALL (x: list[event]):
        (null?(x) OR
          EXISTS (t1: (Par(R_middle(i!1))(Stop[event], Stop))):
            x =
             cons(trans(u!1, car(i!3`4),
                        code(public(car(i!3`4)), nlist(i!3`2))),
                  t1))
         =>
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(x) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (x)
rho_middle rewrites rho_middle(i!1)(ilist(append(i!3`3, i!3`4)))
  to TRUE
rho_middle rewrites rho_middle(i!1)(nlist(cons(i!2`2, i!3`2)))
  to FALSE
rho_middle rewrites 
  rho_middle(i!1)
            (conc(ilist(append(i!3`3, i!3`4)), nlist(cons(i!2`2, i!3`2))))
  to FALSE
E rewrites E(public(car(i!3`4)), nlist(i!3`2))
  to code(public(car(i!3`4)), nlist(i!3`2))
rho_middle rewrites rho_middle(i!1)(nlist(i!3`2))
  to TRUE
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites rho_middle(i!1)(code(public(car(i!3`4)), nlist(i!3`2)))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_middle.1.2.2.2.1.1.1.

restrictmiddle_middle.1.2.2.2.1.1.2 : 
;;; the received message was 'clean', so the outgoing messages will be too

[-1]  i!2`1 = P!1 - 2
[-2]  rho_middle(i!1)
                (conc(ilist(append(i!3`3, i!3`4)),
                      nlist(cons(i!2`2, i!3`2))))
  |-------
{1}   (Stop[event] # R_middle(i!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (trans(u!1, car(i!3`4), E(public(car(i!3`4)), nlist(i!3`2))))
{3}   trans(u!1, car(i!3`4), E(public(car(i!3`4)), nlist(i!3`2))) >>
       (Stop[event] # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.1.1.2 : 
;;; the received message was 'clean', so the outgoing messages will be too

  |-------
[1]   (Stop[event] # R_middle(i!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[2]   trans(u!1, car(i!3`4), E(public(car(i!3`4)), nlist(i!3`2))) >>
       (Stop[event] # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictmiddle_middle.1.2.2.2.1.1.2.


This completes the proof of restrictmiddle_middle.1.2.2.2.1.1.

restrictmiddle_middle.1.2.2.2.1.2 : 
;;; the received message was 'clean', so the outgoing messages will be too

[-1]  rho_middle(i!1)
                (conc(ilist(append(i!3`3, i!3`4)),
                      nlist(cons(i!2`2, i!3`2))))
  |-------
{1}   i!2`1 = P!1 - 2
{2}   ((trans(u!1, car(i!3`4),
              E(public(car(i!3`4)),
                conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                     nlist(i!3`2))))
         >> Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.2.2.1.2.1 : 
;;; the received message was 'clean', so the outgoing messages will be too

[-1]  rho_middle(i!1)
                (conc(ilist(append(i!3`3, i!3`4)),
                      nlist(cons(i!2`2, i!3`2))))
  |-------
{1}   rho_middle(i!1)
                (E(public(car(i!3`4)),
                   conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                        nlist(i!3`2))))
{2}   R_middle(i!1)
              (trans(u!1, car(i!3`4),
                     E(public(car(i!3`4)),
                       conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                            nlist(i!3`2)))))
{3}   trans(u!1, car(i!3`4),
            E(public(car(i!3`4)),
              conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                   nlist(i!3`2))))
       >> (Stop[event] # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   i!2`1 = P!1 - 2

Rerunning step: (delete 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.1.2.1 : 
;;; the received message was 'clean', so the outgoing messages will be too

[-1]  rho_middle(i!1)
                (conc(ilist(append(i!3`3, i!3`4)),
                      nlist(cons(i!2`2, i!3`2))))
  |-------
[1]   rho_middle(i!1)
                (E(public(car(i!3`4)),
                   conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                        nlist(i!3`2))))
[2]   R_middle(i!1)
              (trans(u!1, car(i!3`4),
                     E(public(car(i!3`4)),
                       conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                            nlist(i!3`2)))))
[3]   i!2`1 = P!1 - 2

Rerunning step: (lemma "listprops[Nonce].elt_append2"
                 ("l1" "(:i!2`2:)" "l2" "i!3`2" "t" "n_last"))
Applying listprops[Nonce].elt_append2 where 
  l1 gets (: i!2`2 :),
  l2 gets i!3`2,
  t gets n_last,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.1.2.1 : 
;;; the received message was 'clean', so the outgoing messages will be too

{-1}  elt(i!3`2, n_last) IMPLIES elt(append((: i!2`2 :), i!3`2), n_last)
[-2]  rho_middle(i!1)
                (conc(ilist(append(i!3`3, i!3`4)),
                      nlist(cons(i!2`2, i!3`2))))
  |-------
[1]   rho_middle(i!1)
                (E(public(car(i!3`4)),
                   conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                        nlist(i!3`2))))
[2]   R_middle(i!1)
              (trans(u!1, car(i!3`4),
                     E(public(car(i!3`4)),
                       conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                            nlist(i!3`2)))))
[3]   i!2`1 = P!1 - 2

Rerunning step: (grind :if-match nil :exclude "elt")
append rewrites append((: :), i!3`2)
  to i!3`2
append rewrites append((: i!2`2 :), i!3`2)
  to cons(i!2`2, i!3`2)
E rewrites 
  E(public(car(i!3`4)),
    conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))), nlist(i!3`2)))
  to code(public(car(i!3`4)),
           conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))), nlist(i!3`2)))
rho_middle rewrites 
  rho_middle(i!1)(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))
  to TRUE
rho_middle rewrites rho_middle(i!1)(nlist(i!3`2))
  to NOT elt(i!3`2, n_last)
rho_middle rewrites 
  rho_middle(i!1)
            (conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                  nlist(i!3`2)))
  to NOT elt(i!3`2, n_last)
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites 
  rho_middle(i!1)
            (code(public(car(i!3`4)),
                  conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                       nlist(i!3`2))))
  to NOT elt(i!3`2, n_last) OR
       (public(car(i!3`4)) = public(hu(0)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
           conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))), nlist(i!3`2))
            = conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
        OR
        EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
          public(car(i!3`4)) = public(hu(j)) AND
           EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
             conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                  nlist(i!3`2))
              =
              conc(ilist(cons(car(hu_list), remove(cdr(hu_list), j - 1))),
                   nlist(append(nl, (: n_last :))))
R_middle rewrites 
  R_middle(i!1)
          (trans(u!1, car(i!3`4),
                 code(public(car(i!3`4)),
                      conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                           nlist(i!3`2)))))
  to FALSE
rho_middle rewrites rho_middle(i!1)(ilist(append(i!3`3, i!3`4)))
  to TRUE
rho_middle rewrites rho_middle(i!1)(nlist(cons(i!2`2, i!3`2)))
  to FALSE
rho_middle rewrites 
  rho_middle(i!1)
            (conc(ilist(append(i!3`3, i!3`4)), nlist(cons(i!2`2, i!3`2))))
  to FALSE
E rewrites 
  E(public(car(i!3`4)),
    conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))), nlist(i!3`2)))
  to code(public(car(i!3`4)),
           conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))), nlist(i!3`2)))
rho_middle rewrites 
  rho_middle(i!1)(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))))
  to TRUE
rho_middle rewrites rho_middle(i!1)(nlist(i!3`2))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)
            (conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                  nlist(i!3`2)))
  to TRUE
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites 
  rho_middle(i!1)
            (code(public(car(i!3`4)),
                  conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                       nlist(i!3`2))))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_middle.1.2.2.2.1.2.1.

restrictmiddle_middle.1.2.2.2.1.2.2 : 
;;; the received message was 'clean', so the outgoing messages will be too

[-1]  rho_middle(i!1)
                (conc(ilist(append(i!3`3, i!3`4)),
                      nlist(cons(i!2`2, i!3`2))))
  |-------
{1}   (Stop[event] # R_middle(i!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (trans(u!1, car(i!3`4),
                     E(public(car(i!3`4)),
                       conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                            nlist(i!3`2)))))
{3}   trans(u!1, car(i!3`4),
            E(public(car(i!3`4)),
              conc(ilist(append(i!3`3, cons(u!1, cdr(i!3`4)))),
                   nlist(i!3`2))))
       >> (Stop[event] # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   i!2`1 = P!1 - 2

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.1.2.2 : 
;;; the received message was 'clean', so the outgoing messages will be too

  |-------
[1]   (Stop[event] # R_middle(i!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[2]   i!2`1 = P!1 - 2

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictmiddle_middle.1.2.2.2.1.2.2.


This completes the proof of restrictmiddle_middle.1.2.2.2.1.2.


This completes the proof of restrictmiddle_middle.1.2.2.2.1.

restrictmiddle_middle.1.2.2.2.2 : 
;;; in this situation, the user is not blocked on R, so explore all options that make -1 true

{-1}  (public(u!1) = public(hu(0)) AND
        EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
          conc(ilist(append(i!3`3, i!3`4)), nlist(cons(i!2`2, i!3`2))) =
           conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[2]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.2 : 
;;; in this situation, the user is not blocked on R, so explore all options that make -1 true

{-1}  public(u!1) = public(hu(0))
{-2}  conc(ilist(append(i!3`3, i!3`4)), nlist(cons(i!2`2, i!3`2))) =
       conc(nlist(append(nl!1, (: n_last :))), ilist(cdr(hu_list)))
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
[1]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[2]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (delete -1 -3 -4 -5 +)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.2 : 
;;; in this situation, the user is not blocked on R, so explore all options that make -1 true

[-1]  conc(ilist(append(i!3`3, i!3`4)), nlist(cons(i!2`2, i!3`2))) =
       conc(nlist(append(nl!1, (: n_last :))), ilist(cdr(hu_list)))
  |-------

Rerunning step: (decompose-equality -1)
Applying decompose-equality,

This completes the proof of restrictmiddle_middle.1.2.2.2.2.

restrictmiddle_middle.1.2.2.2.3 : 
;;; in this situation, the user is not blocked on R, so explore all options that make -1 true

{-1}  EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
        public(u!1) = public(hu(j)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
           conc(ilist(append(i!3`3, i!3`4)), nlist(cons(i!2`2, i!3`2))) =
            conc(ilist(remove(hu_list, j)), nlist(append(nl, (: n_last :))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[2]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (comment "in this case, the received message was escaped in rho and the current user isn't blocked on R, so the outgoing message must be shown to be escaped in rho too")
Adding comment: in this case, the received message was escaped in rho and the current user isn't blocked on R, so the outgoing message must be shown to be escaped in rho too
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3 : 
;;; in this case, the received message was escaped in rho and the current user isn't blocked on R, so the outgoing message must be shown to be escaped in rho too

[-1]  EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
        public(u!1) = public(hu(j)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
           conc(ilist(append(i!3`3, i!3`4)), nlist(cons(i!2`2, i!3`2))) =
            conc(ilist(remove(hu_list, j)), nlist(append(nl, (: n_last :))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[2]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (comment "the approach is to prove each conjunct in 1, except for the first, which will be needed to prove that the outgoing message is in rho")
Adding comment: the approach is to prove each conjunct in 1, except for the first, which will be needed to prove that the outgoing message is in rho
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3 : 
;;; the approach is to prove each conjunct in 1, except for the first, which will be needed to prove that the outgoing message is in rho

[-1]  EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
        public(u!1) = public(hu(j)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
           conc(ilist(append(i!3`3, i!3`4)), nlist(cons(i!2`2, i!3`2))) =
            conc(ilist(remove(hu_list, j)), nlist(append(nl, (: n_last :))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[2]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (comment "a special case is the first case of LastMessage, which should not occur")
Adding comment: a special case is the first case of LastMessage, which should not occur
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3 : 
;;; a special case is the first case of LastMessage, which should not occur

[-1]  EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
        public(u!1) = public(hu(j)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
           conc(ilist(append(i!3`3, i!3`4)), nlist(cons(i!2`2, i!3`2))) =
            conc(ilist(remove(hu_list, j)), nlist(append(nl, (: n_last :))))
[-2]  2 <= P!1
[-3]  0 < i!2`1
[-4]  i!2`1 < P!1 - 1
  |-------
[1]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[2]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3 : 
;;; a special case is the first case of LastMessage, which should not occur

{-1}  public(u!1) = public(hu(j!1))
{-2}  conc(ilist(append(i!3`3, i!3`4)), nlist(cons(i!2`2, i!3`2))) =
       conc(ilist(remove(hu_list, j!1)), nlist(append(nl!1, (: n_last :))))
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
[1]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[2]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3 : 
;;; a special case is the first case of LastMessage, which should not occur

{-1}  u!1 = hu(j!1)
[-2]  conc(ilist(append(i!3`3, i!3`4)), nlist(cons(i!2`2, i!3`2))) =
       conc(ilist(remove(hu_list, j!1)), nlist(append(nl!1, (: n_last :))))
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
[1]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[2]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3 : 
;;; a special case is the first case of LastMessage, which should not occur

{-1}  ilist(append(i!3`3, i!3`4)) = ilist(remove(hu_list, j!1))
{-2}  nlist(cons(i!2`2, i!3`2)) = nlist(append(nl!1, (: n_last :)))
[-3]  u!1 = hu(j!1)
[-4]  2 <= P!1
[-5]  0 < i!2`1
[-6]  i!2`1 < P!1 - 1
  |-------
[1]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[2]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3 : 
;;; a special case is the first case of LastMessage, which should not occur

{-1}  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-2]  nlist(cons(i!2`2, i!3`2)) = nlist(append(nl!1, (: n_last :)))
[-3]  u!1 = hu(j!1)
[-4]  2 <= P!1
[-5]  0 < i!2`1
[-6]  i!2`1 < P!1 - 1
  |-------
[1]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[2]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3 : 
;;; a special case is the first case of LastMessage, which should not occur

{-1}  cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-2]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-3]  u!1 = hu(j!1)
[-4]  2 <= P!1
[-5]  0 < i!2`1
[-6]  i!2`1 < P!1 - 1
  |-------
[1]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[2]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (typepred "i!3`2" "i!3`3" "i!3`4" "nl!1" "hu_list"
                 "i!1" "j!1")
Adding type constraints for  i!3`2, i!3`3, i!3`4, nl!1, hu_list, i!1, j!1,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3 : 
;;; a special case is the first case of LastMessage, which should not occur

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`2)
{-2}  length(i!3`2) = P!1 - 1 - i!2`1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`3)
{-4}  length(i!3`3) = i!2`1
{-5}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`4)
{-6}  length(i!3`4) = P!1 - 1 - i!2`1
{-7}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl!1)
{-8}  length(nl!1) = -1 - j!1 + p
{-9}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-10} (length(hu_list) = p)
{-11} FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
{-12} 0 < i!1
{-13} i!1 < p - 1
{-14} 0 < j!1
{-15} j!1 <= i!1
[-16] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-17] append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-18] u!1 = hu(j!1)
[-19] 2 <= P!1
[-20] 0 < i!2`1
[-21] i!2`1 < P!1 - 1
  |-------
[1]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[2]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (delete -1 -3 -5 -7 -9 -20 -21)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3 : 
;;; a special case is the first case of LastMessage, which should not occur

[-1]  length(i!3`2) = P!1 - 1 - i!2`1
[-2]  length(i!3`3) = i!2`1
[-3]  length(i!3`4) = P!1 - 1 - i!2`1
[-4]  length(nl!1) = -1 - j!1 + p
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  0 < i!1
[-8]  i!1 < p - 1
[-9]  0 < j!1
[-10] j!1 <= i!1
[-11] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-12] append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-13] u!1 = hu(j!1)
[-14] 2 <= P!1
  |-------
[1]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[2]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (comment "establish some helpful equalities first")
Adding comment: establish some helpful equalities first
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3 : 
;;; establish some helpful equalities first

[-1]  length(i!3`2) = P!1 - 1 - i!2`1
[-2]  length(i!3`3) = i!2`1
[-3]  length(i!3`4) = P!1 - 1 - i!2`1
[-4]  length(nl!1) = -1 - j!1 + p
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  0 < i!1
[-8]  i!1 < p - 1
[-9]  0 < j!1
[-10] j!1 <= i!1
[-11] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-12] append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-13] u!1 = hu(j!1)
[-14] 2 <= P!1
  |-------
[1]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[2]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (case "P!1=p"
                  "j!1=i!2`1"
                  "length(append(i!3`3,cons(hu(i!2`1),i!3`4)))=p")
Case splitting on 
   P!1 = p, 
   j!1 = i!2`1, 
   length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p, 
this yields  5 subgoals: 
restrictmiddle_middle.1.2.2.2.3.1 : 
;;; establish some helpful equalities first

{-1}  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
{-2}  j!1 = i!2`1
{-3}  P!1 = p
[-4]  length(i!3`2) = P!1 - 1 - i!2`1
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = P!1 - 1 - i!2`1
[-7]  length(nl!1) = -1 - j!1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] 0 < i!1
[-11] i!1 < p - 1
[-12] 0 < j!1
[-13] j!1 <= i!1
[-14] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-15] append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-16] u!1 = hu(j!1)
[-17] 2 <= P!1
  |-------
[1]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[2]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   P!1 = 2

Rerunning step: (replace* -2 -3 -16)
Repeatedly applying the replace rule,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1 : 
;;; establish some helpful equalities first

[-1]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-2]  j!1 = i!2`1
[-3]  P!1 = p
{-4}  length(i!3`2) = p - 1 - i!2`1
[-5]  length(i!3`3) = i!2`1
{-6}  length(i!3`4) = p - 1 - i!2`1
{-7}  length(nl!1) = -1 - i!2`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] 0 < i!1
[-11] i!1 < p - 1
{-12} 0 < i!2`1
{-13} i!2`1 <= i!1
[-14] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
{-15} append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
{-16} u!1 = hu(i!2`1)
{-17} 2 <= p
  |-------
{1}   i!1 = i!2`1 AND
       append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list AND
        nth(i!3`2, p - 2 - i!2`1) = n_last
{2}   (((LastMessage(p, i!2`1, hu(i!2`1), i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{3}   p = 2

Rerunning step: (delete -2 -16)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1 : 
;;; establish some helpful equalities first

[-1]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-2]  P!1 = p
[-3]  length(i!3`2) = p - 1 - i!2`1
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = p - 1 - i!2`1
[-6]  length(nl!1) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] 0 < i!2`1
[-12] i!2`1 <= i!1
[-13] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-14] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-15] 2 <= p
  |-------
[1]   i!1 = i!2`1 AND
       append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list AND
        nth(i!3`2, p - 2 - i!2`1) = n_last
[2]   (((LastMessage(p, i!2`1, hu(i!2`1), i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   p = 2

Rerunning step: (split)
Splitting conjunctions,
this yields  3 subgoals: 
restrictmiddle_middle.1.2.2.2.3.1.1 : 
;;; establish some helpful equalities first

[-1]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-2]  P!1 = p
[-3]  length(i!3`2) = p - 1 - i!2`1
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = p - 1 - i!2`1
[-6]  length(nl!1) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] 0 < i!2`1
[-12] i!2`1 <= i!1
[-13] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-14] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-15] 2 <= p
  |-------
{1}   i!1 = i!2`1
[2]   (((LastMessage(p, i!2`1, hu(i!2`1), i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   p = 2

Rerunning step: (comment "get rid of first case of LastMessage first")
Adding comment: get rid of first case of LastMessage first
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1 : 
;;; get rid of first case of LastMessage first

[-1]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-2]  P!1 = p
[-3]  length(i!3`2) = p - 1 - i!2`1
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = p - 1 - i!2`1
[-6]  length(nl!1) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] 0 < i!2`1
[-12] i!2`1 <= i!1
[-13] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-14] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-15] 2 <= p
  |-------
[1]   i!1 = i!2`1
[2]   (((LastMessage(p, i!2`1, hu(i!2`1), i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   p = 2

Rerunning step: (expand "LastMessage")
Expanding the definition of LastMessage,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1 : 
;;; get rid of first case of LastMessage first

[-1]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-2]  P!1 = p
[-3]  length(i!3`2) = p - 1 - i!2`1
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = p - 1 - i!2`1
[-6]  length(nl!1) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] 0 < i!2`1
[-12] i!2`1 <= i!1
[-13] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-14] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-15] 2 <= p
  |-------
[1]   i!1 = i!2`1
{2}   ((IF i!2`1 = p - 2
          THEN trans(hu(i!2`1), car(i!3`4),
                     E(public(car(i!3`4)), nlist(i!3`2)))
        ELSE trans(hu(i!2`1), car(i!3`4),
                   E(public(car(i!3`4)),
                     conc(ilist(append(i!3`3,
                                       cons(hu(i!2`1), cdr(i!3`4)))),
                          nlist(i!3`2))))
        ENDIF
         >> Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   p = 2

Rerunning step: (lift-if)
Lifting IF-conditions to the top level,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1 : 
;;; get rid of first case of LastMessage first

[-1]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-2]  P!1 = p
[-3]  length(i!3`2) = p - 1 - i!2`1
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = p - 1 - i!2`1
[-6]  length(nl!1) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] 0 < i!2`1
[-12] i!2`1 <= i!1
[-13] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-14] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-15] 2 <= p
  |-------
[1]   i!1 = i!2`1
{2}   IF i!2`1 = p - 2
        THEN ((trans(hu(i!2`1), car(i!3`4),
                     E(public(car(i!3`4)), nlist(i!3`2)))
                >> Stop[event])
               # R_middle(i!1))
              |>
              LAMBDA (t: list[event]):
                every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))
                     (t)
                 =>
                 every(LAMBDA (e: event):
                         NOT rec?(e) => rho_middle(i!1)(msg(e)))
                      (t)
      ELSE ((trans(hu(i!2`1), car(i!3`4),
                   E(public(car(i!3`4)),
                     conc(ilist(append(i!3`3,
                                       cons(hu(i!2`1), cdr(i!3`4)))),
                          nlist(i!3`2))))
              >> Stop[event])
             # R_middle(i!1))
            |>
            LAMBDA (t: list[event]):
              every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))
                   (t)
               =>
               every(LAMBDA (e: event):
                       NOT rec?(e) => rho_middle(i!1)(msg(e)))
                    (t)
      ENDIF
[3]   p = 2

Rerunning step: (prop)
Applying propositional simplification,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.2.2.3.1.1.1 : 
;;; get rid of first case of LastMessage first

{-1}  i!2`1 = p - 2
[-2]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-3]  P!1 = p
[-4]  length(i!3`2) = p - 1 - i!2`1
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = p - 1 - i!2`1
[-7]  length(nl!1) = -1 - i!2`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] 0 < i!1
[-11] i!1 < p - 1
[-12] 0 < i!2`1
[-13] i!2`1 <= i!1
[-14] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-15] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-16] 2 <= p
  |-------
{1}   ((trans(hu(i!2`1), car(i!3`4), E(public(car(i!3`4)), nlist(i!3`2)))
         >> Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[2]   i!1 = i!2`1
[3]   p = 2

Rerunning step: (delete -2 -3 -4 -5 -6 -7 -8 -9 -10 -12 -14 -15 1)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.1 : 
;;; get rid of first case of LastMessage first

[-1]  i!2`1 = p - 2
[-2]  i!1 < p - 1
[-3]  i!2`1 <= i!1
[-4]  2 <= p
  |-------
[1]   i!1 = i!2`1
[2]   p = 2

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.1.1.

restrictmiddle_middle.1.2.2.2.3.1.1.2 : 
;;; get rid of first case of LastMessage first

[-1]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-2]  P!1 = p
[-3]  length(i!3`2) = p - 1 - i!2`1
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = p - 1 - i!2`1
[-6]  length(nl!1) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] 0 < i!2`1
[-12] i!2`1 <= i!1
[-13] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-14] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-15] 2 <= p
  |-------
{1}   i!2`1 = p - 2
{2}   ((trans(hu(i!2`1), car(i!3`4),
              E(public(car(i!3`4)),
                conc(ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))),
                     nlist(i!3`2))))
         >> Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   i!1 = i!2`1
[4]   p = 2

Rerunning step: (comment "first case has been gotten rid of, now prove that the outgoing message conforms to rho")
Adding comment: first case has been gotten rid of, now prove that the outgoing message conforms to rho
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2 : 
;;; first case has been gotten rid of, now prove that the outgoing message conforms to rho

[-1]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-2]  P!1 = p
[-3]  length(i!3`2) = p - 1 - i!2`1
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = p - 1 - i!2`1
[-6]  length(nl!1) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] 0 < i!2`1
[-12] i!2`1 <= i!1
[-13] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-14] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-15] 2 <= p
  |-------
[1]   i!2`1 = p - 2
[2]   ((trans(hu(i!2`1), car(i!3`4),
              E(public(car(i!3`4)),
                conc(ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))),
                     nlist(i!3`2))))
         >> Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   i!1 = i!2`1
[4]   p = 2

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1 : 
;;; first case has been gotten rid of, now prove that the outgoing message conforms to rho

[-1]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-2]  P!1 = p
{-3}  length(i!3`2) = -1 - i!2`1 + p
[-4]  length(i!3`3) = i!2`1
{-5}  length(i!3`4) = -1 - i!2`1 + p
[-6]  length(nl!1) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] 0 < i!2`1
[-12] i!2`1 <= i!1
[-13] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-14] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-15] 2 <= p
  |-------
{1}   rho_middle(i!1)
                (E(public(car(i!3`4)),
                   conc(ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))),
                        nlist(i!3`2))))
{2}   R_middle(i!1)
              (trans(hu(i!2`1), car(i!3`4),
                     E(public(car(i!3`4)),
                       conc(ilist(append(i!3`3,
                                         cons(hu(i!2`1), cdr(i!3`4)))),
                            nlist(i!3`2)))))
{3}   trans(hu(i!2`1), car(i!3`4),
            E(public(car(i!3`4)),
              conc(ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))),
                   nlist(i!3`2))))
       >> (Stop[event] # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   i!2`1 = p - 2
[5]   i!1 = i!2`1
[6]   p = 2

Rerunning step: (expand "E")
Expanding the definition of E,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1 : 
;;; first case has been gotten rid of, now prove that the outgoing message conforms to rho

[-1]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-2]  P!1 = p
[-3]  length(i!3`2) = -1 - i!2`1 + p
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = -1 - i!2`1 + p
[-6]  length(nl!1) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] 0 < i!2`1
[-12] i!2`1 <= i!1
[-13] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-14] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-15] 2 <= p
  |-------
{1}   rho_middle(i!1)
                (code(public(car(i!3`4)),
                      conc(ilist(append(i!3`3,
                                        cons(hu(i!2`1), cdr(i!3`4)))),
                           nlist(i!3`2))))
{2}   R_middle(i!1)
              (trans(hu(i!2`1), car(i!3`4),
                     code(public(car(i!3`4)),
                          conc(ilist(append
                                     (i!3`3, cons(hu(i!2`1), cdr(i!3`4)))),
                               nlist(i!3`2)))))
{3}   trans(hu(i!2`1), car(i!3`4),
            code(public(car(i!3`4)),
                 conc(ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))),
                      nlist(i!3`2))))
       >> (Stop[event] # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   i!2`1 = p - 2
[5]   i!1 = i!2`1
[6]   p = 2

Rerunning step: (expand "rho_middle" 1)
Expanding the definition of rho_middle,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1 : 
;;; first case has been gotten rid of, now prove that the outgoing message conforms to rho

[-1]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-2]  P!1 = p
[-3]  length(i!3`2) = -1 - i!2`1 + p
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = -1 - i!2`1 + p
[-6]  length(nl!1) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] 0 < i!2`1
[-12] i!2`1 <= i!1
[-13] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-14] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-15] 2 <= p
  |-------
{1}   rho_middle(i!1)
                (conc(ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))),
                      nlist(i!3`2)))
       OR
       (public(car(i!3`4)) = public(hu(0)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
           conc(ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))),
                nlist(i!3`2))
            = conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
        OR
        EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
          public(car(i!3`4)) = public(hu(j)) AND
           EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
             conc(ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))),
                  nlist(i!3`2))
              =
              conc(ilist(remove(hu_list, j)),
                   nlist(append(nl, (: n_last :))))
[2]   R_middle(i!1)
              (trans(hu(i!2`1), car(i!3`4),
                     code(public(car(i!3`4)),
                          conc(ilist(append
                                     (i!3`3, cons(hu(i!2`1), cdr(i!3`4)))),
                               nlist(i!3`2)))))
[3]   trans(hu(i!2`1), car(i!3`4),
            code(public(car(i!3`4)),
                 conc(ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))),
                      nlist(i!3`2))))
       >> (Stop[event] # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   i!2`1 = p - 2
[5]   i!1 = i!2`1
[6]   p = 2

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1 : 
;;; first case has been gotten rid of, now prove that the outgoing message conforms to rho

[-1]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-2]  P!1 = p
[-3]  length(i!3`2) = -1 - i!2`1 + p
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = -1 - i!2`1 + p
[-6]  length(nl!1) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] 0 < i!2`1
[-12] i!2`1 <= i!1
[-13] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-14] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-15] 2 <= p
  |-------
{1}   rho_middle(i!1)
                (conc(ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))),
                      nlist(i!3`2)))
{2}   (public(car(i!3`4)) = public(hu(0)) AND
        EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
          conc(ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))),
               nlist(i!3`2))
           = conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
{3}   EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
        public(car(i!3`4)) = public(hu(j)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
           conc(ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))),
                nlist(i!3`2))
            =
            conc(ilist(remove(hu_list, j)), nlist(append(nl, (: n_last :))))
[4]   R_middle(i!1)
              (trans(hu(i!2`1), car(i!3`4),
                     code(public(car(i!3`4)),
                          conc(ilist(append
                                     (i!3`3, cons(hu(i!2`1), cdr(i!3`4)))),
                               nlist(i!3`2)))))
[5]   trans(hu(i!2`1), car(i!3`4),
            code(public(car(i!3`4)),
                 conc(ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))),
                      nlist(i!3`2))))
       >> (Stop[event] # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[6]   i!2`1 = p - 2
[7]   i!1 = i!2`1
[8]   p = 2

Rerunning step: (delete 1 2 4 5 7)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1 : 
;;; first case has been gotten rid of, now prove that the outgoing message conforms to rho

[-1]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-2]  P!1 = p
[-3]  length(i!3`2) = -1 - i!2`1 + p
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = -1 - i!2`1 + p
[-6]  length(nl!1) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] 0 < i!2`1
[-12] i!2`1 <= i!1
[-13] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-14] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-15] 2 <= p
  |-------
[1]   EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
        public(car(i!3`4)) = public(hu(j)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
           conc(ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))),
                nlist(i!3`2))
            =
            conc(ilist(remove(hu_list, j)), nlist(append(nl, (: n_last :))))
[2]   i!2`1 = p - 2
[3]   p = 2

Rerunning step: (comment "the next message is sent to i!2`1+1")
Adding comment: the next message is sent to i!2`1+1
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1 : 
;;; the next message is sent to i!2`1+1

[-1]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-2]  P!1 = p
[-3]  length(i!3`2) = -1 - i!2`1 + p
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = -1 - i!2`1 + p
[-6]  length(nl!1) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] 0 < i!2`1
[-12] i!2`1 <= i!1
[-13] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-14] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-15] 2 <= p
  |-------
[1]   EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
        public(car(i!3`4)) = public(hu(j)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
           conc(ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))),
                nlist(i!3`2))
            =
            conc(ilist(remove(hu_list, j)), nlist(append(nl, (: n_last :))))
[2]   i!2`1 = p - 2
[3]   p = 2

Rerunning step: (inst 1 "i!2`1+1")
Instantiating the top quantifier in 1 with the terms: 
 i!2`1+1,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1 : 
;;; the next message is sent to i!2`1+1

[-1]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-2]  P!1 = p
[-3]  length(i!3`2) = -1 - i!2`1 + p
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = -1 - i!2`1 + p
[-6]  length(nl!1) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] 0 < i!2`1
[-12] i!2`1 <= i!1
[-13] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-14] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-15] 2 <= p
  |-------
{1}   public(car(i!3`4)) = public(hu(i!2`1 + 1)) AND
       EXISTS (nl: {x: list[Nonce] | length(x) = -2 - i!2`1 + p}):
         conc(ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))),
              nlist(i!3`2))
          =
          conc(ilist(remove(hu_list, i!2`1 + 1)),
               nlist(append(nl, (: n_last :))))
[2]   i!2`1 = p - 2
[3]   p = 2

Rerunning step: (lemma "listprops[Identity].equality_nth"
                 ("l1" "append(i!3`3,i!3`4)" "l2"
                  "remove(hu_list,i!2`1)"))
Applying listprops[Identity].equality_nth where 
  l1 gets append(i!3`3, i!3`4),
  l2 gets remove(hu_list, i!2`1),
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1 : 
;;; the next message is sent to i!2`1+1

{-1}  append(i!3`3, i!3`4) = remove(hu_list, i!2`1) IMPLIES
       FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
         nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-2]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-3]  P!1 = p
[-4]  length(i!3`2) = -1 - i!2`1 + p
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  length(nl!1) = -1 - i!2`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] 0 < i!1
[-11] i!1 < p - 1
[-12] 0 < i!2`1
[-13] i!2`1 <= i!1
[-14] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-15] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-16] 2 <= p
  |-------
[1]   public(car(i!3`4)) = public(hu(i!2`1 + 1)) AND
       EXISTS (nl: {x: list[Nonce] | length(x) = -2 - i!2`1 + p}):
         conc(ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))),
              nlist(i!3`2))
          =
          conc(ilist(remove(hu_list, i!2`1 + 1)),
               nlist(append(nl, (: n_last :))))
[2]   i!2`1 = p - 2
[3]   p = 2

Rerunning step: (lemma "listprops[Identity].nth_append"
                 ("l1" "i!3`3" "l2" "i!3`4"))
Applying listprops[Identity].nth_append where 
  l1 gets i!3`3,
  l2 gets i!3`4,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1 : 
;;; the next message is sent to i!2`1+1

{-1}  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-2]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1) IMPLIES
       FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
         nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-3]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-4]  P!1 = p
[-5]  length(i!3`2) = -1 - i!2`1 + p
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = -1 - i!2`1 + p
[-8]  length(nl!1) = -1 - i!2`1 + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] 0 < i!1
[-12] i!1 < p - 1
[-13] 0 < i!2`1
[-14] i!2`1 <= i!1
[-15] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-16] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-17] 2 <= p
  |-------
[1]   public(car(i!3`4)) = public(hu(i!2`1 + 1)) AND
       EXISTS (nl: {x: list[Nonce] | length(x) = -2 - i!2`1 + p}):
         conc(ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))),
              nlist(i!3`2))
          =
          conc(ilist(remove(hu_list, i!2`1 + 1)),
               nlist(append(nl, (: n_last :))))
[2]   i!2`1 = p - 2
[3]   p = 2

Rerunning step: (lemma "listprops[Identity].nth_remove"
                 ("l" "hu_list" "i" "i!2`1"))
Applying listprops[Identity].nth_remove where 
  l gets hu_list,
  i gets i!2`1,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1 : 
;;; the next message is sent to i!2`1+1

{-1}  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-2]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-3]  append(i!3`3, i!3`4) = remove(hu_list, i!2`1) IMPLIES
       FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
         nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-4]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-5]  P!1 = p
[-6]  length(i!3`2) = -1 - i!2`1 + p
[-7]  length(i!3`3) = i!2`1
[-8]  length(i!3`4) = -1 - i!2`1 + p
[-9]  length(nl!1) = -1 - i!2`1 + p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] 0 < i!1
[-13] i!1 < p - 1
[-14] 0 < i!2`1
[-15] i!2`1 <= i!1
[-16] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-17] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-18] 2 <= p
  |-------
[1]   public(car(i!3`4)) = public(hu(i!2`1 + 1)) AND
       EXISTS (nl: {x: list[Nonce] | length(x) = -2 - i!2`1 + p}):
         conc(ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))),
              nlist(i!3`2))
          =
          conc(ilist(remove(hu_list, i!2`1 + 1)),
               nlist(append(nl, (: n_last :))))
[2]   i!2`1 = p - 2
[3]   p = 2

Rerunning step: (prop)
Applying propositional simplification,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.1 : 
;;; the next message is sent to i!2`1+1

{-1}  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-2]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-3]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-4]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-5]  P!1 = p
[-6]  length(i!3`2) = -1 - i!2`1 + p
[-7]  length(i!3`3) = i!2`1
[-8]  length(i!3`4) = -1 - i!2`1 + p
[-9]  length(nl!1) = -1 - i!2`1 + p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] 0 < i!1
[-13] i!1 < p - 1
[-14] 0 < i!2`1
[-15] i!2`1 <= i!1
[-16] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-17] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-18] 2 <= p
  |-------
{1}   public(car(i!3`4)) = public(hu(i!2`1 + 1))
[2]   i!2`1 = p - 2
[3]   p = 2

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.1 : 
;;; the next message is sent to i!2`1+1

[-1]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
{-2}  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, 1 + j) ENDIF
[-3]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-4]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-5]  P!1 = p
[-6]  length(i!3`2) = -1 - i!2`1 + p
[-7]  length(i!3`3) = i!2`1
[-8]  length(i!3`4) = -1 - i!2`1 + p
[-9]  length(nl!1) = -1 - i!2`1 + p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] 0 < i!1
[-13] i!1 < p - 1
[-14] 0 < i!2`1
[-15] i!2`1 <= i!1
[-16] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-17] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-18] 2 <= p
  |-------
{1}   car(i!3`4) = hu(1 + i!2`1)
[2]   i!2`1 = p - 2
[3]   p = 2

Rerunning step: (inst -1 "i!2`1")
Instantiating the top quantifier in -1 with the terms: 
 i!2`1,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.1.1 : 
;;; the next message is sent to i!2`1+1

{-1}  nth(append(i!3`3, i!3`4), i!2`1) = nth(remove(hu_list, i!2`1), i!2`1)
[-2]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, 1 + j) ENDIF
[-3]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-4]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-5]  P!1 = p
[-6]  length(i!3`2) = -1 - i!2`1 + p
[-7]  length(i!3`3) = i!2`1
[-8]  length(i!3`4) = -1 - i!2`1 + p
[-9]  length(nl!1) = -1 - i!2`1 + p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] 0 < i!1
[-13] i!1 < p - 1
[-14] 0 < i!2`1
[-15] i!2`1 <= i!1
[-16] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-17] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-18] 2 <= p
  |-------
[1]   car(i!3`4) = hu(1 + i!2`1)
[2]   i!2`1 = p - 2
[3]   p = 2

Rerunning step: (inst -2 "i!2`1")
Instantiating the top quantifier in -2 with the terms: 
 i!2`1,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.1.1 : 
;;; the next message is sent to i!2`1+1

[-1]  nth(append(i!3`3, i!3`4), i!2`1) = nth(remove(hu_list, i!2`1), i!2`1)
{-2}  nth(remove(hu_list, i!2`1), i!2`1) =
       IF i!2`1 < i!2`1 THEN nth(hu_list, i!2`1)
       ELSE nth(hu_list, 1 + i!2`1)
       ENDIF
[-3]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-4]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-5]  P!1 = p
[-6]  length(i!3`2) = -1 - i!2`1 + p
[-7]  length(i!3`3) = i!2`1
[-8]  length(i!3`4) = -1 - i!2`1 + p
[-9]  length(nl!1) = -1 - i!2`1 + p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] 0 < i!1
[-13] i!1 < p - 1
[-14] 0 < i!2`1
[-15] i!2`1 <= i!1
[-16] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-17] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-18] 2 <= p
  |-------
[1]   car(i!3`4) = hu(1 + i!2`1)
[2]   i!2`1 = p - 2
[3]   p = 2

Rerunning step: (inst -3 "i!2`1")
Instantiating the top quantifier in -3 with the terms: 
 i!2`1,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.1.1 : 
;;; the next message is sent to i!2`1+1

[-1]  nth(append(i!3`3, i!3`4), i!2`1) = nth(remove(hu_list, i!2`1), i!2`1)
[-2]  nth(remove(hu_list, i!2`1), i!2`1) =
       IF i!2`1 < i!2`1 THEN nth(hu_list, i!2`1)
       ELSE nth(hu_list, 1 + i!2`1)
       ENDIF
{-3}  nth(append(i!3`3, i!3`4), i!2`1) =
       IF i!2`1 < length[Identity](i!3`3) THEN nth(i!3`3, i!2`1)
       ELSE nth(i!3`4, i!2`1 - length[Identity](i!3`3))
       ENDIF
[-4]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-5]  P!1 = p
[-6]  length(i!3`2) = -1 - i!2`1 + p
[-7]  length(i!3`3) = i!2`1
[-8]  length(i!3`4) = -1 - i!2`1 + p
[-9]  length(nl!1) = -1 - i!2`1 + p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] 0 < i!1
[-13] i!1 < p - 1
[-14] 0 < i!2`1
[-15] i!2`1 <= i!1
[-16] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-17] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-18] 2 <= p
  |-------
[1]   car(i!3`4) = hu(1 + i!2`1)
[2]   i!2`1 = p - 2
[3]   p = 2

Rerunning step: (delete -4 -5
                  -6 -8
                  -9 -10
                  -12 -13
                  -14 -15
                  -16 -17
                  -18 2
                  3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.1.1 : 
;;; the next message is sent to i!2`1+1

[-1]  nth(append(i!3`3, i!3`4), i!2`1) = nth(remove(hu_list, i!2`1), i!2`1)
[-2]  nth(remove(hu_list, i!2`1), i!2`1) =
       IF i!2`1 < i!2`1 THEN nth(hu_list, i!2`1)
       ELSE nth(hu_list, 1 + i!2`1)
       ENDIF
[-3]  nth(append(i!3`3, i!3`4), i!2`1) =
       IF i!2`1 < length[Identity](i!3`3) THEN nth(i!3`3, i!2`1)
       ELSE nth(i!3`4, i!2`1 - length[Identity](i!3`3))
       ENDIF
[-4]  length(i!3`3) = i!2`1
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
  |-------
[1]   car(i!3`4) = hu(1 + i!2`1)

Rerunning step: (inst -5 "1+i!2`1")
Instantiating the top quantifier in -5 with the terms: 
 1+i!2`1,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.1.1 : 
;;; the next message is sent to i!2`1+1

[-1]  nth(append(i!3`3, i!3`4), i!2`1) = nth(remove(hu_list, i!2`1), i!2`1)
[-2]  nth(remove(hu_list, i!2`1), i!2`1) =
       IF i!2`1 < i!2`1 THEN nth(hu_list, i!2`1)
       ELSE nth(hu_list, 1 + i!2`1)
       ENDIF
[-3]  nth(append(i!3`3, i!3`4), i!2`1) =
       IF i!2`1 < length[Identity](i!3`3) THEN nth(i!3`3, i!2`1)
       ELSE nth(i!3`4, i!2`1 - length[Identity](i!3`3))
       ENDIF
[-4]  length(i!3`3) = i!2`1
{-5}  nth(hu_list, 1 + i!2`1) = hu(1 + i!2`1)
  |-------
[1]   car(i!3`4) = hu(1 + i!2`1)

Rerunning step: (grind :exclude ("append" "remove"))
nth rewrites nth(append(i!3`3, i!3`4), i!2`1)
  to nth(cdr(append(i!3`3, i!3`4)), i!2`1 - 1)
nth rewrites nth(remove(hu_list, i!2`1), i!2`1)
  to nth(cdr(remove(hu_list, i!2`1)), i!2`1 - 1)
nth rewrites nth(cdr(hu_list), i!2`1)
  to nth(cdr(cdr(hu_list)), i!2`1 - 1)
nth rewrites nth(hu_list, 1 + i!2`1)
  to nth(cdr(cdr(hu_list)), i!2`1 - 1)
nth rewrites nth(i!3`4, i!2`1 - length[Identity](i!3`3))
  to car(i!3`4)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.1.2.1.1.1.

restrictmiddle_middle.1.2.2.2.3.1.1.2.1.1.2 (TCC):   

[-1]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, 1 + j) ENDIF
[-2]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-3]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-4]  P!1 = p
[-5]  length(i!3`2) = -1 - i!2`1 + p
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = -1 - i!2`1 + p
[-8]  length(nl!1) = -1 - i!2`1 + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] 0 < i!1
[-12] i!1 < p - 1
[-13] 0 < i!2`1
[-14] i!2`1 <= i!1
[-15] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-16] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-17] 2 <= p
  |-------
{1}   i!2`1 < length[Identity](append[Identity](i!3`3, i!3`4))
[2]   car(i!3`4) = hu(1 + i!2`1)
[3]   i!2`1 = p - 2
[4]   p = 2

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets i!3`4,
l1: list[T] gets i!3`3,
Rewriting using length_append, matching in 1,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.1.2 : 
;;; the next message is sent to i!2`1+1

[-1]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, 1 + j) ENDIF
[-2]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-3]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-4]  P!1 = p
[-5]  length(i!3`2) = -1 - i!2`1 + p
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = -1 - i!2`1 + p
[-8]  length(nl!1) = -1 - i!2`1 + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] 0 < i!1
[-12] i!1 < p - 1
[-13] 0 < i!2`1
[-14] i!2`1 <= i!1
[-15] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-16] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-17] 2 <= p
  |-------
{1}   i!2`1 < length(i!3`3) + length(i!3`4)
[2]   car(i!3`4) = hu(1 + i!2`1)
[3]   i!2`1 = p - 2
[4]   p = 2

Rerunning step: (delete -1 -2
                  -3 -4
                  -5 -8
                  -9 -10
                  -11 -13
                  -15 -16
                  -17 2
                  3 4)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.1.2 : 
;;; the next message is sent to i!2`1+1

[-1]  length(i!3`3) = i!2`1
[-2]  length(i!3`4) = -1 - i!2`1 + p
[-3]  i!1 < p - 1
[-4]  i!2`1 <= i!1
  |-------
[1]   i!2`1 < length(i!3`3) + length(i!3`4)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.1.2.1.1.2.


This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.1.2.1.1.

restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2 : 
;;; the next message is sent to i!2`1+1

{-1}  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-2]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-3]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-4]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-5]  P!1 = p
[-6]  length(i!3`2) = -1 - i!2`1 + p
[-7]  length(i!3`3) = i!2`1
[-8]  length(i!3`4) = -1 - i!2`1 + p
[-9]  length(nl!1) = -1 - i!2`1 + p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] 0 < i!1
[-13] i!1 < p - 1
[-14] 0 < i!2`1
[-15] i!2`1 <= i!1
[-16] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-17] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-18] 2 <= p
  |-------
{1}   EXISTS (nl: {x: list[Nonce] | length(x) = -2 - i!2`1 + p}):
        conc(ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))),
             nlist(i!3`2))
         =
         conc(ilist(remove(hu_list, i!2`1 + 1)),
              nlist(append(nl, (: n_last :))))
[2]   i!2`1 = p - 2
[3]   p = 2

Rerunning step: (lemma "more_list_props[Identity].length_non_zero"
                 ("l" "nl!1"))
Applying more_list_props[Identity].length_non_zero where 
  l gets nl!1,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2 : 
;;; the next message is sent to i!2`1+1

{-1}  length(nl!1) > 0 IFF cons?(nl!1)
[-2]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-3]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-4]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-5]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-6]  P!1 = p
[-7]  length(i!3`2) = -1 - i!2`1 + p
[-8]  length(i!3`3) = i!2`1
[-9]  length(i!3`4) = -1 - i!2`1 + p
[-10] length(nl!1) = -1 - i!2`1 + p
[-11] (length(hu_list) = p)
[-12] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-13] 0 < i!1
[-14] i!1 < p - 1
[-15] 0 < i!2`1
[-16] i!2`1 <= i!1
[-17] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-18] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-19] 2 <= p
  |-------
[1]   EXISTS (nl: {x: list[Nonce] | length(x) = -2 - i!2`1 + p}):
        conc(ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))),
             nlist(i!3`2))
         =
         conc(ilist(remove(hu_list, i!2`1 + 1)),
              nlist(append(nl, (: n_last :))))
[2]   i!2`1 = p - 2
[3]   p = 2

Rerunning step: (ground)
Applying propositional simplification and decision procedures,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2 : 
;;; the next message is sent to i!2`1+1

{-1}  length(nl!1) > 0
{-2}  cons?(nl!1)
[-3]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
{-4}  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, 1 + j) ENDIF
[-5]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-6]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-7]  P!1 = p
[-8]  length(i!3`2) = -1 - i!2`1 + p
[-9]  length(i!3`3) = i!2`1
[-10] length(i!3`4) = -1 - i!2`1 + p
[-11] length(nl!1) = -1 - i!2`1 + p
[-12] (length(hu_list) = p)
[-13] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-14] 0 < i!1
[-15] i!1 < p - 1
[-16] 0 < i!2`1
[-17] i!2`1 <= i!1
[-18] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-19] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-20] 2 <= p
  |-------
{1}   EXISTS (nl: {x: list[Nonce] | length(x) = -2 - i!2`1 + p}):
        conc(ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))),
             nlist(i!3`2))
         =
         conc(ilist(remove(hu_list, 1 + i!2`1)),
              nlist(append(nl, (: n_last :))))
[2]   i!2`1 = p - 2
[3]   p = 2

Rerunning step: (inst 1 "cdr(nl!1)")
Instantiating the top quantifier in 1 with the terms: 
 cdr(nl!1),
this yields  2 subgoals: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1 : 
;;; the next message is sent to i!2`1+1

[-1]  length(nl!1) > 0
[-2]  cons?(nl!1)
[-3]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-4]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, 1 + j) ENDIF
[-5]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-6]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-7]  P!1 = p
[-8]  length(i!3`2) = -1 - i!2`1 + p
[-9]  length(i!3`3) = i!2`1
[-10] length(i!3`4) = -1 - i!2`1 + p
[-11] length(nl!1) = -1 - i!2`1 + p
[-12] (length(hu_list) = p)
[-13] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-14] 0 < i!1
[-15] i!1 < p - 1
[-16] 0 < i!2`1
[-17] i!2`1 <= i!1
[-18] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-19] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-20] 2 <= p
  |-------
{1}   conc(ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))), nlist(i!3`2))
       =
       conc(ilist(remove(hu_list, 1 + i!2`1)),
            nlist(append(cdr(nl!1), (: n_last :))))
[2]   i!2`1 = p - 2
[3]   p = 2

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1 : 
;;; the next message is sent to i!2`1+1

[-1]  length(nl!1) > 0
[-2]  cons?(nl!1)
[-3]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-4]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, 1 + j) ENDIF
[-5]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-6]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-7]  P!1 = p
[-8]  length(i!3`2) = -1 - i!2`1 + p
[-9]  length(i!3`3) = i!2`1
[-10] length(i!3`4) = -1 - i!2`1 + p
[-11] length(nl!1) = -1 - i!2`1 + p
[-12] (length(hu_list) = p)
[-13] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-14] 0 < i!1
[-15] i!1 < p - 1
[-16] 0 < i!2`1
[-17] i!2`1 <= i!1
[-18] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-19] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-20] 2 <= p
  |-------
{1}   ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) =
       ilist(remove(hu_list, 1 + i!2`1))
[2]   i!2`1 = p - 2
[3]   p = 2

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1 : 
;;; the next message is sent to i!2`1+1

[-1]  length(nl!1) > 0
[-2]  cons?(nl!1)
[-3]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-4]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, 1 + j) ENDIF
[-5]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-6]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-7]  P!1 = p
[-8]  length(i!3`2) = -1 - i!2`1 + p
[-9]  length(i!3`3) = i!2`1
[-10] length(i!3`4) = -1 - i!2`1 + p
[-11] length(nl!1) = -1 - i!2`1 + p
[-12] (length(hu_list) = p)
[-13] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-14] 0 < i!1
[-15] i!1 < p - 1
[-16] 0 < i!2`1
[-17] i!2`1 <= i!1
[-18] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-19] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-20] 2 <= p
  |-------
{1}   append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))) =
       remove(hu_list, 1 + i!2`1)
[2]   i!2`1 = p - 2
[3]   p = 2

Rerunning step: (rewrite "length_nth_equality[Identity]" 1)
Found matching substitution:
l2: list[Identity] gets remove(hu_list, 1 + i!2`1),
l1: list[Identity] gets append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))),
Rewriting using length_nth_equality[Identity], matching in 1,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.1 : 
;;; the next message is sent to i!2`1+1

[-1]  length(nl!1) > 0
[-2]  cons?(nl!1)
[-3]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-4]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, 1 + j) ENDIF
[-5]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-6]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-7]  P!1 = p
[-8]  length(i!3`2) = -1 - i!2`1 + p
[-9]  length(i!3`3) = i!2`1
[-10] length(i!3`4) = -1 - i!2`1 + p
[-11] length(nl!1) = -1 - i!2`1 + p
[-12] (length(hu_list) = p)
[-13] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-14] 0 < i!1
[-15] i!1 < p - 1
[-16] 0 < i!2`1
[-17] i!2`1 <= i!1
[-18] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-19] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-20] 2 <= p
  |-------
{1}   length[Identity](append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) =
       length[Identity](remove(hu_list, 1 + i!2`1))
[2]   append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))) =
       remove(hu_list, 1 + i!2`1)
[3]   i!2`1 = p - 2
[4]   p = 2

Rerunning step: (delete -1 -2
                  -3 -4
                  -5 -6
                  -7 -8
                  -11 -13
                  -14 -15
                  -16 -17
                  -18 -19
                  2 3
                  4)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.1 : 
;;; the next message is sent to i!2`1+1

[-1]  length(i!3`3) = i!2`1
[-2]  length(i!3`4) = -1 - i!2`1 + p
[-3]  (length(hu_list) = p)
[-4]  2 <= p
  |-------
[1]   length[Identity](append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))) =
       length[Identity](remove(hu_list, 1 + i!2`1))

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets cons(hu(i!2`1), cdr(i!3`4)),
l1: list[T] gets i!3`3,
Rewriting using length_append, matching in 1,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.1 : 
;;; the next message is sent to i!2`1+1

[-1]  length(i!3`3) = i!2`1
[-2]  length(i!3`4) = -1 - i!2`1 + p
[-3]  (length(hu_list) = p)
[-4]  2 <= p
  |-------
{1}   length(cons(hu(i!2`1), cdr(i!3`4))) + length(i!3`3) =
       length[Identity](remove(hu_list, 1 + i!2`1))

Rerunning step: (rewrite "length_remove" 1 :dir rl)
Found matching substitution:
i: below[length(c)] gets 1 + i!2`1,
c: (cons?[T]) gets hu_list,
Rewriting using length_remove, matching in 1,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.1.1 : 
;;; the next message is sent to i!2`1+1

[-1]  length(i!3`3) = i!2`1
[-2]  length(i!3`4) = -1 - i!2`1 + p
[-3]  (length(hu_list) = p)
[-4]  2 <= p
  |-------
{1}   length(cons(hu(i!2`1), cdr(i!3`4))) + length(i!3`3) =
       length[Identity](hu_list) - 1

Rerunning step: (expand "length" 1 1)
Expanding the definition of length,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.1.1 : 
;;; the next message is sent to i!2`1+1

[-1]  length(i!3`3) = i!2`1
[-2]  length(i!3`4) = -1 - i!2`1 + p
[-3]  (length(hu_list) = p)
[-4]  2 <= p
  |-------
{1}   1 + length[Nonce](cdr(i!3`4)) + length(i!3`3) =
       length[Identity](hu_list) - 1

Rerunning step: (rewrite "length_cdr" 1)
Found matching substitution:
cons_l: (cons?[T]) gets i!3`4,
Rewriting using length_cdr, matching in 1,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.1.1 : 
;;; the next message is sent to i!2`1+1

[-1]  length(i!3`3) = i!2`1
[-2]  length(i!3`4) = -1 - i!2`1 + p
[-3]  (length(hu_list) = p)
[-4]  2 <= p
  |-------
{1}   1 + (length(i!3`4) - 1) + length(i!3`3) =
       length[Identity](hu_list) - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.1.1.

restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.1.2 : 
;;; the next message is sent to i!2`1+1

[-1]  length(i!3`3) = i!2`1
[-2]  length(i!3`4) = -1 - i!2`1 + p
[-3]  (length(hu_list) = p)
[-4]  2 <= p
  |-------
{1}   cons?[Identity](hu_list)
[2]   length(cons(hu(i!2`1), cdr(i!3`4))) + length(i!3`3) =
       length[Identity](remove(hu_list, 1 + i!2`1))

Rerunning step: (delete -1 -2 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.1.2 : 
;;; the next message is sent to i!2`1+1

[-1]  (length(hu_list) = p)
[-2]  2 <= p
  |-------
[1]   cons?[Identity](hu_list)

Rerunning step: (nonemptylist "hu_list")
Relating existence of a tail to a list's length,

This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.1.2.


This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.1.

restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2 : 
;;; the next message is sent to i!2`1+1

[-1]  length(nl!1) > 0
[-2]  cons?(nl!1)
[-3]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-4]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, 1 + j) ENDIF
[-5]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-6]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-7]  P!1 = p
[-8]  length(i!3`2) = -1 - i!2`1 + p
[-9]  length(i!3`3) = i!2`1
[-10] length(i!3`4) = -1 - i!2`1 + p
[-11] length(nl!1) = -1 - i!2`1 + p
[-12] (length(hu_list) = p)
[-13] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-14] 0 < i!1
[-15] i!1 < p - 1
[-16] 0 < i!2`1
[-17] i!2`1 <= i!1
[-18] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-19] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-20] 2 <= p
  |-------
{1}   FORALL (i:
                below[length[Identity]
                          (append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))))]):
        nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i) =
         nth(remove(hu_list, 1 + i!2`1), i)
[2]   append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))) =
       remove(hu_list, 1 + i!2`1)
[3]   i!2`1 = p - 2
[4]   p = 2

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2 : 
;;; the next message is sent to i!2`1+1

{-1}  i!4 < length[Identity](append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))))
[-2]  length(nl!1) > 0
[-3]  cons?(nl!1)
[-4]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-5]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, 1 + j) ENDIF
[-6]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-7]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-8]  P!1 = p
[-9]  length(i!3`2) = -1 - i!2`1 + p
[-10] length(i!3`3) = i!2`1
[-11] length(i!3`4) = -1 - i!2`1 + p
[-12] length(nl!1) = -1 - i!2`1 + p
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] 0 < i!1
[-16] i!1 < p - 1
[-17] 0 < i!2`1
[-18] i!2`1 <= i!1
[-19] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-20] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-21] 2 <= p
  |-------
{1}   nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i!4) =
       nth(remove(hu_list, 1 + i!2`1), i!4)
[2]   append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))) =
       remove(hu_list, 1 + i!2`1)
[3]   i!2`1 = p - 2
[4]   p = 2

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets cons(hu(i!2`1), cdr(i!3`4)),
l1: list[T] gets i!3`3,
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2 : 
;;; the next message is sent to i!2`1+1

{-1}  i!4 < length(cons(hu(i!2`1), cdr(i!3`4))) + length(i!3`3)
[-2]  length(nl!1) > 0
[-3]  cons?(nl!1)
[-4]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-5]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, 1 + j) ENDIF
[-6]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-7]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-8]  P!1 = p
[-9]  length(i!3`2) = -1 - i!2`1 + p
[-10] length(i!3`3) = i!2`1
[-11] length(i!3`4) = -1 - i!2`1 + p
[-12] length(nl!1) = -1 - i!2`1 + p
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] 0 < i!1
[-16] i!1 < p - 1
[-17] 0 < i!2`1
[-18] i!2`1 <= i!1
[-19] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-20] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-21] 2 <= p
  |-------
[1]   nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i!4) =
       nth(remove(hu_list, 1 + i!2`1), i!4)
[2]   append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))) =
       remove(hu_list, 1 + i!2`1)
[3]   i!2`1 = p - 2
[4]   p = 2

Rerunning step: (expand "length" -1 1)
Expanding the definition of length,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2 : 
;;; the next message is sent to i!2`1+1

{-1}  i!4 < 1 + length[Nonce](cdr(i!3`4)) + length(i!3`3)
[-2]  length(nl!1) > 0
[-3]  cons?(nl!1)
[-4]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-5]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, 1 + j) ENDIF
[-6]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-7]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-8]  P!1 = p
[-9]  length(i!3`2) = -1 - i!2`1 + p
[-10] length(i!3`3) = i!2`1
[-11] length(i!3`4) = -1 - i!2`1 + p
[-12] length(nl!1) = -1 - i!2`1 + p
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] 0 < i!1
[-16] i!1 < p - 1
[-17] 0 < i!2`1
[-18] i!2`1 <= i!1
[-19] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-20] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-21] 2 <= p
  |-------
[1]   nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i!4) =
       nth(remove(hu_list, 1 + i!2`1), i!4)
[2]   append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))) =
       remove(hu_list, 1 + i!2`1)
[3]   i!2`1 = p - 2
[4]   p = 2

Rerunning step: (rewrite "length_cdr" -1)
Found matching substitution:
cons_l: (cons?[T]) gets i!3`4,
Rewriting using length_cdr, matching in -1,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2 : 
;;; the next message is sent to i!2`1+1

{-1}  i!4 < 1 + (length(i!3`4) - 1) + length(i!3`3)
[-2]  length(nl!1) > 0
[-3]  cons?(nl!1)
[-4]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-5]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, 1 + j) ENDIF
[-6]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-7]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-8]  P!1 = p
[-9]  length(i!3`2) = -1 - i!2`1 + p
[-10] length(i!3`3) = i!2`1
[-11] length(i!3`4) = -1 - i!2`1 + p
[-12] length(nl!1) = -1 - i!2`1 + p
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] 0 < i!1
[-16] i!1 < p - 1
[-17] 0 < i!2`1
[-18] i!2`1 <= i!1
[-19] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-20] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-21] 2 <= p
  |-------
[1]   nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i!4) =
       nth(remove(hu_list, 1 + i!2`1), i!4)
[2]   append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))) =
       remove(hu_list, 1 + i!2`1)
[3]   i!2`1 = p - 2
[4]   p = 2

Rerunning step: (simplify -1)
Simplifying with decision procedures,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2 : 
;;; the next message is sent to i!2`1+1

{-1}  i!4 < length(i!3`3) + length(i!3`4)
[-2]  length(nl!1) > 0
[-3]  cons?(nl!1)
[-4]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-5]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, 1 + j) ENDIF
[-6]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-7]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-8]  P!1 = p
[-9]  length(i!3`2) = -1 - i!2`1 + p
[-10] length(i!3`3) = i!2`1
[-11] length(i!3`4) = -1 - i!2`1 + p
[-12] length(nl!1) = -1 - i!2`1 + p
[-13] (length(hu_list) = p)
[-14] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-15] 0 < i!1
[-16] i!1 < p - 1
[-17] 0 < i!2`1
[-18] i!2`1 <= i!1
[-19] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-20] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-21] 2 <= p
  |-------
[1]   nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i!4) =
       nth(remove(hu_list, 1 + i!2`1), i!4)
[2]   append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))) =
       remove(hu_list, 1 + i!2`1)
[3]   i!2`1 = p - 2
[4]   p = 2

Rerunning step: (delete -2 -3 -7 -8 -9 -12 -15 -17 -18 -19 -20 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2 : 
;;; the next message is sent to i!2`1+1

[-1]  i!4 < length(i!3`3) + length(i!3`4)
[-2]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-3]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, 1 + j) ENDIF
[-4]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] 2 <= p
  |-------
[1]   nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i!4) =
       nth(remove(hu_list, 1 + i!2`1), i!4)

Rerunning step: (inst -2 "i!4")
Instantiating the top quantifier in -2 with the terms: 
 i!4,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1 : 
;;; the next message is sent to i!2`1+1

[-1]  i!4 < length(i!3`3) + length(i!3`4)
{-2}  nth(append(i!3`3, i!3`4), i!4) = nth(remove(hu_list, i!2`1), i!4)
[-3]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, 1 + j) ENDIF
[-4]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] 2 <= p
  |-------
[1]   nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i!4) =
       nth(remove(hu_list, 1 + i!2`1), i!4)

Rerunning step: (inst -3 "i!4")
Instantiating the top quantifier in -3 with the terms: 
 i!4,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.1 : 
;;; the next message is sent to i!2`1+1

[-1]  i!4 < length(i!3`3) + length(i!3`4)
[-2]  nth(append(i!3`3, i!3`4), i!4) = nth(remove(hu_list, i!2`1), i!4)
{-3}  nth(remove(hu_list, i!2`1), i!4) =
       IF i!4 < i!2`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF
[-4]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] 2 <= p
  |-------
[1]   nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i!4) =
       nth(remove(hu_list, 1 + i!2`1), i!4)

Rerunning step: (inst -4 "i!4")
Instantiating the top quantifier in -4 with the terms: 
 i!4,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.1 : 
;;; the next message is sent to i!2`1+1

[-1]  i!4 < length(i!3`3) + length(i!3`4)
[-2]  nth(append(i!3`3, i!3`4), i!4) = nth(remove(hu_list, i!2`1), i!4)
[-3]  nth(remove(hu_list, i!2`1), i!4) =
       IF i!4 < i!2`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF
{-4}  nth(append(i!3`3, i!3`4), i!4) =
       IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
       ELSE nth(i!3`4, i!4 - length[Identity](i!3`3))
       ENDIF
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] 2 <= p
  |-------
[1]   nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i!4) =
       nth(remove(hu_list, 1 + i!2`1), i!4)

Rerunning step: (replace* -5 -6)
Repeatedly applying the replace rule,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.1 : 
;;; the next message is sent to i!2`1+1

{-1}  i!4 < i!2`1 + (-1 - i!2`1 + p)
[-2]  nth(append(i!3`3, i!3`4), i!4) = nth(remove(hu_list, i!2`1), i!4)
[-3]  nth(remove(hu_list, i!2`1), i!4) =
       IF i!4 < i!2`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF
{-4}  nth(append(i!3`3, i!3`4), i!4) =
       IF i!4 < i!2`1 THEN nth(i!3`3, i!4)
       ELSE nth(i!3`4, i!4 - i!2`1)
       ENDIF
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] 2 <= p
  |-------
[1]   nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i!4) =
       nth(remove(hu_list, 1 + i!2`1), i!4)

Rerunning step: (lemma "listprops[Identity].nth_append"
                 ("l1" "i!3`3" "l2" "cons(hu(i!2`1),cdr(i!3`4))" "i"
                  "i!4"))
Applying listprops[Identity].nth_append where 
  l1 gets i!3`3,
  l2 gets cons(hu(i!2`1), cdr(i!3`4)),
  i gets i!4,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.1.1 : 
;;; the next message is sent to i!2`1+1

{-1}  nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i!4) =
       IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
       ELSE nth(cons(hu(i!2`1), cdr(i!3`4)), i!4 - length[Identity](i!3`3))
       ENDIF
[-2]  i!4 < i!2`1 + (-1 - i!2`1 + p)
[-3]  nth(append(i!3`3, i!3`4), i!4) = nth(remove(hu_list, i!2`1), i!4)
[-4]  nth(remove(hu_list, i!2`1), i!4) =
       IF i!4 < i!2`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF
[-5]  nth(append(i!3`3, i!3`4), i!4) =
       IF i!4 < i!2`1 THEN nth(i!3`3, i!4)
       ELSE nth(i!3`4, i!4 - i!2`1)
       ENDIF
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = -1 - i!2`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1 < p - 1
[-11] 2 <= p
  |-------
[1]   nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i!4) =
       nth(remove(hu_list, 1 + i!2`1), i!4)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.1.1 : 
;;; the next message is sent to i!2`1+1

[-1]  nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i!4) =
       IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
       ELSE nth(cons(hu(i!2`1), cdr(i!3`4)), i!4 - length[Identity](i!3`3))
       ENDIF
[-2]  i!4 < i!2`1 + (-1 - i!2`1 + p)
[-3]  nth(append(i!3`3, i!3`4), i!4) = nth(remove(hu_list, i!2`1), i!4)
[-4]  nth(remove(hu_list, i!2`1), i!4) =
       IF i!4 < i!2`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF
[-5]  nth(append(i!3`3, i!3`4), i!4) =
       IF i!4 < i!2`1 THEN nth(i!3`3, i!4)
       ELSE nth(i!3`4, i!4 - i!2`1)
       ENDIF
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = -1 - i!2`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1 < p - 1
[-11] 2 <= p
  |-------
{1}   IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
      ELSE nth(cons(hu(i!2`1), cdr(i!3`4)), i!4 - length[Identity](i!3`3))
      ENDIF
       = nth(remove(hu_list, 1 + i!2`1), i!4)

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.1.1 : 
;;; the next message is sent to i!2`1+1

[-1]  i!4 < i!2`1 + (-1 - i!2`1 + p)
[-2]  nth(append(i!3`3, i!3`4), i!4) = nth(remove(hu_list, i!2`1), i!4)
[-3]  nth(remove(hu_list, i!2`1), i!4) =
       IF i!4 < i!2`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF
[-4]  nth(append(i!3`3, i!3`4), i!4) =
       IF i!4 < i!2`1 THEN nth(i!3`3, i!4)
       ELSE nth(i!3`4, i!4 - i!2`1)
       ENDIF
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
      ELSE nth(cons(hu(i!2`1), cdr(i!3`4)), i!4 - length[Identity](i!3`3))
      ENDIF
       = nth(remove(hu_list, 1 + i!2`1), i!4)

Rerunning step: (lemma "listprops[Identity].nth_remove"
                 ("l" "hu_list" "i" "1+i!2`1" "j" "i!4"))
Applying listprops[Identity].nth_remove where 
  l gets hu_list,
  i gets 1 + i!2`1,
  j gets i!4,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.1.1.1 : 
;;; the next message is sent to i!2`1+1

{-1}  nth(remove(hu_list, 1 + i!2`1), i!4) =
       IF i!4 < 1 + i!2`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF
[-2]  i!4 < i!2`1 + (-1 - i!2`1 + p)
[-3]  nth(append(i!3`3, i!3`4), i!4) = nth(remove(hu_list, i!2`1), i!4)
[-4]  nth(remove(hu_list, i!2`1), i!4) =
       IF i!4 < i!2`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF
[-5]  nth(append(i!3`3, i!3`4), i!4) =
       IF i!4 < i!2`1 THEN nth(i!3`3, i!4)
       ELSE nth(i!3`4, i!4 - i!2`1)
       ENDIF
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = -1 - i!2`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1 < p - 1
[-11] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
      ELSE nth(cons(hu(i!2`1), cdr(i!3`4)), i!4 - length[Identity](i!3`3))
      ENDIF
       = nth(remove(hu_list, 1 + i!2`1), i!4)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.1.1.1 : 
;;; the next message is sent to i!2`1+1

[-1]  nth(remove(hu_list, 1 + i!2`1), i!4) =
       IF i!4 < 1 + i!2`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF
[-2]  i!4 < i!2`1 + (-1 - i!2`1 + p)
[-3]  nth(append(i!3`3, i!3`4), i!4) = nth(remove(hu_list, i!2`1), i!4)
[-4]  nth(remove(hu_list, i!2`1), i!4) =
       IF i!4 < i!2`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF
[-5]  nth(append(i!3`3, i!3`4), i!4) =
       IF i!4 < i!2`1 THEN nth(i!3`3, i!4)
       ELSE nth(i!3`4, i!4 - i!2`1)
       ENDIF
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = -1 - i!2`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1 < p - 1
[-11] 2 <= p
  |-------
{1}   IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
      ELSE nth(cons(hu(i!2`1), cdr(i!3`4)), i!4 - length[Identity](i!3`3))
      ENDIF
       =
       IF i!4 < 1 + i!2`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.1.1.1 : 
;;; the next message is sent to i!2`1+1

[-1]  i!4 < i!2`1 + (-1 - i!2`1 + p)
[-2]  nth(append(i!3`3, i!3`4), i!4) = nth(remove(hu_list, i!2`1), i!4)
[-3]  nth(remove(hu_list, i!2`1), i!4) =
       IF i!4 < i!2`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF
[-4]  nth(append(i!3`3, i!3`4), i!4) =
       IF i!4 < i!2`1 THEN nth(i!3`3, i!4)
       ELSE nth(i!3`4, i!4 - i!2`1)
       ENDIF
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
      ELSE nth(cons(hu(i!2`1), cdr(i!3`4)), i!4 - length[Identity](i!3`3))
      ENDIF
       =
       IF i!4 < 1 + i!2`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (case "i!4<i!2`1 OR i!4=i!2`1 OR i!4>i!2`1")
Case splitting on 
   i!4 < i!2`1 OR i!4 = i!2`1 OR i!4 > i!2`1, 
this yields  2 subgoals: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.1.1.1.1 : 
;;; the next message is sent to i!2`1+1

{-1}  i!4 < i!2`1 OR i!4 = i!2`1 OR i!4 > i!2`1
[-2]  i!4 < i!2`1 + (-1 - i!2`1 + p)
[-3]  nth(append(i!3`3, i!3`4), i!4) = nth(remove(hu_list, i!2`1), i!4)
[-4]  nth(remove(hu_list, i!2`1), i!4) =
       IF i!4 < i!2`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF
[-5]  nth(append(i!3`3, i!3`4), i!4) =
       IF i!4 < i!2`1 THEN nth(i!3`3, i!4)
       ELSE nth(i!3`4, i!4 - i!2`1)
       ENDIF
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = -1 - i!2`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1 < p - 1
[-11] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
      ELSE nth(cons(hu(i!2`1), cdr(i!3`4)), i!4 - length[Identity](i!3`3))
      ENDIF
       =
       IF i!4 < 1 + i!2`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (expand "nth" 1 2)
Expanding the definition of nth,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.1.1.1.1 : 
;;; the next message is sent to i!2`1+1

[-1]  i!4 < i!2`1 OR i!4 = i!2`1 OR i!4 > i!2`1
[-2]  i!4 < i!2`1 + (-1 - i!2`1 + p)
[-3]  nth(append(i!3`3, i!3`4), i!4) = nth(remove(hu_list, i!2`1), i!4)
[-4]  nth(remove(hu_list, i!2`1), i!4) =
       IF i!4 < i!2`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF
[-5]  nth(append(i!3`3, i!3`4), i!4) =
       IF i!4 < i!2`1 THEN nth(i!3`3, i!4)
       ELSE nth(i!3`4, i!4 - i!2`1)
       ENDIF
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = -1 - i!2`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!1 < p - 1
[-11] 2 <= p
  |-------
{1}   IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
      ELSE IF i!4 - length[Identity](i!3`3) = 0 THEN hu(i!2`1)
           ELSE nth(cdr(i!3`4), -1 - length[Identity](i!3`3) + i!4)
           ENDIF
      ENDIF
       =
       IF i!4 < 1 + i!2`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF

Rerunning step: (grind :exclude ("nth" "append" "remove"))
Trying repeated skolemization, instantiation, and if-lifting,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.1.1.1.1 : 
;;; the next message is sent to i!2`1+1

{-1}  i!4 > i!2`1
{-2}  i!4 < p - 1
{-3}  nth(append(i!3`3, i!3`4), i!4) = hu(1 + i!4)
{-4}  nth(remove(hu_list, i!2`1), i!4) = hu(1 + i!4)
{-5}  nth(hu_list, 1 + i!4) = hu(1 + i!4)
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = -1 - i!2`1 + p
[-8]  (length(hu_list) = p)
{-9}  nth(i!3`4, i!4 - i!2`1) = hu(1 + i!4)
[-10] i!1 < p - 1
[-11] 2 <= p
  |-------
{1}   nth(cdr(i!3`4), -1 - i!2`1 + i!4) = hu(1 + i!4)

Rerunning step: (rewrite "nth_cdr" 1)
Found matching substitution:
i: below[length(c) - 1] gets -1 - i!2`1 + i!4,
c: (cons?[T]) gets i!3`4,
Rewriting using nth_cdr, matching in 1,

This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.1.1.1.1.

restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.1.1.1.2 : 
;;; the next message is sent to i!2`1+1

[-1]  i!4 < i!2`1 + (-1 - i!2`1 + p)
[-2]  nth(append(i!3`3, i!3`4), i!4) = nth(remove(hu_list, i!2`1), i!4)
[-3]  nth(remove(hu_list, i!2`1), i!4) =
       IF i!4 < i!2`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF
[-4]  nth(append(i!3`3, i!3`4), i!4) =
       IF i!4 < i!2`1 THEN nth(i!3`3, i!4)
       ELSE nth(i!3`4, i!4 - i!2`1)
       ENDIF
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] 2 <= p
  |-------
{1}   i!4 < i!2`1 OR i!4 = i!2`1 OR i!4 > i!2`1
[2]   IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
      ELSE nth(cons(hu(i!2`1), cdr(i!3`4)), i!4 - length[Identity](i!3`3))
      ENDIF
       =
       IF i!4 < 1 + i!2`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, i!4 + 1)
       ENDIF

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.1.1.1.2 : 
;;; the next message is sent to i!2`1+1

  |-------
[1]   i!4 < i!2`1 OR i!4 = i!2`1 OR i!4 > i!2`1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.1.1.1.2.


This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.1.1.1.

restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.1.1.2T (TCC):   

[-1]  i!4 < i!2`1 + (-1 - i!2`1 + p)
[-2]  nth(append(i!3`3, i!3`4), i!4) = nth(remove(hu_list, i!2`1), i!4)
[-3]  nth(remove(hu_list, i!2`1), i!4) =
       IF i!4 < i!2`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF
[-4]  nth(append(i!3`3, i!3`4), i!4) =
       IF i!4 < i!2`1 THEN nth(i!3`3, i!4)
       ELSE nth(i!3`4, i!4 - i!2`1)
       ENDIF
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] 2 <= p
  |-------
{1}   i!4 < length[Identity](hu_list) - 1
[2]   IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
      ELSE nth(cons(hu(i!2`1), cdr(i!3`4)), i!4 - length[Identity](i!3`3))
      ENDIF
       = nth(remove(hu_list, 1 + i!2`1), i!4)

Rerunning step: (delete -2 -3 -4 -5 -6 -8 -9 -10 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.1.1.2T : 
;;; the next message is sent to i!2`1+1

[-1]  i!4 < i!2`1 + (-1 - i!2`1 + p)
[-2]  (length(hu_list) = p)
  |-------
[1]   i!4 < length[Identity](hu_list) - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.1.1.2T.


This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.1.1.

restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.1.2T (TCC):   

[-1]  i!4 < i!2`1 + (-1 - i!2`1 + p)
[-2]  nth(append(i!3`3, i!3`4), i!4) = nth(remove(hu_list, i!2`1), i!4)
[-3]  nth(remove(hu_list, i!2`1), i!4) =
       IF i!4 < i!2`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF
[-4]  nth(append(i!3`3, i!3`4), i!4) =
       IF i!4 < i!2`1 THEN nth(i!3`3, i!4)
       ELSE nth(i!3`4, i!4 - i!2`1)
       ENDIF
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] 2 <= p
  |-------
{1}   i!4 <
       length[Identity](cons[Identity](hu(i!2`1), cdr[Identity](i!3`4))) +
        length[Identity](i!3`3)
[2]   nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i!4) =
       nth(remove(hu_list, 1 + i!2`1), i!4)

Rerunning step: (expand "length" 1 1)
Expanding the definition of length,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.1.2T : 
;;; the next message is sent to i!2`1+1

[-1]  i!4 < i!2`1 + (-1 - i!2`1 + p)
[-2]  nth(append(i!3`3, i!3`4), i!4) = nth(remove(hu_list, i!2`1), i!4)
[-3]  nth(remove(hu_list, i!2`1), i!4) =
       IF i!4 < i!2`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF
[-4]  nth(append(i!3`3, i!3`4), i!4) =
       IF i!4 < i!2`1 THEN nth(i!3`3, i!4)
       ELSE nth(i!3`4, i!4 - i!2`1)
       ENDIF
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] 2 <= p
  |-------
{1}   i!4 <
       1 + length[Identity](cdr[Identity](i!3`4)) + length[Identity](i!3`3)
[2]   nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i!4) =
       nth(remove(hu_list, 1 + i!2`1), i!4)

Rerunning step: (rewrite "length_cdr" 1)
Found matching substitution:
cons_l: (cons?[T]) gets i!3`4,
Rewriting using length_cdr, matching in 1,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.1.2T : 
;;; the next message is sent to i!2`1+1

[-1]  i!4 < i!2`1 + (-1 - i!2`1 + p)
[-2]  nth(append(i!3`3, i!3`4), i!4) = nth(remove(hu_list, i!2`1), i!4)
[-3]  nth(remove(hu_list, i!2`1), i!4) =
       IF i!4 < i!2`1 THEN nth(hu_list, i!4)
       ELSE nth(hu_list, 1 + i!4)
       ENDIF
[-4]  nth(append(i!3`3, i!3`4), i!4) =
       IF i!4 < i!2`1 THEN nth(i!3`3, i!4)
       ELSE nth(i!3`4, i!4 - i!2`1)
       ENDIF
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  i!1 < p - 1
[-10] 2 <= p
  |-------
{1}   i!4 < 1 + (length(i!3`4) - 1) + length[Identity](i!3`3)
[2]   nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i!4) =
       nth(remove(hu_list, 1 + i!2`1), i!4)

Rerunning step: (delete -2 -3 -4 -7 -8 -9 -10 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.1.2T : 
;;; the next message is sent to i!2`1+1

[-1]  i!4 < i!2`1 + (-1 - i!2`1 + p)
[-2]  length(i!3`3) = i!2`1
[-3]  length(i!3`4) = -1 - i!2`1 + p
  |-------
[1]   i!4 < 1 + (length(i!3`4) - 1) + length[Identity](i!3`3)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.1.2T.


This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.1.

restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.2 (TCC):   

[-1]  i!4 < length(i!3`3) + length(i!3`4)
[-2]  nth(append(i!3`3, i!3`4), i!4) = nth(remove(hu_list, i!2`1), i!4)
[-3]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = -1 - i!2`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!1 < p - 1
[-9]  2 <= p
  |-------
{1}   i!4 < length[Identity](hu_list) - 1
[2]   nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i!4) =
       nth(remove(hu_list, 1 + i!2`1), i!4)

Rerunning step: (delete -2 -3 -7 -8 -9 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.2 : 
;;; the next message is sent to i!2`1+1

[-1]  i!4 < length(i!3`3) + length(i!3`4)
[-2]  length(i!3`3) = i!2`1
[-3]  length(i!3`4) = -1 - i!2`1 + p
[-4]  (length(hu_list) = p)
  |-------
[1]   i!4 < length[Identity](hu_list) - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.2.


This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.1.

restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.2 (TCC):   

[-1]  i!4 < length(i!3`3) + length(i!3`4)
[-2]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, 1 + j) ENDIF
[-3]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = -1 - i!2`1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  i!1 < p - 1
[-9]  2 <= p
  |-------
{1}   i!4 < length[Identity](append[Identity](i!3`3, i!3`4))
[2]   nth(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4))), i!4) =
       nth(remove(hu_list, 1 + i!2`1), i!4)

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets i!3`4,
l1: list[T] gets i!3`3,
Rewriting using length_append, matching in 1,

This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.2.


This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.2.


This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.1.

restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.2 : 
;;; the next message is sent to i!2`1+1

[-1]  length(nl!1) > 0
[-2]  cons?(nl!1)
[-3]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-4]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, 1 + j) ENDIF
[-5]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-6]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-7]  P!1 = p
[-8]  length(i!3`2) = -1 - i!2`1 + p
[-9]  length(i!3`3) = i!2`1
[-10] length(i!3`4) = -1 - i!2`1 + p
[-11] length(nl!1) = -1 - i!2`1 + p
[-12] (length(hu_list) = p)
[-13] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-14] 0 < i!1
[-15] i!1 < p - 1
[-16] 0 < i!2`1
[-17] i!2`1 <= i!1
[-18] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-19] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-20] 2 <= p
  |-------
{1}   nlist(i!3`2) = nlist(append(cdr(nl!1), (: n_last :)))
[2]   i!2`1 = p - 2
[3]   p = 2

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.2 : 
;;; the next message is sent to i!2`1+1

[-1]  length(nl!1) > 0
[-2]  cons?(nl!1)
[-3]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-4]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, 1 + j) ENDIF
[-5]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-6]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-7]  P!1 = p
[-8]  length(i!3`2) = -1 - i!2`1 + p
[-9]  length(i!3`3) = i!2`1
[-10] length(i!3`4) = -1 - i!2`1 + p
[-11] length(nl!1) = -1 - i!2`1 + p
[-12] (length(hu_list) = p)
[-13] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-14] 0 < i!1
[-15] i!1 < p - 1
[-16] 0 < i!2`1
[-17] i!2`1 <= i!1
[-18] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-19] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-20] 2 <= p
  |-------
{1}   i!3`2 = append(cdr(nl!1), (: n_last :))
[2]   i!2`1 = p - 2
[3]   p = 2

Rerunning step: (delete -1 -3
                  -4 -5
                  -6 -7
                  -8 -9
                  -10 -11
                  -12 -13
                  -14 -15
                  -16 -17
                  -19 -20
                  2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.2 : 
;;; the next message is sent to i!2`1+1

[-1]  cons?(nl!1)
[-2]  cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
  |-------
[1]   i!3`2 = append(cdr(nl!1), (: n_last :))

Rerunning step: (expand "append" -2)
Expanding the definition of append,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.2 : 
;;; the next message is sent to i!2`1+1

[-1]  cons?(nl!1)
{-2}  cons(i!2`2, i!3`2) = cons(car(nl!1), append(cdr(nl!1), (: n_last :)))
  |-------
[1]   i!3`2 = append(cdr(nl!1), (: n_last :))

Rerunning step: (decompose-equality -2)
Applying decompose-equality,

This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.2.


This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.1.

restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.2 (TCC):   

[-1]  length(nl!1) > 0
[-2]  cons?(nl!1)
[-3]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-4]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, 1 + j) ENDIF
[-5]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-6]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-7]  P!1 = p
[-8]  length(i!3`2) = -1 - i!2`1 + p
[-9]  length(i!3`3) = i!2`1
[-10] length(i!3`4) = -1 - i!2`1 + p
[-11] length(nl!1) = -1 - i!2`1 + p
[-12] (length(hu_list) = p)
[-13] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-14] 0 < i!1
[-15] i!1 < p - 1
[-16] 0 < i!2`1
[-17] i!2`1 <= i!1
[-18] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-19] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-20] 2 <= p
  |-------
{1}   length[Nonce](cdr[Nonce](nl!1)) = -2 - i!2`1 + p
[2]   i!2`1 = p - 2
[3]   p = 2

Rerunning step: (rewrite "length_cdr" 1)
Found matching substitution:
cons_l: (cons?[T]) gets nl!1,
Rewriting using length_cdr, matching in 1,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.2 : 
;;; the next message is sent to i!2`1+1

[-1]  length(nl!1) > 0
[-2]  cons?(nl!1)
[-3]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-4]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, 1 + j) ENDIF
[-5]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-6]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-7]  P!1 = p
[-8]  length(i!3`2) = -1 - i!2`1 + p
[-9]  length(i!3`3) = i!2`1
[-10] length(i!3`4) = -1 - i!2`1 + p
[-11] length(nl!1) = -1 - i!2`1 + p
[-12] (length(hu_list) = p)
[-13] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-14] 0 < i!1
[-15] i!1 < p - 1
[-16] 0 < i!2`1
[-17] i!2`1 <= i!1
[-18] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-19] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-20] 2 <= p
  |-------
{1}   length(nl!1) - 1 = -2 - i!2`1 + p
[2]   i!2`1 = p - 2
[3]   p = 2

Rerunning step: (delete -1 -2
                  -3 -4
                  -5 -6
                  -7 -8
                  -9 -10
                  -12 -13
                  -14 -15
                  -16 -17
                  -18 -19
                  -20 2
                  3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.2 : 
;;; the next message is sent to i!2`1+1

[-1]  length(nl!1) = -1 - i!2`1 + p
  |-------
[1]   length(nl!1) - 1 = -2 - i!2`1 + p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.2.


This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.1.2.1.2.


This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.1.2.1.

restrictmiddle_middle.1.2.2.2.3.1.1.2.2 : 
;;; first case has been gotten rid of, now prove that the outgoing message conforms to rho

[-1]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-2]  P!1 = p
{-3}  length(i!3`2) = -1 - i!2`1 + p
[-4]  length(i!3`3) = i!2`1
{-5}  length(i!3`4) = -1 - i!2`1 + p
[-6]  length(nl!1) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] 0 < i!2`1
[-12] i!2`1 <= i!1
[-13] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-14] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-15] 2 <= p
  |-------
{1}   (Stop[event] # R_middle(i!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (trans(hu(i!2`1), car(i!3`4),
                     E(public(car(i!3`4)),
                       conc(ilist(append(i!3`3,
                                         cons(hu(i!2`1), cdr(i!3`4)))),
                            nlist(i!3`2)))))
{3}   trans(hu(i!2`1), car(i!3`4),
            E(public(car(i!3`4)),
              conc(ilist(append(i!3`3, cons(hu(i!2`1), cdr(i!3`4)))),
                   nlist(i!3`2))))
       >> (Stop[event] # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   i!2`1 = p - 2
[5]   i!1 = i!2`1
[6]   p = 2

Rerunning step: (delete - 2 3 4 5 6)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.1.2.2 : 
;;; first case has been gotten rid of, now prove that the outgoing message conforms to rho

  |-------
[1]   (Stop[event] # R_middle(i!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.1.2.2.


This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.1.2.


This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.1.

restrictmiddle_middle.1.2.2.2.3.1.2 : 
;;; establish some helpful equalities first

[-1]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-2]  P!1 = p
[-3]  length(i!3`2) = p - 1 - i!2`1
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = p - 1 - i!2`1
[-6]  length(nl!1) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] 0 < i!2`1
[-12] i!2`1 <= i!1
[-13] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-14] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-15] 2 <= p
  |-------
{1}   append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list
[2]   (((LastMessage(p, i!2`1, hu(i!2`1), i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   p = 2

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.2 : 
;;; establish some helpful equalities first

[-1]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-2]  P!1 = p
[-3]  length(i!3`2) = p - 1 - i!2`1
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = p - 1 - i!2`1
[-6]  length(nl!1) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] 0 < i!2`1
[-12] i!2`1 <= i!1
[-13] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-14] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-15] 2 <= p
  |-------
[1]   append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list
[2]   p = 2

Rerunning step: (rewrite "length_nth_equality[Identity]" 1)
Found matching substitution:
l2: list[Identity] gets hu_list,
l1: list[Identity] gets append(i!3`3, cons(hu(i!2`1), i!3`4)),
Rewriting using length_nth_equality[Identity], matching in 1,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.2 : 
;;; establish some helpful equalities first

[-1]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-2]  P!1 = p
{-3}  length(i!3`2) = -1 - i!2`1 + p
[-4]  length(i!3`3) = i!2`1
{-5}  length(i!3`4) = -1 - i!2`1 + p
[-6]  length(nl!1) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] 0 < i!2`1
[-12] i!2`1 <= i!1
[-13] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-14] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-15] 2 <= p
  |-------
{1}   FORALL (i:
                below[length[Identity]
                          (append(i!3`3, cons(hu(i!2`1), i!3`4)))]):
        nth(append(i!3`3, cons(hu(i!2`1), i!3`4)), i) = nth(hu_list, i)
[2]   append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list
[3]   p = 2

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.2 : 
;;; establish some helpful equalities first

{-1}  i!4 < length[Identity](append(i!3`3, cons(hu(i!2`1), i!3`4)))
[-2]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-3]  P!1 = p
[-4]  length(i!3`2) = -1 - i!2`1 + p
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  length(nl!1) = -1 - i!2`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] 0 < i!1
[-11] i!1 < p - 1
[-12] 0 < i!2`1
[-13] i!2`1 <= i!1
[-14] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-15] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-16] 2 <= p
  |-------
{1}   nth(append(i!3`3, cons(hu(i!2`1), i!3`4)), i!4) = nth(hu_list, i!4)
[2]   append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list
[3]   p = 2

Rerunning step: (lemma "listprops[Identity].nth_append"
                 ("l1" "i!3`3" "l2" "cons(hu(i!2`1),i!3`4)" "i" "i!4"))
Applying listprops[Identity].nth_append where 
  l1 gets i!3`3,
  l2 gets cons(hu(i!2`1), i!3`4),
  i gets i!4,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.2.2.3.1.2.1 : 
;;; establish some helpful equalities first

{-1}  nth(append(i!3`3, cons(hu(i!2`1), i!3`4)), i!4) =
       IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
       ELSE nth(cons(hu(i!2`1), i!3`4), i!4 - length[Identity](i!3`3))
       ENDIF
[-2]  i!4 < length[Identity](append(i!3`3, cons(hu(i!2`1), i!3`4)))
[-3]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-4]  P!1 = p
[-5]  length(i!3`2) = -1 - i!2`1 + p
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = -1 - i!2`1 + p
[-8]  length(nl!1) = -1 - i!2`1 + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] 0 < i!1
[-12] i!1 < p - 1
[-13] 0 < i!2`1
[-14] i!2`1 <= i!1
[-15] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-16] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-17] 2 <= p
  |-------
[1]   nth(append(i!3`3, cons(hu(i!2`1), i!3`4)), i!4) = nth(hu_list, i!4)
[2]   append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list
[3]   p = 2

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.2.1 : 
;;; establish some helpful equalities first

[-1]  nth(append(i!3`3, cons(hu(i!2`1), i!3`4)), i!4) =
       IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
       ELSE nth(cons(hu(i!2`1), i!3`4), i!4 - length[Identity](i!3`3))
       ENDIF
[-2]  i!4 < length[Identity](append(i!3`3, cons(hu(i!2`1), i!3`4)))
[-3]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-4]  P!1 = p
[-5]  length(i!3`2) = -1 - i!2`1 + p
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = -1 - i!2`1 + p
[-8]  length(nl!1) = -1 - i!2`1 + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] 0 < i!1
[-12] i!1 < p - 1
[-13] 0 < i!2`1
[-14] i!2`1 <= i!1
[-15] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-16] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-17] 2 <= p
  |-------
{1}   IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
      ELSE nth(cons(hu(i!2`1), i!3`4), i!4 - length[Identity](i!3`3))
      ENDIF
       = nth(hu_list, i!4)
[2]   append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list
[3]   p = 2

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.2.1 : 
;;; establish some helpful equalities first

[-1]  i!4 < length[Identity](append(i!3`3, cons(hu(i!2`1), i!3`4)))
[-2]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-3]  P!1 = p
[-4]  length(i!3`2) = -1 - i!2`1 + p
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  length(nl!1) = -1 - i!2`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] 0 < i!1
[-11] i!1 < p - 1
[-12] 0 < i!2`1
[-13] i!2`1 <= i!1
[-14] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-15] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-16] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
      ELSE nth(cons(hu(i!2`1), i!3`4), i!4 - length[Identity](i!3`3))
      ENDIF
       = nth(hu_list, i!4)
[2]   append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list
[3]   p = 2

Rerunning step: (lemma "listprops[Identity].equality_nth"
                 ("l1" "append(i!3`3,i!3`4)" "l2"
                  "remove(hu_list,i!2`1)"))
Applying listprops[Identity].equality_nth where 
  l1 gets append(i!3`3, i!3`4),
  l2 gets remove(hu_list, i!2`1),
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.2.1 : 
;;; establish some helpful equalities first

{-1}  append(i!3`3, i!3`4) = remove(hu_list, i!2`1) IMPLIES
       FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
         nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-2]  i!4 < length[Identity](append(i!3`3, cons(hu(i!2`1), i!3`4)))
[-3]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-4]  P!1 = p
[-5]  length(i!3`2) = -1 - i!2`1 + p
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = -1 - i!2`1 + p
[-8]  length(nl!1) = -1 - i!2`1 + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] 0 < i!1
[-12] i!1 < p - 1
[-13] 0 < i!2`1
[-14] i!2`1 <= i!1
[-15] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-16] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-17] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
      ELSE nth(cons(hu(i!2`1), i!3`4), i!4 - length[Identity](i!3`3))
      ENDIF
       = nth(hu_list, i!4)
[2]   append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list
[3]   p = 2

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.2.1 : 
;;; establish some helpful equalities first

{-1}  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-2]  i!4 < length[Identity](append(i!3`3, cons(hu(i!2`1), i!3`4)))
[-3]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-4]  P!1 = p
[-5]  length(i!3`2) = -1 - i!2`1 + p
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = -1 - i!2`1 + p
[-8]  length(nl!1) = -1 - i!2`1 + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] 0 < i!1
[-12] i!1 < p - 1
[-13] 0 < i!2`1
[-14] i!2`1 <= i!1
[-15] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-16] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-17] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
      ELSE nth(cons(hu(i!2`1), i!3`4), i!4 - length[Identity](i!3`3))
      ENDIF
       = nth(hu_list, i!4)
[2]   append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list
[3]   p = 2

Rerunning step: (lemma "listprops[Identity].nth_append"
                 ("l1" "i!3`3" "l2" "i!3`4"))
Applying listprops[Identity].nth_append where 
  l1 gets i!3`3,
  l2 gets i!3`4,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.2.1 : 
;;; establish some helpful equalities first

{-1}  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-2]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-3]  i!4 < length[Identity](append(i!3`3, cons(hu(i!2`1), i!3`4)))
[-4]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-5]  P!1 = p
[-6]  length(i!3`2) = -1 - i!2`1 + p
[-7]  length(i!3`3) = i!2`1
[-8]  length(i!3`4) = -1 - i!2`1 + p
[-9]  length(nl!1) = -1 - i!2`1 + p
[-10] (length(hu_list) = p)
[-11] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-12] 0 < i!1
[-13] i!1 < p - 1
[-14] 0 < i!2`1
[-15] i!2`1 <= i!1
[-16] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-17] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-18] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
      ELSE nth(cons(hu(i!2`1), i!3`4), i!4 - length[Identity](i!3`3))
      ENDIF
       = nth(hu_list, i!4)
[2]   append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list
[3]   p = 2

Rerunning step: (lemma "listprops[Identity].nth_remove"
                 ("l" "hu_list" "i" "i!2`1"))
Applying listprops[Identity].nth_remove where 
  l gets hu_list,
  i gets i!2`1,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.2.1 : 
;;; establish some helpful equalities first

{-1}  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-2]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-3]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-4]  i!4 < length[Identity](append(i!3`3, cons(hu(i!2`1), i!3`4)))
[-5]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-6]  P!1 = p
[-7]  length(i!3`2) = -1 - i!2`1 + p
[-8]  length(i!3`3) = i!2`1
[-9]  length(i!3`4) = -1 - i!2`1 + p
[-10] length(nl!1) = -1 - i!2`1 + p
[-11] (length(hu_list) = p)
[-12] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-13] 0 < i!1
[-14] i!1 < p - 1
[-15] 0 < i!2`1
[-16] i!2`1 <= i!1
[-17] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-18] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-19] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
      ELSE nth(cons(hu(i!2`1), i!3`4), i!4 - length[Identity](i!3`3))
      ENDIF
       = nth(hu_list, i!4)
[2]   append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list
[3]   p = 2

Rerunning step: (delete -7 -10 -13 -15 -17 -18 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.2.1 : 
;;; establish some helpful equalities first

[-1]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-2]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-3]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-4]  i!4 < length[Identity](append(i!3`3, cons(hu(i!2`1), i!3`4)))
[-5]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-6]  P!1 = p
[-7]  length(i!3`3) = i!2`1
[-8]  length(i!3`4) = -1 - i!2`1 + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] i!1 < p - 1
[-12] i!2`1 <= i!1
[-13] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
      ELSE nth(cons(hu(i!2`1), i!3`4), i!4 - length[Identity](i!3`3))
      ENDIF
       = nth(hu_list, i!4)
[2]   p = 2

Rerunning step: (expand "nth" 1 2)
Expanding the definition of nth,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.2.1 : 
;;; establish some helpful equalities first

[-1]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-2]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-3]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-4]  i!4 < length[Identity](append(i!3`3, cons(hu(i!2`1), i!3`4)))
[-5]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-6]  P!1 = p
[-7]  length(i!3`3) = i!2`1
[-8]  length(i!3`4) = -1 - i!2`1 + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] i!1 < p - 1
[-12] i!2`1 <= i!1
[-13] 2 <= p
  |-------
{1}   IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
      ELSE IF i!4 - length[Identity](i!3`3) = 0 THEN hu(i!2`1)
           ELSE nth(i!3`4, -1 - length[Identity](i!3`3) + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)
[2]   p = 2

Rerunning step: (inst -10 "i!2`1")
Instantiating the top quantifier in -10 with the terms: 
 i!2`1,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.2.1 : 
;;; establish some helpful equalities first

[-1]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-2]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-3]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-4]  i!4 < length[Identity](append(i!3`3, cons(hu(i!2`1), i!3`4)))
[-5]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-6]  P!1 = p
[-7]  length(i!3`3) = i!2`1
[-8]  length(i!3`4) = -1 - i!2`1 + p
[-9]  (length(hu_list) = p)
{-10} nth(hu_list, i!2`1) = hu(i!2`1)
[-11] i!1 < p - 1
[-12] i!2`1 <= i!1
[-13] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
      ELSE IF i!4 - length[Identity](i!3`3) = 0 THEN hu(i!2`1)
           ELSE nth(i!3`4, -1 - length[Identity](i!3`3) + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)
[2]   p = 2

Rerunning step: (case "i!4<i!2`1 OR i!4=i!2`1 OR (i!2`1<i!4 AND i!4<p-1) OR i!4=p-1")
Case splitting on 
   i!4 < i!2`1 OR
    i!4 = i!2`1 OR (i!2`1 < i!4 AND i!4 < p - 1) OR i!4 = p - 1, 
this yields  2 subgoals: 
restrictmiddle_middle.1.2.2.2.3.1.2.1.1 : 
;;; establish some helpful equalities first

{-1}  i!4 < i!2`1 OR
       i!4 = i!2`1 OR (i!2`1 < i!4 AND i!4 < p - 1) OR i!4 = p - 1
[-2]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-3]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-4]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-5]  i!4 < length[Identity](append(i!3`3, cons(hu(i!2`1), i!3`4)))
[-6]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-7]  P!1 = p
[-8]  length(i!3`3) = i!2`1
[-9]  length(i!3`4) = -1 - i!2`1 + p
[-10] (length(hu_list) = p)
[-11] nth(hu_list, i!2`1) = hu(i!2`1)
[-12] i!1 < p - 1
[-13] i!2`1 <= i!1
[-14] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
      ELSE IF i!4 - length[Identity](i!3`3) = 0 THEN hu(i!2`1)
           ELSE nth(i!3`4, -1 - length[Identity](i!3`3) + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)
[2]   p = 2

Rerunning step: (grind :exclude ("nth" "append" "remove"))

Trying repeated skolemization, instantiation, and if-lifting,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.2.1.1 : 
;;; establish some helpful equalities first

{-1}  i!2`1 < i!4
{-2}  i!4 < p - 1
{-3}  nth(remove(hu_list, i!2`1), i!4) = nth(hu_list, 1 + i!4)
{-4}  nth(append(i!3`3, i!3`4), i!4 - 1) =
       nth(remove(hu_list, i!2`1), i!4 - 1)
{-5}  nth(i!3`4, -1 - i!2`1 + i!4) = nth(remove(hu_list, i!2`1), i!4 - 1)
{-6}  i!4 < p
[-7]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-8]  P!1 = p
[-9]  length(i!3`3) = i!2`1
[-10] length(i!3`4) = -1 - i!2`1 + p
[-11] (length(hu_list) = p)
[-12] nth(hu_list, i!2`1) = hu(i!2`1)
[-13] i!1 < p - 1
[-14] i!2`1 <= i!1
[-15] 2 <= p
  |-------
{1}   nth(remove(hu_list, i!2`1), i!4 - 1) = nth(hu_list, i!4)
[2]   p = 2

Rerunning step: (reveal -3)
Revealing hidden formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.2.1.1 : 
;;; establish some helpful equalities first

{-1}  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, 1 + j) ENDIF
[-2]  i!2`1 < i!4
[-3]  i!4 < p - 1
[-4]  nth(remove(hu_list, i!2`1), i!4) = nth(hu_list, 1 + i!4)
[-5]  nth(append(i!3`3, i!3`4), i!4 - 1) =
       nth(remove(hu_list, i!2`1), i!4 - 1)
[-6]  nth(i!3`4, -1 - i!2`1 + i!4) = nth(remove(hu_list, i!2`1), i!4 - 1)
[-7]  i!4 < p
[-8]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-9]  P!1 = p
[-10] length(i!3`3) = i!2`1
[-11] length(i!3`4) = -1 - i!2`1 + p
[-12] (length(hu_list) = p)
[-13] nth(hu_list, i!2`1) = hu(i!2`1)
[-14] i!1 < p - 1
[-15] i!2`1 <= i!1
[-16] 2 <= p
  |-------
[1]   nth(remove(hu_list, i!2`1), i!4 - 1) = nth(hu_list, i!4)
[2]   p = 2

Rerunning step: (inst -1 "i!4-1")
Instantiating the top quantifier in -1 with the terms: 
 i!4-1,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.2.1.1 : 
;;; establish some helpful equalities first

{-1}  nth(remove(hu_list, i!2`1), i!4 - 1) =
       IF i!4 - 1 < i!2`1 THEN nth(hu_list, i!4 - 1)
       ELSE nth(hu_list, 1 + (i!4 - 1))
       ENDIF
[-2]  i!2`1 < i!4
[-3]  i!4 < p - 1
[-4]  nth(remove(hu_list, i!2`1), i!4) = nth(hu_list, 1 + i!4)
[-5]  nth(append(i!3`3, i!3`4), i!4 - 1) =
       nth(remove(hu_list, i!2`1), i!4 - 1)
[-6]  nth(i!3`4, -1 - i!2`1 + i!4) = nth(remove(hu_list, i!2`1), i!4 - 1)
[-7]  i!4 < p
[-8]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-9]  P!1 = p
[-10] length(i!3`3) = i!2`1
[-11] length(i!3`4) = -1 - i!2`1 + p
[-12] (length(hu_list) = p)
[-13] nth(hu_list, i!2`1) = hu(i!2`1)
[-14] i!1 < p - 1
[-15] i!2`1 <= i!1
[-16] 2 <= p
  |-------
[1]   nth(remove(hu_list, i!2`1), i!4 - 1) = nth(hu_list, i!4)
[2]   p = 2

Rerunning step: (delete -3 -4
                  -5 -6
                  -7 -8
                  -9 -10
                  -11 -12
                  -13 -14
                  -15 -16
                  2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.2.1.1 : 
;;; establish some helpful equalities first

[-1]  nth(remove(hu_list, i!2`1), i!4 - 1) =
       IF i!4 - 1 < i!2`1 THEN nth(hu_list, i!4 - 1)
       ELSE nth(hu_list, 1 + (i!4 - 1))
       ENDIF
[-2]  i!2`1 < i!4
  |-------
[1]   nth(remove(hu_list, i!2`1), i!4 - 1) = nth(hu_list, i!4)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.2.1.1.

restrictmiddle_middle.1.2.2.2.3.1.2.1.2 : 
;;; establish some helpful equalities first

[-1]  FORALL (j: below[length[Identity](hu_list) - 1]):
        nth(remove(hu_list, i!2`1), j) =
         IF j < i!2`1 THEN nth(hu_list, j) ELSE nth(hu_list, j + 1) ENDIF
[-2]  FORALL (i: below[length[Identity](i!3`3) + length[Identity](i!3`4)]):
        nth(append(i!3`3, i!3`4), i) =
         IF i < length[Identity](i!3`3) THEN nth(i!3`3, i)
         ELSE nth(i!3`4, i - length[Identity](i!3`3))
         ENDIF
[-3]  FORALL (i: below[length[Identity](append(i!3`3, i!3`4))]):
        nth(append(i!3`3, i!3`4), i) = nth(remove(hu_list, i!2`1), i)
[-4]  i!4 < length[Identity](append(i!3`3, cons(hu(i!2`1), i!3`4)))
[-5]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-6]  P!1 = p
[-7]  length(i!3`3) = i!2`1
[-8]  length(i!3`4) = -1 - i!2`1 + p
[-9]  (length(hu_list) = p)
[-10] nth(hu_list, i!2`1) = hu(i!2`1)
[-11] i!1 < p - 1
[-12] i!2`1 <= i!1
[-13] 2 <= p
  |-------
{1}   i!4 < i!2`1 OR
       i!4 = i!2`1 OR (i!2`1 < i!4 AND i!4 < p - 1) OR i!4 = p - 1
[2]   IF i!4 < length[Identity](i!3`3) THEN nth(i!3`3, i!4)
      ELSE IF i!4 - length[Identity](i!3`3) = 0 THEN hu(i!2`1)
           ELSE nth(i!3`4, -1 - length[Identity](i!3`3) + i!4)
           ENDIF
      ENDIF
       = nth(hu_list, i!4)
[3]   p = 2

Rerunning step: (delete -1 -2 -3 -6 -7 -8 -9 -10 -11 -12 -13 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.2.1.2 : 
;;; establish some helpful equalities first

[-1]  i!4 < length[Identity](append(i!3`3, cons(hu(i!2`1), i!3`4)))
[-2]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
  |-------
[1]   i!4 < i!2`1 OR
       i!4 = i!2`1 OR (i!2`1 < i!4 AND i!4 < p - 1) OR i!4 = p - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.2.1.2.


This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.2.1.

restrictmiddle_middle.1.2.2.2.3.1.2.2T (TCC):   

[-1]  i!4 < length[Identity](append(i!3`3, cons(hu(i!2`1), i!3`4)))
[-2]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-3]  P!1 = p
[-4]  length(i!3`2) = -1 - i!2`1 + p
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = -1 - i!2`1 + p
[-7]  length(nl!1) = -1 - i!2`1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] 0 < i!1
[-11] i!1 < p - 1
[-12] 0 < i!2`1
[-13] i!2`1 <= i!1
[-14] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-15] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-16] 2 <= p
  |-------
{1}   i!4 <
       length[Identity](cons[Identity](hu(i!2`1), i!3`4)) +
        length[Identity](i!3`3)
[2]   nth(append(i!3`3, cons(hu(i!2`1), i!3`4)), i!4) = nth(hu_list, i!4)
[3]   append(i!3`3, cons(hu(i!2`1), i!3`4)) = hu_list
[4]   p = 2

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets cons(hu(i!2`1), i!3`4),
l1: list[T] gets i!3`3,
Rewriting using length_append, matching in -1,

This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.2.2T.


This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.2.

restrictmiddle_middle.1.2.2.2.3.1.3 : 
;;; establish some helpful equalities first

[-1]  length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[-2]  P!1 = p
[-3]  length(i!3`2) = p - 1 - i!2`1
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = p - 1 - i!2`1
[-6]  length(nl!1) = -1 - i!2`1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] 0 < i!2`1
[-12] i!2`1 <= i!1
[-13] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-14] append(i!3`3, i!3`4) = remove(hu_list, i!2`1)
[-15] 2 <= p
  |-------
{1}   nth(i!3`2, p - 2 - i!2`1) = n_last
[2]   (((LastMessage(p, i!2`1, hu(i!2`1), i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[3]   p = 2

Rerunning step: (delete -1 -2 -4 -5 -7 -8 -9 -11 -14 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.3 : 
;;; establish some helpful equalities first

[-1]  length(i!3`2) = p - 1 - i!2`1
[-2]  length(nl!1) = -1 - i!2`1 + p
[-3]  i!1 < p - 1
[-4]  i!2`1 <= i!1
[-5]  cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-6]  2 <= p
  |-------
[1]   nth(i!3`2, p - 2 - i!2`1) = n_last
[2]   p = 2

Rerunning step: (lemma "listprops[Identity].equality_nth"
                 ("l1" "cons(i!2`2,i!3`2)" "l2"
                  "append(nl!1,(:n_last:))"))
Applying listprops[Identity].equality_nth where 
  l1 gets cons(i!2`2, i!3`2),
  l2 gets append(nl!1, (: n_last :)),
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.3 : 
;;; establish some helpful equalities first

{-1}  cons(i!2`2, i!3`2) = append(nl!1, (: n_last :)) IMPLIES
       FORALL (i: below[length[Identity](cons(i!2`2, i!3`2))]):
         nth(cons(i!2`2, i!3`2), i) = nth(append(nl!1, (: n_last :)), i)
[-2]  length(i!3`2) = p - 1 - i!2`1
[-3]  length(nl!1) = -1 - i!2`1 + p
[-4]  i!1 < p - 1
[-5]  i!2`1 <= i!1
[-6]  cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-7]  2 <= p
  |-------
[1]   nth(i!3`2, p - 2 - i!2`1) = n_last
[2]   p = 2

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.3 : 
;;; establish some helpful equalities first

{-1}  FORALL (i: below[length[Identity](cons(i!2`2, i!3`2))]):
        nth(cons(i!2`2, i!3`2), i) = nth(append(nl!1, (: n_last :)), i)
[-2]  length(i!3`2) = p - 1 - i!2`1
[-3]  length(nl!1) = -1 - i!2`1 + p
[-4]  i!1 < p - 1
[-5]  i!2`1 <= i!1
[-6]  cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-7]  2 <= p
  |-------
[1]   nth(i!3`2, p - 2 - i!2`1) = n_last
[2]   p = 2

Rerunning step: (inst -1 "p-1-i!2`1")
Instantiating the top quantifier in -1 with the terms: 
 p-1-i!2`1,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.2.2.3.1.3.1 : 
;;; establish some helpful equalities first

{-1}  nth(cons(i!2`2, i!3`2), p - 1 - i!2`1) =
       nth(append(nl!1, (: n_last :)), p - 1 - i!2`1)
[-2]  length(i!3`2) = p - 1 - i!2`1
[-3]  length(nl!1) = -1 - i!2`1 + p
[-4]  i!1 < p - 1
[-5]  i!2`1 <= i!1
[-6]  cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-7]  2 <= p
  |-------
[1]   nth(i!3`2, p - 2 - i!2`1) = n_last
[2]   p = 2

Rerunning step: (expand "nth" -1 1)
Expanding the definition of nth,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.3.1 : 
;;; establish some helpful equalities first

{-1}  IF -1 - i!2`1 + p = 0 THEN i!2`2
      ELSE nth(i!3`2, -2 - i!2`1 + p)
      ENDIF
       = nth(append(nl!1, (: n_last :)), -1 - i!2`1 + p)
[-2]  length(i!3`2) = p - 1 - i!2`1
[-3]  length(nl!1) = -1 - i!2`1 + p
[-4]  i!1 < p - 1
[-5]  i!2`1 <= i!1
[-6]  cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-7]  2 <= p
  |-------
[1]   nth(i!3`2, p - 2 - i!2`1) = n_last
[2]   p = 2

Rerunning step: (ground)
Applying propositional simplification and decision procedures,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.3.1 : 
;;; establish some helpful equalities first

{-1}  nth(i!3`2, -2 - i!2`1 + p) =
       nth(append(nl!1, (: n_last :)), -1 - i!2`1 + p)
{-2}  length(i!3`2) = -1 - i!2`1 + p
[-3]  length(nl!1) = -1 - i!2`1 + p
[-4]  i!1 < p - 1
[-5]  i!2`1 <= i!1
[-6]  cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-7]  2 <= p
  |-------
{1}   nth(i!3`2, -2 - i!2`1 + p) = n_last
[2]   p = 2

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.3.1 : 
;;; establish some helpful equalities first

[-1]  nth(i!3`2, -2 - i!2`1 + p) =
       nth(append(nl!1, (: n_last :)), -1 - i!2`1 + p)
[-2]  length(i!3`2) = -1 - i!2`1 + p
[-3]  length(nl!1) = -1 - i!2`1 + p
[-4]  i!1 < p - 1
[-5]  i!2`1 <= i!1
[-6]  cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-7]  2 <= p
  |-------
{1}   nth(append(nl!1, (: n_last :)), -1 - i!2`1 + p) = n_last
[2]   p = 2

Rerunning step: (rewrite "nth_append" 1)
Found matching substitution:
i: below[length(l1) + length(l2)] gets -1 - i!2`1 + p,
l2: list[T] gets (: n_last :),
l1: list[T] gets nl!1,
Rewriting using nth_append, matching in 1,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.2.2.3.1.3.1.1 : 
;;; establish some helpful equalities first

{-1}  nth(i!3`2, -2 - i!2`1 + p) =
       nth((: n_last :), -1 - length[Identity](nl!1) - i!2`1 + p)
[-2]  length(i!3`2) = -1 - i!2`1 + p
[-3]  length(nl!1) = -1 - i!2`1 + p
[-4]  i!1 < p - 1
[-5]  i!2`1 <= i!1
[-6]  cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-7]  2 <= p
  |-------
{1}   nth((: n_last :), -1 - length[Identity](nl!1) - i!2`1 + p) = n_last
[2]   p = 2

Rerunning step: (expand "nth" 1)
Expanding the definition of nth,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.3.1.1 : 
;;; establish some helpful equalities first

[-1]  nth(i!3`2, -2 - i!2`1 + p) =
       nth((: n_last :), -1 - length[Identity](nl!1) - i!2`1 + p)
[-2]  length(i!3`2) = -1 - i!2`1 + p
[-3]  length(nl!1) = -1 - i!2`1 + p
[-4]  i!1 < p - 1
[-5]  i!2`1 <= i!1
[-6]  cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-7]  2 <= p
  |-------
{1}   TRUE
[2]   p = 2

which is trivially true.

This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.3.1.1.

restrictmiddle_middle.1.2.2.2.3.1.3.1.2 : 
;;; establish some helpful equalities first

[-1]  nth(i!3`2, -2 - i!2`1 + p) =
       nth(append(nl!1, (: n_last :)), -1 - i!2`1 + p)
[-2]  length(i!3`2) = -1 - i!2`1 + p
[-3]  length(nl!1) = -1 - i!2`1 + p
[-4]  i!1 < p - 1
[-5]  i!2`1 <= i!1
[-6]  cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-7]  2 <= p
  |-------
{1}   -1 - i!2`1 + p <
       length[Identity]((: n_last :)) + length[Identity](nl!1)
[2]   nth(append(nl!1, (: n_last :)), -1 - i!2`1 + p) = n_last
[3]   p = 2

Rerunning step: (delete -1 -2 -4 -5 -6 -7 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.3.1.2 : 
;;; establish some helpful equalities first

[-1]  length(nl!1) = -1 - i!2`1 + p
  |-------
[1]   -1 - i!2`1 + p <
       length[Identity]((: n_last :)) + length[Identity](nl!1)

Rerunning step: (grind)
length rewrites length[Nonce]((: :))
  to 0
length rewrites length[Identity]((: n_last :))
  to 1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.3.1.2.


This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.3.1.

restrictmiddle_middle.1.2.2.2.3.1.3.2 (TCC):   

[-1]  length(i!3`2) = p - 1 - i!2`1
[-2]  length(nl!1) = -1 - i!2`1 + p
[-3]  i!1 < p - 1
[-4]  i!2`1 <= i!1
[-5]  cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-6]  2 <= p
  |-------
{1}   -1 - i!2`1 + p >= 0 AND
       -1 - i!2`1 + p < length[Identity](cons[Nonce](i!2`2, i!3`2))
[2]   nth(i!3`2, p - 2 - i!2`1) = n_last
[3]   p = 2

Rerunning step: (expand "length" 1)
Expanding the definition of length,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.3.2 : 
;;; establish some helpful equalities first

[-1]  length(i!3`2) = p - 1 - i!2`1
[-2]  length(nl!1) = -1 - i!2`1 + p
[-3]  i!1 < p - 1
[-4]  i!2`1 <= i!1
[-5]  cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-6]  2 <= p
  |-------
{1}   -1 - i!2`1 + p >= 0 AND -1 - i!2`1 + p < 1 + length[Identity](i!3`2)
[2]   nth(i!3`2, p - 2 - i!2`1) = n_last
[3]   p = 2

Rerunning step: (delete -2 -5 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.1.3.2 : 
;;; establish some helpful equalities first

[-1]  length(i!3`2) = p - 1 - i!2`1
[-2]  i!1 < p - 1
[-3]  i!2`1 <= i!1
[-4]  2 <= p
  |-------
[1]   -1 - i!2`1 + p >= 0 AND -1 - i!2`1 + p < 1 + length[Identity](i!3`2)
[2]   p = 2

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.3.2.


This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.3.


This completes the proof of restrictmiddle_middle.1.2.2.2.3.1.

restrictmiddle_middle.1.2.2.2.3.2 : 
;;; establish some helpful equalities first

{-1}  j!1 = i!2`1
{-2}  P!1 = p
[-3]  length(i!3`2) = P!1 - 1 - i!2`1
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = P!1 - 1 - i!2`1
[-6]  length(nl!1) = -1 - j!1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] 0 < j!1
[-12] j!1 <= i!1
[-13] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-14] append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-15] u!1 = hu(j!1)
[-16] 2 <= P!1
  |-------
{1}   length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p
[2]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[3]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   P!1 = 2

Rerunning step: (delete -1 -3
                  -6 -7
                  -8 -9
                  -10 -11
                  -12 -13
                  -14 -15
                  -16 2
                  3 4)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.2 : 
;;; establish some helpful equalities first

[-1]  P!1 = p
[-2]  length(i!3`3) = i!2`1
[-3]  length(i!3`4) = P!1 - 1 - i!2`1
  |-------
[1]   length(append(i!3`3, cons(hu(i!2`1), i!3`4))) = p

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets cons(hu(i!2`1), i!3`4),
l1: list[T] gets i!3`3,
Rewriting using length_append, matching in 1,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.2 : 
;;; establish some helpful equalities first

[-1]  P!1 = p
[-2]  length(i!3`3) = i!2`1
[-3]  length(i!3`4) = P!1 - 1 - i!2`1
  |-------
{1}   length(cons(hu(i!2`1), i!3`4)) + length(i!3`3) = p

Rerunning step: (expand "length" 1 1)
Expanding the definition of length,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.2 : 
;;; establish some helpful equalities first

[-1]  P!1 = p
[-2]  length(i!3`3) = i!2`1
[-3]  length(i!3`4) = P!1 - 1 - i!2`1
  |-------
{1}   1 + length(i!3`3) + length[Nonce](i!3`4) = p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_middle.1.2.2.2.3.2.

restrictmiddle_middle.1.2.2.2.3.3 : 
;;; establish some helpful equalities first

{-1}  P!1 = p
[-2]  length(i!3`2) = P!1 - 1 - i!2`1
[-3]  length(i!3`3) = i!2`1
[-4]  length(i!3`4) = P!1 - 1 - i!2`1
[-5]  length(nl!1) = -1 - j!1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  0 < i!1
[-9]  i!1 < p - 1
[-10] 0 < j!1
[-11] j!1 <= i!1
[-12] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-13] append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-14] u!1 = hu(j!1)
[-15] 2 <= P!1
  |-------
{1}   j!1 = i!2`1
[2]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[3]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   P!1 = 2

Rerunning step: (lemma "listprops[Identity].equality_length"
                 ("l1" "cons(i!2`2,i!3`2)" "l2"
                  "append(nl!1,(:n_last:))"))
Applying listprops[Identity].equality_length where 
  l1 gets cons(i!2`2, i!3`2),
  l2 gets append(nl!1, (: n_last :)),
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.3 : 
;;; establish some helpful equalities first

{-1}  cons(i!2`2, i!3`2) = append(nl!1, (: n_last :)) IMPLIES
       length[Identity](cons(i!2`2, i!3`2)) =
        length[Identity](append(nl!1, (: n_last :)))
[-2]  P!1 = p
[-3]  length(i!3`2) = P!1 - 1 - i!2`1
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = P!1 - 1 - i!2`1
[-6]  length(nl!1) = -1 - j!1 + p
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] 0 < j!1
[-12] j!1 <= i!1
[-13] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-14] append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-15] u!1 = hu(j!1)
[-16] 2 <= P!1
  |-------
[1]   j!1 = i!2`1
[2]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[3]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   P!1 = 2

Rerunning step: (delete -4 -5 -7 -8 -9 -10 -11 -12 -14 -15 -16 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.3 : 
;;; establish some helpful equalities first

[-1]  cons(i!2`2, i!3`2) = append(nl!1, (: n_last :)) IMPLIES
       length[Identity](cons(i!2`2, i!3`2)) =
        length[Identity](append(nl!1, (: n_last :)))
[-2]  P!1 = p
[-3]  length(i!3`2) = P!1 - 1 - i!2`1
[-4]  length(nl!1) = -1 - j!1 + p
[-5]  cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
  |-------
[1]   j!1 = i!2`1

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.3 : 
;;; establish some helpful equalities first

{-1}  length[Identity](cons(i!2`2, i!3`2)) =
       length[Identity](append(nl!1, (: n_last :)))
[-2]  P!1 = p
[-3]  length(i!3`2) = P!1 - 1 - i!2`1
[-4]  length(nl!1) = -1 - j!1 + p
[-5]  cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
  |-------
[1]   j!1 = i!2`1

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets (: n_last :),
l1: list[T] gets nl!1,
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.3 : 
;;; establish some helpful equalities first

{-1}  length[Identity](cons(i!2`2, i!3`2)) =
       length((: n_last :)) + length(nl!1)
[-2]  P!1 = p
[-3]  length(i!3`2) = P!1 - 1 - i!2`1
[-4]  length(nl!1) = -1 - j!1 + p
[-5]  cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
  |-------
[1]   j!1 = i!2`1

Rerunning step: (expand "length" -1 1)
Expanding the definition of length,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.3 : 
;;; establish some helpful equalities first

{-1}  1 + length[Identity](i!3`2) = length((: n_last :)) + length(nl!1)
[-2]  P!1 = p
[-3]  length(i!3`2) = P!1 - 1 - i!2`1
[-4]  length(nl!1) = -1 - j!1 + p
[-5]  cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
  |-------
[1]   j!1 = i!2`1

Rerunning step: (replace* -2 -3 -4)
Repeatedly applying the replace rule,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.3 : 
;;; establish some helpful equalities first

{-1}  1 + (p - 1 - i!2`1) = length((: n_last :)) + (-1 - j!1 + p)
[-2]  P!1 = p
{-3}  length(i!3`2) = p - 1 - i!2`1
[-4]  length(nl!1) = -1 - j!1 + p
[-5]  cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
  |-------
[1]   j!1 = i!2`1

Rerunning step: (delete -2 -3 -4 -5)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.3 : 
;;; establish some helpful equalities first

[-1]  1 + (p - 1 - i!2`1) = length((: n_last :)) + (-1 - j!1 + p)
  |-------
[1]   j!1 = i!2`1

Rerunning step: (grind)
length rewrites length[Nonce]((: :))
  to 0
length rewrites length((: n_last :))
  to 1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_middle.1.2.2.2.3.3.

restrictmiddle_middle.1.2.2.2.3.4 : 
;;; establish some helpful equalities first

[-1]  length(i!3`2) = P!1 - 1 - i!2`1
[-2]  length(i!3`3) = i!2`1
[-3]  length(i!3`4) = P!1 - 1 - i!2`1
[-4]  length(nl!1) = -1 - j!1 + p
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  0 < i!1
[-8]  i!1 < p - 1
[-9]  0 < j!1
[-10] j!1 <= i!1
[-11] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-12] append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-13] u!1 = hu(j!1)
[-14] 2 <= P!1
  |-------
{1}   P!1 = p
[2]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[3]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   P!1 = 2

Rerunning step: (lemma "listprops[Identity].equality_length"
                 ("l1" "append(i!3`3,i!3`4)" "l2"
                  "remove(hu_list,j!1)"))
Applying listprops[Identity].equality_length where 
  l1 gets append(i!3`3, i!3`4),
  l2 gets remove(hu_list, j!1),
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.4 : 
;;; establish some helpful equalities first

{-1}  append(i!3`3, i!3`4) = remove(hu_list, j!1) IMPLIES
       length[Identity](append(i!3`3, i!3`4)) =
        length[Identity](remove(hu_list, j!1))
[-2]  length(i!3`2) = P!1 - 1 - i!2`1
[-3]  length(i!3`3) = i!2`1
[-4]  length(i!3`4) = P!1 - 1 - i!2`1
[-5]  length(nl!1) = -1 - j!1 + p
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  0 < i!1
[-9]  i!1 < p - 1
[-10] 0 < j!1
[-11] j!1 <= i!1
[-12] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-13] append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-14] u!1 = hu(j!1)
[-15] 2 <= P!1
  |-------
[1]   P!1 = p
[2]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[3]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   P!1 = 2

Rerunning step: (delete -2 -5 -7 -8 -9 -10 -11 -12 -14 -15 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.4 : 
;;; establish some helpful equalities first

[-1]  append(i!3`3, i!3`4) = remove(hu_list, j!1) IMPLIES
       length[Identity](append(i!3`3, i!3`4)) =
        length[Identity](remove(hu_list, j!1))
[-2]  length(i!3`3) = i!2`1
[-3]  length(i!3`4) = P!1 - 1 - i!2`1
[-4]  (length(hu_list) = p)
[-5]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
  |-------
[1]   P!1 = p

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.4 : 
;;; establish some helpful equalities first

{-1}  length[Identity](append(i!3`3, i!3`4)) =
       length[Identity](remove(hu_list, j!1))
[-2]  length(i!3`3) = i!2`1
[-3]  length(i!3`4) = P!1 - 1 - i!2`1
[-4]  (length(hu_list) = p)
[-5]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
  |-------
[1]   P!1 = p

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets i!3`4,
l1: list[T] gets i!3`3,
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.4 : 
;;; establish some helpful equalities first

{-1}  length(i!3`3) + length(i!3`4) = length[Identity](remove(hu_list, j!1))
[-2]  length(i!3`3) = i!2`1
[-3]  length(i!3`4) = P!1 - 1 - i!2`1
[-4]  (length(hu_list) = p)
[-5]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
  |-------
[1]   P!1 = p

Rerunning step: (rewrite "length_remove" -1 :dir rl)
Found matching substitution:
i: below[length(c)] gets j!1,
c: (cons?[T]) gets hu_list,
Rewriting using length_remove, matching in -1,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.2.2.3.4.1 : 
;;; establish some helpful equalities first

{-1}  length(i!3`3) + length(i!3`4) = length[Identity](hu_list) - 1
[-2]  length(i!3`3) = i!2`1
[-3]  length(i!3`4) = P!1 - 1 - i!2`1
[-4]  (length(hu_list) = p)
[-5]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
  |-------
[1]   P!1 = p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_middle.1.2.2.2.3.4.1.

restrictmiddle_middle.1.2.2.2.3.4.2 : 
;;; establish some helpful equalities first

[-1]  length(i!3`3) + length(i!3`4) = length[Identity](remove(hu_list, j!1))
[-2]  length(i!3`3) = i!2`1
[-3]  length(i!3`4) = P!1 - 1 - i!2`1
[-4]  (length(hu_list) = p)
[-5]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
  |-------
{1}   cons?[Identity](hu_list)
[2]   P!1 = p

Rerunning step: (typepred "p")
Adding type constraints for  p,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.4.2 : 
;;; establish some helpful equalities first

{-1}  2 <= p
[-2]  length(i!3`3) + length(i!3`4) = length[Identity](remove(hu_list, j!1))
[-3]  length(i!3`3) = i!2`1
[-4]  length(i!3`4) = P!1 - 1 - i!2`1
[-5]  (length(hu_list) = p)
[-6]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
  |-------
[1]   cons?[Identity](hu_list)
[2]   P!1 = p

Rerunning step: (delete -2 -3 -4 -6 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.4.2 : 
;;; establish some helpful equalities first

[-1]  2 <= p
[-2]  (length(hu_list) = p)
  |-------
[1]   cons?[Identity](hu_list)

Rerunning step: (nonemptylist "hu_list")
Relating existence of a tail to a list's length,

This completes the proof of restrictmiddle_middle.1.2.2.2.3.4.2.


This completes the proof of restrictmiddle_middle.1.2.2.2.3.4.

restrictmiddle_middle.1.2.2.2.3.5T (TCC):   

[-1]  length(i!3`2) = P!1 - 1 - i!2`1
[-2]  length(i!3`3) = i!2`1
[-3]  length(i!3`4) = P!1 - 1 - i!2`1
[-4]  length(nl!1) = -1 - j!1 + p
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  0 < i!1
[-8]  i!1 < p - 1
[-9]  0 < j!1
[-10] j!1 <= i!1
[-11] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-12] append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-13] u!1 = hu(j!1)
[-14] 2 <= P!1
  |-------
{1}   i!2`1 < p
[2]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[3]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   P!1 = 2

Rerunning step: (typepred "i!2`1" "p")
Adding type constraints for  i!2`1, p,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.5T : 
;;; establish some helpful equalities first

{-1}  0 < i!2`1
{-2}  i!2`1 < P!1 - 1
{-3}  2 <= p
[-4]  length(i!3`2) = P!1 - 1 - i!2`1
[-5]  length(i!3`3) = i!2`1
[-6]  length(i!3`4) = P!1 - 1 - i!2`1
[-7]  length(nl!1) = -1 - j!1 + p
[-8]  (length(hu_list) = p)
[-9]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] 0 < i!1
[-11] i!1 < p - 1
[-12] 0 < j!1
[-13] j!1 <= i!1
[-14] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-15] append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-16] u!1 = hu(j!1)
[-17] 2 <= P!1
  |-------
[1]   i!2`1 < p
[2]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[3]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   P!1 = 2

Rerunning step: (lemma "listprops[Identity].equality_length"
                 ("l1" "append(i!3`3,i!3`4)" "l2"
                  "remove(hu_list,j!1)"))
Applying listprops[Identity].equality_length where 
  l1 gets append(i!3`3, i!3`4),
  l2 gets remove(hu_list, j!1),
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.5T : 
;;; establish some helpful equalities first

{-1}  append(i!3`3, i!3`4) = remove(hu_list, j!1) IMPLIES
       length[Identity](append(i!3`3, i!3`4)) =
        length[Identity](remove(hu_list, j!1))
[-2]  0 < i!2`1
[-3]  i!2`1 < P!1 - 1
[-4]  2 <= p
[-5]  length(i!3`2) = P!1 - 1 - i!2`1
[-6]  length(i!3`3) = i!2`1
[-7]  length(i!3`4) = P!1 - 1 - i!2`1
[-8]  length(nl!1) = -1 - j!1 + p
[-9]  (length(hu_list) = p)
[-10] FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-11] 0 < i!1
[-12] i!1 < p - 1
[-13] 0 < j!1
[-14] j!1 <= i!1
[-15] cons(i!2`2, i!3`2) = append(nl!1, (: n_last :))
[-16] append(i!3`3, i!3`4) = remove(hu_list, j!1)
[-17] u!1 = hu(j!1)
[-18] 2 <= P!1
  |-------
[1]   i!2`1 < p
[2]   i!1 = i!2`1 AND
       append(i!3`3, cons(u!1, i!3`4)) = hu_list AND
        nth(i!3`2, P!1 - 2 - i!2`1) = n_last
[3]   (((LastMessage(P!1, i!2`1, u!1, i!3`1, i!3`2, i!3`3, i!3`4)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   P!1 = 2

Rerunning step: (delete -2 -5 -8 -10 -11 -12 -13 -14 -15 -17 -18 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.5T : 
;;; establish some helpful equalities first

[-1]  append(i!3`3, i!3`4) = remove(hu_list, j!1) IMPLIES
       length[Identity](append(i!3`3, i!3`4)) =
        length[Identity](remove(hu_list, j!1))
[-2]  i!2`1 < P!1 - 1
[-3]  2 <= p
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = P!1 - 1 - i!2`1
[-6]  (length(hu_list) = p)
[-7]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
  |-------
[1]   i!2`1 < p

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.5T : 
;;; establish some helpful equalities first

{-1}  length[Identity](append(i!3`3, i!3`4)) =
       length[Identity](remove(hu_list, j!1))
[-2]  i!2`1 < P!1 - 1
[-3]  2 <= p
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = P!1 - 1 - i!2`1
[-6]  (length(hu_list) = p)
[-7]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
  |-------
[1]   i!2`1 < p

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets i!3`4,
l1: list[T] gets i!3`3,
Rewriting using length_append, matching in -1,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.5T : 
;;; establish some helpful equalities first

{-1}  length(i!3`3) + length(i!3`4) = length[Identity](remove(hu_list, j!1))
[-2]  i!2`1 < P!1 - 1
[-3]  2 <= p
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = P!1 - 1 - i!2`1
[-6]  (length(hu_list) = p)
[-7]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
  |-------
[1]   i!2`1 < p

Rerunning step: (rewrite "length_remove" -1 :dir rl)
Found matching substitution:
i: below[length(c)] gets j!1,
c: (cons?[T]) gets hu_list,
Rewriting using length_remove, matching in -1,
this yields  2 subgoals: 
restrictmiddle_middle.1.2.2.2.3.5T.1 : 
;;; establish some helpful equalities first

{-1}  length(i!3`3) + length(i!3`4) = length[Identity](hu_list) - 1
[-2]  i!2`1 < P!1 - 1
[-3]  2 <= p
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = P!1 - 1 - i!2`1
[-6]  (length(hu_list) = p)
[-7]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
  |-------
[1]   i!2`1 < p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_middle.1.2.2.2.3.5T.1.

restrictmiddle_middle.1.2.2.2.3.5T.2 : 
;;; establish some helpful equalities first

[-1]  length(i!3`3) + length(i!3`4) = length[Identity](remove(hu_list, j!1))
[-2]  i!2`1 < P!1 - 1
[-3]  2 <= p
[-4]  length(i!3`3) = i!2`1
[-5]  length(i!3`4) = P!1 - 1 - i!2`1
[-6]  (length(hu_list) = p)
[-7]  append(i!3`3, i!3`4) = remove(hu_list, j!1)
  |-------
{1}   cons?[Identity](hu_list)
[2]   i!2`1 < p

Rerunning step: (delete -1 -2 -4 -5 -7 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.1.2.2.2.3.5T.2 : 
;;; establish some helpful equalities first

[-1]  2 <= p
[-2]  (length(hu_list) = p)
  |-------
[1]   cons?[Identity](hu_list)

Rerunning step: (nonemptylist "hu_list")
Relating existence of a tail to a list's length,

This completes the proof of restrictmiddle_middle.1.2.2.2.3.5T.2.


This completes the proof of restrictmiddle_middle.1.2.2.2.3.5T.


This completes the proof of restrictmiddle_middle.1.2.2.2.3.


This completes the proof of restrictmiddle_middle.1.2.2.2.


This completes the proof of restrictmiddle_middle.1.2.2.


This completes the proof of restrictmiddle_middle.1.2.


This completes the proof of restrictmiddle_middle.1.

restrictmiddle_middle.2 :  

[-1]  2 <= P!1
[-2]  0 < i!2`1
[-3]  i!2`1 < P!1 - 1
  |-------
{1}   P!1 - 2 - i!2`1 < length[Nonce](i!3`2)
[2]   P!1 = 2
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!2`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!2`1},
                  {x: list[Identity] | length(x) = i!2`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!2`1}]):
        (rec(u!1, nth(i`3, i!2`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!2`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!2`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!2`2, i`2)))))
              >>
              (signal(running(i!2`1, append(i`3, cons(u!1, i`4)),
                              nth(i`2, P!1 - 2 - i!2`1)))
                >>
                ((LastMessage(P!1, i!2`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (typepred "i!3`2")
Adding type constraints for  i!3`2,
this simplifies to: 
restrictmiddle_middle.2 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`2)
{-2}  length(i!3`2) = P!1 - 1 - i!2`1
[-3]  2 <= P!1
[-4]  0 < i!2`1
[-5]  i!2`1 < P!1 - 1
  |-------
[1]   P!1 - 2 - i!2`1 < length[Nonce](i!3`2)
[2]   P!1 = 2
[3]   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!2`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!2`1},
                  {x: list[Identity] | length(x) = i!2`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!2`1}]):
        (rec(u!1, nth(i`3, i!2`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!2`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!2`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!2`2, i`2)))))
              >>
              (signal(running(i!2`1, append(i`3, cons(u!1, i`4)),
                              nth(i`2, P!1 - 2 - i!2`1)))
                >>
                ((LastMessage(P!1, i!2`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -3 -4 -5 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.2 :  

[-1]  length(i!3`2) = P!1 - 1 - i!2`1
  |-------
[1]   P!1 - 2 - i!2`1 < length[Nonce](i!3`2)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_middle.2.

restrictmiddle_middle.3 :  

[-1]  2 <= P!1
[-2]  0 < i!2`1
[-3]  i!2`1 < P!1 - 1
  |-------
{1}   cons?[Identity](i!3`4)
[2]   P!1 = 2
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!2`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!2`1},
                  {x: list[Identity] | length(x) = i!2`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!2`1}]):
        (rec(u!1, nth(i`3, i!2`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!2`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!2`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!2`2, i`2)))))
              >>
              (signal(running(i!2`1, append(i`3, cons(u!1, i`4)),
                              nth(i`2, P!1 - 2 - i!2`1)))
                >>
                ((LastMessage(P!1, i!2`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -2 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.3 :  

[-1]  2 <= P!1
[-2]  i!2`1 < P!1 - 1
  |-------
[1]   cons?[Identity](i!3`4)

Rerunning step: (nonemptylist "i!3`4")
Relating existence of a tail to a list's length,

This completes the proof of restrictmiddle_middle.3.

restrictmiddle_middle.4 :  

[-1]  2 <= P!1
[-2]  0 < i!2`1
[-3]  i!2`1 < P!1 - 1
  |-------
{1}   i!2`1 - 1 < length[Identity](i!3`3)
[2]   P!1 = 2
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = i!2`1},
                  {x: list[Nonce] | length(x) = P!1 - 1 - i!2`1},
                  {x: list[Identity] | length(x) = i!2`1},
                  {x: list[Identity] | length(x) = P!1 - 1 - i!2`1}]):
        (rec(u!1, nth(i`3, i!2`1 - 1),
             E(public(u!1), conc(nlist(i`1), ilist(append(i`3, i`4)))))
          >>
          (trans(u!1, car(i`4),
                 E(public(car(i`4)),
                   conc(nlist(append(i`1, (: i!2`2 :))),
                        ilist(append(i`3, cons(u!1, cdr(i`4)))))))
            >>
            (rec(u!1, nth(i`3, i!2`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(i`3, i`4)), nlist(cons(i!2`2, i`2)))))
              >>
              (signal(running(i!2`1, append(i`3, cons(u!1, i`4)),
                              nth(i`2, P!1 - 2 - i!2`1)))
                >>
                ((LastMessage(P!1, i!2`1, u!1, i`1, i`2, i`3, i`4)) >>
                  Stop[event])))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -3 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.4 :  

[-1]  0 < i!2`1
  |-------
[1]   i!2`1 - 1 < length[Identity](i!3`3)

Rerunning step: (nonemptylist "i!3`3")
Relating existence of a tail to a list's length,

This completes the proof of restrictmiddle_middle.4.

restrictmiddle_middle.5 :  

[-1]  2 <= P!1
[-2]  0 < i!2`1
[-3]  i!2`1 < P!1 - 1
  |-------
{1}   FORALL (nl1: {x: list[Nonce] | length[Nonce](x) = i!2`1},
              nl2: {x: list[Nonce] | length[Nonce](x) = P!1 - 1 - i!2`1},
              il1: {x: list[Identity] | length[Identity](x) = i!2`1},
              il2:
                {x: list[Identity] |
                   length[Identity](x) = P!1 - 1 - i!2`1}):
        cons?[Identity](il2)
[2]   P!1 = 2
[3]   Choice! (nl1: {x: list[Nonce] | length(x) = i!2`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!2`1},
               il1: {x: list[Identity] | length(x) = i!2`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!2`1}):
        (rec(u!1, nth(il1, i!2`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!2`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!2`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!2`2, nl2)))))
              >>
              (signal(running(i!2`1, append(il1, cons(u!1, il2)),
                              nth(nl2, P!1 - 2 - i!2`1)))
                >>
                ((LastMessage(P!1, i!2`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictmiddle_middle.5 :  

[-1]  2 <= P!1
[-2]  0 < i!2`1
[-3]  i!2`1 < P!1 - 1
  |-------
{1}   cons?[Identity](il2!1)
[2]   P!1 = 2
[3]   Choice! (nl1: {x: list[Nonce] | length(x) = i!2`1},
               nl2: {x: list[Nonce] | length(x) = P!1 - 1 - i!2`1},
               il1: {x: list[Identity] | length(x) = i!2`1},
               il2: {x: list[Identity] | length(x) = P!1 - 1 - i!2`1}):
        (rec(u!1, nth(il1, i!2`1 - 1),
             E(public(u!1), conc(nlist(nl1), ilist(append(il1, il2)))))
          >>
          (trans(u!1, car(il2),
                 E(public(car(il2)),
                   conc(nlist(append(nl1, (: i!2`2 :))),
                        ilist(append(il1, cons(u!1, cdr(il2)))))))
            >>
            (rec(u!1, nth(il1, i!2`1 - 1),
                 E(public(u!1),
                   conc(ilist(append(il1, il2)), nlist(cons(i!2`2, nl2)))))
              >>
              (signal(running(i!2`1, append(il1, cons(u!1, il2)),
                              nth(nl2, P!1 - 2 - i!2`1)))
                >>
                ((LastMessage(P!1, i!2`1, u!1, nl1, nl2, il1, il2)) >>
                  Stop[event])))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -2 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_middle.5 :  

[-1]  2 <= P!1
[-2]  i!2`1 < P!1 - 1
  |-------
[1]   cons?[Identity](il2!1)

Rerunning step: (nonemptylist "il2!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictmiddle_middle.5.

Q.E.D.


Run time  = 9.53 secs.
Real time = 15.77 secs.
nil
pvs(67): 
Installing rewrite rule sets.singleton_rew (all instances)
restrictmiddle_last :  

  |-------
{1}   FORALL (P: nat_from_2, i: nat_1_to(p), u: Identity):
        ((Interleave! (nnP: Nonces(P, u, P - 1)): UROLE_LAST(P, u, nnP)) #
          R_middle(i))
         |> RankUser(rho_middle(i))

Rerunning step: (auto-rewrite-theory "sets")
Rewriting relative to the theory: sets,
this simplifies to: 
restrictmiddle_last :  

  |-------
[1]   FORALL (P: nat_from_2, i: nat_1_to(p), u: Identity):
        ((Interleave! (nnP: Nonces(P, u, P - 1)): UROLE_LAST(P, u, nnP)) #
          R_middle(i))
         |> RankUser(rho_middle(i))

Rerunning step: (auto-rewrite "n_last_TCC2")
Installing rewrite rule gnsl_last.n_last_TCC2
Installing automatic rewrites from: 
  n_last_TCC2
this simplifies to: 
restrictmiddle_last :  

  |-------
[1]   FORALL (P: nat_from_2, i: nat_1_to(p), u: Identity):
        ((Interleave! (nnP: Nonces(P, u, P - 1)): UROLE_LAST(P, u, nnP)) #
          R_middle(i))
         |> RankUser(rho_middle(i))

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictmiddle_last :  

  |-------
{1}   ((Interleave! (nnP: Nonces(P!1, u!1, P!1 - 1)):
          UROLE_LAST(P!1, u!1, nnP))
        # R_middle(i!1))
       |> RankUser(rho_middle(i!1))

Rerunning step: (expand "RankUser")
Expanding the definition of RankUser,
this simplifies to: 
restrictmiddle_last :  

  |-------
{1}   ((Interleave! (nnP: Nonces(P!1, u!1, P!1 - 1)):
          UROLE_LAST(P!1, u!1, nnP))
        # R_middle(i!1))
       |>
       LAMBDA (tr: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(tr)
          =>
          every(LAMBDA (e: event):
                  complement(rec?)(e) => rho_middle(i!1)(msg(e)))
               (tr)

Rerunning step: (interleaving2)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
Applying interleaving rule,
this simplifies to: 
restrictmiddle_last :  

  |-------
{1}   UROLE_LAST(P!1, u!1, i!2) # R_middle(i!1) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (expand "UROLE_LAST")
Expanding the definition of UROLE_LAST,
this simplifies to: 
restrictmiddle_last :  

  |-------
{1}   IF i!2 = n_last
        THEN Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
                      il:
                        {x: list[Identity] |
                           length(x) = P!1 - 1 AND
                            FORALL (i: below[P!1 - 1]):
                              nth(x, i) = hu(i)}):
               (rec(u!1, nth(il, P!1 - 2),
                    E(public(u!1), conc(nlist(nl), ilist(il))))
                 >>
                 (trans(u!1, car(il),
                        E(public(car(il)),
                          conc(nlist(append(nl, (: i!2 :))),
                               ilist(append(cdr(il), (: u!1 :))))))
                   >>
                   (rec(u!1, nth(il, P!1 - 2),
                        E(public(u!1), nlist((: i!2 :))))
                     >>
                     (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!2))
                       >> Stop[event]))))
      ELSE Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
                    il: {x: list[Identity] | length(x) = P!1 - 1}):
             (rec(u!1, nth(il, P!1 - 2),
                  E(public(u!1), conc(nlist(nl), ilist(il))))
               >>
               (trans(u!1, car(il),
                      E(public(car(il)),
                        conc(nlist(append(nl, (: i!2 :))),
                             ilist(append(cdr(il), (: u!1 :))))))
                 >>
                 (rec(u!1, nth(il, P!1 - 2),
                      E(public(u!1), nlist((: i!2 :))))
                   >>
                   (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!2)) >>
                     Stop[event]))))
      ENDIF
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (lift-if)
Lifting IF-conditions to the top level,
this simplifies to: 
restrictmiddle_last :  

  |-------
{1}   IF i!2 = n_last
        THEN Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
                      il:
                        {x: list[Identity] |
                           length(x) = P!1 - 1 AND
                            FORALL (i: below[P!1 - 1]):
                              nth(x, i) = hu(i)}):
               (rec(u!1, nth(il, P!1 - 2),
                    E(public(u!1), conc(nlist(nl), ilist(il))))
                 >>
                 (trans(u!1, car(il),
                        E(public(car(il)),
                          conc(nlist(append(nl, (: i!2 :))),
                               ilist(append(cdr(il), (: u!1 :))))))
                   >>
                   (rec(u!1, nth(il, P!1 - 2),
                        E(public(u!1), nlist((: i!2 :))))
                     >>
                     (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!2))
                       >> Stop[event]))))
              # R_middle(i!1)
              |>
              LAMBDA (t: list[event]):
                every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))
                     (t)
                 =>
                 every(LAMBDA (e: event):
                         NOT rec?(e) => rho_middle(i!1)(msg(e)))
                      (t)
      ELSE Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
                    il: {x: list[Identity] | length(x) = P!1 - 1}):
             (rec(u!1, nth(il, P!1 - 2),
                  E(public(u!1), conc(nlist(nl), ilist(il))))
               >>
               (trans(u!1, car(il),
                      E(public(car(il)),
                        conc(nlist(append(nl, (: i!2 :))),
                             ilist(append(cdr(il), (: u!1 :))))))
                 >>
                 (rec(u!1, nth(il, P!1 - 2),
                      E(public(u!1), nlist((: i!2 :))))
                   >>
                   (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!2)) >>
                     Stop[event]))))
            # R_middle(i!1)
            |>
            LAMBDA (t: list[event]):
              every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))
                   (t)
               =>
               every(LAMBDA (e: event):
                       NOT rec?(e) => rho_middle(i!1)(msg(e)))
                    (t)
      ENDIF

Rerunning step: (typepred "P!1")
Adding type constraints for  P!1,
this simplifies to: 
restrictmiddle_last :  

{-1}  2 <= P!1
  |-------
[1]   IF i!2 = n_last
        THEN Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
                      il:
                        {x: list[Identity] |
                           length(x) = P!1 - 1 AND
                            FORALL (i: below[P!1 - 1]):
                              nth(x, i) = hu(i)}):
               (rec(u!1, nth(il, P!1 - 2),
                    E(public(u!1), conc(nlist(nl), ilist(il))))
                 >>
                 (trans(u!1, car(il),
                        E(public(car(il)),
                          conc(nlist(append(nl, (: i!2 :))),
                               ilist(append(cdr(il), (: u!1 :))))))
                   >>
                   (rec(u!1, nth(il, P!1 - 2),
                        E(public(u!1), nlist((: i!2 :))))
                     >>
                     (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!2))
                       >> Stop[event]))))
              # R_middle(i!1)
              |>
              LAMBDA (t: list[event]):
                every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))
                     (t)
                 =>
                 every(LAMBDA (e: event):
                         NOT rec?(e) => rho_middle(i!1)(msg(e)))
                      (t)
      ELSE Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
                    il: {x: list[Identity] | length(x) = P!1 - 1}):
             (rec(u!1, nth(il, P!1 - 2),
                  E(public(u!1), conc(nlist(nl), ilist(il))))
               >>
               (trans(u!1, car(il),
                      E(public(car(il)),
                        conc(nlist(append(nl, (: i!2 :))),
                             ilist(append(cdr(il), (: u!1 :))))))
                 >>
                 (rec(u!1, nth(il, P!1 - 2),
                      E(public(u!1), nlist((: i!2 :))))
                   >>
                   (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!2)) >>
                     Stop[event]))))
            # R_middle(i!1)
            |>
            LAMBDA (t: list[event]):
              every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))
                   (t)
               =>
               every(LAMBDA (e: event):
                       NOT rec?(e) => rho_middle(i!1)(msg(e)))
                    (t)
      ENDIF

Rerunning step: (prop)
Applying propositional simplification,
this yields  2 subgoals: 
restrictmiddle_last.1 :  

{-1}  i!2 = n_last
[-2]  2 <= P!1
  |-------
{1}   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    length(x) = P!1 - 1 AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!2 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!2)) >>
                Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (choice3)
Applying choice rule,
this yields  12 subgoals: 
restrictmiddle_last.1.1 :  

[-1]  i!2 = n_last
[-2]  2 <= P!1
  |-------
{1}   (rec(u!1, nth(i!3`2, P!1 - 2),
           E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
        >>
        (trans(u!1, car(i!3`2),
               E(public(car(i!3`2)),
                 conc(nlist(append(i!3`1, (: i!2 :))),
                      ilist(append(cdr(i!3`2), (: u!1 :))))))
          >>
          (rec(u!1, nth(i!3`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
            >>
            (signal(commit(P!1 - 1, append(i!3`2, (: u!1 :)), i!2)) >>
              Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (typepred "i!2")
Adding type constraints for  i!2,
this simplifies to: 
restrictmiddle_last.1.1 :  

{-1}  IRpart(P!1, u!1, P!1 - 1)(i!2)
[-2]  i!2 = n_last
[-3]  2 <= P!1
  |-------
[1]   (rec(u!1, nth(i!3`2, P!1 - 2),
           E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
        >>
        (trans(u!1, car(i!3`2),
               E(public(car(i!3`2)),
                 conc(nlist(append(i!3`1, (: i!2 :))),
                      ilist(append(cdr(i!3`2), (: u!1 :))))))
          >>
          (rec(u!1, nth(i!3`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
            >>
            (signal(commit(P!1 - 1, append(i!3`2, (: u!1 :)), i!2)) >>
              Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (lemma "n_orig" ("P" "P!1" "u" "u!1" "r" "P!1-1"))
Applying n_orig where 
  P gets P!1,
  u gets u!1,
  r gets P!1 - 1,
this simplifies to: 
restrictmiddle_last.1.1 :  

{-1}  IRpart(P!1, u!1, P!1 - 1)(n_last) =>
       (P!1 = p AND u!1 = hu(p - 1) AND P!1 - 1 = p - 1)
[-2]  IRpart(P!1, u!1, P!1 - 1)(i!2)
[-3]  i!2 = n_last
[-4]  2 <= P!1
  |-------
[1]   (rec(u!1, nth(i!3`2, P!1 - 2),
           E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
        >>
        (trans(u!1, car(i!3`2),
               E(public(car(i!3`2)),
                 conc(nlist(append(i!3`1, (: i!2 :))),
                      ilist(append(cdr(i!3`2), (: u!1 :))))))
          >>
          (rec(u!1, nth(i!3`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
            >>
            (signal(commit(P!1 - 1, append(i!3`2, (: u!1 :)), i!2)) >>
              Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,
this simplifies to: 
restrictmiddle_last.1.1 :  

{-1}  P!1 = p
{-2}  u!1 = hu(p - 1)
{-3}  P!1 = p
[-4]  IRpart(P!1, u!1, P!1 - 1)(i!2)
[-5]  i!2 = n_last
[-6]  2 <= P!1
  |-------
[1]   (rec(u!1, nth(i!3`2, P!1 - 2),
           E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
        >>
        (trans(u!1, car(i!3`2),
               E(public(car(i!3`2)),
                 conc(nlist(append(i!3`1, (: i!2 :))),
                      ilist(append(cdr(i!3`2), (: u!1 :))))))
          >>
          (rec(u!1, nth(i!3`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
            >>
            (signal(commit(P!1 - 1, append(i!3`2, (: u!1 :)), i!2)) >>
              Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.1 :  

[-1]  u!1 = hu(p - 1)
[-2]  P!1 = p
[-3]  IRpart(P!1, u!1, P!1 - 1)(i!2)
[-4]  i!2 = n_last
[-5]  2 <= P!1
  |-------
[1]   (rec(u!1, nth(i!3`2, P!1 - 2),
           E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
        >>
        (trans(u!1, car(i!3`2),
               E(public(car(i!3`2)),
                 conc(nlist(append(i!3`1, (: i!2 :))),
                      ilist(append(cdr(i!3`2), (: u!1 :))))))
          >>
          (rec(u!1, nth(i!3`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
            >>
            (signal(commit(P!1 - 1, append(i!3`2, (: u!1 :)), i!2)) >>
              Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (replace* -1 -2 -4)
Repeatedly applying the replace rule,
this simplifies to: 
restrictmiddle_last.1.1 :  

[-1]  u!1 = hu(p - 1)
[-2]  P!1 = p
{-3}  IRpart(p, hu(p - 1), p - 1)(n_last)
[-4]  i!2 = n_last
{-5}  2 <= p
  |-------
{1}   (rec(hu(p - 1), nth(i!3`2, p - 2),
           E(public(hu(p - 1)), conc(nlist(i!3`1), ilist(i!3`2))))
        >>
        (trans(hu(p - 1), car(i!3`2),
               E(public(car(i!3`2)),
                 conc(nlist(append(i!3`1, (: n_last :))),
                      ilist(append(cdr(i!3`2), (: hu(p - 1) :))))))
          >>
          (rec(hu(p - 1), nth(i!3`2, p - 2),
               E(public(hu(p - 1)), nlist((: n_last :))))
            >>
            (signal(commit(p - 1, append(i!3`2, (: hu(p - 1) :)), n_last))
              >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -3 -4)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.1 :  

[-1]  P!1 = p
[-2]  2 <= p
  |-------
[1]   (rec(hu(p - 1), nth(i!3`2, p - 2),
           E(public(hu(p - 1)), conc(nlist(i!3`1), ilist(i!3`2))))
        >>
        (trans(hu(p - 1), car(i!3`2),
               E(public(car(i!3`2)),
                 conc(nlist(append(i!3`1, (: n_last :))),
                      ilist(append(cdr(i!3`2), (: hu(p - 1) :))))))
          >>
          (rec(hu(p - 1), nth(i!3`2, p - 2),
               E(public(hu(p - 1)), nlist((: n_last :))))
            >>
            (signal(commit(p - 1, append(i!3`2, (: hu(p - 1) :)), n_last))
              >> Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictmiddle_last.1.1 :  

{-1}  rho_middle(i!1)
                (E(public(hu(p - 1)), conc(nlist(i!3`1), ilist(i!3`2))))
[-2]  P!1 = p
[-3]  2 <= p
  |-------
{1}   ((trans(hu(p - 1), car(i!3`2),
              E(public(car(i!3`2)),
                conc(nlist(append(i!3`1, (: n_last :))),
                     ilist(append(cdr(i!3`2), (: hu(p - 1) :))))))
         >>
         (rec(hu(p - 1), nth(i!3`2, p - 2),
              E(public(hu(p - 1)), nlist((: n_last :))))
           >>
           (signal(commit(p - 1, append(i!3`2, (: hu(p - 1) :)), n_last))
             >> Stop[event])))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (rec(hu(p - 1), nth(i!3`2, p - 2),
                   E(public(hu(p - 1)), conc(nlist(i!3`1), ilist(i!3`2)))))
{3}   rec(hu(p - 1), nth(i!3`2, p - 2),
          E(public(hu(p - 1)), conc(nlist(i!3`1), ilist(i!3`2))))
       >>
       ((trans(hu(p - 1), car(i!3`2),
               E(public(car(i!3`2)),
                 conc(nlist(append(i!3`1, (: n_last :))),
                      ilist(append(cdr(i!3`2), (: hu(p - 1) :))))))
          >>
          (rec(hu(p - 1), nth(i!3`2, p - 2),
               E(public(hu(p - 1)), nlist((: n_last :))))
            >>
            (signal(commit(p - 1, append(i!3`2, (: hu(p - 1) :)), n_last))
              >> Stop[event])))
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.1 :  

[-1]  rho_middle(i!1)
                (E(public(hu(p - 1)), conc(nlist(i!3`1), ilist(i!3`2))))
[-2]  P!1 = p
[-3]  2 <= p
  |-------
[1]   ((trans(hu(p - 1), car(i!3`2),
              E(public(car(i!3`2)),
                conc(nlist(append(i!3`1, (: n_last :))),
                     ilist(append(cdr(i!3`2), (: hu(p - 1) :))))))
         >>
         (rec(hu(p - 1), nth(i!3`2, p - 2),
              E(public(hu(p - 1)), nlist((: n_last :))))
           >>
           (signal(commit(p - 1, append(i!3`2, (: hu(p - 1) :)), n_last))
             >> Stop[event])))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictmiddle_last.1.1.1 :  

[-1]  rho_middle(i!1)
                (E(public(hu(p - 1)), conc(nlist(i!3`1), ilist(i!3`2))))
[-2]  P!1 = p
[-3]  2 <= p
  |-------
{1}   rho_middle(i!1)
                (E(public(car(i!3`2)),
                   conc(nlist(append(i!3`1, (: n_last :))),
                        ilist(append(cdr(i!3`2), (: hu(p - 1) :))))))
{2}   R_middle(i!1)
              (trans(hu(p - 1), car(i!3`2),
                     E(public(car(i!3`2)),
                       conc(nlist(append(i!3`1, (: n_last :))),
                            ilist(append(cdr(i!3`2), (: hu(p - 1) :)))))))
{3}   trans(hu(p - 1), car(i!3`2),
            E(public(car(i!3`2)),
              conc(nlist(append(i!3`1, (: n_last :))),
                   ilist(append(cdr(i!3`2), (: hu(p - 1) :))))))
       >>
       ((rec(hu(p - 1), nth(i!3`2, p - 2),
             E(public(hu(p - 1)), nlist((: n_last :))))
          >>
          (signal(commit(p - 1, append(i!3`2, (: hu(p - 1) :)), n_last)) >>
            Stop[event]))
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.1.1 :  

[-1]  rho_middle(i!1)
                (E(public(hu(p - 1)), conc(nlist(i!3`1), ilist(i!3`2))))
[-2]  P!1 = p
[-3]  2 <= p
  |-------
[1]   rho_middle(i!1)
                (E(public(car(i!3`2)),
                   conc(nlist(append(i!3`1, (: n_last :))),
                        ilist(append(cdr(i!3`2), (: hu(p - 1) :))))))

Rerunning step: (typepred "i!3`1" "i!3`2" "hu_list" "i!1")
Adding type constraints for  i!3`1, i!3`2, hu_list, i!1,
this simplifies to: 
restrictmiddle_last.1.1.1 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`1)
{-2}  length(i!3`1) = P!1 - 1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`2)
{-4}  length(i!3`2) = P!1 - 1
{-5}  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
{-6}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-7}  (length(hu_list) = p)
{-8}  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
{-9}  0 < i!1
{-10} i!1 < p - 1
[-11] rho_middle(i!1)
                (E(public(hu(p - 1)), conc(nlist(i!3`1), ilist(i!3`2))))
[-12] P!1 = p
[-13] 2 <= p
  |-------
[1]   rho_middle(i!1)
                (E(public(car(i!3`2)),
                   conc(nlist(append(i!3`1, (: n_last :))),
                        ilist(append(cdr(i!3`2), (: hu(p - 1) :))))))

Rerunning step: (delete -1 -3 -6 -11)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.1.1 :  

[-1]  length(i!3`1) = P!1 - 1
[-2]  length(i!3`2) = P!1 - 1
[-3]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  0 < i!1
[-7]  i!1 < p - 1
[-8]  P!1 = p
[-9]  2 <= p
  |-------
[1]   rho_middle(i!1)
                (E(public(car(i!3`2)),
                   conc(nlist(append(i!3`1, (: n_last :))),
                        ilist(append(cdr(i!3`2), (: hu(p - 1) :))))))

Rerunning step: (expand "E")
Expanding the definition of E,
this simplifies to: 
restrictmiddle_last.1.1.1 :  

[-1]  length(i!3`1) = P!1 - 1
[-2]  length(i!3`2) = P!1 - 1
[-3]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  0 < i!1
[-7]  i!1 < p - 1
[-8]  P!1 = p
[-9]  2 <= p
  |-------
{1}   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(nlist(append(i!3`1, (: n_last :))),
                           ilist(append(cdr(i!3`2), (: hu(p - 1) :))))))

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
restrictmiddle_last.1.1.1 :  

[-1]  length(i!3`1) = P!1 - 1
[-2]  length(i!3`2) = P!1 - 1
[-3]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  0 < i!1
[-7]  i!1 < p - 1
[-8]  P!1 = p
[-9]  2 <= p
  |-------
{1}   rho_middle(i!1)
                (conc(nlist(append(i!3`1, (: n_last :))),
                      ilist(append(cdr(i!3`2), (: hu(p - 1) :)))))
       OR
       (public(car(i!3`2)) = public(hu(0)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
           conc(nlist(append(i!3`1, (: n_last :))),
                ilist(append(cdr(i!3`2), (: hu(p - 1) :))))
            = conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
        OR
        EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
          public(car(i!3`2)) = public(hu(j)) AND
           EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
             conc(nlist(append(i!3`1, (: n_last :))),
                  ilist(append(cdr(i!3`2), (: hu(p - 1) :))))
              =
              conc(ilist(remove(hu_list, j)),
                   nlist(append(nl, (: n_last :))))

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
restrictmiddle_last.1.1.1 :  

[-1]  length(i!3`1) = P!1 - 1
[-2]  length(i!3`2) = P!1 - 1
[-3]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  0 < i!1
[-7]  i!1 < p - 1
[-8]  P!1 = p
[-9]  2 <= p
  |-------
{1}   rho_middle(i!1)
                (conc(nlist(append(i!3`1, (: n_last :))),
                      ilist(append(cdr(i!3`2), (: hu(p - 1) :)))))
{2}   (public(car(i!3`2)) = public(hu(0)) AND
        EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
          conc(nlist(append(i!3`1, (: n_last :))),
               ilist(append(cdr(i!3`2), (: hu(p - 1) :))))
           = conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
{3}   EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
        public(car(i!3`2)) = public(hu(j)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
           conc(nlist(append(i!3`1, (: n_last :))),
                ilist(append(cdr(i!3`2), (: hu(p - 1) :))))
            =
            conc(ilist(remove(hu_list, j)), nlist(append(nl, (: n_last :))))

Rerunning step: (delete 1 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.1.1 :  

[-1]  length(i!3`1) = P!1 - 1
[-2]  length(i!3`2) = P!1 - 1
[-3]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  0 < i!1
[-7]  i!1 < p - 1
[-8]  P!1 = p
[-9]  2 <= p
  |-------
[1]   (public(car(i!3`2)) = public(hu(0)) AND
        EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
          conc(nlist(append(i!3`1, (: n_last :))),
               ilist(append(cdr(i!3`2), (: hu(p - 1) :))))
           = conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
restrictmiddle_last.1.1.1.1 :  

[-1]  length(i!3`1) = P!1 - 1
[-2]  length(i!3`2) = P!1 - 1
[-3]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  0 < i!1
[-7]  i!1 < p - 1
[-8]  P!1 = p
[-9]  2 <= p
  |-------
{1}   public(car(i!3`2)) = public(hu(0))

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_last.1.1.1.1 :  

[-1]  length(i!3`1) = P!1 - 1
[-2]  length(i!3`2) = P!1 - 1
[-3]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  0 < i!1
[-7]  i!1 < p - 1
[-8]  P!1 = p
[-9]  2 <= p
  |-------
{1}   car(i!3`2) = hu(0)

Rerunning step: (inst -3 "0")
Instantiating the top quantifier in -3 with the terms: 
 0,
this simplifies to: 
restrictmiddle_last.1.1.1.1 :  

[-1]  length(i!3`1) = P!1 - 1
[-2]  length(i!3`2) = P!1 - 1
{-3}  nth(i!3`2, 0) = hu(0)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  0 < i!1
[-7]  i!1 < p - 1
[-8]  P!1 = p
[-9]  2 <= p
  |-------
[1]   car(i!3`2) = hu(0)

Rerunning step: (replace -3 1 rl)
Replacing using formula -3,
this simplifies to: 
restrictmiddle_last.1.1.1.1 :  

[-1]  length(i!3`1) = P!1 - 1
[-2]  length(i!3`2) = P!1 - 1
[-3]  nth(i!3`2, 0) = hu(0)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  0 < i!1
[-7]  i!1 < p - 1
[-8]  P!1 = p
[-9]  2 <= p
  |-------
{1}   car(i!3`2) = nth(i!3`2, 0)

Rerunning step: (expand "nth" 1)
Expanding the definition of nth,
this simplifies to: 
restrictmiddle_last.1.1.1.1 :  

[-1]  length(i!3`1) = P!1 - 1
[-2]  length(i!3`2) = P!1 - 1
[-3]  nth(i!3`2, 0) = hu(0)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  0 < i!1
[-7]  i!1 < p - 1
[-8]  P!1 = p
[-9]  2 <= p
  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictmiddle_last.1.1.1.1.

restrictmiddle_last.1.1.1.2 :  

[-1]  length(i!3`1) = P!1 - 1
[-2]  length(i!3`2) = P!1 - 1
[-3]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  0 < i!1
[-7]  i!1 < p - 1
[-8]  P!1 = p
[-9]  2 <= p
  |-------
{1}   EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
        conc(nlist(append(i!3`1, (: n_last :))),
             ilist(append(cdr(i!3`2), (: hu(p - 1) :))))
         = conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list)))

Rerunning step: (inst 1 "i!3`1")
Instantiating the top quantifier in 1 with the terms: 
 i!3`1,
this simplifies to: 
restrictmiddle_last.1.1.1.2 :  

[-1]  length(i!3`1) = P!1 - 1
[-2]  length(i!3`2) = P!1 - 1
[-3]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  0 < i!1
[-7]  i!1 < p - 1
[-8]  P!1 = p
[-9]  2 <= p
  |-------
{1}   conc(nlist(append(i!3`1, (: n_last :))),
           ilist(append(cdr(i!3`2), (: hu(p - 1) :))))
       = conc(nlist(append(i!3`1, (: n_last :))), ilist(cdr(hu_list)))

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_last.1.1.1.2 :  

[-1]  length(i!3`1) = P!1 - 1
[-2]  length(i!3`2) = P!1 - 1
[-3]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  0 < i!1
[-7]  i!1 < p - 1
[-8]  P!1 = p
[-9]  2 <= p
  |-------
{1}   ilist(append(cdr(i!3`2), (: hu(p - 1) :))) = ilist(cdr(hu_list))

Rerunning step: (decompose-equality 1)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_last.1.1.1.2 :  

[-1]  length(i!3`1) = P!1 - 1
[-2]  length(i!3`2) = P!1 - 1
[-3]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  0 < i!1
[-7]  i!1 < p - 1
[-8]  P!1 = p
[-9]  2 <= p
  |-------
{1}   append(cdr(i!3`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (case "length(append(cdr(i!3`2),(:hu(p-1):)))=p-1")
Case splitting on 
   length(append(cdr(i!3`2), (: hu(p - 1) :))) = p - 1, 
this yields  2 subgoals: 
restrictmiddle_last.1.1.1.2.1 :  

{-1}  length(append(cdr(i!3`2), (: hu(p - 1) :))) = p - 1
[-2]  length(i!3`1) = P!1 - 1
[-3]  length(i!3`2) = P!1 - 1
[-4]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  0 < i!1
[-8]  i!1 < p - 1
[-9]  P!1 = p
[-10] 2 <= p
  |-------
[1]   append(cdr(i!3`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (rewrite "length_nth_equality[Identity]")
Found matching substitution:
l2: list[Identity] gets cdr(hu_list),
l1: list[Identity] gets append(cdr(i!3`2), (: hu(p - 1) :)),
Rewriting using length_nth_equality[Identity], matching in *,
this yields  2 subgoals: 
restrictmiddle_last.1.1.1.2.1.1 :  

[-1]  length(append(cdr(i!3`2), (: hu(p - 1) :))) = p - 1
[-2]  length(i!3`1) = P!1 - 1
[-3]  length(i!3`2) = P!1 - 1
[-4]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  0 < i!1
[-8]  i!1 < p - 1
[-9]  P!1 = p
[-10] 2 <= p
  |-------
{1}   length[Identity](append(cdr(i!3`2), (: hu(p - 1) :))) =
       length[Identity](cdr(hu_list))
[2]   append(cdr(i!3`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (rewrite "length_cdr" 1)
Found matching substitution:
cons_l: (cons?[T]) gets hu_list,
Rewriting using length_cdr, matching in 1,
this simplifies to: 
restrictmiddle_last.1.1.1.2.1.1 :  

[-1]  length(append(cdr(i!3`2), (: hu(p - 1) :))) = p - 1
[-2]  length(i!3`1) = P!1 - 1
[-3]  length(i!3`2) = P!1 - 1
[-4]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  0 < i!1
[-8]  i!1 < p - 1
[-9]  P!1 = p
[-10] 2 <= p
  |-------
{1}   length[Identity](append(cdr(i!3`2), (: hu(p - 1) :))) =
       length(hu_list) - 1
[2]   append(cdr(i!3`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (delete -2 -3 -4 -6 -7 -8 -9 -10 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.1.1.2.1.1 :  

[-1]  length(append(cdr(i!3`2), (: hu(p - 1) :))) = p - 1
[-2]  (length(hu_list) = p)
  |-------
[1]   length[Identity](append(cdr(i!3`2), (: hu(p - 1) :))) =
       length(hu_list) - 1

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_last.1.1.1.2.1.1.

restrictmiddle_last.1.1.1.2.1.2 :  

[-1]  length(append(cdr(i!3`2), (: hu(p - 1) :))) = p - 1
[-2]  length(i!3`1) = P!1 - 1
[-3]  length(i!3`2) = P!1 - 1
[-4]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  0 < i!1
[-8]  i!1 < p - 1
[-9]  P!1 = p
[-10] 2 <= p
  |-------
{1}   FORALL (i:
                below[length[Identity]
                          (append(cdr(i!3`2), (: hu(p - 1) :)))]):
        nth(append(cdr(i!3`2), (: hu(p - 1) :)), i) = nth(cdr(hu_list), i)
[2]   append(cdr(i!3`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictmiddle_last.1.1.1.2.1.2 :  

{-1}  i!4 < length[Identity](append(cdr(i!3`2), (: hu(p - 1) :)))
[-2]  length(append(cdr(i!3`2), (: hu(p - 1) :))) = p - 1
[-3]  length(i!3`1) = P!1 - 1
[-4]  length(i!3`2) = P!1 - 1
[-5]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  0 < i!1
[-9]  i!1 < p - 1
[-10] P!1 = p
[-11] 2 <= p
  |-------
{1}   nth(append(cdr(i!3`2), (: hu(p - 1) :)), i!4) = nth(cdr(hu_list), i!4)
[2]   append(cdr(i!3`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (lemma "listprops[Identity].nth_append"
                 ("l1" "cdr(i!3`2)" "l2" "(:hu(p-1):)" "i" "i!4"))
Applying listprops[Identity].nth_append where 
  l1 gets cdr(i!3`2),
  l2 gets (: hu(p - 1) :),
  i gets i!4,
this yields  2 subgoals: 
restrictmiddle_last.1.1.1.2.1.2.1 :  

{-1}  nth(append(cdr(i!3`2), (: hu(p - 1) :)), i!4) =
       IF i!4 < length[Identity](cdr(i!3`2)) THEN nth(cdr(i!3`2), i!4)
       ELSE nth((: hu(p - 1) :), i!4 - length[Identity](cdr(i!3`2)))
       ENDIF
[-2]  i!4 < length[Identity](append(cdr(i!3`2), (: hu(p - 1) :)))
[-3]  length(append(cdr(i!3`2), (: hu(p - 1) :))) = p - 1
[-4]  length(i!3`1) = P!1 - 1
[-5]  length(i!3`2) = P!1 - 1
[-6]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] P!1 = p
[-12] 2 <= p
  |-------
[1]   nth(append(cdr(i!3`2), (: hu(p - 1) :)), i!4) = nth(cdr(hu_list), i!4)
[2]   append(cdr(i!3`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictmiddle_last.1.1.1.2.1.2.1 :  

[-1]  nth(append(cdr(i!3`2), (: hu(p - 1) :)), i!4) =
       IF i!4 < length[Identity](cdr(i!3`2)) THEN nth(cdr(i!3`2), i!4)
       ELSE nth((: hu(p - 1) :), i!4 - length[Identity](cdr(i!3`2)))
       ENDIF
[-2]  i!4 < length[Identity](append(cdr(i!3`2), (: hu(p - 1) :)))
[-3]  length(append(cdr(i!3`2), (: hu(p - 1) :))) = p - 1
[-4]  length(i!3`1) = P!1 - 1
[-5]  length(i!3`2) = P!1 - 1
[-6]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] P!1 = p
[-12] 2 <= p
  |-------
{1}   IF i!4 < length[Identity](cdr(i!3`2)) THEN nth(cdr(i!3`2), i!4)
      ELSE nth((: hu(p - 1) :), i!4 - length[Identity](cdr(i!3`2)))
      ENDIF
       = nth(cdr(hu_list), i!4)
[2]   append(cdr(i!3`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (delete -1 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.1.1.2.1.2.1 :  

[-1]  i!4 < length[Identity](append(cdr(i!3`2), (: hu(p - 1) :)))
[-2]  length(append(cdr(i!3`2), (: hu(p - 1) :))) = p - 1
[-3]  length(i!3`1) = P!1 - 1
[-4]  length(i!3`2) = P!1 - 1
[-5]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  0 < i!1
[-9]  i!1 < p - 1
[-10] P!1 = p
[-11] 2 <= p
  |-------
[1]   IF i!4 < length[Identity](cdr(i!3`2)) THEN nth(cdr(i!3`2), i!4)
      ELSE nth((: hu(p - 1) :), i!4 - length[Identity](cdr(i!3`2)))
      ENDIF
       = nth(cdr(hu_list), i!4)

Rerunning step: (rewrite "length_cdr" 1)
Found matching substitution:
cons_l: (cons?[T]) gets i!3`2,
Rewriting using length_cdr, matching in 1,
this simplifies to: 
restrictmiddle_last.1.1.1.2.1.2.1 :  

[-1]  i!4 < length[Identity](append(cdr(i!3`2), (: hu(p - 1) :)))
[-2]  length(append(cdr(i!3`2), (: hu(p - 1) :))) = p - 1
[-3]  length(i!3`1) = P!1 - 1
[-4]  length(i!3`2) = P!1 - 1
[-5]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  0 < i!1
[-9]  i!1 < p - 1
[-10] P!1 = p
[-11] 2 <= p
  |-------
{1}   IF i!4 < length(i!3`2) - 1 THEN nth(cdr(i!3`2), i!4)
      ELSE nth((: hu(p - 1) :), i!4 - (length(i!3`2) - 1))
      ENDIF
       = nth(cdr(hu_list), i!4)

Rerunning step: (lemma "nth_cdr" ("c" "hu_list" "i" "i!4"))
Using instance
  listprops[Identity].nth_cdr
Applying nth_cdr where 
  c gets hu_list,
  i gets i!4,
this simplifies to: 
restrictmiddle_last.1.1.1.2.1.2.1 :  

{-1}  nth(cdr(hu_list), i!4) = nth(hu_list, i!4 + 1)
[-2]  i!4 < length[Identity](append(cdr(i!3`2), (: hu(p - 1) :)))
[-3]  length(append(cdr(i!3`2), (: hu(p - 1) :))) = p - 1
[-4]  length(i!3`1) = P!1 - 1
[-5]  length(i!3`2) = P!1 - 1
[-6]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] P!1 = p
[-12] 2 <= p
  |-------
[1]   IF i!4 < length(i!3`2) - 1 THEN nth(cdr(i!3`2), i!4)
      ELSE nth((: hu(p - 1) :), i!4 - (length(i!3`2) - 1))
      ENDIF
       = nth(cdr(hu_list), i!4)

Rerunning step: (replace -1 1)
Replacing using formula -1,
this simplifies to: 
restrictmiddle_last.1.1.1.2.1.2.1 :  

[-1]  nth(cdr(hu_list), i!4) = nth(hu_list, i!4 + 1)
[-2]  i!4 < length[Identity](append(cdr(i!3`2), (: hu(p - 1) :)))
[-3]  length(append(cdr(i!3`2), (: hu(p - 1) :))) = p - 1
[-4]  length(i!3`1) = P!1 - 1
[-5]  length(i!3`2) = P!1 - 1
[-6]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-7]  (length(hu_list) = p)
[-8]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] P!1 = p
[-12] 2 <= p
  |-------
{1}   IF i!4 < length(i!3`2) - 1 THEN nth(cdr(i!3`2), i!4)
      ELSE nth((: hu(p - 1) :), i!4 - (length(i!3`2) - 1))
      ENDIF
       = nth(hu_list, i!4 + 1)

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.1.1.2.1.2.1 :  

[-1]  i!4 < length[Identity](append(cdr(i!3`2), (: hu(p - 1) :)))
[-2]  length(append(cdr(i!3`2), (: hu(p - 1) :))) = p - 1
[-3]  length(i!3`1) = P!1 - 1
[-4]  length(i!3`2) = P!1 - 1
[-5]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  0 < i!1
[-9]  i!1 < p - 1
[-10] P!1 = p
[-11] 2 <= p
  |-------
[1]   IF i!4 < length(i!3`2) - 1 THEN nth(cdr(i!3`2), i!4)
      ELSE nth((: hu(p - 1) :), i!4 - (length(i!3`2) - 1))
      ENDIF
       = nth(hu_list, i!4 + 1)

Rerunning step: (inst -7 "i!4+1")
Instantiating the top quantifier in -7 with the terms: 
 i!4+1,
this simplifies to: 
restrictmiddle_last.1.1.1.2.1.2.1 :  

[-1]  i!4 < length[Identity](append(cdr(i!3`2), (: hu(p - 1) :)))
[-2]  length(append(cdr(i!3`2), (: hu(p - 1) :))) = p - 1
[-3]  length(i!3`1) = P!1 - 1
[-4]  length(i!3`2) = P!1 - 1
[-5]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-6]  (length(hu_list) = p)
{-7}  nth(hu_list, i!4 + 1) = hu(i!4 + 1)
[-8]  0 < i!1
[-9]  i!1 < p - 1
[-10] P!1 = p
[-11] 2 <= p
  |-------
[1]   IF i!4 < length(i!3`2) - 1 THEN nth(cdr(i!3`2), i!4)
      ELSE nth((: hu(p - 1) :), i!4 - (length(i!3`2) - 1))
      ENDIF
       = nth(hu_list, i!4 + 1)

Rerunning step: (case "i!4<p-2 OR i!4=p-2")
Case splitting on 
   i!4 < p - 2 OR i!4 = p - 2, 
this yields  2 subgoals: 
restrictmiddle_last.1.1.1.2.1.2.1.1 :  

{-1}  i!4 < p - 2 OR i!4 = p - 2
[-2]  i!4 < length[Identity](append(cdr(i!3`2), (: hu(p - 1) :)))
[-3]  length(append(cdr(i!3`2), (: hu(p - 1) :))) = p - 1
[-4]  length(i!3`1) = P!1 - 1
[-5]  length(i!3`2) = P!1 - 1
[-6]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-7]  (length(hu_list) = p)
[-8]  nth(hu_list, i!4 + 1) = hu(i!4 + 1)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] P!1 = p
[-12] 2 <= p
  |-------
[1]   IF i!4 < length(i!3`2) - 1 THEN nth(cdr(i!3`2), i!4)
      ELSE nth((: hu(p - 1) :), i!4 - (length(i!3`2) - 1))
      ENDIF
       = nth(hu_list, i!4 + 1)

Rerunning step: (grind :exclude "nth")
Trying repeated skolemization, instantiation, and if-lifting,
this yields  2 subgoals: 
restrictmiddle_last.1.1.1.2.1.2.1.1.1 :  

{-1}  i!4 < p - 2
{-2}  i!4 < p - 1
[-3]  length(append(cdr(i!3`2), (: hu(p - 1) :))) = p - 1
{-4}  length(i!3`1) = p - 1
{-5}  length(i!3`2) = p - 1
{-6}  nth(i!3`2, 1 + i!4) = hu(1 + i!4)
[-7]  (length(hu_list) = p)
{-8}  nth(hu_list, 1 + i!4) = hu(1 + i!4)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] P!1 = p
[-12] 2 <= p
  |-------
{1}   nth(cdr(i!3`2), i!4) = hu(1 + i!4)

Rerunning step: (expand "nth" -6)
Expanding the definition of nth,
this simplifies to: 
restrictmiddle_last.1.1.1.2.1.2.1.1.1 :  

[-1]  i!4 < p - 2
[-2]  i!4 < p - 1
[-3]  length(append(cdr(i!3`2), (: hu(p - 1) :))) = p - 1
[-4]  length(i!3`1) = p - 1
[-5]  length(i!3`2) = p - 1
{-6}  nth(cdr(i!3`2), i!4) = hu(1 + i!4)
[-7]  (length(hu_list) = p)
[-8]  nth(hu_list, 1 + i!4) = hu(1 + i!4)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] P!1 = p
[-12] 2 <= p
  |-------
[1]   nth(cdr(i!3`2), i!4) = hu(1 + i!4)

which is trivially true.

This completes the proof of restrictmiddle_last.1.1.1.2.1.2.1.1.1.

restrictmiddle_last.1.1.1.2.1.2.1.1.2 :  

{-1}  i!4 = p - 2
{-2}  p - 2 < p - 1
[-3]  length(append(cdr(i!3`2), (: hu(p - 1) :))) = p - 1
{-4}  length(i!3`1) = p - 1
{-5}  length(i!3`2) = p - 1
[-6]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-7]  (length(hu_list) = p)
{-8}  nth(hu_list, p - 1) = hu(p - 1)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] P!1 = p
[-12] 2 <= p
  |-------
{1}   nth((: hu(p - 1) :), 0) = hu(p - 1)

Rerunning step: (expand "nth" 1)
Expanding the definition of nth,
this simplifies to: 
restrictmiddle_last.1.1.1.2.1.2.1.1.2 :  

[-1]  i!4 = p - 2
[-2]  p - 2 < p - 1
[-3]  length(append(cdr(i!3`2), (: hu(p - 1) :))) = p - 1
[-4]  length(i!3`1) = p - 1
[-5]  length(i!3`2) = p - 1
[-6]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-7]  (length(hu_list) = p)
[-8]  nth(hu_list, p - 1) = hu(p - 1)
[-9]  0 < i!1
[-10] i!1 < p - 1
[-11] P!1 = p
[-12] 2 <= p
  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictmiddle_last.1.1.1.2.1.2.1.1.2.


This completes the proof of restrictmiddle_last.1.1.1.2.1.2.1.1.

restrictmiddle_last.1.1.1.2.1.2.1.2 :  

[-1]  i!4 < length[Identity](append(cdr(i!3`2), (: hu(p - 1) :)))
[-2]  length(append(cdr(i!3`2), (: hu(p - 1) :))) = p - 1
[-3]  length(i!3`1) = P!1 - 1
[-4]  length(i!3`2) = P!1 - 1
[-5]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-6]  (length(hu_list) = p)
[-7]  nth(hu_list, i!4 + 1) = hu(i!4 + 1)
[-8]  0 < i!1
[-9]  i!1 < p - 1
[-10] P!1 = p
[-11] 2 <= p
  |-------
{1}   i!4 < p - 2 OR i!4 = p - 2
[2]   IF i!4 < length(i!3`2) - 1 THEN nth(cdr(i!3`2), i!4)
      ELSE nth((: hu(p - 1) :), i!4 - (length(i!3`2) - 1))
      ENDIF
       = nth(hu_list, i!4 + 1)

Rerunning step: (delete -3 -4 -5 -6 -7 -8 -9 -10 -11 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.1.1.2.1.2.1.2 :  

[-1]  i!4 < length[Identity](append(cdr(i!3`2), (: hu(p - 1) :)))
[-2]  length(append(cdr(i!3`2), (: hu(p - 1) :))) = p - 1
  |-------
[1]   i!4 < p - 2 OR i!4 = p - 2

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_last.1.1.1.2.1.2.1.2.


This completes the proof of restrictmiddle_last.1.1.1.2.1.2.1.

restrictmiddle_last.1.1.1.2.1.2.2T (TCC):   

[-1]  i!4 < length[Identity](append(cdr(i!3`2), (: hu(p - 1) :)))
[-2]  length(append(cdr(i!3`2), (: hu(p - 1) :))) = p - 1
[-3]  length(i!3`1) = P!1 - 1
[-4]  length(i!3`2) = P!1 - 1
[-5]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-6]  (length(hu_list) = p)
[-7]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-8]  0 < i!1
[-9]  i!1 < p - 1
[-10] P!1 = p
[-11] 2 <= p
  |-------
{1}   i!4 <
       length[Identity](cdr[Identity](i!3`2)) +
        length[Identity]((: hu(p - 1) :))
[2]   nth(append(cdr(i!3`2), (: hu(p - 1) :)), i!4) = nth(cdr(hu_list), i!4)
[3]   append(cdr(i!3`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (delete -2 -3 -4 -5 -6 -7 -8 -9 -10 -11 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.1.1.2.1.2.2T :  

[-1]  i!4 < length[Identity](append(cdr(i!3`2), (: hu(p - 1) :)))
  |-------
[1]   i!4 <
       length[Identity](cdr[Identity](i!3`2)) +
        length[Identity]((: hu(p - 1) :))

Rerunning step: (rewrite "length_append" -1)
Found matching substitution:
l2: list[T] gets (: hu(p - 1) :),
l1: list[T] gets cdr(i!3`2),
Rewriting using length_append, matching in -1,

This completes the proof of restrictmiddle_last.1.1.1.2.1.2.2T.


This completes the proof of restrictmiddle_last.1.1.1.2.1.2.


This completes the proof of restrictmiddle_last.1.1.1.2.1.

restrictmiddle_last.1.1.1.2.2 :  

[-1]  length(i!3`1) = P!1 - 1
[-2]  length(i!3`2) = P!1 - 1
[-3]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  0 < i!1
[-7]  i!1 < p - 1
[-8]  P!1 = p
[-9]  2 <= p
  |-------
{1}   length(append(cdr(i!3`2), (: hu(p - 1) :))) = p - 1
[2]   append(cdr(i!3`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (rewrite "length_append" 1)
Found matching substitution:
l2: list[T] gets (: hu(p - 1) :),
l1: list[T] gets cdr(i!3`2),
Rewriting using length_append, matching in 1,
this simplifies to: 
restrictmiddle_last.1.1.1.2.2 :  

[-1]  length(i!3`1) = P!1 - 1
[-2]  length(i!3`2) = P!1 - 1
[-3]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  0 < i!1
[-7]  i!1 < p - 1
[-8]  P!1 = p
[-9]  2 <= p
  |-------
{1}   length(cdr(i!3`2)) + length((: hu(p - 1) :)) = p - 1
[2]   append(cdr(i!3`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (rewrite "length_cdr" 1)
Found matching substitution:
cons_l: (cons?[T]) gets i!3`2,
Rewriting using length_cdr, matching in 1,
this simplifies to: 
restrictmiddle_last.1.1.1.2.2 :  

[-1]  length(i!3`1) = P!1 - 1
[-2]  length(i!3`2) = P!1 - 1
[-3]  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  0 < i!1
[-7]  i!1 < p - 1
[-8]  P!1 = p
[-9]  2 <= p
  |-------
{1}   length(i!3`2) - 1 + length((: hu(p - 1) :)) = p - 1
[2]   append(cdr(i!3`2), (: hu(p - 1) :)) = cdr(hu_list)

Rerunning step: (delete -1 -3 -4 -5 -6 -7 -9 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.1.1.2.2 :  

[-1]  length(i!3`2) = P!1 - 1
[-2]  P!1 = p
  |-------
[1]   length(i!3`2) - 1 + length((: hu(p - 1) :)) = p - 1

Rerunning step: (grind)
length rewrites length[Identity]((: :))
  to 0
length rewrites length((: hu(p - 1) :))
  to 1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_last.1.1.1.2.2.


This completes the proof of restrictmiddle_last.1.1.1.2.


This completes the proof of restrictmiddle_last.1.1.1.

restrictmiddle_last.1.1.2 :  

[-1]  rho_middle(i!1)
                (E(public(hu(p - 1)), conc(nlist(i!3`1), ilist(i!3`2))))
[-2]  P!1 = p
[-3]  2 <= p
  |-------
{1}   ((rec(hu(p - 1), nth(i!3`2, p - 2),
            E(public(hu(p - 1)), nlist((: n_last :))))
         >>
         (signal(commit(p - 1, append(i!3`2, (: hu(p - 1) :)), n_last)) >>
           Stop[event]))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (trans(hu(p - 1), car(i!3`2),
                     E(public(car(i!3`2)),
                       conc(nlist(append(i!3`1, (: n_last :))),
                            ilist(append(cdr(i!3`2), (: hu(p - 1) :)))))))
{3}   trans(hu(p - 1), car(i!3`2),
            E(public(car(i!3`2)),
              conc(nlist(append(i!3`1, (: n_last :))),
                   ilist(append(cdr(i!3`2), (: hu(p - 1) :))))))
       >>
       ((rec(hu(p - 1), nth(i!3`2, p - 2),
             E(public(hu(p - 1)), nlist((: n_last :))))
          >>
          (signal(commit(p - 1, append(i!3`2, (: hu(p - 1) :)), n_last)) >>
            Stop[event]))
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.1.2 :  

[-1]  rho_middle(i!1)
                (E(public(hu(p - 1)), conc(nlist(i!3`1), ilist(i!3`2))))
[-2]  P!1 = p
[-3]  2 <= p
  |-------
[1]   ((rec(hu(p - 1), nth(i!3`2, p - 2),
            E(public(hu(p - 1)), nlist((: n_last :))))
         >>
         (signal(commit(p - 1, append(i!3`2, (: hu(p - 1) :)), n_last)) >>
           Stop[event]))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictmiddle_last.1.1.2 :  

{-1}  rho_middle(i!1)(E(public(hu(p - 1)), nlist((: n_last :))))
[-2]  rho_middle(i!1)
                (E(public(hu(p - 1)), conc(nlist(i!3`1), ilist(i!3`2))))
[-3]  P!1 = p
[-4]  2 <= p
  |-------
{1}   ((signal(commit(p - 1, append(i!3`2, (: hu(p - 1) :)), n_last)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (rec(hu(p - 1), nth(i!3`2, p - 2),
                   E(public(hu(p - 1)), nlist((: n_last :)))))
{3}   rec(hu(p - 1), nth(i!3`2, p - 2),
          E(public(hu(p - 1)), nlist((: n_last :))))
       >>
       ((signal(commit(p - 1, append(i!3`2, (: hu(p - 1) :)), n_last)) >>
          Stop[event])
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -2 +)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.1.2 :  

[-1]  rho_middle(i!1)(E(public(hu(p - 1)), nlist((: n_last :))))
[-2]  P!1 = p
[-3]  2 <= p
  |-------

Rerunning step: (grind :if-match nil)
E rewrites E(public(hu(p - 1)), nlist((: n_last :)))
  to code(public(hu(p - 1)), nlist((: n_last :)))
elt rewrites elt((: n_last :), n_last)
  to EXISTS (i: below[length((: n_last :))]): nth((: n_last :), i) = n_last
rho_middle rewrites rho_middle(i!1)(nlist((: n_last :)))
  to NOT EXISTS (i: below[length((: n_last :))]):
            nth((: n_last :), i) = n_last
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites 
  rho_middle(i!1)(code(public(hu(p - 1)), nlist((: n_last :))))
  to NOT EXISTS (i: below[length((: n_last :))]):
            nth((: n_last :), i) = n_last
Trying repeated skolemization, instantiation, and if-lifting,
this simplifies to: 
restrictmiddle_last.1.1.2 :  

[-1]  P!1 = p
[-2]  2 <= p
  |-------
{1}   EXISTS (i: below[length((: n_last :))]): nth((: n_last :), i) = n_last

Rerunning step: (inst 1 "0")
length rewrites length[Identity]((: :))
  to 0
length rewrites length[Nonce]((: n_last :))
  to 1
Instantiating the top quantifier in 1 with the terms: 
 0,
this simplifies to: 
restrictmiddle_last.1.1.2 :  

[-1]  P!1 = p
[-2]  2 <= p
  |-------
{1}   nth((: n_last :), 0) = n_last

Rerunning step: (expand "nth")
Expanding the definition of nth,
this simplifies to: 
restrictmiddle_last.1.1.2 :  

[-1]  P!1 = p
[-2]  2 <= p
  |-------
{1}   TRUE

which is trivially true.

This completes the proof of restrictmiddle_last.1.1.2.


This completes the proof of restrictmiddle_last.1.1.

restrictmiddle_last.1.2 :  

[-1]  i!2 = n_last
[-2]  2 <= P!1
  |-------
{1}   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!2 :))
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     length(x) = P!1 - 1 AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!2 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!2)) >>
                Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.2 :  

  |-------
[1]   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!2 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!2 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_last.1.2.

restrictmiddle_last.1.3 :  

[-1]  i!2 = n_last
[-2]  2 <= P!1
  |-------
{1}   cons?[Identity](i!3`2)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     length(x) = P!1 - 1 AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!2 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!2)) >>
                Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -1 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.3 :  

[-1]  2 <= P!1
  |-------
[1]   cons?[Identity](i!3`2)

Rerunning step: (nonemptylist "i!3`2")
Relating existence of a tail to a list's length,

This completes the proof of restrictmiddle_last.1.3.

restrictmiddle_last.1.4 :  

[-1]  i!2 = n_last
[-2]  2 <= P!1
  |-------
{1}   P!1 - 2 < length[Identity](i!3`2)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     length(x) = P!1 - 1 AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!2 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!2)) >>
                Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (typepred "i!3`2")
Adding type constraints for  i!3`2,
this simplifies to: 
restrictmiddle_last.1.4 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`2)
{-2}  length(i!3`2) = P!1 - 1
{-3}  FORALL (i: below[P!1 - 1]): nth(i!3`2, i) = hu(i)
[-4]  i!2 = n_last
[-5]  2 <= P!1
  |-------
[1]   P!1 - 2 < length[Identity](i!3`2)
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     length(x) = P!1 - 1 AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!2 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!2)) >>
                Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -3 -4 -5 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.4 :  

[-1]  length(i!3`2) = P!1 - 1
  |-------
[1]   P!1 - 2 < length[Identity](i!3`2)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_last.1.4.

restrictmiddle_last.1.5 :  

[-1]  i!2 = n_last
[-2]  2 <= P!1
  |-------
{1}   length(x!1) = P!1 - 1 IMPLIES FORALL (i: below[P!1 - 1]): i < p
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     length(x) = P!1 - 1 AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!2 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!2)) >>
                Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictmiddle_last.1.5 :  

{-1}  length(x!1) = P!1 - 1
[-2]  i!2 = n_last
[-3]  2 <= P!1
  |-------
{1}   FORALL (i: below[P!1 - 1]): i < p
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     length(x) = P!1 - 1 AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!2 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!2)) >>
                Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictmiddle_last.1.5 :  

[-1]  length(x!1) = P!1 - 1
[-2]  i!2 = n_last
[-3]  2 <= P!1
  |-------
{1}   i!3 < p
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     length(x) = P!1 - 1 AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!2 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!2)) >>
                Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (typepred "i!3" "i!2")
Adding type constraints for  i!3, i!2,
this simplifies to: 
restrictmiddle_last.1.5 :  

{-1}  i!3 < P!1 - 1
{-2}  IRpart(P!1, u!1, P!1 - 1)(i!2)
[-3]  length(x!1) = P!1 - 1
[-4]  i!2 = n_last
[-5]  2 <= P!1
  |-------
[1]   i!3 < p
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     length(x) = P!1 - 1 AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!2 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!2)) >>
                Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (lemma "n_orig" ("P" "P!1" "u" "u!1" "r" "P!1-1"))
Applying n_orig where 
  P gets P!1,
  u gets u!1,
  r gets P!1 - 1,
this simplifies to: 
restrictmiddle_last.1.5 :  

{-1}  IRpart(P!1, u!1, P!1 - 1)(n_last) =>
       (P!1 = p AND u!1 = hu(p - 1) AND P!1 - 1 = p - 1)
[-2]  i!3 < P!1 - 1
[-3]  IRpart(P!1, u!1, P!1 - 1)(i!2)
[-4]  length(x!1) = P!1 - 1
[-5]  i!2 = n_last
[-6]  2 <= P!1
  |-------
[1]   i!3 < p
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     length(x) = P!1 - 1 AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!2 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!2)) >>
                Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -4 -5 -6 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.5 :  

[-1]  IRpart(P!1, u!1, P!1 - 1)(n_last) =>
       (P!1 = p AND u!1 = hu(p - 1) AND P!1 - 1 = p - 1)
[-2]  i!3 < P!1 - 1
[-3]  IRpart(P!1, u!1, P!1 - 1)(i!2)
  |-------
[1]   i!3 < p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_last.1.5.

restrictmiddle_last.1.6 :  

[-1]  i!2 = n_last
[-2]  2 <= P!1
  |-------
{1}   length(x!1) = P!1 - 1 IMPLIES
       FORALL (i: below[P!1 - 1]): i < length[Identity](x!1)
{2}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     length(x) = P!1 - 1 AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!2 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!2)) >>
                Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
restrictmiddle_last.1.6 :  

{-1}  length(x!1) = P!1 - 1
[-2]  i!2 = n_last
[-3]  2 <= P!1
  |-------
{1}   FORALL (i: below[P!1 - 1]): i < length[Identity](x!1)
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     length(x) = P!1 - 1 AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!2 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!2)) >>
                Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictmiddle_last.1.6 :  

{-1}  i!3 < P!1 - 1
[-2]  length(x!1) = P!1 - 1
[-3]  i!2 = n_last
[-4]  2 <= P!1
  |-------
{1}   i!3 < length[Identity](x!1)
[2]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] |
                     length(x) = P!1 - 1 AND
                      FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!2 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!2)) >>
                Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -3 -4 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.6 :  

[-1]  i!3 < P!1 - 1
[-2]  length(x!1) = P!1 - 1
  |-------
[1]   i!3 < length[Identity](x!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_last.1.6.

restrictmiddle_last.1.7 :  

[-1]  i!2 = n_last
[-2]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il:
                {x: list[Identity] |
                   length[Identity](x) = P!1 - 1 AND
                    FORALL (i: below[P!1 - 1]):
                      nth[Identity](x, i) = hu(i)}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!2 :))
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    length(x) = P!1 - 1 AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!2 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!2)) >>
                Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.7 :  

  |-------
[1]   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il:
                {x: list[Identity] |
                   length[Identity](x) = P!1 - 1 AND
                    FORALL (i: below[P!1 - 1]):
                      nth[Identity](x, i) = hu(i)}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!2 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!2 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_last.1.7.

restrictmiddle_last.1.8 :  

[-1]  i!2 = n_last
[-2]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il:
                {x: list[Identity] |
                   length[Identity](x) = P!1 - 1 AND
                    FORALL (i: below[P!1 - 1]):
                      nth[Identity](x, i) = hu(i)}):
        cons?[Identity](il)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    length(x) = P!1 - 1 AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!2 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!2)) >>
                Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictmiddle_last.1.8 :  

[-1]  i!2 = n_last
[-2]  2 <= P!1
  |-------
{1}   cons?[Identity](il!1)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    length(x) = P!1 - 1 AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!2 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!2)) >>
                Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -1 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.8 :  

[-1]  2 <= P!1
  |-------
[1]   cons?[Identity](il!1)

Rerunning step: (nonemptylist "il!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictmiddle_last.1.8.

restrictmiddle_last.1.9 :  

[-1]  i!2 = n_last
[-2]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              x: list[Identity]):
        length(x) = P!1 - 1 IMPLIES FORALL (i: below[P!1 - 1]): i < p
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    length(x) = P!1 - 1 AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!2 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!2)) >>
                Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictmiddle_last.1.9 :  

{-1}  length(x!1) = P!1 - 1
[-2]  i!2 = n_last
[-3]  2 <= P!1
  |-------
{1}   i!3 < p
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    length(x) = P!1 - 1 AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!2 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!2)) >>
                Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (typepred "i!3" "i!2")
Adding type constraints for  i!3, i!2,
this simplifies to: 
restrictmiddle_last.1.9 :  

{-1}  i!3 < P!1 - 1
{-2}  IRpart(P!1, u!1, P!1 - 1)(i!2)
[-3]  length(x!1) = P!1 - 1
[-4]  i!2 = n_last
[-5]  2 <= P!1
  |-------
[1]   i!3 < p
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    length(x) = P!1 - 1 AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!2 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!2)) >>
                Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -3 -5 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.9 :  

[-1]  i!3 < P!1 - 1
[-2]  IRpart(P!1, u!1, P!1 - 1)(i!2)
[-3]  i!2 = n_last
  |-------
[1]   i!3 < p

Rerunning step: (lemma "n_orig" ("P" "P!1" "u" "u!1" "r" "P!1-1"))
Applying n_orig where 
  P gets P!1,
  u gets u!1,
  r gets P!1 - 1,
this simplifies to: 
restrictmiddle_last.1.9 :  

{-1}  IRpart(P!1, u!1, P!1 - 1)(n_last) =>
       (P!1 = p AND u!1 = hu(p - 1) AND P!1 - 1 = p - 1)
[-2]  i!3 < P!1 - 1
[-3]  IRpart(P!1, u!1, P!1 - 1)(i!2)
[-4]  i!2 = n_last
  |-------
[1]   i!3 < p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_last.1.9.

restrictmiddle_last.1.10 :  

[-1]  i!2 = n_last
[-2]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              x: list[Identity]):
        length(x) = P!1 - 1 IMPLIES
         FORALL (i: below[P!1 - 1]): i < length[Identity](x)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    length(x) = P!1 - 1 AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!2 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!2)) >>
                Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictmiddle_last.1.10 :  

{-1}  length(x!1) = P!1 - 1
[-2]  i!2 = n_last
[-3]  2 <= P!1
  |-------
{1}   i!3 < length[Identity](x!1)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    length(x) = P!1 - 1 AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!2 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!2)) >>
                Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (typepred "i!3")
Adding type constraints for  i!3,
this simplifies to: 
restrictmiddle_last.1.10 :  

{-1}  i!3 < P!1 - 1
[-2]  length(x!1) = P!1 - 1
[-3]  i!2 = n_last
[-4]  2 <= P!1
  |-------
[1]   i!3 < length[Identity](x!1)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    length(x) = P!1 - 1 AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!2 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!2)) >>
                Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -3 -4 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.10 :  

[-1]  i!3 < P!1 - 1
[-2]  length(x!1) = P!1 - 1
  |-------
[1]   i!3 < length[Identity](x!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_last.1.10.

restrictmiddle_last.1.11 :  

[-1]  i!2 = n_last
[-2]  2 <= P!1
  |-------
{1}   FORALL (x: list[Identity]):
        length(x) = P!1 - 1 IMPLIES FORALL (i: below[P!1 - 1]): i < p
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    length(x) = P!1 - 1 AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!2 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!2)) >>
                Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.11 :  

  |-------
[1]   FORALL (x: list[Identity]):
        length(x) = P!1 - 1 IMPLIES FORALL (i: below[P!1 - 1]): i < p

Rerunning step: (lemma "n_orig" ("P" "P!1" "u" "u!1" "r" "P!1-1"))
Applying n_orig where 
  P gets P!1,
  u gets u!1,
  r gets P!1 - 1,
this simplifies to: 
restrictmiddle_last.1.11 :  

{-1}  IRpart(P!1, u!1, P!1 - 1)(n_last) =>
       (P!1 = p AND u!1 = hu(p - 1) AND P!1 - 1 = p - 1)
  |-------
[1]   FORALL (x: list[Identity]):
        length(x) = P!1 - 1 IMPLIES FORALL (i: below[P!1 - 1]): i < p

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictmiddle_last.1.11 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (x!1)
[-2]  IRpart(P!1, u!1, P!1 - 1)(n_last) =>
       (P!1 = p AND u!1 = hu(p - 1) AND P!1 - 1 = p - 1)
  |-------
{1}   length(x!1) = P!1 - 1 IMPLIES FORALL (i: below[P!1 - 1]): i < p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_last.1.11.

restrictmiddle_last.1.12 :  

[-1]  i!2 = n_last
[-2]  2 <= P!1
  |-------
{1}   FORALL (x: list[Identity]):
        length(x) = P!1 - 1 IMPLIES
         FORALL (i: below[P!1 - 1]): i < length[Identity](x)
[2]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il:
                 {x: list[Identity] |
                    length(x) = P!1 - 1 AND
                     FORALL (i: below[P!1 - 1]): nth(x, i) = hu(i)}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!2 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!2)) >>
                Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete - 2)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.1.12 :  

  |-------
[1]   FORALL (x: list[Identity]):
        length(x) = P!1 - 1 IMPLIES
         FORALL (i: below[P!1 - 1]): i < length[Identity](x)

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
restrictmiddle_last.1.12 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (x!1)
  |-------
{1}   length(x!1) = P!1 - 1 IMPLIES
       FORALL (i: below[P!1 - 1]): i < length[Identity](x!1)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_last.1.12.


This completes the proof of restrictmiddle_last.1.

restrictmiddle_last.2 :  

[-1]  2 <= P!1
  |-------
{1}   i!2 = n_last
{2}   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!2 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!2)) >>
                Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (choice3)
Applying choice rule,
this yields  6 subgoals: 
restrictmiddle_last.2.1 :  

[-1]  2 <= P!1
  |-------
[1]   i!2 = n_last
{2}   (rec(u!1, nth(i!3`2, P!1 - 2),
           E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
        >>
        (trans(u!1, car(i!3`2),
               E(public(car(i!3`2)),
                 conc(nlist(append(i!3`1, (: i!2 :))),
                      ilist(append(cdr(i!3`2), (: u!1 :))))))
          >>
          (rec(u!1, nth(i!3`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
            >>
            (signal(commit(P!1 - 1, append(i!3`2, (: u!1 :)), i!2)) >>
              Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictmiddle_last.2.1 :  

{-1}  rho_middle(i!1)(E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
{1}   ((trans(u!1, car(i!3`2),
              E(public(car(i!3`2)),
                conc(nlist(append(i!3`1, (: i!2 :))),
                     ilist(append(cdr(i!3`2), (: u!1 :))))))
         >>
         (rec(u!1, nth(i!3`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
           >>
           (signal(commit(P!1 - 1, append(i!3`2, (: u!1 :)), i!2)) >>
             Stop[event])))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (rec(u!1, nth(i!3`2, P!1 - 2),
                   E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2)))))
{3}   rec(u!1, nth(i!3`2, P!1 - 2),
          E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
       >>
       ((trans(u!1, car(i!3`2),
               E(public(car(i!3`2)),
                 conc(nlist(append(i!3`1, (: i!2 :))),
                      ilist(append(cdr(i!3`2), (: u!1 :))))))
          >>
          (rec(u!1, nth(i!3`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
            >>
            (signal(commit(P!1 - 1, append(i!3`2, (: u!1 :)), i!2)) >>
              Stop[event])))
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   i!2 = n_last

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.2.1 :  

[-1]  rho_middle(i!1)(E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
[1]   ((trans(u!1, car(i!3`2),
              E(public(car(i!3`2)),
                conc(nlist(append(i!3`1, (: i!2 :))),
                     ilist(append(cdr(i!3`2), (: u!1 :))))))
         >>
         (rec(u!1, nth(i!3`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
           >>
           (signal(commit(P!1 - 1, append(i!3`2, (: u!1 :)), i!2)) >>
             Stop[event])))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[2]   i!2 = n_last

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictmiddle_last.2.1.1 :  

[-1]  rho_middle(i!1)(E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
{1}   rho_middle(i!1)
                (E(public(car(i!3`2)),
                   conc(nlist(append(i!3`1, (: i!2 :))),
                        ilist(append(cdr(i!3`2), (: u!1 :))))))
{2}   R_middle(i!1)
              (trans(u!1, car(i!3`2),
                     E(public(car(i!3`2)),
                       conc(nlist(append(i!3`1, (: i!2 :))),
                            ilist(append(cdr(i!3`2), (: u!1 :)))))))
{3}   trans(u!1, car(i!3`2),
            E(public(car(i!3`2)),
              conc(nlist(append(i!3`1, (: i!2 :))),
                   ilist(append(cdr(i!3`2), (: u!1 :))))))
       >>
       ((rec(u!1, nth(i!3`2, P!1 - 2), E(public(u!1), nlist((: i!2 :)))) >>
          (signal(commit(P!1 - 1, append(i!3`2, (: u!1 :)), i!2)) >>
            Stop[event]))
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   i!2 = n_last

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.2.1.1 :  

[-1]  rho_middle(i!1)(E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (E(public(car(i!3`2)),
                   conc(nlist(append(i!3`1, (: i!2 :))),
                        ilist(append(cdr(i!3`2), (: u!1 :))))))
[2]   i!2 = n_last

Rerunning step: (expand "E")
Expanding the definition of E,
this simplifies to: 
restrictmiddle_last.2.1.1 :  

{-1}  rho_middle(i!1)(code(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
{1}   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(nlist(append(i!3`1, (: i!2 :))),
                           ilist(append(cdr(i!3`2), (: u!1 :))))))
[2]   i!2 = n_last

Rerunning step: (expand "rho_middle" -1)
Expanding the definition of rho_middle,
this simplifies to: 
restrictmiddle_last.2.1.1 :  

{-1}  rho_middle(i!1)(conc(nlist(i!3`1), ilist(i!3`2))) OR
       (public(u!1) = public(hu(0)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
           conc(nlist(i!3`1), ilist(i!3`2)) =
            conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
        OR
        EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
          public(u!1) = public(hu(j)) AND
           EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
             conc(nlist(i!3`1), ilist(i!3`2)) =
              conc(ilist(remove(hu_list, j)),
                   nlist(append(nl, (: n_last :))))
[-2]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(nlist(append(i!3`1, (: i!2 :))),
                           ilist(append(cdr(i!3`2), (: u!1 :))))))
[2]   i!2 = n_last

Rerunning step: (split)
Splitting conjunctions,
this yields  3 subgoals: 
restrictmiddle_last.2.1.1.1 :  

{-1}  rho_middle(i!1)(conc(nlist(i!3`1), ilist(i!3`2)))
[-2]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(nlist(append(i!3`1, (: i!2 :))),
                           ilist(append(cdr(i!3`2), (: u!1 :))))))
[2]   i!2 = n_last

Rerunning step: (lemma "listprops[Nonce].elt_append3"
                 ("l1" "i!3`1" "l2" "(:i!2:)" "t" "n_last"))
Applying listprops[Nonce].elt_append3 where 
  l1 gets i!3`1,
  l2 gets (: i!2 :),
  t gets n_last,
this simplifies to: 
restrictmiddle_last.2.1.1.1 :  

{-1}  elt(append(i!3`1, (: i!2 :)), n_last) IMPLIES
       elt(i!3`1, n_last) OR elt((: i!2 :), n_last)
[-2]  rho_middle(i!1)(conc(nlist(i!3`1), ilist(i!3`2)))
[-3]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(nlist(append(i!3`1, (: i!2 :))),
                           ilist(append(cdr(i!3`2), (: u!1 :))))))
[2]   i!2 = n_last

Rerunning step: (lemma "listprops[Nonce].elt_singleton"
                 ("t1" "i!2" "t2" "n_last"))
Applying listprops[Nonce].elt_singleton where 
  t1 gets i!2,
  t2 gets n_last,
this simplifies to: 
restrictmiddle_last.2.1.1.1 :  

{-1}  elt((: i!2 :), n_last) IFF i!2 = n_last
[-2]  elt(append(i!3`1, (: i!2 :)), n_last) IMPLIES
       elt(i!3`1, n_last) OR elt((: i!2 :), n_last)
[-3]  rho_middle(i!1)(conc(nlist(i!3`1), ilist(i!3`2)))
[-4]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(nlist(append(i!3`1, (: i!2 :))),
                           ilist(append(cdr(i!3`2), (: u!1 :))))))
[2]   i!2 = n_last

Rerunning step: (grind :if-match nil :exclude "elt")
rho_middle rewrites rho_middle(i!1)(nlist(i!3`1))
  to FALSE
rho_middle rewrites rho_middle(i!1)(ilist(i!3`2))
  to TRUE
rho_middle rewrites rho_middle(i!1)(conc(nlist(i!3`1), ilist(i!3`2)))
  to FALSE
rho_middle rewrites rho_middle(i!1)(nlist(i!3`1))
  to NOT elt(i!3`1, n_last)
rho_middle rewrites rho_middle(i!1)(ilist(i!3`2))
  to TRUE
rho_middle rewrites rho_middle(i!1)(conc(nlist(i!3`1), ilist(i!3`2)))
  to NOT elt(i!3`1, n_last)
rho_middle rewrites rho_middle(i!1)(nlist(append(i!3`1, (: i!2 :))))
  to TRUE
rho_middle rewrites rho_middle(i!1)(ilist(append(cdr(i!3`2), (: u!1 :))))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)
            (conc(nlist(append(i!3`1, (: i!2 :))),
                  ilist(append(cdr(i!3`2), (: u!1 :)))))
  to TRUE
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites 
  rho_middle(i!1)
            (code(public(car(i!3`2)),
                  conc(nlist(append(i!3`1, (: i!2 :))),
                       ilist(append(cdr(i!3`2), (: u!1 :))))))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_last.2.1.1.1.

restrictmiddle_last.2.1.1.2 :  

{-1}  (public(u!1) = public(hu(0)) AND
        EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
          conc(nlist(i!3`1), ilist(i!3`2)) =
           conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
[-2]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(nlist(append(i!3`1, (: i!2 :))),
                           ilist(append(cdr(i!3`2), (: u!1 :))))))
[2]   i!2 = n_last

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictmiddle_last.2.1.1.2 :  

{-1}  public(u!1) = public(hu(0))
{-2}  conc(nlist(i!3`1), ilist(i!3`2)) =
       conc(nlist(append(nl!1, (: n_last :))), ilist(cdr(hu_list)))
[-3]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(nlist(append(i!3`1, (: i!2 :))),
                           ilist(append(cdr(i!3`2), (: u!1 :))))))
[2]   i!2 = n_last

Rerunning step: (comment "a contradiction is lurking in -2")
Adding comment: a contradiction is lurking in -2
this simplifies to: 
restrictmiddle_last.2.1.1.2 : 
;;; a contradiction is lurking in -2

[-1]  public(u!1) = public(hu(0))
[-2]  conc(nlist(i!3`1), ilist(i!3`2)) =
       conc(nlist(append(nl!1, (: n_last :))), ilist(cdr(hu_list)))
[-3]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(nlist(append(i!3`1, (: i!2 :))),
                           ilist(append(cdr(i!3`2), (: u!1 :))))))
[2]   i!2 = n_last

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_last.2.1.1.2 : 
;;; a contradiction is lurking in -2

{-1}  u!1 = hu(0)
[-2]  conc(nlist(i!3`1), ilist(i!3`2)) =
       conc(nlist(append(nl!1, (: n_last :))), ilist(cdr(hu_list)))
[-3]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(nlist(append(i!3`1, (: i!2 :))),
                           ilist(append(cdr(i!3`2), (: u!1 :))))))
[2]   i!2 = n_last

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_last.2.1.1.2 : 
;;; a contradiction is lurking in -2

{-1}  nlist(i!3`1) = nlist(append(nl!1, (: n_last :)))
{-2}  ilist(i!3`2) = ilist(cdr(hu_list))
[-3]  u!1 = hu(0)
[-4]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(nlist(append(i!3`1, (: i!2 :))),
                           ilist(append(cdr(i!3`2), (: u!1 :))))))
[2]   i!2 = n_last

Rerunning step: (decompose-equality -1)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_last.2.1.1.2 : 
;;; a contradiction is lurking in -2

{-1}  i!3`1 = append(nl!1, (: n_last :))
[-2]  ilist(i!3`2) = ilist(cdr(hu_list))
[-3]  u!1 = hu(0)
[-4]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(nlist(append(i!3`1, (: i!2 :))),
                           ilist(append(cdr(i!3`2), (: u!1 :))))))
[2]   i!2 = n_last

Rerunning step: (decompose-equality -2)
Applying decompose-equality,
this simplifies to: 
restrictmiddle_last.2.1.1.2 : 
;;; a contradiction is lurking in -2

{-1}  i!3`2 = cdr(hu_list)
[-2]  i!3`1 = append(nl!1, (: n_last :))
[-3]  u!1 = hu(0)
[-4]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(nlist(append(i!3`1, (: i!2 :))),
                           ilist(append(cdr(i!3`2), (: u!1 :))))))
[2]   i!2 = n_last

Rerunning step: (typepred "nl!1" "i!3`1" "i!3`2" "hu_list")
Adding type constraints for  nl!1, i!3`1, i!3`2, hu_list,
this simplifies to: 
restrictmiddle_last.2.1.1.2 : 
;;; a contradiction is lurking in -2

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (nl!1)
{-2}  length(nl!1) = p - 1
{-3}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`1)
{-4}  length(i!3`1) = P!1 - 1
{-5}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`2)
{-6}  length(i!3`2) = P!1 - 1
{-7}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (hu_list)
{-8}  (length(hu_list) = p)
{-9}  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-10] i!3`2 = cdr(hu_list)
[-11] i!3`1 = append(nl!1, (: n_last :))
[-12] u!1 = hu(0)
[-13] 2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(nlist(append(i!3`1, (: i!2 :))),
                           ilist(append(cdr(i!3`2), (: u!1 :))))))
[2]   i!2 = n_last

Rerunning step: (delete -1 -3 -5 -7 -12 +)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.2.1.1.2 : 
;;; a contradiction is lurking in -2

[-1]  length(nl!1) = p - 1
[-2]  length(i!3`1) = P!1 - 1
[-3]  length(i!3`2) = P!1 - 1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  i!3`2 = cdr(hu_list)
[-7]  i!3`1 = append(nl!1, (: n_last :))
[-8]  2 <= P!1
  |-------

Rerunning step: (case "P!1=p")
Case splitting on 
   P!1 = p, 
this yields  2 subgoals: 
restrictmiddle_last.2.1.1.2.1 : 
;;; a contradiction is lurking in -2

{-1}  P!1 = p
[-2]  length(nl!1) = p - 1
[-3]  length(i!3`1) = P!1 - 1
[-4]  length(i!3`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  i!3`2 = cdr(hu_list)
[-8]  i!3`1 = append(nl!1, (: n_last :))
[-9]  2 <= P!1
  |-------

Rerunning step: (replace -8 -3)
Replacing using formula -8,
this simplifies to: 
restrictmiddle_last.2.1.1.2.1 : 
;;; a contradiction is lurking in -2

[-1]  P!1 = p
[-2]  length(nl!1) = p - 1
{-3}  length(append(nl!1, (: n_last :))) = P!1 - 1
[-4]  length(i!3`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  i!3`2 = cdr(hu_list)
[-8]  i!3`1 = append(nl!1, (: n_last :))
[-9]  2 <= P!1
  |-------

Rerunning step: (rewrite "length_append" -3)
Found matching substitution:
l2: list[T] gets (: n_last :),
l1: list[T] gets nl!1,
Rewriting using length_append, matching in -3,
this simplifies to: 
restrictmiddle_last.2.1.1.2.1 : 
;;; a contradiction is lurking in -2

[-1]  P!1 = p
[-2]  length(nl!1) = p - 1
{-3}  length((: n_last :)) + length(nl!1) = P!1 - 1
[-4]  length(i!3`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  i!3`2 = cdr(hu_list)
[-8]  i!3`1 = append(nl!1, (: n_last :))
[-9]  2 <= P!1
  |-------

Rerunning step: (replace -2 -3)
Replacing using formula -2,
this simplifies to: 
restrictmiddle_last.2.1.1.2.1 : 
;;; a contradiction is lurking in -2

[-1]  P!1 = p
[-2]  length(nl!1) = p - 1
{-3}  length((: n_last :)) + (p - 1) = P!1 - 1
[-4]  length(i!3`2) = P!1 - 1
[-5]  (length(hu_list) = p)
[-6]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-7]  i!3`2 = cdr(hu_list)
[-8]  i!3`1 = append(nl!1, (: n_last :))
[-9]  2 <= P!1
  |-------

Rerunning step: (delete -2 -4 -5 -6 -7 -8 -9)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.2.1.1.2.1 : 
;;; a contradiction is lurking in -2

[-1]  P!1 = p
[-2]  length((: n_last :)) + (p - 1) = P!1 - 1
  |-------

Rerunning step: (grind)
length rewrites length[Identity]((: :))
  to 0
length rewrites length((: n_last :))
  to 1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_last.2.1.1.2.1.

restrictmiddle_last.2.1.1.2.2 : 
;;; a contradiction is lurking in -2

[-1]  length(nl!1) = p - 1
[-2]  length(i!3`1) = P!1 - 1
[-3]  length(i!3`2) = P!1 - 1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  i!3`2 = cdr(hu_list)
[-7]  i!3`1 = append(nl!1, (: n_last :))
[-8]  2 <= P!1
  |-------
{1}   P!1 = p

Rerunning step: (replace -6 -3)
Replacing using formula -6,
this simplifies to: 
restrictmiddle_last.2.1.1.2.2 : 
;;; a contradiction is lurking in -2

[-1]  length(nl!1) = p - 1
[-2]  length(i!3`1) = P!1 - 1
{-3}  length(cdr(hu_list)) = P!1 - 1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  i!3`2 = cdr(hu_list)
[-7]  i!3`1 = append(nl!1, (: n_last :))
[-8]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (rewrite "length_cdr" -3)
Found matching substitution:
cons_l: (cons?[T]) gets hu_list,
Rewriting using length_cdr, matching in -3,
this simplifies to: 
restrictmiddle_last.2.1.1.2.2 : 
;;; a contradiction is lurking in -2

[-1]  length(nl!1) = p - 1
[-2]  length(i!3`1) = P!1 - 1
{-3}  length(hu_list) - 1 = P!1 - 1
[-4]  (length(hu_list) = p)
[-5]  FORALL (i: nat_to_p): nth(hu_list, i) = hu(i)
[-6]  i!3`2 = cdr(hu_list)
[-7]  i!3`1 = append(nl!1, (: n_last :))
[-8]  2 <= P!1
  |-------
[1]   P!1 = p

Rerunning step: (delete -1 -2 -5 -6 -7 -8)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.2.1.1.2.2 : 
;;; a contradiction is lurking in -2

[-1]  length(hu_list) - 1 = P!1 - 1
[-2]  (length(hu_list) = p)
  |-------
[1]   P!1 = p

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_last.2.1.1.2.2.


This completes the proof of restrictmiddle_last.2.1.1.2.

restrictmiddle_last.2.1.1.3 :  

{-1}  EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
        public(u!1) = public(hu(j)) AND
         EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
           conc(nlist(i!3`1), ilist(i!3`2)) =
            conc(ilist(remove(hu_list, j)), nlist(append(nl, (: n_last :))))
[-2]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(nlist(append(i!3`1, (: i!2 :))),
                           ilist(append(cdr(i!3`2), (: u!1 :))))))
[2]   i!2 = n_last

Rerunning step: (skosimp*)
Repeatedly Skolemizing and flattening,
this simplifies to: 
restrictmiddle_last.2.1.1.3 :  

{-1}  public(u!1) = public(hu(j!1))
{-2}  conc(nlist(i!3`1), ilist(i!3`2)) =
       conc(ilist(remove(hu_list, j!1)), nlist(append(nl!1, (: n_last :))))
[-3]  2 <= P!1
  |-------
[1]   rho_middle(i!1)
                (code(public(car(i!3`2)),
                      conc(nlist(append(i!3`1, (: i!2 :))),
                           ilist(append(cdr(i!3`2), (: u!1 :))))))
[2]   i!2 = n_last

Rerunning step: (delete -1 -3 +)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.2.1.1.3 :  

[-1]  conc(nlist(i!3`1), ilist(i!3`2)) =
       conc(ilist(remove(hu_list, j!1)), nlist(append(nl!1, (: n_last :))))
  |-------

Rerunning step: (decompose-equality -1)
Applying decompose-equality,

This completes the proof of restrictmiddle_last.2.1.1.3.


This completes the proof of restrictmiddle_last.2.1.1.

restrictmiddle_last.2.1.2 :  

[-1]  rho_middle(i!1)(E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
{1}   ((rec(u!1, nth(i!3`2, P!1 - 2), E(public(u!1), nlist((: i!2 :)))) >>
         (signal(commit(P!1 - 1, append(i!3`2, (: u!1 :)), i!2)) >>
           Stop[event]))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (trans(u!1, car(i!3`2),
                     E(public(car(i!3`2)),
                       conc(nlist(append(i!3`1, (: i!2 :))),
                            ilist(append(cdr(i!3`2), (: u!1 :)))))))
{3}   trans(u!1, car(i!3`2),
            E(public(car(i!3`2)),
              conc(nlist(append(i!3`1, (: i!2 :))),
                   ilist(append(cdr(i!3`2), (: u!1 :))))))
       >>
       ((rec(u!1, nth(i!3`2, P!1 - 2), E(public(u!1), nlist((: i!2 :)))) >>
          (signal(commit(P!1 - 1, append(i!3`2, (: u!1 :)), i!2)) >>
            Stop[event]))
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   i!2 = n_last

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.2.1.2 :  

[-1]  rho_middle(i!1)(E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
[-2]  2 <= P!1
  |-------
[1]   ((rec(u!1, nth(i!3`2, P!1 - 2), E(public(u!1), nlist((: i!2 :)))) >>
         (signal(commit(P!1 - 1, append(i!3`2, (: u!1 :)), i!2)) >>
           Stop[event]))
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[2]   i!2 = n_last

Rerunning step: (prefix)
Applying prefix rule,
this simplifies to: 
restrictmiddle_last.2.1.2 :  

{-1}  rho_middle(i!1)(E(public(u!1), nlist((: i!2 :))))
[-2]  rho_middle(i!1)(E(public(u!1), conc(nlist(i!3`1), ilist(i!3`2))))
[-3]  2 <= P!1
  |-------
{1}   ((signal(commit(P!1 - 1, append(i!3`2, (: u!1 :)), i!2)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)
              (rec(u!1, nth(i!3`2, P!1 - 2),
                   E(public(u!1), nlist((: i!2 :)))))
{3}   rec(u!1, nth(i!3`2, P!1 - 2), E(public(u!1), nlist((: i!2 :)))) >>
       ((signal(commit(P!1 - 1, append(i!3`2, (: u!1 :)), i!2)) >>
          Stop[event])
         # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   i!2 = n_last

Rerunning step: (delete -2 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.2.1.2 :  

[-1]  rho_middle(i!1)(E(public(u!1), nlist((: i!2 :))))
[-2]  2 <= P!1
  |-------
[1]   ((signal(commit(P!1 - 1, append(i!3`2, (: u!1 :)), i!2)) >>
         Stop[event])
        # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[2]   i!2 = n_last

Rerunning step: (prefix)
Applying prefix rule,
this yields  2 subgoals: 
restrictmiddle_last.2.1.2.1 :  

[-1]  rho_middle(i!1)(E(public(u!1), nlist((: i!2 :))))
[-2]  2 <= P!1
  |-------
{1}   rho_middle(i!1)(commit(P!1 - 1, append(i!3`2, (: u!1 :)), i!2))
{2}   R_middle(i!1)(signal(commit(P!1 - 1, append(i!3`2, (: u!1 :)), i!2)))
{3}   signal(commit(P!1 - 1, append(i!3`2, (: u!1 :)), i!2)) >>
       (Stop[event] # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   i!2 = n_last

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.2.1.2.1 :  

  |-------
[1]   rho_middle(i!1)(commit(P!1 - 1, append(i!3`2, (: u!1 :)), i!2))
[2]   i!2 = n_last

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
restrictmiddle_last.2.1.2.1 :  

  |-------
{1}   TRUE
[2]   i!2 = n_last

which is trivially true.

This completes the proof of restrictmiddle_last.2.1.2.1.

restrictmiddle_last.2.1.2.2 :  

[-1]  rho_middle(i!1)(E(public(u!1), nlist((: i!2 :))))
[-2]  2 <= P!1
  |-------
{1}   (Stop[event] # R_middle(i!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
{2}   R_middle(i!1)(signal(commit(P!1 - 1, append(i!3`2, (: u!1 :)), i!2)))
{3}   signal(commit(P!1 - 1, append(i!3`2, (: u!1 :)), i!2)) >>
       (Stop[event] # R_middle(i!1))
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)
[4]   i!2 = n_last

Rerunning step: (delete - 2 3 4)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.2.1.2.2 :  

  |-------
[1]   (Stop[event] # R_middle(i!1)) |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (stop)
Applying stop rule,

This completes the proof of restrictmiddle_last.2.1.2.2.


This completes the proof of restrictmiddle_last.2.1.2.


This completes the proof of restrictmiddle_last.2.1.

restrictmiddle_last.2.2 :  

[-1]  2 <= P!1
  |-------
{1}   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!2 :))
[2]   i!2 = n_last
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!2 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!2)) >>
                Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.2.2 :  

  |-------
[1]   every[number]
          (LAMBDA (x: number):
                  number_field_pred(x) AND real_pred(x) AND rational_pred(x)
              AND integer_pred(x) AND (x >= 0))
          ((: i!2 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!2 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_last.2.2.

restrictmiddle_last.2.3 :  

[-1]  2 <= P!1
  |-------
{1}   cons?[Identity](i!3`2)
[2]   i!2 = n_last
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!2 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!2)) >>
                Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.2.3 :  

[-1]  2 <= P!1
  |-------
[1]   cons?[Identity](i!3`2)

Rerunning step: (nonemptylist "i!3`2")
Relating existence of a tail to a list's length,

This completes the proof of restrictmiddle_last.2.3.

restrictmiddle_last.2.4 :  

[-1]  2 <= P!1
  |-------
{1}   P!1 - 2 < length[Identity](i!3`2)
[2]   i!2 = n_last
{3}   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!2 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!2)) >>
                Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (typepred "i!3`2")
Adding type constraints for  i!3`2,
this simplifies to: 
restrictmiddle_last.2.4 :  

{-1}  every(LAMBDA (x: number):
                   number_field_pred(x) AND real_pred(x)
               AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
           (i!3`2)
{-2}  length(i!3`2) = P!1 - 1
[-3]  2 <= P!1
  |-------
[1]   P!1 - 2 < length[Identity](i!3`2)
[2]   i!2 = n_last
[3]   Choice! (i:
                 [{x: list[Nonce] | length(x) = P!1 - 1},
                  {x: list[Identity] | length(x) = P!1 - 1}]):
        (rec(u!1, nth(i`2, P!1 - 2),
             E(public(u!1), conc(nlist(i`1), ilist(i`2))))
          >>
          (trans(u!1, car(i`2),
                 E(public(car(i`2)),
                   conc(nlist(append(i`1, (: i!2 :))),
                        ilist(append(cdr(i`2), (: u!1 :))))))
            >>
            (rec(u!1, nth(i`2, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(i`2, (: u!1 :)), i!2)) >>
                Stop[event]))))
         # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete -1 -3 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.2.4 :  

[-1]  length(i!3`2) = P!1 - 1
  |-------
[1]   P!1 - 2 < length[Identity](i!3`2)

Rerunning step: (ground)
Applying propositional simplification and decision procedures,

This completes the proof of restrictmiddle_last.2.4.

restrictmiddle_last.2.5 :  

[-1]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!2 :))
[2]   i!2 = n_last
[3]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!2 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!2)) >>
                Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete - 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.2.5 :  

  |-------
[1]   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        every[number]
            (LAMBDA (x: number):
                    number_field_pred(x) AND real_pred(x)
                AND rational_pred(x) AND integer_pred(x) AND (x >= 0))
            ((: i!2 :))

Rerunning step: (grind)
every rewrites 
  every(LAMBDA (x: number):
               number_field_pred(x) AND real_pred(x) AND rational_pred(x)
           AND integer_pred(x) AND (x >= 0))
       ((: :))
  to TRUE
every rewrites 
  every[number]
      (LAMBDA (x: number):
              number_field_pred(x) AND real_pred(x) AND rational_pred(x)
          AND integer_pred(x) AND (x >= 0))
      ((: i!2 :))
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of restrictmiddle_last.2.5.

restrictmiddle_last.2.6 :  

[-1]  2 <= P!1
  |-------
{1}   FORALL (nl: {x: list[Nonce] | length[Nonce](x) = P!1 - 1},
              il: {x: list[Identity] | length[Identity](x) = P!1 - 1}):
        cons?[Identity](il)
[2]   i!2 = n_last
[3]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!2 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!2)) >>
                Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
restrictmiddle_last.2.6 :  

[-1]  2 <= P!1
  |-------
{1}   cons?[Identity](il!1)
[2]   i!2 = n_last
[3]   Choice! (nl: {x: list[Nonce] | length(x) = P!1 - 1},
               il: {x: list[Identity] | length(x) = P!1 - 1}):
        (rec(u!1, nth(il, P!1 - 2),
             E(public(u!1), conc(nlist(nl), ilist(il))))
          >>
          (trans(u!1, car(il),
                 E(public(car(il)),
                   conc(nlist(append(nl, (: i!2 :))),
                        ilist(append(cdr(il), (: u!1 :))))))
            >>
            (rec(u!1, nth(il, P!1 - 2), E(public(u!1), nlist((: i!2 :))))
              >>
              (signal(commit(P!1 - 1, append(il, (: u!1 :)), i!2)) >>
                Stop[event]))))
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) => rho_middle(i!1)(msg(e)))(t) =>
          every(LAMBDA (e: event): NOT rec?(e) => rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (delete 2 3)
Deleting some formulas,
this simplifies to: 
restrictmiddle_last.2.6 :  

[-1]  2 <= P!1
  |-------
[1]   cons?[Identity](il!1)

Rerunning step: (nonemptylist "il!1")
Relating existence of a tail to a list's length,

This completes the proof of restrictmiddle_last.2.6.


This completes the proof of restrictmiddle_last.2.

Q.E.D.


Run time  = 5.17 secs.
Real time = 7.18 secs.
nil
pvs(72): 
Installing rewrite rule sets.singleton_rew (all instances)
authentication_middle :  

  |-------
{1}   FORALL (i: nat_1_to(p)): network(USER) |> auth(T, R_middle(i))

Rerunning step: (auto-rewrite-theory "sets")
Rewriting relative to the theory: sets,
this simplifies to: 
authentication_middle :  

  |-------
[1]   FORALL (i: nat_1_to(p)): network(USER) |> auth(T, R_middle(i))

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle :  

  |-------
{1}   network(USER) |> auth(T, R_middle(i!1))

Rerunning step: (rewrite "authentication_by_rank" +
                 ("rho" "rho_middle(i!1)"))
Found matching substitution:
R: setof[event] gets R_middle(i!1),
T: setof[event] gets T,
users: [Identity -> process[event]] gets USER,
rho: setof[Message] gets rho_middle(i!1),
member rewrites member(x, INIT)
  to INIT(x)
member rewrites member(x, rho_middle(i!1))
  to rho_middle(i!1)(x)
subset? rewrites subset?(INIT, rho_middle(i!1))
  to FORALL (x: Message): INIT(x) => rho_middle(i!1)(x)
member rewrites member(x, S)
  to S(x)
member rewrites member(x, rho_middle(i!1))
  to rho_middle(i!1)(x)
subset? rewrites subset?(S, rho_middle(i!1))
  to FORALL (x: Message): S(x) => rho_middle(i!1)(x)
Rewriting using authentication_by_rank, matching in + where
  rho gets rho_middle(i!1),
this yields  4 subgoals: 
authentication_middle.1 :  

  |-------
{1}   FORALL (x: Message): INIT(x) => rho_middle(i!1)(x)
[2]   network(USER) |> auth(T, R_middle(i!1))

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_middle.1 :  

  |-------
[1]   FORALL (x: Message): INIT(x) => rho_middle(i!1)(x)

Rerunning step: (comment "intruder's initial knowledge is in rho")
Adding comment: intruder's initial knowledge is in rho
this simplifies to: 
authentication_middle.1 : 
;;; intruder's initial knowledge is in rho

  |-------
[1]   FORALL (x: Message): INIT(x) => rho_middle(i!1)(x)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.1 : 
;;; intruder's initial knowledge is in rho

  |-------
{1}   INIT(x!1) => rho_middle(i!1)(x!1)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_middle.1 : 
;;; intruder's initial knowledge is in rho

{-1}  INIT(x!1)
  |-------
{1}   rho_middle(i!1)(x!1)

Rerunning step: (expand "INIT")
Expanding the definition of INIT,
this simplifies to: 
authentication_middle.1 : 
;;; intruder's initial knowledge is in rho

{-1}  CASES x!1
        OF user(z): TRUE,
           nonce(z): z /= n_last,
           public(z): TRUE,
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i))
        ELSE FALSE
        ENDCASES
  |-------
[1]   rho_middle(i!1)(x!1)

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.1 : 
;;; intruder's initial knowledge is in rho

[-1]  CASES x!1
        OF user(z): TRUE,
           nonce(z): z /= n_last,
           public(z): TRUE,
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i))
        ELSE FALSE
        ENDCASES
  |-------
{1}   CASES x!1
        OF nonce(z): z /= n_last,
           nlist(z): NOT elt(z, n_last),
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i)),
           conc(z1, z2): rho_middle(i!1)(z1) AND rho_middle(i!1)(z2),
           commit(z1, z2, z3):
             z1 /= p - 1 OR z2 /= hu_list OR z3 /= n_last,
           code(z1, z2):
             rho_middle(i!1)(z2) OR
              (z1 = public(hu(0)) AND
                (EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
                   z2 =
                    conc(nlist(append(nl, (: n_last :))),
                         ilist(cdr(hu_list)))))
               OR
               EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
                 z1 = public(hu(j)) AND
                  EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
                    z2 =
                     conc(ilist(remove(hu_list, j)),
                          nlist(append(nl, (: n_last :))))
        ELSE TRUE
        ENDCASES

Rerunning step: (smash)
Repeatedly simplifying with BDDs, decision procedures, rewriting,
and if-lifting,

This completes the proof of authentication_middle.1.

authentication_middle.2 :  

  |-------
{1}   FORALL (S: setof[Message]), (m: Message):
        (FORALL (x: Message): S(x) => rho_middle(i!1)(x)) AND (S |- m)
         IMPLIES rho_middle(i!1)(m)
[2]   network(USER) |> auth(T, R_middle(i!1))

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2 :  

  |-------
[1]   FORALL (S: setof[Message]), (m: Message):
        (FORALL (x: Message): S(x) => rho_middle(i!1)(x)) AND (S |- m)
         IMPLIES rho_middle(i!1)(m)

Rerunning step: (comment "from of a set of messages in rho, no message not in rho can be generated")
Adding comment: from of a set of messages in rho, no message not in rho can be generated
this simplifies to: 
authentication_middle.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   FORALL (S: setof[Message]), (m: Message):
        (FORALL (x: Message): S(x) => rho_middle(i!1)(x)) AND (S |- m)
         IMPLIES rho_middle(i!1)(m)

Rerunning step: (expand "|-")
Expanding the definition of |-,
this simplifies to: 
authentication_middle.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   FORALL (S: setof[Message]), (m: Message):
        (FORALL (x: Message): S(x) => rho_middle(i!1)(x)) AND Gen(S, m)
         IMPLIES rho_middle(i!1)(m)

Rerunning step: (rule-induct "Gen")
Applying rule (co)induction over Gen,
this simplifies to: 
authentication_middle.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   FORALL (m: Message):
        (     S!1(m)
          OR (EXISTS m1, m2:
                rho_middle(i!1)(m1) AND
                 rho_middle(i!1)(m2) AND m = conc(m1, m2))
          OR (EXISTS m1: rho_middle(i!1)(conc(m1, m)))
          OR (EXISTS m2: rho_middle(i!1)(conc(m, m2)))
          OR (EXISTS (n: Nonce):
                rho_middle(i!1)(nonce(n)) AND m = nlist((: n :)))
          OR (EXISTS (n: Nonce):
                rho_middle(i!1)(nlist((: n :))) AND m = nonce(n))
          OR (EXISTS (nl1, nl2: list[Nonce]):
                rho_middle(i!1)(nlist(nl1)) AND
                 rho_middle(i!1)(nlist(nl2)) AND
                  m = nlist(append(nl1, nl2)))
          OR (EXISTS (nl, nl1, nl2: list[Nonce]):
                rho_middle(i!1)(nlist(nl)) AND
                 nl = append(nl1, nl2) AND m = nlist(nl1))
          OR (EXISTS (nl, nl1, nl2: list[Nonce]):
                rho_middle(i!1)(nlist(nl)) AND
                 nl = append(nl1, nl2) AND m = nlist(nl2))
          OR (EXISTS (i: Identity):
                rho_middle(i!1)(user(i)) AND m = ilist((: i :)))
          OR (EXISTS (i: Identity):
                rho_middle(i!1)(ilist((: i :))) AND m = user(i))
          OR (EXISTS (il1, il2: list[Identity]):
                rho_middle(i!1)(ilist(il1)) AND
                 rho_middle(i!1)(ilist(il2)) AND
                  m = ilist(append(il1, il2)))
          OR (EXISTS (il, il1, il2: list[Identity]):
                rho_middle(i!1)(ilist(il)) AND
                 il = append(il1, il2) AND m = ilist(il1))
          OR (EXISTS (il, il1, il2: list[Identity]):
                rho_middle(i!1)(ilist(il)) AND
                 il = append(il1, il2) AND m = ilist(il2))
          OR EXISTS m1, k:
               rho_middle(i!1)(m1) AND rho_middle(i!1)(k) AND m = E(k, m1))
         IMPLIES rho_middle(i!1)(m)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   (     S!1(m!2)
        OR (EXISTS m1, m2:
              rho_middle(i!1)(m1) AND
               rho_middle(i!1)(m2) AND m!2 = conc(m1, m2))
        OR (EXISTS m1: rho_middle(i!1)(conc(m1, m!2)))
        OR (EXISTS m2: rho_middle(i!1)(conc(m!2, m2)))
        OR (EXISTS (n: Nonce):
              rho_middle(i!1)(nonce(n)) AND m!2 = nlist((: n :)))
        OR (EXISTS (n: Nonce):
              rho_middle(i!1)(nlist((: n :))) AND m!2 = nonce(n))
        OR (EXISTS (nl1, nl2: list[Nonce]):
              rho_middle(i!1)(nlist(nl1)) AND
               rho_middle(i!1)(nlist(nl2)) AND
                m!2 = nlist(append(nl1, nl2)))
        OR (EXISTS (nl, nl1, nl2: list[Nonce]):
              rho_middle(i!1)(nlist(nl)) AND
               nl = append(nl1, nl2) AND m!2 = nlist(nl1))
        OR (EXISTS (nl, nl1, nl2: list[Nonce]):
              rho_middle(i!1)(nlist(nl)) AND
               nl = append(nl1, nl2) AND m!2 = nlist(nl2))
        OR (EXISTS (i: Identity):
              rho_middle(i!1)(user(i)) AND m!2 = ilist((: i :)))
        OR (EXISTS (i: Identity):
              rho_middle(i!1)(ilist((: i :))) AND m!2 = user(i))
        OR (EXISTS (il1, il2: list[Identity]):
              rho_middle(i!1)(ilist(il1)) AND
               rho_middle(i!1)(ilist(il2)) AND
                m!2 = ilist(append(il1, il2)))
        OR (EXISTS (il, il1, il2: list[Identity]):
              rho_middle(i!1)(ilist(il)) AND
               il = append(il1, il2) AND m!2 = ilist(il1))
        OR (EXISTS (il, il1, il2: list[Identity]):
              rho_middle(i!1)(ilist(il)) AND
               il = append(il1, il2) AND m!2 = ilist(il2))
        OR EXISTS m1, k:
             rho_middle(i!1)(m1) AND rho_middle(i!1)(k) AND m!2 = E(k, m1))
       IMPLIES rho_middle(i!1)(m!2)

Rerunning step: (smash)
Repeatedly simplifying with BDDs, decision procedures, rewriting,
and if-lifting,
this yields  15 subgoals: 
authentication_middle.2.1 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  S!1(m!2)
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (inst -2 "m!2")
Instantiating the top quantifier in -2 with the terms: 
 m!2,
this simplifies to: 
authentication_middle.2.1 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  S!1(m!2)
{-2}  S!1(m!2) => rho_middle(i!1)(m!2)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_middle.2.1.

authentication_middle.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS m1, m2:
        rho_middle(i!1)(m1) AND rho_middle(i!1)(m2) AND m!2 = conc(m1, m2)
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS m1, m2:
        rho_middle(i!1)(m1) AND rho_middle(i!1)(m2) AND m!2 = conc(m1, m2)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(m1!1) AND
       rho_middle(i!1)(m2!1) AND m!2 = conc(m1!1, m2!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_middle.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(m1!1)
{-2}  rho_middle(i!1)(m2!1)
{-3}  m!2 = conc(m1!1, m2!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_middle.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(m1!1)
[-2]  rho_middle(i!1)(m2!1)
[-3]  m!2 = conc(m1!1, m2!1)
  |-------
{1}   rho_middle(i!1)(conc(m1!1, m2!1))

Rerunning step: (expand "rho_middle" 1)
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(m1!1)
[-2]  rho_middle(i!1)(m2!1)
[-3]  m!2 = conc(m1!1, m2!1)
  |-------
{1}   rho_middle(i!1)(m1!1) AND rho_middle(i!1)(m2!1)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_middle.2.2.

authentication_middle.2.3 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS m1: rho_middle(i!1)(conc(m1, m!2))
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.3 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS m1: rho_middle(i!1)(conc(m1, m!2))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.3 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(conc(m1!1, m!2))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (expand "rho_middle" -1)
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.3 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  FALSE
  |-------
[1]   rho_middle(i!1)(m!2)

which is trivially true.

This completes the proof of authentication_middle.2.3.

authentication_middle.2.4 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS m2: rho_middle(i!1)(conc(m!2, m2))
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.4 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS m2: rho_middle(i!1)(conc(m!2, m2))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.4 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(conc(m!2, m2!1))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (expand "rho_middle" -1)
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.4 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  FALSE
  |-------
[1]   rho_middle(i!1)(m!2)

which is trivially true.

This completes the proof of authentication_middle.2.4.

authentication_middle.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (n: Nonce): rho_middle(i!1)(nonce(n)) AND m!2 = nlist((: n :))
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (n: Nonce): rho_middle(i!1)(nonce(n)) AND m!2 = nlist((: n :))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(nonce(n!1)) AND m!2 = nlist((: n!1 :))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (flatten)
Applying disjunctive simplification to flatten sequent,
this simplifies to: 
authentication_middle.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(nonce(n!1))
{-2}  m!2 = nlist((: n!1 :))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (expand "rho_middle" -1)
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  n!1 /= n_last
[-2]  m!2 = nlist((: n!1 :))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
authentication_middle.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  n!1 /= n_last
[-2]  m!2 = nlist((: n!1 :))
  |-------
{1}   rho_middle(i!1)(nlist((: n!1 :)))

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  n!1 /= n_last
[-2]  m!2 = nlist((: n!1 :))
{-3}  elt((: n!1 :), n_last)
  |-------

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.5 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  n!1 /= n_last
[-2]  elt((: n!1 :), n_last)
  |-------

Rerunning step: (grind)
/= rewrites n!1 /= n_last
  to NOT (n!1 = n_last)
elt rewrites elt((: n!1 :), n_last)
  to EXISTS (i: below[length((: n!1 :))]): nth((: n!1 :), i) = n_last
length rewrites length[Nonce]((: :))
  to 0
length rewrites length((: n!1 :))
  to 1
nth rewrites nth((: n!1 :), i!2)
  to n!1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_middle.2.5.

authentication_middle.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (n: Nonce): rho_middle(i!1)(nlist((: n :))) AND m!2 = nonce(n)
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (n: Nonce): rho_middle(i!1)(nlist((: n :))) AND m!2 = nonce(n)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(nlist((: n!1 :))) AND m!2 = nonce(n!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_middle.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(nlist((: n!1 :)))
{-2}  m!2 = nonce(n!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
authentication_middle.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(nlist((: n!1 :)))
[-2]  m!2 = nonce(n!1)
  |-------
{1}   rho_middle(i!1)(nonce(n!1))

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(nlist((: n!1 :)))
  |-------
[1]   rho_middle(i!1)(nonce(n!1))

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   elt((: n!1 :), n_last)
{2}   n!1 /= n_last

Rerunning step: (expand "elt")
Expanding the definition of elt,
this simplifies to: 
authentication_middle.2.6 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   EXISTS (i: below[length((: n!1 :))]): nth((: n!1 :), i) = n_last
[2]   n!1 /= n_last

Rerunning step: (inst 1 "0")
Instantiating the top quantifier in 1 with the terms: 
 0,
this yields  2 subgoals: 
authentication_middle.2.6.1 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   nth((: n!1 :), 0) = n_last
[2]   n!1 /= n_last

Rerunning step: (grind :exclude 2)
nth rewrites nth((: n!1 :), 0)
  to n!1
/= rewrites n!1 /= n_last
  to TRUE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_middle.2.6.1.

authentication_middle.2.6.2 (TCC):   

  |-------
{1}   0 < length[Nonce]((: n!1 :))
[2]   n!1 /= n_last

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.6.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   0 < length[Nonce]((: n!1 :))

Rerunning step: (grind)
length rewrites length[Nonce]((: :))
  to 0
length rewrites length[Nonce]((: n!1 :))
  to 1
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_middle.2.6.2.


This completes the proof of authentication_middle.2.6.

authentication_middle.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (nl1, nl2: list[Nonce]):
        rho_middle(i!1)(nlist(nl1)) AND
         rho_middle(i!1)(nlist(nl2)) AND m!2 = nlist(append(nl1, nl2))
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (nl1, nl2: list[Nonce]):
        rho_middle(i!1)(nlist(nl1)) AND
         rho_middle(i!1)(nlist(nl2)) AND m!2 = nlist(append(nl1, nl2))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(nlist(nl1!1)) AND
       rho_middle(i!1)(nlist(nl2!1)) AND m!2 = nlist(append(nl1!1, nl2!1))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_middle.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(nlist(nl1!1))
{-2}  rho_middle(i!1)(nlist(nl2!1))
{-3}  m!2 = nlist(append(nl1!1, nl2!1))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_middle.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(nlist(nl1!1))
[-2]  rho_middle(i!1)(nlist(nl2!1))
[-3]  m!2 = nlist(append(nl1!1, nl2!1))
  |-------
{1}   rho_middle(i!1)(nlist(append(nl1!1, nl2!1)))

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(nlist(nl1!1))
[-2]  rho_middle(i!1)(nlist(nl2!1))
  |-------
[1]   rho_middle(i!1)(nlist(append(nl1!1, nl2!1)))

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(append(nl1!1, nl2!1), n_last)
  |-------
{1}   elt(nl1!1, n_last)
{2}   elt(nl2!1, n_last)

Rerunning step: (lemma "listprops[Nonce].elt_append3"
                 ("l1" "nl1!1" "l2" "nl2!1" "t" "n_last"))
Applying listprops[Nonce].elt_append3 where 
  l1 gets nl1!1,
  l2 gets nl2!1,
  t gets n_last,
this simplifies to: 
authentication_middle.2.7 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(append(nl1!1, nl2!1), n_last) IMPLIES
       elt(nl1!1, n_last) OR elt(nl2!1, n_last)
[-2]  elt(append(nl1!1, nl2!1), n_last)
  |-------
[1]   elt(nl1!1, n_last)
[2]   elt(nl2!1, n_last)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_middle.2.7.

authentication_middle.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (nl, nl1, nl2: list[Nonce]):
        rho_middle(i!1)(nlist(nl)) AND
         nl = append(nl1, nl2) AND m!2 = nlist(nl1)
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (nl, nl1, nl2: list[Nonce]):
        rho_middle(i!1)(nlist(nl)) AND
         nl = append(nl1, nl2) AND m!2 = nlist(nl1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(nlist(nl!1)) AND
       nl!1 = append(nl1!1, nl2!1) AND m!2 = nlist(nl1!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_middle.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(nlist(nl!1))
{-2}  nl!1 = append(nl1!1, nl2!1)
{-3}  m!2 = nlist(nl1!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_middle.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(nlist(nl!1))
[-2]  nl!1 = append(nl1!1, nl2!1)
[-3]  m!2 = nlist(nl1!1)
  |-------
{1}   rho_middle(i!1)(nlist(nl1!1))

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(nlist(nl!1))
[-2]  nl!1 = append(nl1!1, nl2!1)
  |-------
[1]   rho_middle(i!1)(nlist(nl1!1))

Rerunning step: (replace -2 -1)
Replacing using formula -2,
this simplifies to: 
authentication_middle.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(nlist(append(nl1!1, nl2!1)))
[-2]  nl!1 = append(nl1!1, nl2!1)
  |-------
[1]   rho_middle(i!1)(nlist(nl1!1))

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(nlist(append(nl1!1, nl2!1)))
  |-------
[1]   rho_middle(i!1)(nlist(nl1!1))

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(nl1!1, n_last)
  |-------
{1}   elt(append(nl1!1, nl2!1), n_last)

Rerunning step: (lemma "listprops[Nonce].elt_append1"
                 ("l1" "nl1!1" "l2" "nl2!1" "t" "n_last"))
Applying listprops[Nonce].elt_append1 where 
  l1 gets nl1!1,
  l2 gets nl2!1,
  t gets n_last,
this simplifies to: 
authentication_middle.2.8 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(nl1!1, n_last) IMPLIES elt(append(nl1!1, nl2!1), n_last)
[-2]  elt(nl1!1, n_last)
  |-------
[1]   elt(append(nl1!1, nl2!1), n_last)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_middle.2.8.

authentication_middle.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (nl, nl1, nl2: list[Nonce]):
        rho_middle(i!1)(nlist(nl)) AND
         nl = append(nl1, nl2) AND m!2 = nlist(nl2)
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (nl, nl1, nl2: list[Nonce]):
        rho_middle(i!1)(nlist(nl)) AND
         nl = append(nl1, nl2) AND m!2 = nlist(nl2)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(nlist(nl!1)) AND
       nl!1 = append(nl1!1, nl2!1) AND m!2 = nlist(nl2!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_middle.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(nlist(nl!1))
{-2}  nl!1 = append(nl1!1, nl2!1)
{-3}  m!2 = nlist(nl2!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_middle.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(nlist(nl!1))
[-2]  nl!1 = append(nl1!1, nl2!1)
[-3]  m!2 = nlist(nl2!1)
  |-------
{1}   rho_middle(i!1)(nlist(nl2!1))

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(nlist(nl!1))
[-2]  nl!1 = append(nl1!1, nl2!1)
  |-------
[1]   rho_middle(i!1)(nlist(nl2!1))

Rerunning step: (replace -2 -1)
Replacing using formula -2,
this simplifies to: 
authentication_middle.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(nlist(append(nl1!1, nl2!1)))
[-2]  nl!1 = append(nl1!1, nl2!1)
  |-------
[1]   rho_middle(i!1)(nlist(nl2!1))

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(nlist(append(nl1!1, nl2!1)))
  |-------
[1]   rho_middle(i!1)(nlist(nl2!1))

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(nl2!1, n_last)
  |-------
{1}   elt(append(nl1!1, nl2!1), n_last)

Rerunning step: (lemma "listprops[Nonce].elt_append2"
                 ("l1" "nl1!1" "l2" "nl2!1" "t" "n_last"))
Applying listprops[Nonce].elt_append2 where 
  l1 gets nl1!1,
  l2 gets nl2!1,
  t gets n_last,
this simplifies to: 
authentication_middle.2.9 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  elt(nl2!1, n_last) IMPLIES elt(append(nl1!1, nl2!1), n_last)
[-2]  elt(nl2!1, n_last)
  |-------
[1]   elt(append(nl1!1, nl2!1), n_last)

Rerunning step: (prop)
Applying propositional simplification,

This completes the proof of authentication_middle.2.9.

authentication_middle.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (i: Identity):
        rho_middle(i!1)(user(i)) AND m!2 = ilist((: i :))
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (i: Identity):
        rho_middle(i!1)(user(i)) AND m!2 = ilist((: i :))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(user(i!2)) AND m!2 = ilist((: i!2 :))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_middle.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(user(i!2))
{-2}  m!2 = ilist((: i!2 :))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
authentication_middle.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(user(i!2))
[-2]  m!2 = ilist((: i!2 :))
  |-------
{1}   rho_middle(i!1)(ilist((: i!2 :)))

Rerunning step: (delete -1 -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   rho_middle(i!1)(ilist((: i!2 :)))

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.10 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_middle.2.10.

authentication_middle.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (i: Identity):
        rho_middle(i!1)(ilist((: i :))) AND m!2 = user(i)
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (i: Identity):
        rho_middle(i!1)(ilist((: i :))) AND m!2 = user(i)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(ilist((: i!2 :))) AND m!2 = user(i!2)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_middle.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(ilist((: i!2 :)))
{-2}  m!2 = user(i!2)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (replace -2 1)
Replacing using formula -2,
this simplifies to: 
authentication_middle.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(ilist((: i!2 :)))
[-2]  m!2 = user(i!2)
  |-------
{1}   rho_middle(i!1)(user(i!2))

Rerunning step: (delete -1 -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   rho_middle(i!1)(user(i!2))

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.11 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_middle.2.11.

authentication_middle.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (il1, il2: list[Identity]):
        rho_middle(i!1)(ilist(il1)) AND
         rho_middle(i!1)(ilist(il2)) AND m!2 = ilist(append(il1, il2))
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (il1, il2: list[Identity]):
        rho_middle(i!1)(ilist(il1)) AND
         rho_middle(i!1)(ilist(il2)) AND m!2 = ilist(append(il1, il2))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(ilist(il1!1)) AND
       rho_middle(i!1)(ilist(il2!1)) AND m!2 = ilist(append(il1!1, il2!1))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_middle.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(ilist(il1!1))
{-2}  rho_middle(i!1)(ilist(il2!1))
{-3}  m!2 = ilist(append(il1!1, il2!1))
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_middle.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(ilist(il1!1))
[-2]  rho_middle(i!1)(ilist(il2!1))
[-3]  m!2 = ilist(append(il1!1, il2!1))
  |-------
{1}   rho_middle(i!1)(ilist(append(il1!1, il2!1)))

Rerunning step: (delete -1 -2 -3)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   rho_middle(i!1)(ilist(append(il1!1, il2!1)))

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.12 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_middle.2.12.

authentication_middle.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (il, il1, il2: list[Identity]):
        rho_middle(i!1)(ilist(il)) AND
         il = append(il1, il2) AND m!2 = ilist(il1)
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (il, il1, il2: list[Identity]):
        rho_middle(i!1)(ilist(il)) AND
         il = append(il1, il2) AND m!2 = ilist(il1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(ilist(il!1)) AND
       il!1 = append(il1!1, il2!1) AND m!2 = ilist(il1!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_middle.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(ilist(il!1))
{-2}  il!1 = append(il1!1, il2!1)
{-3}  m!2 = ilist(il1!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_middle.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(ilist(il!1))
[-2]  il!1 = append(il1!1, il2!1)
[-3]  m!2 = ilist(il1!1)
  |-------
{1}   rho_middle(i!1)(ilist(il1!1))

Rerunning step: (delete -1 -2 -3)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   rho_middle(i!1)(ilist(il1!1))

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.13 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_middle.2.13.

authentication_middle.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS (il, il1, il2: list[Identity]):
        rho_middle(i!1)(ilist(il)) AND
         il = append(il1, il2) AND m!2 = ilist(il2)
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS (il, il1, il2: list[Identity]):
        rho_middle(i!1)(ilist(il)) AND
         il = append(il1, il2) AND m!2 = ilist(il2)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(ilist(il!1)) AND
       il!1 = append(il1!1, il2!1) AND m!2 = ilist(il2!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_middle.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(ilist(il!1))
{-2}  il!1 = append(il1!1, il2!1)
{-3}  m!2 = ilist(il2!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_middle.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(ilist(il!1))
[-2]  il!1 = append(il1!1, il2!1)
[-3]  m!2 = ilist(il2!1)
  |-------
{1}   rho_middle(i!1)(ilist(il2!1))

Rerunning step: (delete -1 -2 -3)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
[1]   rho_middle(i!1)(ilist(il2!1))

Rerunning step: (expand "rho_middle")
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.14 : 
;;; from of a set of messages in rho, no message not in rho can be generated

  |-------
{1}   TRUE

which is trivially true.

This completes the proof of authentication_middle.2.14.

authentication_middle.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  EXISTS m1, k:
        rho_middle(i!1)(m1) AND rho_middle(i!1)(k) AND m!2 = E(k, m1)
[-2]  FORALL (x: Message): S!1(x) => rho_middle(i!1)(x)
  |-------
{1}   rho_middle(i!1)(m!2)

Rerunning step: (delete -2)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  EXISTS m1, k:
        rho_middle(i!1)(m1) AND rho_middle(i!1)(k) AND m!2 = E(k, m1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(m1!1) AND rho_middle(i!1)(k!1) AND m!2 = E(k!1, m1!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (prop)
Applying propositional simplification,
this simplifies to: 
authentication_middle.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  rho_middle(i!1)(m1!1)
{-2}  rho_middle(i!1)(k!1)
{-3}  m!2 = E(k!1, m1!1)
  |-------
[1]   rho_middle(i!1)(m!2)

Rerunning step: (replace -3 1)
Replacing using formula -3,
this simplifies to: 
authentication_middle.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(m1!1)
[-2]  rho_middle(i!1)(k!1)
[-3]  m!2 = E(k!1, m1!1)
  |-------
{1}   rho_middle(i!1)(E(k!1, m1!1))

Rerunning step: (delete -3)
Deleting some formulas,
this simplifies to: 
authentication_middle.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  rho_middle(i!1)(m1!1)
[-2]  rho_middle(i!1)(k!1)
  |-------
[1]   rho_middle(i!1)(E(k!1, m1!1))

Rerunning step: (typepred "k!1")
Adding type constraints for  k!1,
this simplifies to: 
authentication_middle.2.15 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  public?(k!1) OR secret?(k!1)
[-2]  rho_middle(i!1)(m1!1)
[-3]  rho_middle(i!1)(k!1)
  |-------
[1]   rho_middle(i!1)(E(k!1, m1!1))

Rerunning step: (split)
Splitting conjunctions,
this yields  2 subgoals: 
authentication_middle.2.15.1 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  public?(k!1)
[-2]  rho_middle(i!1)(m1!1)
[-3]  rho_middle(i!1)(k!1)
  |-------
[1]   rho_middle(i!1)(E(k!1, m1!1))

Rerunning step: (grind)
rho_middle rewrites rho_middle(i!1)(k!1)
  to TRUE
E rewrites E(k!1, m1!1)
  to CASES m1!1
        OF code(k1, m1):
             CASES k1
               OF public(i):
                    IF k!1 = secret(i) THEN m1 ELSE code(k!1, m1!1) ENDIF,
                  secret(i):
                    IF k!1 = public(i) THEN m1 ELSE code(k!1, m1!1) ENDIF
               ENDCASES
        ELSE code(k!1, m1!1)
        ENDCASES
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites rho_middle(i!1)(code(k!1, m1!1))
  to TRUE
rho_middle rewrites rho_middle(i!1)(public(x_secret(x_code(m1!1))))
  to TRUE
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites rho_middle(i!1)(m1!1)
  to FALSE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_middle.2.15.1.

authentication_middle.2.15.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

{-1}  secret?(k!1)
[-2]  rho_middle(i!1)(m1!1)
[-3]  rho_middle(i!1)(k!1)
  |-------
[1]   rho_middle(i!1)(E(k!1, m1!1))

Rerunning step: (expand "rho_middle" -3)
Expanding the definition of rho_middle,
this simplifies to: 
authentication_middle.2.15.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  secret?(k!1)
[-2]  rho_middle(i!1)(m1!1)
{-3}  CASES k!1
        OF nonce(z): z /= n_last,
           nlist(z): NOT elt(z, n_last),
           secret(z): NOT (EXISTS (i: nat_to_p): z = hu(i)),
           conc(z1, z2): rho_middle(i!1)(z1) AND rho_middle(i!1)(z2),
           commit(z1, z2, z3):
             z1 /= p - 1 OR z2 /= hu_list OR z3 /= n_last,
           code(z1, z2):
             rho_middle(i!1)(z2) OR
              (z1 = public(hu(0)) AND
                (EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
                   z2 =
                    conc(nlist(append(nl, (: n_last :))),
                         ilist(cdr(hu_list)))))
               OR
               EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
                 z1 = public(hu(j)) AND
                  EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
                    z2 =
                     conc(ilist(remove(hu_list, j)),
                          nlist(append(nl, (: n_last :))))
        ELSE TRUE
        ENDCASES
  |-------
[1]   rho_middle(i!1)(E(k!1, m1!1))

Rerunning step: (assert)
Simplifying, rewriting, and recording with decision procedures,
this simplifies to: 
authentication_middle.2.15.2 : 
;;; from of a set of messages in rho, no message not in rho can be generated

[-1]  secret?(k!1)
[-2]  rho_middle(i!1)(m1!1)
  |-------
{1}   EXISTS (i: nat_to_p): x_secret(k!1) = hu(i)
[2]   rho_middle(i!1)(E(k!1, m1!1))

Rerunning step: (lazy-grind)
E rewrites E(k!1, m1!1)
  to CASES m1!1
        OF code(k1, m1):
             CASES k1
               OF public(i):
                    IF k!1 = secret(i) THEN m1 ELSE code(k!1, m1!1) ENDIF,
                  secret(i):
                    IF k!1 = public(i) THEN m1 ELSE code(k!1, m1!1) ENDIF
               ENDCASES
        ELSE code(k!1, m1!1)
        ENDCASES
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites rho_middle(i!1)(code(k!1, m1!1))
  to TRUE
remove rewrites remove(hu_list, j)
  to cons(car(hu_list), remove(cdr(hu_list), j - 1))
rho_middle rewrites rho_middle(i!1)(m1!1)
  to (x_code(m1!1) = public(hu(0)) AND
        EXISTS (nl: {x: list[Nonce] | length(x) = p - 1}):
          y_code(m1!1) =
           conc(nlist(append(nl, (: n_last :))), ilist(cdr(hu_list))))
       OR
       EXISTS (j: {x: nat | 0 < x AND x <= i!1}):
         x_code(m1!1) = public(hu(j)) AND
          EXISTS (nl: {x: list[Nonce] | length(x) = -1 - j + p}):
            y_code(m1!1) =
             conc(ilist(cons(car(hu_list), remove(cdr(hu_list), j - 1))),
                  nlist(append(nl, (: n_last :))))
elt rewrites elt(append(nl!1, (: n_last :)), n_last)
  to EXISTS (i: below[length(append(nl!1, (: n_last :)))]):
        nth(append(nl!1, (: n_last :)), i) = n_last
rho_middle rewrites rho_middle(i!1)(nlist(append(nl!1, (: n_last :))))
  to NOT EXISTS (i: below[length(append(nl!1, (: n_last :)))]):
            nth(append(nl!1, (: n_last :)), i) = n_last
rho_middle rewrites rho_middle(i!1)(ilist(cdr(hu_list)))
  to TRUE
rho_middle rewrites 
  rho_middle(i!1)
            (conc(nlist(append(nl!1, (: n_last :))), ilist(cdr(hu_list))))
  to NOT EXISTS (i: below[length(append(nl!1, (: n_last :)))]):
            nth(append(nl!1, (: n_last :)), i) = n_last
rho_middle rewrites 
  rho_middle(i!1)(ilist(cons(car(hu_list), remove(cdr(hu_list), j!1 - 1))))
  to TRUE
elt rewrites elt(append(nl!1, (: n_last :)), n_last)
  to EXISTS (i: below[length(append(nl!1, (: n_last :)))]):
        nth(append(nl!1, (: n_last :)), i) = n_last
rho_middle rewrites rho_middle(i!1)(nlist(append(nl!1, (: n_last :))))
  to NOT EXISTS (i: below[length(append(nl!1, (: n_last :)))]):
            nth(append(nl!1, (: n_last :)), i) = n_last
rho_middle rewrites 
  rho_middle(i!1)
            (conc(ilist(cons(car(hu_list), remove(cdr(hu_list), j!1 - 1))),
                  nlist(append(nl!1, (: n_last :)))))
  to NOT EXISTS (i: below[length(append(nl!1, (: n_last :)))]):
            nth(append(nl!1, (: n_last :)), i) = n_last
By skolemization, if-lifting, simplification and instantiation,

This completes the proof of authentication_middle.2.15.2.


This completes the proof of authentication_middle.2.15.


This completes the proof of authentication_middle.2.

authentication_middle.3 :  

  |-------
{1}   FORALL (i: Identity):
        USER(i) # R_middle(i!1) |> RankUser(rho_middle(i!1))
[2]   network(USER) |> auth(T, R_middle(i!1))

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_middle.3 :  

  |-------
[1]   FORALL (i: Identity):
        USER(i) # R_middle(i!1) |> RankUser(rho_middle(i!1))

Rerunning step: (comment "users maintain the rank function")
Adding comment: users maintain the rank function
this simplifies to: 
authentication_middle.3 : 
;;; users maintain the rank function

  |-------
[1]   FORALL (i: Identity):
        USER(i) # R_middle(i!1) |> RankUser(rho_middle(i!1))

Rerunning step: (skolem!)
Skolemizing,
this simplifies to: 
authentication_middle.3 : 
;;; users maintain the rank function

  |-------
{1}   USER(i!2) # R_middle(i!1) |> RankUser(rho_middle(i!1))

Rerunning step: (expand "USER")
Expanding the definition of USER,
this simplifies to: 
authentication_middle.3 : 
;;; users maintain the rank function

  |-------
{1}   (Interleave! (P: nat_from_2):
         (Interleave! (nn0: Nonces(P, i!2, 0)): UROLE_INIT(P, i!2, nn0)) //
          (Interleave! (nnP: Nonces(P, i!2, P - 1)):
             UROLE_LAST(P, i!2, nnP))
          //
          IF P = 2 THEN Stop[event]
          ELSE (Interleave! (j: nat_1_to(P), nnJ: Nonces(P, i!2, j)):
                  UROLE_MIDDLE(P, j, i!2, nnJ))
          ENDIF)
       # R_middle(i!1)
       |> RankUser(rho_middle(i!1))

Rerunning step: (expand "RankUser")
Expanding the definition of RankUser,
this simplifies to: 
authentication_middle.3 : 
;;; users maintain the rank function

  |-------
{1}   (Interleave! (P: nat_from_2):
         (Interleave! (nn0: Nonces(P, i!2, 0)): UROLE_INIT(P, i!2, nn0)) //
          (Interleave! (nnP: Nonces(P, i!2, P - 1)):
             UROLE_LAST(P, i!2, nnP))
          //
          IF P = 2 THEN Stop[event]
          ELSE (Interleave! (j: nat_1_to(P), nnJ: Nonces(P, i!2, j)):
                  UROLE_MIDDLE(P, j, i!2, nnJ))
          ENDIF)
       # R_middle(i!1)
       |>
       LAMBDA (tr: list[event]):
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (tr)
          IMPLIES
          every(LAMBDA (e: event):
                  complement(rec?)(e) IMPLIES rho_middle(i!1)(msg(e)))
               (tr)

Rerunning step: (interleaving2)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
Applying interleaving rule,
this simplifies to: 
authentication_middle.3 : 
;;; users maintain the rank function

  |-------
{1}   (Interleave! (nn0: Nonces(i!3, i!2, 0)): UROLE_INIT(i!3, i!2, nn0))
       //
       (Interleave! (nnP: Nonces(i!3, i!2, i!3 - 1)):
          UROLE_LAST(i!3, i!2, nnP))
       //
       IF i!3 = 2 THEN Stop[event]
       ELSE (Interleave! (j: nat_1_to(i!3), nnJ: Nonces(i!3, i!2, j)):
               UROLE_MIDDLE(i!3, j, i!2, nnJ))
       ENDIF
       # R_middle(i!1)
       |>
       LAMBDA (t: list[event]):
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (t)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (t)

Rerunning step: (interleaving)
Applying interleaving rule,
this yields  2 subgoals: 
authentication_middle.3.1 : 
;;; users maintain the rank function

  |-------
{1}   (((Interleave! (nn0: Nonces(i!3, i!2, 0)): UROLE_INIT(i!3, i!2, nn0))
         //
         (Interleave! (nnP: Nonces(i!3, i!2, i!3 - 1)):
            UROLE_LAST(i!3, i!2, nnP))
         # R_middle(i!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                (t))

Rerunning step: (interleaving)
Applying interleaving rule,
this yields  2 subgoals: 
authentication_middle.3.1.1 : 
;;; users maintain the rank function

  |-------
{1}   (((Interleave! (nn0: Nonces(i!3, i!2, 0)): UROLE_INIT(i!3, i!2, nn0))
         # R_middle(i!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                (t))

Rerunning step: (lemma "restrictmiddle_init"
                 ("P" "i!3" "u" "i!2" "i" "i!1"))
Applying restrictmiddle_init where 
  P gets i!3,
  u gets i!2,
  i gets i!1,
this simplifies to: 
authentication_middle.3.1.1 : 
;;; users maintain the rank function

{-1}  ((Interleave! (nn0: Nonces(i!3, i!2, 0)): UROLE_INIT(i!3, i!2, nn0))
        # R_middle(i!1))
       |> RankUser(rho_middle(i!1))
  |-------
[1]   (((Interleave! (nn0: Nonces(i!3, i!2, 0)): UROLE_INIT(i!3, i!2, nn0))
         # R_middle(i!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                (t))

Rerunning step: (grind :exclude ("rho_middle" "UROLE_INIT"))
Interleave rewrites 
  (Interleave! (nn0: Nonces(i!3, i!2, 0)): UROLE_INIT(i!3, i!2, nn0))
  to Par(emptyset)
         (LAMBDA (nn0: Nonces(i!3, i!2, 0)): UROLE_INIT(i!3, i!2, nn0))
# rewrites 
  (Par(emptyset)
      (LAMBDA (nn0: Nonces(i!3, i!2, 0)): UROLE_INIT(i!3, i!2, nn0))
    # R_middle(i!1))
  to Par(R_middle(i!1))
         (Par(emptyset)
             (LAMBDA (nn0: Nonces(i!3, i!2, 0)):
                UROLE_INIT(i!3, i!2, nn0)),
          Stop)
Par rewrites 
  Par(R_middle(i!1))
     (Par(emptyset)
         (LAMBDA (nn0: Nonces(i!3, i!2, 0)): UROLE_INIT(i!3, i!2, nn0)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nn0: Nonces(i!3, i!2, 0)):
                       UROLE_INIT(i!3, i!2, nn0)))),
             (t2: (Stop)):
        prod(R_middle(i!1))(t1, t2, x)
member rewrites 
  member(x,
         Par(R_middle(i!1))
            (Par(emptyset)
                (LAMBDA (nn0: Nonces(i!3, i!2, 0)):
                   UROLE_INIT(i!3, i!2, nn0)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nn0: Nonces(i!3, i!2, 0)):
                       UROLE_INIT(i!3, i!2, nn0)))),
             (t2: (Stop)):
        prod(R_middle(i!1))(t1, t2, x)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
RankUser rewrites RankUser(rho_middle(i!1))(x)
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))(x)
       IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
            (x)
member rewrites member(x, RankUser(rho_middle(i!1)))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))(x)
       IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
            (x)
subset? rewrites 
  subset?(Par(R_middle(i!1))
             (Par(emptyset)
                 (LAMBDA (nn0: Nonces(i!3, i!2, 0)):
                    UROLE_INIT(i!3, i!2, nn0)),
              Stop),
          RankUser(rho_middle(i!1)))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nn0: Nonces(i!3, i!2, 0)):
                          UROLE_INIT(i!3, i!2, nn0)))),
                (t2: (Stop)):
           prod(R_middle(i!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (x)
          IMPLIES
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (x)
|> rewrites 
  Par(R_middle(i!1))
     (Par(emptyset)
         (LAMBDA (nn0: Nonces(i!3, i!2, 0)): UROLE_INIT(i!3, i!2, nn0)),
      Stop)
   |> RankUser(rho_middle(i!1))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nn0: Nonces(i!3, i!2, 0)):
                          UROLE_INIT(i!3, i!2, nn0)))),
                (t2: (Stop)):
           prod(R_middle(i!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (x)
          IMPLIES
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (x)
Par rewrites 
  Par(R_middle(i!1))
     (Par(emptyset)
         (LAMBDA (nn0: Nonces(i!3, i!2, 0)): UROLE_INIT(i!3, i!2, nn0)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nn0: Nonces(i!3, i!2, 0)):
                       UROLE_INIT(i!3, i!2, nn0)))),
             (t2: (Stop)):
        prod(R_middle(i!1))(t1, t2, x)
member rewrites 
  member(x,
         Par(R_middle(i!1))
            (Par(emptyset)
                (LAMBDA (nn0: Nonces(i!3, i!2, 0)):
                   UROLE_INIT(i!3, i!2, nn0)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nn0: Nonces(i!3, i!2, 0)):
                       UROLE_INIT(i!3, i!2, nn0)))),
             (t2: (Stop)):
        prod(R_middle(i!1))(t1, t2, x)
member rewrites 
  member(x,
         LAMBDA (t: list[event]):
           every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                (t)
            =>
            every(LAMBDA (e: event):
                    NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                 (t))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))(x)
       =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
            (x)
subset? rewrites 
  subset?(Par(R_middle(i!1))
             (Par(emptyset)
                 (LAMBDA (nn0: Nonces(i!3, i!2, 0)):
                    UROLE_INIT(i!3, i!2, nn0)),
              Stop),
          LAMBDA (t: list[event]):
            every(LAMBDA (e: event):
                    rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                 (t)
             =>
             every(LAMBDA (e: event):
                     NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                  (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nn0: Nonces(i!3, i!2, 0)):
                          UROLE_INIT(i!3, i!2, nn0)))),
                (t2: (Stop)):
           prod(R_middle(i!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (x)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (x)
|> rewrites 
  (Par(R_middle(i!1))
      (Par(emptyset)
          (LAMBDA (nn0: Nonces(i!3, i!2, 0)): UROLE_INIT(i!3, i!2, nn0)),
       Stop)
    |>
    LAMBDA (t: list[event]):
      every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))(t)
       =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
            (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nn0: Nonces(i!3, i!2, 0)):
                          UROLE_INIT(i!3, i!2, nn0)))),
                (t2: (Stop)):
           prod(R_middle(i!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (x)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (x)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_middle.3.1.1.

authentication_middle.3.1.2 : 
;;; users maintain the rank function

  |-------
{1}   (((Interleave! (nnP: Nonces(i!3, i!2, i!3 - 1)):
           UROLE_LAST(i!3, i!2, nnP))
         # R_middle(i!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                (t))

Rerunning step: (lemma "restrictmiddle_last"
                 ("P" "i!3" "u" "i!2" "i" "i!1"))
Applying restrictmiddle_last where 
  P gets i!3,
  u gets i!2,
  i gets i!1,
this simplifies to: 
authentication_middle.3.1.2 : 
;;; users maintain the rank function

{-1}  ((Interleave! (nnP: Nonces(i!3, i!2, i!3 - 1)):
          UROLE_LAST(i!3, i!2, nnP))
        # R_middle(i!1))
       |> RankUser(rho_middle(i!1))
  |-------
[1]   (((Interleave! (nnP: Nonces(i!3, i!2, i!3 - 1)):
           UROLE_LAST(i!3, i!2, nnP))
         # R_middle(i!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                (t))

Rerunning step: (grind :exclude ("rho_middle" "UROLE_LAST"))
Interleave rewrites 
  (Interleave! (nnP: Nonces(i!3, i!2, i!3 - 1)): UROLE_LAST(i!3, i!2, nnP))
  to Par(emptyset)
         (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
            UROLE_LAST(i!3, i!2, nnP))
# rewrites 
  (Par(emptyset)
      (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)): UROLE_LAST(i!3, i!2, nnP))
    # R_middle(i!1))
  to Par(R_middle(i!1))
         (Par(emptyset)
             (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
                UROLE_LAST(i!3, i!2, nnP)),
          Stop)
Par rewrites 
  Par(R_middle(i!1))
     (Par(emptyset)
         (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
            UROLE_LAST(i!3, i!2, nnP)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
                       UROLE_LAST(i!3, i!2, nnP)))),
             (t2: (Stop)):
        prod(R_middle(i!1))(t1, t2, x)
member rewrites 
  member(x,
         Par(R_middle(i!1))
            (Par(emptyset)
                (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
                   UROLE_LAST(i!3, i!2, nnP)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
                       UROLE_LAST(i!3, i!2, nnP)))),
             (t2: (Stop)):
        prod(R_middle(i!1))(t1, t2, x)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
RankUser rewrites RankUser(rho_middle(i!1))(x)
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))(x)
       IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
            (x)
member rewrites member(x, RankUser(rho_middle(i!1)))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))(x)
       IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
            (x)
subset? rewrites 
  subset?(Par(R_middle(i!1))
             (Par(emptyset)
                 (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
                    UROLE_LAST(i!3, i!2, nnP)),
              Stop),
          RankUser(rho_middle(i!1)))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
                          UROLE_LAST(i!3, i!2, nnP)))),
                (t2: (Stop)):
           prod(R_middle(i!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (x)
          IMPLIES
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (x)
|> rewrites 
  Par(R_middle(i!1))
     (Par(emptyset)
         (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
            UROLE_LAST(i!3, i!2, nnP)),
      Stop)
   |> RankUser(rho_middle(i!1))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
                          UROLE_LAST(i!3, i!2, nnP)))),
                (t2: (Stop)):
           prod(R_middle(i!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (x)
          IMPLIES
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (x)
Par rewrites 
  Par(R_middle(i!1))
     (Par(emptyset)
         (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
            UROLE_LAST(i!3, i!2, nnP)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
                       UROLE_LAST(i!3, i!2, nnP)))),
             (t2: (Stop)):
        prod(R_middle(i!1))(t1, t2, x)
member rewrites 
  member(x,
         Par(R_middle(i!1))
            (Par(emptyset)
                (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
                   UROLE_LAST(i!3, i!2, nnP)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
                       UROLE_LAST(i!3, i!2, nnP)))),
             (t2: (Stop)):
        prod(R_middle(i!1))(t1, t2, x)
member rewrites 
  member(x,
         LAMBDA (t: list[event]):
           every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                (t)
            =>
            every(LAMBDA (e: event):
                    NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                 (t))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))(x)
       =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
            (x)
subset? rewrites 
  subset?(Par(R_middle(i!1))
             (Par(emptyset)
                 (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
                    UROLE_LAST(i!3, i!2, nnP)),
              Stop),
          LAMBDA (t: list[event]):
            every(LAMBDA (e: event):
                    rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                 (t)
             =>
             every(LAMBDA (e: event):
                     NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                  (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
                          UROLE_LAST(i!3, i!2, nnP)))),
                (t2: (Stop)):
           prod(R_middle(i!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (x)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (x)
|> rewrites 
  (Par(R_middle(i!1))
      (Par(emptyset)
          (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
             UROLE_LAST(i!3, i!2, nnP)),
       Stop)
    |>
    LAMBDA (t: list[event]):
      every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))(t)
       =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
            (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (nnP: Nonces(i!3, i!2, i!3 - 1)):
                          UROLE_LAST(i!3, i!2, nnP)))),
                (t2: (Stop)):
           prod(R_middle(i!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (x)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (x)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_middle.3.1.2.


This completes the proof of authentication_middle.3.1.

authentication_middle.3.2 : 
;;; users maintain the rank function

  |-------
{1}   ((IF i!3 = 2 THEN Stop[event]
        ELSE (Interleave! (j: nat_1_to(i!3), nnJ: Nonces(i!3, i!2, j)):
                UROLE_MIDDLE(i!3, j, i!2, nnJ))
        ENDIF
         # R_middle(i!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                (t))

Rerunning step: (lift-if)
Lifting IF-conditions to the top level,
this simplifies to: 
authentication_middle.3.2 : 
;;; users maintain the rank function

  |-------
{1}   IF i!3 = 2
        THEN ((Stop[event] # R_middle(i!1)) |>
               LAMBDA (t: list[event]):
                 every(LAMBDA (e: event):
                         rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                      (t)
                  =>
                  every(LAMBDA (e: event):
                          NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                       (t))
      ELSE (((Interleave! (j: nat_1_to(i!3), nnJ: Nonces(i!3, i!2, j)):
                UROLE_MIDDLE(i!3, j, i!2, nnJ))
              # R_middle(i!1))
             |>
             LAMBDA (t: list[event]):
               every(LAMBDA (e: event):
                       rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                    (t)
                =>
                every(LAMBDA (e: event):
                        NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                     (t))
      ENDIF

Rerunning step: (prop)
Applying propositional simplification,
this yields  2 subgoals: 
authentication_middle.3.2.1 : 
;;; users maintain the rank function

{-1}  i!3 = 2
  |-------
{1}   ((Stop[event] # R_middle(i!1)) |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                (t))

Rerunning step: (stop)
Applying stop rule,

This completes the proof of authentication_middle.3.2.1.

authentication_middle.3.2.2 : 
;;; users maintain the rank function

  |-------
{1}   i!3 = 2
{2}   (((Interleave! (j: nat_1_to(i!3), nnJ: Nonces(i!3, i!2, j)):
           UROLE_MIDDLE(i!3, j, i!2, nnJ))
         # R_middle(i!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                (t))

Rerunning step: (lemma "restrictmiddle_middle"
                 ("P" "i!3" "u" "i!2" "i" "i!1"))
Applying restrictmiddle_middle where 
  P gets i!3,
  u gets i!2,
  i gets i!1,
this simplifies to: 
authentication_middle.3.2.2 : 
;;; users maintain the rank function

{-1}  i!3 /= 2 =>
       (((Interleave! (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
            UROLE_MIDDLE(i!3, k, i!2, nnK))
          # R_middle(i!1))
         |> RankUser(rho_middle(i!1)))
  |-------
[1]   i!3 = 2
[2]   (((Interleave! (j: nat_1_to(i!3), nnJ: Nonces(i!3, i!2, j)):
           UROLE_MIDDLE(i!3, j, i!2, nnJ))
         # R_middle(i!1))
        |>
        LAMBDA (t: list[event]):
          every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (t)
           =>
           every(LAMBDA (e: event):
                   NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                (t))

Rerunning step: (grind :exclude ("rho_middle" "UROLE_MIDDLE"))
Interleave rewrites 
  (Interleave! (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
     UROLE_MIDDLE(i!3, k, i!2, nnK))
  to Par(emptyset)
         (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
            UROLE_MIDDLE(i!3, k, i!2, nnK))
# rewrites 
  (Par(emptyset)
      (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
         UROLE_MIDDLE(i!3, k, i!2, nnK))
    # R_middle(i!1))
  to Par(R_middle(i!1))
         (Par(emptyset)
             (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
                UROLE_MIDDLE(i!3, k, i!2, nnK)),
          Stop)
Par rewrites 
  Par(R_middle(i!1))
     (Par(emptyset)
         (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
            UROLE_MIDDLE(i!3, k, i!2, nnK)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
                       UROLE_MIDDLE(i!3, k, i!2, nnK)))),
             (t2: (Stop)):
        prod(R_middle(i!1))(t1, t2, x)
member rewrites 
  member(x,
         Par(R_middle(i!1))
            (Par(emptyset)
                (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
                   UROLE_MIDDLE(i!3, k, i!2, nnK)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
                       UROLE_MIDDLE(i!3, k, i!2, nnK)))),
             (t2: (Stop)):
        prod(R_middle(i!1))(t1, t2, x)
member rewrites member(e, rec?)
  to rec?(e)
complement rewrites complement(rec?)(e)
  to NOT rec?(e)
RankUser rewrites RankUser(rho_middle(i!1))(x)
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))(x)
       IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
            (x)
member rewrites member(x, RankUser(rho_middle(i!1)))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))(x)
       IMPLIES
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
            (x)
subset? rewrites 
  subset?(Par(R_middle(i!1))
             (Par(emptyset)
                 (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
                    UROLE_MIDDLE(i!3, k, i!2, nnK)),
              Stop),
          RankUser(rho_middle(i!1)))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (k: nat_1_to(i!3),
                                nnK: Nonces(i!3, i!2, k)):
                          UROLE_MIDDLE(i!3, k, i!2, nnK)))),
                (t2: (Stop)):
           prod(R_middle(i!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (x)
          IMPLIES
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (x)
|> rewrites 
  (Par(R_middle(i!1))
      (Par(emptyset)
          (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
             UROLE_MIDDLE(i!3, k, i!2, nnK)),
       Stop)
    |> RankUser(rho_middle(i!1)))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (k: nat_1_to(i!3),
                                nnK: Nonces(i!3, i!2, k)):
                          UROLE_MIDDLE(i!3, k, i!2, nnK)))),
                (t2: (Stop)):
           prod(R_middle(i!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (x)
          IMPLIES
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (x)
Par rewrites 
  Par(R_middle(i!1))
     (Par(emptyset)
         (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
            UROLE_MIDDLE(i!3, k, i!2, nnK)),
      Stop)
     (x)
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
                       UROLE_MIDDLE(i!3, k, i!2, nnK)))),
             (t2: (Stop)):
        prod(R_middle(i!1))(t1, t2, x)
member rewrites 
  member(x,
         Par(R_middle(i!1))
            (Par(emptyset)
                (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
                   UROLE_MIDDLE(i!3, k, i!2, nnK)),
             Stop))
  to EXISTS (t1:
                (Par(emptyset)
                    (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
                       UROLE_MIDDLE(i!3, k, i!2, nnK)))),
             (t2: (Stop)):
        prod(R_middle(i!1))(t1, t2, x)
member rewrites 
  member(x,
         LAMBDA (t: list[event]):
           every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                (t)
            =>
            every(LAMBDA (e: event):
                    NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                 (t))
  to every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))(x)
       =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
            (x)
subset? rewrites 
  subset?(Par(R_middle(i!1))
             (Par(emptyset)
                 (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
                    UROLE_MIDDLE(i!3, k, i!2, nnK)),
              Stop),
          LAMBDA (t: list[event]):
            every(LAMBDA (e: event):
                    rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                 (t)
             =>
             every(LAMBDA (e: event):
                     NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
                  (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (k: nat_1_to(i!3),
                                nnK: Nonces(i!3, i!2, k)):
                          UROLE_MIDDLE(i!3, k, i!2, nnK)))),
                (t2: (Stop)):
           prod(R_middle(i!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (x)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (x)
|> rewrites 
  (Par(R_middle(i!1))
      (Par(emptyset)
          (LAMBDA (k: nat_1_to(i!3), nnK: Nonces(i!3, i!2, k)):
             UROLE_MIDDLE(i!3, k, i!2, nnK)),
       Stop)
    |>
    LAMBDA (t: list[event]):
      every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))(t)
       =>
       every(LAMBDA (e: event): NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
            (t))
  to FORALL (x: list[event]):
        (EXISTS (t1:
                   (Par(emptyset)
                       (LAMBDA (k: nat_1_to(i!3),
                                nnK: Nonces(i!3, i!2, k)):
                          UROLE_MIDDLE(i!3, k, i!2, nnK)))),
                (t2: (Stop)):
           prod(R_middle(i!1))(t1, t2, x))
         =>
         every(LAMBDA (e: event): rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
              (x)
          =>
          every(LAMBDA (e: event):
                  NOT rec?(e) IMPLIES rho_middle(i!1)(msg(e)))
               (x)
/= rewrites i!3 /= 2
  to NOT (i!3 = 2)
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_middle.3.2.2.


This completes the proof of authentication_middle.3.2.


This completes the proof of authentication_middle.3.

authentication_middle.4 :  

  |-------
{1}   FORALL (e: (T)): NOT rho_middle(i!1)(msg(e))
[2]   network(USER) |> auth(T, R_middle(i!1))

Rerunning step: (delete 2)
Deleting some formulas,
this simplifies to: 
authentication_middle.4 :  

  |-------
[1]   FORALL (e: (T)): NOT rho_middle(i!1)(msg(e))

Rerunning step: (comment "T is not in rho")
Adding comment: T is not in rho
this simplifies to: 
authentication_middle.4 : 
;;; T is not in rho

  |-------
[1]   FORALL (e: (T)): NOT rho_middle(i!1)(msg(e))

Rerunning step: (skolem-typepred)
Skolemizing (with typepred on new Skolem constants),
this simplifies to: 
authentication_middle.4 : 
;;; T is not in rho

{-1}  T(e!1)
{-2}  rho_middle(i!1)(msg(e!1))
  |-------

Rerunning step: (expand "T")
Expanding the definition of T,
this simplifies to: 
authentication_middle.4 : 
;;; T is not in rho

{-1}  e!1 = signal(commit(p - 1, hu_list, n_last))
[-2]  rho_middle(i!1)(msg(e!1))
  |-------

Rerunning step: (replace -1 -2)
Replacing using formula -1,
this simplifies to: 
authentication_middle.4 : 
;;; T is not in rho

[-1]  e!1 = signal(commit(p - 1, hu_list, n_last))
{-2}  rho_middle(i!1)(msg(signal(commit(p - 1, hu_list, n_last))))
  |-------

Rerunning step: (delete -1)
Deleting some formulas,
this simplifies to: 
authentication_middle.4 : 
;;; T is not in rho

[-1]  rho_middle(i!1)(msg(signal(commit(p - 1, hu_list, n_last))))
  |-------

Rerunning step: (grind)
rho_middle rewrites rho_middle(i!1)(commit(p - 1, hu_list, n_last))
  to FALSE
Trying repeated skolemization, instantiation, and if-lifting,

This completes the proof of authentication_middle.4.

Q.E.D.


Run time  = 4.11 secs.
Real time = 4.97 secs.
nil
pvs(77): 
