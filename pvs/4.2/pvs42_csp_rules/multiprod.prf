(multiprod
 (prod_TCC1 0
  (prod_TCC1-1 nil 3417191624 3417191702
   ("" (skosimp*) (("" (inst?) (("" (assert) nil nil)) nil)) nil)
   proved ((U formal-nonempty-type-decl nil multiprod nil)) 73 20 nil
   nil))
 (prod_TCC2 0
  (prod_TCC2-1 nil 3417191624 3417191702 ("" (tcc) nil nil) proved
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   123 80 nil nil))
 (prod_TCC3 0
  (prod_TCC3-1 nil 3417191624 3417191702 ("" (tcc) nil nil) proved
   ((length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   163 90 nil nil))
 (multiprod_add1 0
  (multiprod_add1-1 nil 3417191624 3417191703
   ("" (induct "u")
    (("1" (grind) nil nil)
     ("2" (skosimp*)
      (("2" (expand "prod" -2)
        (("2" (split -2)
          (("1" (flatten)
            (("1"
              (case "add(cons(cons1_var!1, cons2_var!1), a!1) = cons(cons1_var!1, add(cons2_var!1, a!1))")
              (("1" (replace -1)
                (("1" (delete -1)
                  (("1" (expand "prod" 1)
                    (("1" (assert)
                      (("1" (split)
                        (("1" (skolem!)
                          (("1" (inst?)
                            (("1" (split)
                              (("1" (grind) nil nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2"
                          (case "(LAMBDA (i_105: U): cdr(add(t!1(i_105), a!1))) = (LAMBDA (u : U) : add(cdr(t!1(u)), a!1))")
                          (("1" (replace -1)
                            (("1" (delete -1)
                              (("1"
                                (inst?)
                                (("1" (assert) nil nil)
                                 ("2"
                                  (skolem!)
                                  (("2"
                                    (inst?)
                                    (("2" (flatten) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (apply-extensionality :hide? t)
                            (("1" (inst?)
                              (("1"
                                (flatten)
                                (("1"
                                  (lemma "list_cons_eta[T]")
                                  (("1"
                                    (inst -1 "t!1(x!1)")
                                    (("1"
                                      (replace -1 1 rl)
                                      (("1"
                                        (delete -1)
                                        (("1"
                                          (rewrite "add_cons[T]")
                                          (("1"
                                            (delete
                                             -1
                                             -2
                                             -3
                                             -4
                                             -5
                                             -6
                                             2)
                                            (("1" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (skolem!)
                              (("2"
                                (inst?)
                                (("2" (flatten) nil nil))
                                nil))
                              nil))
                            nil)
                           ("3" (skolem!)
                            (("3" (inst?) (("3" (flatten) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (delete -1 -2 -3 -4 -5 2) (("2" (grind) nil nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (skosimp)
              (("2"
                (case "add(cons(cons1_var!1, cons2_var!1), a!1) = cons(cons1_var!1, add(cons2_var!1, a!1))")
                (("1" (replace -1)
                  (("1" (expand "prod" 2)
                    (("1" (assert)
                      (("1" (delete -1)
                        (("1" (inst? 2)
                          (("1" (split)
                            (("1" (grind) nil nil)
                             ("2" (grind) nil nil)
                             ("3"
                              (case "((LAMBDA i: add(t!1(i), a!1))
                            WITH [(i!1) := cdr(add(t!1(i!1), a!1))])  = (LAMBDA i: add(t!1 WITH [(i!1) := cdr(t!1(i!1))](i), a!1))")
                              (("1"
                                (replace -1)
                                (("1"
                                  (delete -1)
                                  (("1"
                                    (inst?)
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (delete -2 -3 -4 -5 2 3)
                                (("2"
                                  (apply-extensionality :hide? t)
                                  (("1" (grind) nil nil)
                                   ("2"
                                    (lemma "list_cons_eta[T]")
                                    (("2"
                                      (inst -1 "t!1(i!1)")
                                      (("2"
                                        (replace -1 1 rl)
                                        (("2"
                                          (rewrite "add_cons[T]")
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("3"
                                (delete -2 -3 -4 -5 2 3)
                                (("3"
                                  (lemma "list_cons_eta[T]")
                                  (("3"
                                    (inst -1 "t!1(i!1)")
                                    (("3"
                                      (replace -1 1 rl)
                                      (("3"
                                        (rewrite "add_cons[T]")
                                        (("3" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (delete -1 -2 -3 -4 -5 2 3)
                  (("2" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((= const-decl "[T, T -> boolean]" equalities nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (t!1 skolem-const-decl "[U -> trace[T]]" multiprod nil)
    (list_cons_eta formula-decl nil list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (add_cons formula-decl nil more_list_props nil)
    (append def-decl "list[T]" list_props nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil multiprod nil)
    (add const-decl "(cons?[T])" more_list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (prod def-decl "bool" multiprod nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (U formal-nonempty-type-decl nil multiprod nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   1122 660 nil nil))
 (multiprod_add2 0
  (multiprod_add2-1 nil 3417192242 3417192252
   ("" (induct "u")
    (("1" (skosimp)
      (("1" (skolem!)
        (("1" (expand "prod" -1)
          (("1" (rewrite "add_null[T]")
            (("1" (expand "prod" 2)
              (("1" (assert)
                (("1" (inst? 2)
                  (("1" (split)
                    (("1" (grind) nil) ("2" (grind) nil)
                     ("3" (expand "prod")
                      (("3" (skolem!)
                        (("3" (inst -1 "i!2")
                          (("3" (grind) nil)))))))))))))))))))))))
     ("2" (skosimp*)
      (("2" (expand "prod" -2)
        (("2" (split -2)
          (("1" (flatten)
            (("1"
              (case "add(cons(cons1_var!1, cons2_var!1), a!1) = cons(cons1_var!1, add(cons2_var!1, a!1))")
              (("1" (replace -1)
                (("1" (delete -1)
                  (("1" (expand "prod" 2)
                    (("1" (assert)
                      (("1" (split)
                        (("1" (skolem!)
                          (("1" (inst -2 "i!2")
                            (("1" (flatten)
                              (("1"
                                (split)
                                (("1" (grind) nil)
                                 ("2" (grind) nil)))))))))
                         ("2" (inst? -4)
                          (("1" (inst? -4)
                            (("1" (assert)
                              (("1"
                                (inst? -4)
                                (("1"
                                  (case
                                   "((LAMBDA i: cdr(t!1(i))) WITH [(i!1) := add(cdr(t!1(i!1)), a!1)]) = (LAMBDA i: cdr(t!1 WITH [(i!1) := add(t!1(i!1), a!1)](i)))")
                                  (("1"
                                    (replace -1)
                                    (("1" (propax) nil)))
                                   ("2"
                                    (delete -1 -3 -4 2 3)
                                    (("2"
                                      (apply-extensionality :hide? t)
                                      (("1" (grind) nil)
                                       ("2"
                                        (skolem!)
                                        (("2"
                                          (inst -1 "i!2")
                                          (("2" (grind) nil)))))
                                       ("3" (lazy-grind) nil)))))
                                   ("3"
                                    (delete -1 -3 -4 2 3)
                                    (("3"
                                      (skolem!)
                                      (("3"
                                        (inst -1 "i!2")
                                        (("3" (grind) nil)))))))
                                   ("4"
                                    (skolem!)
                                    (("4"
                                      (inst -2 "i!2")
                                      (("4" (flatten) nil)))))))))))))
                           ("2" (skolem!)
                            (("2" (inst -2 "i!2")
                              (("2" (flatten) nil)))))))))))))))))
               ("2" (delete -1 -2 -3 -4 2 3) (("2" (grind) nil)))))))
           ("2" (flatten)
            (("2" (skosimp)
              (("2"
                (case "add(cons(cons1_var!1, cons2_var!1), a!1) = cons(cons1_var!1, add(cons2_var!1, a!1))")
                (("1" (replace -1)
                  (("1" (expand "prod" 3)
                    (("1" (assert)
                      (("1" (delete -1)
                        (("1" (inst 3 "i!2")
                          (("1" (split)
                            (("1" (grind) nil) ("2" (grind) nil)
                             ("3"
                              (inst -4 "A!1" "a!1"
                               "t!1 WITH [(i!2) := cdr(t!1(i!2))]")
                              (("3"
                                (assert)
                                (("3"
                                  (inst?)
                                  (("3"
                                    (case
                                     "(t!1
                                           WITH [(i!2) := cdr(t!1(i!2)),
                                                 (i!1)
                                                   := add(t!1 WITH [(i!2) := cdr(t!1(i!2))](i!1), a!1)]) = (t!1
                                           WITH [(i!1) := add(t!1(i!1), a!1),
                                                 (i!2)
                                                   := cdr(t!1 WITH [(i!1) := add(t!1(i!1), a!1)](i!2))])")
                                    (("1"
                                      (replace -1)
                                      (("1" (propax) nil)))
                                     ("2"
                                      (delete -3 -4 2 3 4)
                                      (("2"
                                        (apply-extensionality :hide? t)
                                        (("2"
                                          (grind)
                                          nil)))))))))))))))))))))))))
                 ("2" (delete -1 -2 -3 -4 2 3 4)
                  (("2" (grind) nil))))))))))))))))
    nil)
   proved
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (U formal-nonempty-type-decl nil multiprod nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (prod def-decl "bool" multiprod nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (add const-decl "(cons?[T])" more_list_props nil)
    (T formal-type-decl nil multiprod nil)
    (list_induction formula-decl nil list_adt nil)
    (add_null formula-decl nil more_list_props nil)
    (append def-decl "list[T]" list_props nil)
    (t!1 skolem-const-decl "[U -> trace[T]]" multiprod nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (i!1 skolem-const-decl "U" multiprod nil)
    (a!1 skolem-const-decl "T" multiprod nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil))
   7419 1600 nil nil))
 (multiprod_reverse 0
  (multiprod_reverse-1 nil 3417191624 3417191708
   ("" (induct "u")
    (("1" (skosimp)
      (("1" (expand "reverse" 1 2)
        (("1" (expand "prod") (("1" (grind) nil nil)) nil)) nil))
      nil)
     ("2" (skosimp*)
      (("2" (expand "prod" -2)
        (("2" (split)
          (("1" (flatten)
            (("1" (inst? -4)
              (("1" (assert)
                (("1" (lemma "multiprod_add1")
                  (("1"
                    (inst -1 "A!1" "cons1_var!1"
                     "LAMBDA i: reverse(cdr(t!1(i)))"
                     "reverse(cons2_var!1)")
                    (("1" (assert)
                      (("1" (rewrite "reverse_cons" :dir rl)
                        (("1"
                          (case "(LAMBDA (i_96: U): add(reverse(cdr(t!1(i_96))), cons1_var!1)) = (LAMBDA i: reverse(t!1(i)))")
                          (("1" (replace -1) (("1" (propax) nil nil))
                            nil)
                           ("2" (delete -1 -2 -4 -5 2)
                            (("2" (apply-extensionality :hide? t)
                              (("1"
                                (inst?)
                                (("1"
                                  (rewrite "reverse_cons" :dir rl)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (replace -2 :dir rl)
                                      (("1"
                                        (use "list_cons_eta[T]")
                                        (("1"
                                          (replace -1)
                                          (("1" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (skolem!)
                                (("2"
                                  (inst?)
                                  (("2"
                                    (use "list_cons_eta[T]")
                                    (("1"
                                      (replace -1 1 rl)
                                      (("1"
                                        (expand "reverse")
                                        (("1"
                                          (expand "append")
                                          (("1"
                                            (lift-if)
                                            (("1"
                                              (split)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil)
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("3" (grind) nil nil))
                              nil))
                            nil)
                           ("3" (grind) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (skosimp)
              (("2" (inst?)
                (("2" (assert)
                  (("2" (lemma "multiprod_add2")
                    (("2"
                      (inst -1 "A!1" "cons1_var!1"
                       "LAMBDA i: reverse(t!1 WITH [(i!1) := cdr(t!1(i!1))](i))"
                       "reverse(cons2_var!1)")
                      (("2" (assert)
                        (("2" (rewrite "reverse_cons" :dir rl)
                          (("2" (inst?)
                            (("2"
                              (case "((LAMBDA i: reverse(t!1 WITH [(i!1) := cdr(t!1(i!1))](i)))
             WITH [(i!1)
                     := add(reverse(t!1 WITH [(i!1) := cdr(t!1(i!1))]
                                    (i!1)),
                            cons1_var!1)]) = (LAMBDA i: reverse(t!1(i)))")
                              (("1"
                                (replace -1)
                                (("1" (propax) nil nil))
                                nil)
                               ("2"
                                (delete -1 -4 -5 2 3)
                                (("2"
                                  (apply-extensionality :hide? t)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (t!1 skolem-const-decl "[U -> trace[T]]" multiprod nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (multiprod_add1 formula-decl nil multiprod nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (add const-decl "(cons?[T])" more_list_props nil)
    (list_cons_eta formula-decl nil list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (reverse_cons formula-decl nil more_list_props nil)
    (multiprod_add2 formula-decl nil multiprod nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil multiprod nil)
    (reverse def-decl "list[T]" list_props nil)
    (prod def-decl "bool" multiprod nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (U formal-nonempty-type-decl nil multiprod nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   1387 970 nil nil))
 (multiprod_reverse2 0
  (multiprod_reverse2-1 nil 3417191624 3417191708
   ("" (skosimp)
    (("" (lemma "multiprod_reverse")
      (("" (inst -1 "A!1" "LAMBDA i : reverse(t!1(i))" "reverse(u!1)")
        (("" (assert)
          (("" (rewrite "reverse_reverse")
            ((""
              (case "(LAMBDA (i_118: U): reverse(reverse(t!1(i_118)))) = t!1")
              (("1" (replace -1) (("1" (propax) nil nil)) nil)
               ("2" (delete -1 -2 2)
                (("2" (apply-extensionality :hide? t)
                  (("2" (rewrite "reverse_reverse") nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((multiprod_reverse formula-decl nil multiprod nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (reverse_reverse formula-decl nil list_props nil)
    (reverse def-decl "list[T]" list_props nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (U formal-nonempty-type-decl nil multiprod nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil multiprod nil))
   170 80 nil nil))
 (multiprod_reverse3 0
  (multiprod_reverse3-1 nil 3417191624 3417191708
   ("" (skosimp)
    (("" (iff)
      (("" (split)
        (("1" (use "multiprod_reverse") nil nil)
         ("2" (lemma "multiprod_reverse2")
          (("2" (inst -1 "A!1" "t!1" "u!1") nil nil)) nil))
        nil))
      nil))
    nil)
   proved
   ((multiprod_reverse2 formula-decl nil multiprod nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (U formal-nonempty-type-decl nil multiprod nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil multiprod nil)
    (multiprod_reverse formula-decl nil multiprod nil))
   70 30 nil nil))
 (multiprod_add 0
  (multiprod_add-1 nil 3417191624 3417191709
   ("" (skolem!)
    (("" (iff)
      (("" (split)
        (("1" (ground)
          (("1" (rewrite "multiprod_reverse3")
            (("1" (rewrite "reverse_add")
              (("1" (expand "prod" -2)
                (("1" (flatten)
                  (("1" (rewrite "multiprod_reverse3")
                    (("1"
                      (inst 1
                       "LAMBDA i : reverse(cdr(reverse(t!1(i))))")
                      (("1" (split)
                        (("1" (apply-extensionality :hide? t)
                          (("1" (inst?)
                            (("1" (rewrite "reverse_cons" 1 :dir rl)
                              (("1"
                                (flatten)
                                (("1"
                                  (replace -3 1 rl)
                                  (("1"
                                    (case
                                     "cons(car(reverse(t!1(x!1))), cdr(reverse(t!1(x!1)))) = reverse(t!1(x!1))")
                                    (("1"
                                      (replace -1)
                                      (("1"
                                        (rewrite "reverse_reverse")
                                        nil
                                        nil))
                                      nil)
                                     ("2"
                                      (lemma "list_cons_eta[T]")
                                      (("2" (inst?) nil nil))
                                      nil)
                                     ("3" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil)
                         ("2" (rewrite "reverse_reverse") nil nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (rewrite "multiprod_reverse3")
            (("2" (rewrite "reverse_add")
              (("2" (expand "prod" -1)
                (("2" (skosimp)
                  (("2" (rewrite "multiprod_reverse3")
                    (("2"
                      (inst 2 "LAMBDA (i_149: U):
                   reverse((LAMBDA i: reverse(t!1(i)))
                             WITH [(i!1) := cdr(reverse(t!1(i!1)))]
                               (i_149))" "i!1")
                      (("2" (split)
                        (("1" (delete -3 2)
                          (("1" (apply-extensionality :hide? t)
                            (("1" (case "x!1 =i!1")
                              (("1"
                                (replace -1)
                                (("1"
                                  (assert)
                                  (("1"
                                    (rewrite "reverse_cons" 1 :dir rl)
                                    (("1"
                                      (replace -3 1 rl)
                                      (("1"
                                        (case
                                         "cons(car(reverse(t!1(i!1))), cdr(reverse(t!1(i!1)))) = reverse(t!1(i!1))")
                                        (("1"
                                          (replace -1)
                                          (("1"
                                            (rewrite "reverse_reverse")
                                            nil
                                            nil))
                                          nil)
                                         ("2"
                                          (lemma "list_cons_eta[T]")
                                          (("2" (inst?) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (assert)
                                (("2"
                                  (rewrite "reverse_reverse")
                                  nil
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (rewrite "reverse_reverse") nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (split)
            (("1" (flatten)
              (("1" (skosimp)
                (("1" (replace -2)
                  (("1" (delete -2)
                    (("1" (use "multiprod_add1")
                      (("1" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (skosimp)
                (("2" (replace -1)
                  (("2" (delete -1)
                    (("2" (use "multiprod_add2")
                      (("2" (assert) (("2" (inst?) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((multiprod_add2 formula-decl nil multiprod nil)
    (multiprod_add1 formula-decl nil multiprod nil)
    (reverse_add formula-decl nil more_list_props nil)
    (t!1 skolem-const-decl "[U -> trace[T]]" multiprod nil)
    (reverse_cons formula-decl nil more_list_props nil)
    (list_cons_eta formula-decl nil list_adt nil)
    (reverse_reverse formula-decl nil list_props nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (reverse def-decl "list[T]" list_props nil)
    (prod def-decl "bool" multiprod nil)
    (add const-decl "(cons?[T])" more_list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (U formal-nonempty-type-decl nil multiprod nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil multiprod nil)
    (multiprod_reverse3 formula-decl nil multiprod nil))
   1146 730 nil nil))
 (proj_multiprod 0
  (proj_multiprod-1 nil 3417191624 3417191710
   ("" (auto-rewrite-defs)
    (("" (skolem + ("A!1" _ _))
      (("" (induct "u")
        (("1" (reduce) nil nil)
         ("2" (skosimp*)
          (("2" (case "A!1(cons1_var!1)")
            (("1" (reduce) nil nil)
             ("2" (assert)
              (("2" (skosimp)
                (("2" (assert)
                  (("2" (inst?)
                    (("2" (assert)
                      (("2" (inst - "i!1")
                        (("2" (case "i!1 = i!2")
                          (("1" (assert) nil nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (t!1 skolem-const-decl "[U -> trace[T]]" multiprod nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (filter def-decl "list[T]" filters nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil multiprod nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (prod def-decl "bool" multiprod nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (U formal-nonempty-type-decl nil multiprod nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   413 280 nil nil))
 (prefix_multiprod 0
  (prefix_multiprod-1 nil 3417191624 3417191710
   ("" (auto-rewrite "prefix_null[T]" "null_prefix[T]")
    (("" (skolem + ("A!1" _ _ _))
      (("" (induct "u")
        (("1" (auto-rewrite "prod")
          (("1" (skosimp)
            (("1" (inst + "lambda i : null") (("1" (assert) nil nil))
              nil))
            nil))
          nil)
         ("2" (skosimp*)
          (("2" (rewrite "prefix_equiv")
            (("2" (ground)
              (("1" (auto-rewrite "prod")
                (("1" (inst + "lambda i : null")
                  (("1" (delete -2 -3) (("1" (assert) nil nil)) nil))
                  nil))
                nil)
               ("2" (auto-rewrite "prod")
                (("2" (case "A!1(cons1_var!1)")
                  (("1" (assert)
                    (("1" (ground)
                      (("1"
                        (inst - "LAMBDA (i: U): cdr(t!1(i))"
                         "cdr(v!1)")
                        (("1" (assert)
                          (("1" (skosimp)
                            (("1"
                              (inst +
                               "lambda i : cons(cons1_var!1, t1!1(i))")
                              (("1"
                                (ground)
                                (("1"
                                  (apply-eta "t1!1")
                                  (("1" (assert) nil nil))
                                  nil)
                                 ("2"
                                  (skolem!)
                                  (("2"
                                    (inst?)
                                    (("2"
                                      (inst?)
                                      (("2"
                                        (rewrite "prefix_equiv" +)
                                        (("2" (ground) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (skolem!)
                          (("2" (inst?) (("2" (ground) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert)
                    (("2" (skosimp)
                      (("2"
                        (inst - "t!1 WITH [(i!1) := cdr(t!1(i!1))]"
                         "cdr(v!1)")
                        (("2" (assert)
                          (("2" (skosimp)
                            (("2"
                              (inst +
                               "t1!1 with [(i!1) := cons(cons1_var!1, t1!1(i!1))]")
                              (("2"
                                (ground)
                                (("1"
                                  (inst + "i!1")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (case-replace
                                       "t1!1
                                   WITH [(i!1) := cons(cons1_var!1, t1!1(i!1)), (i!1) := t1!1(i!1)] = t1!1")
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (skolem!)
                                  (("2"
                                    (inst - "i!2")
                                    (("2"
                                      (case "i!1 = i!2")
                                      (("1"
                                        (assert)
                                        (("1"
                                          (rewrite "prefix_equiv" +)
                                          nil
                                          nil))
                                        nil)
                                       ("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((= const-decl "[T, T -> boolean]" equalities nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (t!1 skolem-const-decl "[U -> trace[T]]" multiprod nil)
    (prefix_equiv formula-decl nil traces nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null_prefix formula-decl nil traces nil)
    (prefix_null formula-decl nil traces nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil multiprod nil)
    (prefix const-decl "bool" traces nil)
    (prod def-decl "bool" multiprod nil)
    (set type-eq-decl nil sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (U formal-nonempty-type-decl nil multiprod nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   720 430 nil nil))
 (multiprod_fullset 0
  (multiprod_fullset-1 nil 3417191624 3417191711
   ("" (auto-rewrite "fullset" "prod")
    (("" (induct "u")
      (("1" (reduce) nil nil)
       ("2" (skosimp*)
        (("2" (assert)
          (("2" (ground)
            (("1" (inst? -3)
              (("1" (assert)
                (("1" (skolem!)
                  (("1" (inst?)
                    (("1" (inst?)
                      (("1" (apply-extensionality :hide? t) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (skolem!)
                (("2" (inst?) (("2" (ground) nil nil)) nil)) nil))
              nil)
             ("2" (skolem!)
              (("2" (inst?)
                (("2" (replace*) (("2" (assert) nil nil)) nil)) nil))
              nil)
             ("3" (inst? -2)
              (("1" (assert)
                (("1" (skolem!)
                  (("1" (inst?)
                    (("1" (replace*) (("1" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (skolem!)
                (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (U formal-nonempty-type-decl nil multiprod nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (prod def-decl "bool" multiprod nil)
    (fullset const-decl "set" sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil multiprod nil)
    (list_induction formula-decl nil list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (t!1 skolem-const-decl "[U -> trace[T]]" multiprod nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil))
   281 160 nil nil))
 (free_multiprod 0
  (free_multiprod-1 nil 3417192203 3417192207
   ("" (auto-rewrite-defs)
    (("" (induct "u")
      (("1" (skosimp*)
        (("1" (assert)
          (("1" (skosimp*)
            (("1" (case "(i!1=j!1) OR NOT (i!1=j!1)")
              (("1" (ground) nil) ("2" (prop) nil)))))))))
       ("2" (skosimp*)
        (("2" (assert)
          (("2" (inst?)
            (("2" (assert)
              (("2" (inst?) (("2" (assert) nil))))))))))))))
    nil)
   proved
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil multiprod nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (emptyset const-decl "set" sets nil)
    (prod def-decl "bool" multiprod nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (U formal-nonempty-type-decl nil multiprod nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   2325 250 t nil))
 (sigma_multiprod 0
  (sigma_multiprod-1 nil 3417191624 3417191712
   ("" (induct-and-simplify "u")
    (("1" (apply-extensionality :hide? t) (("1" (reduce) nil nil)) nil)
     ("2" (replace*)
      (("2" (delete -1 -4)
        (("2" (apply-extensionality :hide? t)
          (("1" (reduce)
            (("1" (inst + "epsilon! i : true")
              (("1" (inst?)
                (("1" (ground) (("1" (assert) nil nil)) nil)) nil))
              nil))
            nil)
           ("2" (reduce) nil nil))
          nil))
        nil))
      nil)
     ("3" (replace*)
      (("3" (delete -1 -4)
        (("3" (apply-extensionality :hide? t)
          (("3" (iff)
            (("3" (ground)
              (("1" (inst?) (("1" (assert) nil nil)) nil)
               ("2" (skolem!)
                (("2" (inst + "i!2")
                  (("2" (case "i!1 = i!2")
                    (("1" (assert) nil nil) ("2" (assert) nil nil))
                    nil))
                  nil))
                nil)
               ("3" (skolem!)
                (("3" (inst?)
                  (("3" (assert)
                    (("3" (case "i!1 = i!2")
                      (("1" (assert) nil nil) ("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((nonempty? const-decl "bool" sets nil)
    (add const-decl "(nonempty?)" sets nil)
    (member const-decl "bool" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (epsilon const-decl "T" epsilons nil)
    (pred type-eq-decl nil defined_types nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (t!1 skolem-const-decl "[U -> trace[T]]" multiprod nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list2set def-decl "set[T]" list2set nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (U formal-nonempty-type-decl nil multiprod nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (prod def-decl "bool" multiprod nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (union const-decl "set[T]" parametric_sets nil)
    (T formal-type-decl nil multiprod nil)
    (list_induction formula-decl nil list_adt nil))
   1609 1300 nil nil))
 (sigma_multiprod_inter 0
  (sigma_multiprod_inter-1 nil 3417191624 3417191713
   ("" (skosimp)
    (("" (forward-chain "proj_multiprod")
      (("" (inst?)
        (("" (rewrite "sigma_proj" :dir rl)
          (("" (rewrite "sigma_proj" :dir rl) (("" (assert) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((proj_multiprod formula-decl nil multiprod nil)
    (T formal-type-decl nil multiprod nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (U formal-nonempty-type-decl nil multiprod nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (sigma_proj formula-decl nil traces nil)
    (setof type-eq-decl nil defined_types nil))
   160 60 nil nil))
 (inter_disjoint 0
  (inter_disjoint-1 nil 3417191624 3417191713
   ("" (skolem + ("A!1" _ _))
    (("" (induct "u")
      (("1" (skosimp)
        (("1" (expand "prod") (("1" (grind) nil nil)) nil)) nil)
       ("2" (skosimp)
        (("2" (skosimp)
          (("2" (expand "prod" -4)
            (("2" (split)
              (("1" (flatten)
                (("1" (expand "emptyset" -1) (("1" (propax) nil nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (delete 1)
                  (("2" (skosimp)
                    (("2" (inst -4 "t!1 WITH [(i!1) := cdr(t!1(i!1))]")
                      (("2" (ground)
                        (("1" (expand "sub_alphabet")
                          (("1" (expand "subset?")
                            (("1" (expand "member")
                              (("1"
                                (inst? -6)
                                (("1"
                                  (inst -6 "cons1_var!1")
                                  (("1"
                                    (expand "sigma")
                                    (("1"
                                      (expand "list2set")
                                      (("1"
                                        (replace -3 -6 :dir rl)
                                        (("1"
                                          (expand "add")
                                          (("1"
                                            (skolem!)
                                            (("1"
                                              (inst -1 "i!2")
                                              (("1"
                                                (case "i!1 = i!2")
                                                (("1"
                                                  (rewrite "proj_cons")
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (apply-extensionality)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (expand
                                                   "disj_alphabet")
                                                  (("2"
                                                    (inst
                                                     -5
                                                     "i!1"
                                                     "i!2")
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (expand
                                                         "disjoint?")
                                                        (("2"
                                                          (expand
                                                           "empty?")
                                                          (("2"
                                                            (expand
                                                             "member")
                                                            (("2"
                                                              (expand
                                                               "intersection")
                                                              (("2"
                                                                (expand
                                                                 "member")
                                                                (("2"
                                                                  (inst
                                                                   -5
                                                                   "cons1_var!1")
                                                                  (("2"
                                                                    (assert)
                                                                    (("2"
                                                                      (rewrite
                                                                       "proj_cons")
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (delete -3 -4 2)
                          (("2" (expand "sub_alphabet")
                            (("2" (skolem!)
                              (("2"
                                (inst -3 "i!2")
                                (("2"
                                  (expand "subset?")
                                  (("2"
                                    (expand "member")
                                    (("2"
                                      (case "i!1 = i!2")
                                      (("1"
                                        (skosimp)
                                        (("1"
                                          (inst?)
                                          (("1"
                                            (assert)
                                            (("1"
                                              (replace -1 2 :dir rl)
                                              (("1"
                                                (expand "sigma")
                                                (("1"
                                                  (expand "list2set" 2)
                                                  (("1"
                                                    (expand "add")
                                                    (("1"
                                                      (flatten)
                                                      (("1"
                                                        (expand
                                                         "member")
                                                        (("1"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (U formal-nonempty-type-decl nil multiprod nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (disj_alphabet const-decl "bool" multiprod nil)
    (sub_alphabet const-decl "bool" multiprod nil)
    (prod def-decl "bool" multiprod nil)
    (emptyset const-decl "set" sets nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (T formal-type-decl nil multiprod nil)
    (list_induction formula-decl nil list_adt nil)
    (filter def-decl "list[T]" filters nil)
    (subset? const-decl "bool" sets nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (disjoint? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (/= const-decl "boolean" notequal nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list2set def-decl "set[T]" list2set nil)
    (add const-decl "(nonempty?)" sets nil)
    (setof type-eq-decl nil defined_types nil)
    (proj_cons formula-decl nil traces nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   663 350 nil nil))
 (prod_disjoint 0
  (prod_disjoint-1 nil 3417191624 3417191714
   ("" (skolem + ("A!1" "S!1" _ _))
    (("" (induct "u")
      (("1" (skosimp)
        (("1" (expand "prod") (("1" (grind) nil nil)) nil)) nil)
       ("2" (skosimp)
        (("2" (skosimp)
          (("2" (expand "prod" -4)
            (("2" (split)
              (("1" (flatten)
                (("1" (skolem!)
                  (("1" (inst -4 "LAMBDA i: cdr(t!1(i))")
                    (("1" (split)
                      (("1" (inst? -1)
                        (("1" (assert)
                          (("1" (inst? -3)
                            (("1" (flatten)
                              (("1"
                                (rewrite "proj_cons")
                                (("1"
                                  (lift-if)
                                  (("1"
                                    (split)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (apply-extensionality)
                                        nil
                                        nil))
                                      nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (expand "sub_alphabet")
                                        (("2"
                                          (expand "subset?")
                                          (("2"
                                            (expand "member")
                                            (("2"
                                              (inst? -6)
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (expand "sigma")
                                                  (("2"
                                                    (expand "list2set")
                                                    (("2"
                                                      (expand "add")
                                                      (("2"
                                                        (propax)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (delete -3 -5 2)
                        (("2" (expand "sub_alphabet")
                          (("2" (skolem!)
                            (("2" (inst?)
                              (("2"
                                (inst -3 "i!2")
                                (("2"
                                  (expand "subset?")
                                  (("2"
                                    (expand "member")
                                    (("2"
                                      (case "i!1 = i!2")
                                      (("1"
                                        (skosimp)
                                        (("1"
                                          (inst?)
                                          (("1"
                                            (assert)
                                            (("1"
                                              (replace -1 2 :dir rl)
                                              (("1"
                                                (expand "sigma")
                                                (("1"
                                                  (expand "list2set" 2)
                                                  (("1"
                                                    (expand "add")
                                                    (("1"
                                                      (flatten)
                                                      (("1"
                                                        (expand
                                                         "member")
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (skosimp)
                                          (("2"
                                            (inst?)
                                            (("2"
                                              (assert)
                                              (("2"
                                                (expand "sigma")
                                                (("2"
                                                  (expand "list2set" 3)
                                                  (("2"
                                                    (expand "add")
                                                    (("2"
                                                      (flatten)
                                                      (("2"
                                                        (expand
                                                         "member")
                                                        (("2"
                                                          (propax)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (propax) nil nil) ("4" (propax) nil nil))
                      nil)
                     ("2" (skolem!)
                      (("2" (inst? -2) (("2" (flatten) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (skosimp)
                  (("2" (inst -4 "t!1 WITH [(i!1) := cdr(t!1(i!1))]")
                    (("2" (ground)
                      (("1" (expand "sub_alphabet")
                        (("1" (expand "subset?")
                          (("1" (expand "member")
                            (("1" (inst? -5)
                              (("1"
                                (inst -5 "cons1_var!1")
                                (("1"
                                  (expand "sigma")
                                  (("1"
                                    (expand "list2set")
                                    (("1"
                                      (expand "add")
                                      (("1"
                                        (skolem!)
                                        (("1"
                                          (inst -1 "i!2")
                                          (("1"
                                            (case "i!1 = i!2")
                                            (("1"
                                              (rewrite "proj_cons")
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (apply-extensionality)
                                                  nil
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (inst -6 "i!1" "i!2")
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (expand "disjoint?")
                                                  (("2"
                                                    (expand "empty?")
                                                    (("2"
                                                      (expand
                                                       "intersection")
                                                      (("2"
                                                        (expand
                                                         "member")
                                                        (("2"
                                                          (expand
                                                           "difference")
                                                          (("2"
                                                            (inst
                                                             -6
                                                             "cons1_var!1")
                                                            (("2"
                                                              (expand
                                                               "member")
                                                              (("2"
                                                                (rewrite
                                                                 "proj_cons")
                                                                (("2"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (delete -3 -5 2)
                        (("2" (expand "sub_alphabet")
                          (("2" (skolem!)
                            (("2" (inst -3 "i!2")
                              (("2"
                                (expand "subset?")
                                (("2"
                                  (expand "member")
                                  (("2"
                                    (case "i!1 = i!2")
                                    (("1"
                                      (skosimp)
                                      (("1"
                                        (inst?)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (replace -1 2 :dir rl)
                                            (("1"
                                              (expand "sigma")
                                              (("1"
                                                (expand "list2set" 2)
                                                (("1"
                                                  (expand "add")
                                                  (("1"
                                                    (flatten)
                                                    (("1"
                                                      (expand "member")
                                                      (("1"
                                                        (propax)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (U formal-nonempty-type-decl nil multiprod nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (set type-eq-decl nil sets nil)
    (sub_alphabet const-decl "bool" multiprod nil)
    (/= const-decl "boolean" notequal nil)
    (disjoint? const-decl "bool" sets nil)
    (difference const-decl "set" sets nil)
    (prod def-decl "bool" multiprod nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (T formal-type-decl nil multiprod nil)
    (list_induction formula-decl nil list_adt nil)
    (filter def-decl "list[T]" filters nil)
    (empty? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (add const-decl "(nonempty?)" sets nil)
    (list2set def-decl "set[T]" list2set nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (proj_cons formula-decl nil traces nil)
    (setof type-eq-decl nil defined_types nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (t!1 skolem-const-decl "[U -> trace[T]]" multiprod nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil))
   966 490 nil nil))
 (inter_proj 0
  (inter_proj-1 nil 3417191624 3417191715
   ("" (auto-rewrite "prod" "emptyset" "proj" "filter")
    (("" (skolem + ("A!1" _ _))
      (("" (induct "u")
        (("1" (reduce) nil nil)
         ("2" (skosimp*)
          (("2" (assert)
            (("2" (skosimp)
              (("2" (inst? :where -4)
                (("2" (assert)
                  (("2" (lift-if)
                    (("2" (ground)
                      (("1" (inst?)
                        (("1" (assert)
                          (("1"
                            (case-replace
                             "(LAMBDA i : filter(t!1(i), A!1)) WITH [(i!1) := filter(cdr(t!1(i!1)), A!1)] =
  (LAMBDA i : filter(t!1 WITH [(i!1) := cdr(t!1(i!1))](i), A!1))")
                            (("1" (apply-extensionality :hide? t)
                              (("1"
                                (case "x!1 = i!1")
                                (("1" (assert) nil nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2"
                        (case-replace
                         "(LAMBDA i : filter(t!1(i), A!1)) = 
   LAMBDA i : filter(t!1 WITH [(i!1) := cdr(t!1(i!1))](i), A!1)")
                        (("2" (apply-extensionality :hide? t)
                          (("2" (case "x!1 = i!1")
                            (("1" (assert) nil nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil)
    (filter def-decl "list[T]" filters nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil multiprod nil)
    (proj const-decl "[trace, set[T] -> trace]" traces nil)
    (emptyset const-decl "set" sets nil)
    (prod def-decl "bool" multiprod nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (U formal-nonempty-type-decl nil multiprod nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   535 300 nil nil))
 (null_proj_multiprod 0
  (null_proj_multiprod-1 nil 3417191624 3417191715
   ("" (skosimp)
    (("" (auto-rewrite "null_proj_equiv[T]")
      (("" (assert)
        (("" (forward-chain "sigma_multiprod")
          (("" (replace*)
            (("" (delete -)
              (("" (expand "union")
                (("" (auto-rewrite-theory "sets[T]")
                  (("" (reduce) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((sigma_multiprod formula-decl nil multiprod nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (U formal-nonempty-type-decl nil multiprod nil)
    (list type-decl nil list_adt nil)
    (trace type-eq-decl nil traces nil)
    (member const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (disjoint? const-decl "bool" sets nil)
    (union const-decl "set[T]" parametric_sets nil)
    (T formal-type-decl nil multiprod nil)
    (null_proj_equiv formula-decl nil traces nil))
   524 320 nil nil))
 (null_proj_multiprod2 0
  (null_proj_multiprod2-1 nil 3417191624 3417191716
   ("" (skosimp)
    (("" (auto-rewrite "null_proj_equiv[T]")
      (("" (assert)
        (("" (use "sigma_multiprod_inter")
          (("" (assert)
            (("" (auto-rewrite-theory "sets[T]")
              (("" (reduce)
                (("" (case "intersection(sigma(t!1(i!1)), A!1)(x!1)")
                  (("1" (assert) nil nil)
                   ("2" (replace*) (("2" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((sigma_multiprod_inter formula-decl nil multiprod nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (U formal-nonempty-type-decl nil multiprod nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (sigma const-decl "[trace -> set[T]]" traces nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (intersection const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (disjoint? const-decl "bool" sets nil)
    (T formal-type-decl nil multiprod nil)
    (null_proj_equiv formula-decl nil traces nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil))
   476 320 nil nil))
 (null_inter_proj 0
  (null_inter_proj-1 nil 3417191624 3417191716
   ("" (skosimp)
    (("" (use "null_proj_multiprod") (("" (assert) nil nil)) nil)) nil)
   proved
   ((null_proj_multiprod formula-decl nil multiprod nil)
    (trace type-eq-decl nil traces nil)
    (list type-decl nil list_adt nil)
    (U formal-nonempty-type-decl nil multiprod nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil multiprod nil)
    (emptyset const-decl "set" sets nil)
    (finite_emptyset name-judgement "finite_set" finite_sets nil))
   112 70 nil nil))
 (every_multiprod 0
  (every_multiprod-1 nil 3417191624 3417191717
   ("" (induct "u")
    (("1" (skosimp) (("1" (expand "prod") (("1" (grind) nil nil)) nil))
      nil)
     ("2" (skosimp*)
      (("2" (inst -1 "A!1" "B!1" "_")
        (("2" (expand "prod" -2)
          (("2" (split)
            (("1" (flatten)
              (("1" (inst-cp -2 "i!1")
                (("1" (flatten)
                  (("1" (expand "every" -7)
                    (("1" (flatten)
                      (("1" (use "list_cons_eta[T]")
                        (("1" (replace -1 1 rl)
                          (("1" (expand "every" 1)
                            (("1" (replace -5)
                              (("1"
                                (assert)
                                (("1"
                                  (inst? -7)
                                  (("1"
                                    (assert)
                                    (("1" (inst? -7) nil nil))
                                    nil)
                                   ("2"
                                    (skolem!)
                                    (("2"
                                      (inst?)
                                      (("2" (flatten) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (skosimp)
                (("2" (expand "every" -5)
                  (("2" (flatten)
                    (("2" (case "i!1 = i!2")
                      (("1" (replace -1)
                        (("1" (delete -1)
                          (("1" (use "list_cons_eta[T]")
                            (("1" (replace -1 2 rl)
                              (("1"
                                (expand "every" 2)
                                (("1"
                                  (replace -3)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (inst?)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (inst?)
                                          (("1" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (inst?)
                        (("2" (assert)
                          (("2" (inst?) (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   proved
   ((= const-decl "[T, T -> boolean]" equalities nil)
    (t!1 skolem-const-decl "[U -> trace[T]]" multiprod nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list_cons_eta formula-decl nil list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil multiprod nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (prod def-decl "bool" multiprod nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (U formal-nonempty-type-decl nil multiprod nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (trace type-eq-decl nil traces nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   654 390 nil nil)))

